# Query: p
# Flags: RegExp
# Including: *.pyg
# ContextLines: 1

1262 results - 33 files

z3/src/ackermannization/ackermannization_params.pyg:
  1: def_module_params('ackermannization',
  2:                   description='solving UF via ackermannization',
  3:                   export=True,
  4:                   params=(
  5                            ('eager', BOOL, True, 'eagerly instantiate all congruence rules'),

z3/src/ackermannization/ackermannize_bv_tactic_params.pyg:
  1: def_module_params(module_name='rewriter',
  2:                   class_name='ackermannize_bv_tactic_params',
  3:                   export=True,
  4:                   params=(
  5                            ("div0_ackermann_limit", UINT, 1000, "a bound for number of congruence Ackermann lemmas for div0 modelling"),

z3/src/ast/pp_params.pyg:
   1: def_module_params('pp', 
   2:                   export=True,
   3:                   description='pretty printer',
   4:                   params=(('max_indent', UINT, UINT_MAX, 'max. indentation in pretty printer'),
   5:                           ('max_num_lines', UINT, UINT_MAX, 'max. number of lines to be displayed in pretty printer'),
   6:                           ('max_width', UINT, 80, 'max. width in pretty printer'),
   7:                           ('max_ribbon', UINT, 80, 'max. ribbon (width - indentation) in pretty printer'),
   8:                           ('max_depth', UINT, 5, 'max. term depth (when pretty printing SMT2 terms/formulas)'),
   9:                           ('min_alias_size', UINT, 10, 'min. size for creating an alias for a shared term (when pretty printing SMT2 terms/formulas)'),
  10:                           ('decimal', BOOL, False, 'pretty print real numbers using decimal notation (the output may be truncated). Z3 adds a ? if the value is not precise'),
  11:                           ('decimal_precision', UINT, 10, 'maximum number of decimal places to be used when pp.decimal=true'),
  12:                           ('bv_literals', BOOL, True, 'use Bit-Vector literals (e.g, #x0F and #b0101) during pretty printing'),
  13:                           ('fp_real_literals', BOOL, False, 'use real-numbered floating point literals (e.g, +1.0p-1) during pretty printing'),
  14:                           ('bv_neg', BOOL, False, 'use bvneg when displaying Bit-Vector literals where the most significant bit is 1'),
  15:                           ('flat_assoc', BOOL, True, 'flat associative operators (when pretty printing SMT2 terms/formulas)'),
  16:                           ('fixed_indent', BOOL, False, 'use a fixed indentation for applications'),
  17                            ('single_line', BOOL, False, 'ignore line breaks when true'),
  18                            ('bounded', BOOL, False, 'ignore characters exceeding max width'),
  19:                           ('pretty_proof', BOOL, False, 'use slower, but prettier, printer for proofs'),
  20:                           ('simplify_implies', BOOL, True, 'simplify nested implications for pretty printing')))

z3/src/ast/normal_forms/nnf_params.pyg:
  1: def_module_params('nnf', 
  2:                   description='negation normal form',
  3:                   export=True,
  4:                   params=(max_memory_param(),
  5                            ('sk_hack', BOOL, False, 'hack for VCC'),

  7                             'NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full'),
  8:                           ('ignore_labels', BOOL, False, 'remove/ignore labels in the input formula, this option is ignored if proofs are enabled')))

z3/src/math/polynomial/algebraic_params.pyg:
  1: def_module_params('algebraic', 
  2:                   description='real algebraic number package. Non-default parameter settings are not supported',
  3:                   export=True,
  4:                   params=(('zero_accuracy', UINT, 0, 'one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k)'),
  5:                           ('min_mag', UINT, 16, 'Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16'),
  6:                           ('factor', BOOL, True, 'use polynomial factorization to simplify polynomials representing algebraic numbers'),
  7:                           ('factor_max_prime', UINT, 31, 'parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step'),
  8:                           ('factor_num_primes', UINT, 1, 'parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)\'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching'),
  9:                           ('factor_search_size', UINT, 5000, 'parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space')))
  10  

z3/src/math/realclosure/rcf_params.pyg:
  1: def_module_params('rcf',
  2:                   description='real closed fields', 
  3:                   export=True,
  4:                   params=(('use_prem', BOOL, True, "use pseudo-remainder instead of remainder when computing GCDs and Sturm-Tarski sequences"),
  5                            ('clean_denominators', BOOL, True, "clean denominators before root isolation"),
  6:                           ('initial_precision', UINT, 24, "a value k that is the initial interval size (as 1/2^k) when creating transcendentals and approximated division"),
  7:                           ('inf_precision', UINT, 24, "a value k that is the initial interval size (i.e., (0, 1/2^l)) used as an approximation for infinitesimal values"),
  8:                           ('max_precision', UINT, 128, "during sign determination we switch from interval arithmetic to complete methods when the interval size is less than 1/2^k, where k is the max_precision"),
  9:                           ('lazy_algebraic_normalization', BOOL, True, "during sturm-seq and square-free polynomial computations, only normalize algebraic polynomial expressions when the defining polynomial is monic")
  10                            ))

z3/src/model/model_evaluator_params.pyg:
  1: def_module_params('model_evaluator', 
  2:                   export=True,
  3:                   params=(max_memory_param(),
  4:                           max_steps_param(),
  5:                           ('completion', BOOL, False, 'assigns an interptetation to symbols that do not have one in the current model, when evaluating expressions in the current model'),
  6                            ('array_equalities', BOOL, True, 'evaluate array equalities'),

z3/src/model/model_params.pyg:
  1: def_module_params('model',
  2:                   export=True,
  3:                   params=(('partial', BOOL, False, 'enable/disable partial function interpretations'),
  4:                           ('v1', BOOL, False, 'use Z3 version 1.x pretty printer'),
  5:                           ('v2', BOOL, False, 'use Z3 version 2.x (x <= 16) pretty printer'),
  6:                           ('compact', BOOL, True, 'try to compact function graph (i.e., function interpretations that are lookup tables)'),
  7:                           ('inline_def', BOOL, False, 'inline local function definitions ignoring possible expansion'),
  8                            ('user_functions', BOOL, True, 'include user defined functions in model'),
  9:                           ('completion', BOOL, False, 'enable/disable model completion'),
  10                            ))

z3/src/muz/base/fp_params.pyg:
    1: def_module_params('fp',
    2:                   description='fixedpoint parameters',
    3:                   export=True,
    4:                   params=(('engine', SYMBOL, 'auto-config',
    5:                            'Select: auto-config, datalog, bmc, spacer'),
    6:                           ('datalog.default_table', SYMBOL, 'sparse',
    7:                            'default table implementation: sparse, hashtable, bitvector, interval'),
    8:                           ('datalog.default_relation', SYMBOL, 'pentagon',
    9:                            'default relation implementation: external_relation, pentagon'),
   10:                           ('datalog.generate_explanations', BOOL, False,
   11:                            'produce explanations for produced facts when using the datalog engine'),
   12:                           ('datalog.use_map_names', BOOL, True,
   13:                             "use names from map files when displaying tuples"),
   14                            ('datalog.magic_sets_for_queries', BOOL, False,
   15                             "magic set transformation will be used for queries"),
   16:                           ('datalog.explanations_on_relation_level', BOOL, False,
   17:                            'if true, explanations are generated as history of each relation, ' +
   18:                            'rather than per fact (generate_explanations must be set to true for ' +
   19:                            'this option to have any effect)'),
   20:                           ('datalog.unbound_compressor', BOOL, True,
   21                             "auxiliary relations will be introduced to avoid unbound variables " +
   22                             "in rule heads"),
   23:                           ('datalog.similarity_compressor', BOOL, True,
   24                             "rules that differ only in values of constants will be merged into " +
   25                             "a single rule"),
   26:                           ('datalog.similarity_compressor_threshold', UINT, 11,
   27:                            "if similarity_compressor is on, this value determines how many " +
   28                             "similar rules there must be in order for them to be merged"),
   29                            ('datalog.all_or_nothing_deltas', BOOL, False,
   30:                            "compile rules so that it is enough for the delta relation in " +
   31:                            "union and widening operations to determine only whether the " +
   32:                            "updated relation was modified or not"),
   33:                           ('datalog.compile_with_widening', BOOL, False,
   34:                            "widening will be used to compile recursive rules"),
   35                            ('datalog.default_table_checked', BOOL, False, "if true, the default " +
   36:                            'table will be default_table inside a wrapper that checks that its results ' +
   37                             'are the same as of default_table_checker table'),

   39                            ('datalog.check_relation',SYMBOL,'null', "name of default relation to check. " +
   40:                            "operations on the default relation will be verified using SMT solving"),
   41                            ('datalog.initial_restart_timeout', UINT, 0,

   44                            ('datalog.timeout', UINT, 0, "Time limit used for saturation"),
   45:                           ('datalog.output_profile', BOOL, False,
   46:                            "determines whether profile information should be " +
   47:                            "output when outputting Datalog rules or instructions"),
   48:                           ('datalog.print.tuples', BOOL, True,
   49:                            "determines whether tuples for output predicates should be output"),
   50:                           ('datalog.profile_timeout_milliseconds', UINT, 0,
   51                             "instructions and rules that took less than the threshold " +
   52:                            "will not be printed when printed the instruction/rule list"),
   53:                           ('datalog.dbg_fpr_nonempty_relation_signature', BOOL, False,
   54:                            "if true, finite_product_relation will attempt to avoid creating " +
   55:                            "inner relation with empty signature by putting in half of the " +
   56:                            "table columns, if it would have been empty otherwise"),
   57:                           ('datalog.subsumption', BOOL, True,
   58:                            "if true, removes/filters predicates with total transitions"),
   59:                           ('generate_proof_trace', BOOL, False, "trace for 'sat' answer as proof object"),
   60:                           ('spacer.push_pob', BOOL, False, "push blocked pobs to higher level"),
   61:                           ('spacer.push_pob_max_depth', UINT, UINT_MAX,
   62:                            'Maximum depth at which push_pob is enabled'),
   63                            ('validate', BOOL, False,
   64:                            "validate result (by proof checking or model checking)"),
   65:                           ('spacer.simplify_lemmas_pre', BOOL, False,
   66:                            "simplify derived lemmas before inductive propagation"),
   67:                           ('spacer.simplify_lemmas_post', BOOL, False,
   68:                            "simplify derived lemmas after inductive propagation"),
   69:                           ('spacer.use_inductive_generalizer', BOOL, True,
   70                             "generalize lemmas using induction strengthening"),
   71:                           ('spacer.max_num_contexts', UINT, 500, "maximal number of contexts to create"),
   72:                           ('print_fixedpoint_extensions', BOOL, True,
   73:                            "use SMT-LIB2 fixedpoint extensions, instead of pure SMT2, " +
   74:                            "when printing rules"),
   75:                           ('print_low_level_smt2', BOOL, False,
   76:                            "use (faster) low-level SMT2 printer (the printer is scalable " +
   77                             "but the result may not be as readable)"),
   78:                           ('print_with_variable_declarations', BOOL, True,
   79:                            "use variable declarations when displaying rules " +
   80:                            "(instead of attempting to use original names)"),
   81:                           ('print_answer', BOOL, False, 'print answer instance(s) to query'),
   82:                           ('print_certificate', BOOL, False,
   83:                            'print certificate for reachability or non-reachability'),
   84:                           ('print_boogie_certificate', BOOL, False,
   85:                            'print certificate for reachability or non-reachability using a ' +
   86                             'format understood by Boogie'),
   87:                           ('print_aig', SYMBOL, '',
   88:                            'Dump clauses in AIG text format (AAG) to the given file name'),
   89:                           ('print_statistics',  BOOL, False, 'print statistics'),
   90                            ('tab.selection', SYMBOL, 'weight',

   94                            ('xform.magic', BOOL, False,
   95:                            "perform symbolic magic set transformation"),
   96                            ('xform.scale', BOOL, False,

  100                            ('xform.inline_linear_branch', BOOL, False,
  101:                            "try linear inlining method with potential expansion"),
  102:                           ('xform.compress_unbound', BOOL, True, "compress tails with unbound variables"),
  103                            ('xform.fix_unbound_vars', BOOL, False, "fix unbound variables in tail"),

  105                             "unfold rules statically using iterative squaring"),
  106:                           ('xform.slice', BOOL, True, "simplify clause set using slicing"),
  107:                           ('spacer.use_euf_gen', BOOL, False, 'Generalize lemmas and pobs using implied equalities'),
  108                            ('xform.transform_arrays',  BOOL, False,
  109:                            "Rewrites arrays equalities and applies select over store"),
  110                            ('xform.instantiate_arrays',  BOOL, False,
  111:                            "Transforms P(a) into P(i, a[i] a)"),
  112                            ('xform.instantiate_arrays.enforce',  BOOL, False,
  113:                            "Transforms P(a) into P(i, a[i]), discards a from predicate"),
  114                            ('xform.instantiate_arrays.nb_quantifier',  UINT, 1,
  115:                            "Gives the number of quantifiers per array"),
  116                            ('xform.instantiate_arrays.slice_technique',  SYMBOL, "no-slicing",

  122                            ('xform.coalesce_rules', BOOL, False, "coalesce rules"),
  123:                           ('xform.tail_simplifier_pve', BOOL, True, "propagate_variable_equivalences"),
  124:                           ('xform.subsumption_checker', BOOL, True, "Enable subsumption checker (no support for model conversion)"),
  125:                           ('xform.coi', BOOL, True, "use cone of influence simplification"),
  126:                           ('spacer.order_children', UINT, 0, 'SPACER: order of enqueuing children in non-linear rules : 0 (original), 1 (reverse), 2 (random)'),
  127:                           ('spacer.use_lemma_as_cti', BOOL, False, 'SPACER: use a lemma instead of a CTI in flexible_trace'),
  128:                           ('spacer.reset_pob_queue', BOOL, True, 'SPACER: reset pob obligation queue when entering a new level'),
  129:                           ('spacer.use_array_eq_generalizer', BOOL, True, 'SPACER: attempt to generalize lemmas with array equalities'),
  130:                           ('spacer.use_derivations', BOOL, True, 'SPACER: using derivation mechanism to cache intermediate results for non-linear rules'),
  131                            ('xform.array_blast', BOOL, False, "try to eliminate local array terms using Ackermannization -- some array terms may remain"),
  132                            ('xform.array_blast_full', BOOL, False, "eliminate all local array variables by QE"),
  133:                           ('xform.elim_term_ite', BOOL, False, 'Eliminate term-ite expressions'),
  134:                           ('xform.elim_term_ite.inflation', UINT, 3, 'Maximum inflation for non-Boolean ite-terms blasting: 0 (none), k (multiplicative)'),
  135:                           ('spacer.propagate', BOOL, True, 'Enable propagate/pushing phase'),
  136:                           ('spacer.max_level', UINT, UINT_MAX, "Maximum level to explore"),
  137:                           ('spacer.elim_aux', BOOL, True, "Eliminate auxiliary variables in reachability facts"),
  138:                           ('spacer.blast_term_ite_inflation', UINT, 3, 'Maximum inflation for non-Boolean ite-terms expansion: 0 (none), k (multiplicative)'),
  139:                           ('spacer.reach_dnf', BOOL, True, "Restrict reachability facts to DNF"),
  140:                           ('bmc.linear_unrolling_depth', UINT, UINT_MAX, "Maximal level to explore"),
  141:                           ('spacer.iuc.split_farkas_literals', BOOL, False, "Split Farkas literals"),
  142:                           ('spacer.native_mbp', BOOL, True, "Use native mbp of Z3"),
  143:                           ('spacer.eq_prop', BOOL, True, "Enable equality and bound propagation in arithmetic"),
  144:                           ('spacer.weak_abs', BOOL, True, "Weak abstraction"),
  145:                           ('spacer.restarts', BOOL, False, "Enable resetting obligation queue"),
  146:                           ('spacer.restart_initial_threshold', UINT, 10, "Initial threshold for restarts"),
  147:                           ('spacer.random_seed', UINT, 0, "Random seed to be used by SMT solver"),
  148  
  149:                           ('spacer.mbqi', BOOL, True, 'Enable mbqi'),
  150:                           ('spacer.keep_proxy', BOOL, True, 'keep proxy variables (internal parameter)'),
  151:                           ('spacer.q3', BOOL, True, 'Allow quantified lemmas in frames'),
  152:                           ('spacer.q3.instantiate', BOOL, True, 'Instantiate quantified lemmas'),
  153:                           ('spacer.q3.use_qgen', BOOL, False, 'use quantified lemma generalizer'),
  154:                           ('spacer.q3.qgen.normalize', BOOL, True, 'normalize cube before quantified generalization'),
  155:                           ('spacer.iuc', UINT, 1,
  156:                            '0 = use old implementation of unsat-core-generation, ' +
  157:                            '1 = use new implementation of IUC generation, ' +
  158:                            '2 = use new implementation of IUC + min-cut optimization'),
  159:                           ('spacer.iuc.arith', UINT, 1,
  160:                            '0 = use simple Farkas plugin, ' +
  161:                            '1 = use simple Farkas plugin with constant from other partition (like old unsat-core-generation),' +
  162:                            '2 = use Gaussian elimination optimization (broken), 3 = use additive IUC plugin'),
  163:                           ('spacer.iuc.old_hyp_reducer', BOOL, False, 'use old hyp reducer instead of new implementation, for debugging only'),
  164:                           ('spacer.validate_lemmas', BOOL, False, 'Validate each lemma after generalization'),
  165:                           ('spacer.ground_pobs', BOOL, True, 'Ground pobs by using values from a model'),
  166:                           ('spacer.iuc.print_farkas_stats', BOOL, False, 'prints for each proof how many Farkas lemmas it contains and how many of these participate in the cut (for debugging)'),
  167:                           ('spacer.iuc.debug_proof', BOOL, False, 'prints proof used by unsat-core-learner for debugging purposes (debugging)'),
  168:                           ('spacer.simplify_pob', BOOL, False, 'simplify pobs by removing redundant constraints'),
  169:                           ('spacer.p3.share_lemmas', BOOL, False, 'Share frame lemmas'),
  170:                           ('spacer.p3.share_invariants', BOOL, False, "Share invariants lemmas"),
  171:                           ('spacer.min_level', UINT, 0, 'Minimal level to explore'),
  172:                           ('spacer.trace_file', SYMBOL, '', 'Log file for progress events'),
  173:                           ('spacer.ctp', BOOL, True, 'Enable counterexample-to-pushing'),
  174:                           ('spacer.use_inc_clause', BOOL, True, 'Use incremental clause to represent trans'),
  175:                           ('spacer.dump_benchmarks', BOOL, False, 'Dump SMT queries as benchmarks'),
  176:                           ('spacer.dump_threshold', DOUBLE, 5.0, 'Threshold in seconds on dumping benchmarks'),
  177:                           ('spacer.gpdr', BOOL, False, 'Use GPDR solving strategy for non-linear CHC'),
  178:                           ('spacer.gpdr.bfs', BOOL, True, 'Use BFS exploration strategy for expanding model search'),
  179:                           ('spacer.use_bg_invs', BOOL, False, 'Enable external background invariants'),
  180:                           ('spacer.use_lim_num_gen', BOOL, False, 'Enable limit numbers generalizer to get smaller numbers'),
  181:                           ('spacer.logic', SYMBOL, '', 'SMT-LIB logic to configure internal SMT solvers'),
  182:                           ('spacer.arith.solver', UINT, 2, 'arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver'),
  183:                           ('spacer.global', BOOL, False, 'Enable global guidance'),
  184:                           ('spacer.gg.concretize', BOOL, True, 'Enable global guidance concretize'),
  185:                           ('spacer.gg.conjecture', BOOL, True, 'Enable global guidance conjecture'),
  186:                           ('spacer.gg.subsume', BOOL, True, 'Enable global guidance subsume'),
  187:                           ('spacer.use_iuc', BOOL, True, 'Enable Interpolating Unsat Core(IUC) for lemma generalization'),
  188:                           ('spacer.expand_bnd', BOOL, False, 'Enable expand-bound lemma generalization'),
  189                            ))

z3/src/nlsat/nlsat_params.pyg:
   1  
   2: def_module_params('nlsat', 
   3:                   description='nonlinear solver',
   4:                   export=True,
   5:                   params=(max_memory_param(),
   6                            ('lazy', UINT, 0, "how lazy the solver is."),
   7                            ('reorder', BOOL, True, "reorder variables."),
   8:                           ('log_lemmas', BOOL, False, "display lemmas as self-contained SMT formulas"),
   9:                           ('check_lemmas', BOOL, False, "check lemmas on the fly using an independent nlsat solver"),
  10:                           ('simplify_conflicts', BOOL, True, "simplify conflicts using equalities before resolving them in nlsat solver."),
  11                            ('minimize_conflicts', BOOL, False, "minimize conflicts"),

  14                            ('shuffle_vars', BOOL, False, "use a random variable order."),
  15:                           ('inline_vars', BOOL, False, "inline variables that can be isolated from equations (not supported in incremental mode)"),
  16                            ('seed', UINT, 0, "random seed."),
  17:                           ('factor', BOOL, True, "factor polynomials produced during conflict resolution.")     
  18                            ))         

z3/src/opt/opt_params.pyg:
   1: def_module_params('opt', 
   2:                   description='optimization parameters',
   3:                   export=True,
   4:                   params=(('optsmt_engine', SYMBOL, 'basic', "select optimization engine: 'basic', 'symba'"),
   5:                           ('maxsat_engine', SYMBOL, 'maxres', "select engine for maxsat: 'core_maxsat', 'wmax', 'maxres', 'pd-maxres', 'maxres-bin', 'rc2'"),
   6:                           ('priority', SYMBOL, 'lex', "select how to priortize objectives: 'lex' (lexicographic), 'pareto', 'box'"),
   7:                           ('dump_benchmarks', BOOL, False, 'dump benchmarks for profiling'),
   8:                           ('dump_models', BOOL, False, 'display intermediary models to stdout'),
   9:                           ('solution_prefix', SYMBOL, '', "path prefix to dump intermediary, but non-optimal, solutions"),
  10                            ('timeout', UINT, UINT_MAX, 'timeout (in milliseconds) (UINT_MAX and 0 mean no timeout)'),

  14                            ('lns_conflicts', UINT, 1000, 'initial conflict count for LNS search'),
  15:                           ('enable_core_rotate', BOOL, False, 'enable core rotation to both sample cores and correction sets'),
  16:                           ('enable_sat', BOOL, True, 'enable the new SAT core for propositional constraints'),
  17                            ('elim_01', BOOL, True, 'eliminate 01 variables'),
  18: 			  ('incremental', BOOL, False, 'set incremental mode. It disables pre-processing and enables adding constraints in model event handler'),
  19:                           ('pp.neat', BOOL, True, 'use neat (as opposed to less readable, but faster) pretty printer when displaying context'),
  20:                           ('pb.compile_equality', BOOL, False, 'compile arithmetical equalities into pseudo-Boolean equality (instead of two inequalites)'),
  21:                           ('pp.wcnf', BOOL, False, 'print maxsat benchmark into wcnf format'),
  22:                           ('maxlex.enable', BOOL, True, 'enable maxlex heuristic for lexicographic MaxSAT problems'),
  23                            ('rc2.totalizer', BOOL, True, 'use totalizer for rc2 encoding'),
  24:                           ('maxres.hill_climb', BOOL, True, 'give preference for large weight cores'),
  25:                           ('maxres.add_upper_bound_block', BOOL, False, 'restict upper bound with constraint'),
  26:                           ('maxres.max_num_cores', UINT, 200, 'maximal number of cores per round'),
  27                            ('maxres.max_core_size', UINT, 3, 'break batch of generated cores if size reaches this number'),
  28:                           ('maxres.maximize_assignment', BOOL, False, 'find an MSS/MCS to improve current assignment'), 
  29:                           ('maxres.max_correction_set_size', UINT, 3, 'allow generating correction set constraints up to maximal size'),
  30:                           ('maxres.wmax', BOOL, False, 'use weighted theory solver to constrain upper bounds'),
  31:                           ('maxres.pivot_on_correction_set', BOOL, True, 'reduce soft constraints if the current correction set is smaller than current core')
  32  

z3/src/params/arith_rewriter_params.pyg:
   1: def_module_params(module_name='rewriter',
   2:                   class_name='arith_rewriter_params',
   3:                   export=True,
   4:                   params=(("algebraic_number_evaluator", BOOL, True, "simplify/evaluate expressions containing (algebraic) irrational numbers."),
   5:                           ("mul_to_power", BOOL, False, "collpase (* t ... t) into (^ t k), it is ignored if expand_power is true."),
   6:                           ("expand_power", BOOL, False, "expand (^ t k) into (* t ... t) if  1 < k <= max_degree."),
   7:                           ("expand_tan", BOOL, False, "replace (tan x) with (/ (sin x) (cos x))."),
   8:                           ("max_degree", UINT, 64, "max degree of algebraic numbers (and power operators) processed by simplifier."),
   9:                           ("sort_sums", BOOL, False, "sort the arguments of + application."),
  10                            ("gcd_rounding", BOOL, False, "use gcd rounding on integer arithmetic atoms."),

  12                            ("arith_ineq_lhs", BOOL, False, "rewrite inequalities so that right-hand-side is a constant."),
  13:                           ("elim_to_real", BOOL, False, "eliminate to_real from arithmetic predicates that contain only integers."),
  14:                           ("push_to_real", BOOL, True, "distribute to_real over * and +."),
  15:                           ("eq2ineq", BOOL, False, "expand equalities into two inequalities"),
  16:                           ("elim_rem", BOOL, False, "replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))).")))

z3/src/params/array_rewriter_params.pyg:
  1: def_module_params(module_name='rewriter',
  2:                   class_name='array_rewriter_params',
  3:                   export=True,
  4:                   params=(("expand_select_store", BOOL, False, "conservatively replace a (select (store ...) ...) term by an if-then-else term"),
  5:                           ("blast_select_store", BOOL, False, "eagerly replace all (select (store ..) ..) term by an if-then-else term"),
  6:                           ("expand_nested_stores", BOOL, False, "replace nested stores by a lambda expression"),
  7:                           ("expand_select_ite", BOOL, False, "expand select over ite expressions"),
  8:                           ("expand_store_eq", BOOL, False, "reduce (store ...) = (store ...) with a common base into selects"),
  9                            ("sort_store", BOOL, False, "sort nested stores when the indices are known to be different")))

z3/src/params/bool_rewriter_params.pyg:
   1: def_module_params(module_name='rewriter',
   2:                   class_name='bool_rewriter_params',
   3:                   export=True,
   4:                   params=(("ite_extra_rules", BOOL, True, "extra ite simplifications, these additional simplifications may reduce size locally but increase globally"),
   5:                           ("flat", BOOL, True, "create nary applications for +,*,bvadd,bvmul,bvand,bvor,bvxor"),
   6:                           ("flat_and_or", BOOL, True, "create nary applications for and,or"),
   7                            ("elim_and", BOOL, False, "conjunctions are rewritten using negation and disjunctions"),
   8                            ('elim_ite', BOOL, True,  "eliminate ite in favor of and/or"),
   9:                           ("local_ctx", BOOL, False, "perform local (i.e., cheap) context simplifications"),
  10:                           ("local_ctx_limit", UINT, UINT_MAX, "limit for applying local context simplifier"),
  11:                           ("blast_distinct", BOOL, False, "expand a distinct predicate into a quadratic number of disequalities"), 
  12:                           ("blast_distinct_threshold", UINT, UINT_MAX, "when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted")  
  13                            ))

z3/src/params/bv_rewriter_params.pyg:
   1: def_module_params(module_name='rewriter',
   2:                   class_name='bv_rewriter_params',
   3:                   export=True,
   4:                   params=(("split_concat_eq", BOOL, False, "split equalities of the form (= (concat t1 t2) t3)"),
   5                            ("bit2bool", BOOL, True, "try to convert bit-vector terms of size 1 into Boolean terms"),
   6                            ("blast_eq_value", BOOL, False, "blast (some) Bit-vector equalities into bits"),
   7:                           ("elim_sign_ext", BOOL, True, "expand sign-ext operator using concat and extract"),
   8:                           ("hi_div0", BOOL, True, "use the 'hardware interpretation' for division by zero (for bit-vector terms)"),
   9:                           ("mul2concat", BOOL, False, "replace multiplication by a power of two into a concatenation"),
  10:                           ("bv_sort_ac", BOOL, False, "sort the arguments of all AC operators"),
  11:                           ("bv_extract_prop", BOOL, False, "attempt to partially propagate extraction inwards"),
  12:                           ("bv_not_simpl", BOOL, False, "apply simplifications for bvnot"),
  13:                           ("bv_ite2id", BOOL, False, "rewrite ite that can be simplified to identity"),
  14:                           ("bv_le_extra", BOOL, False, "additional bu_(u/s)le simplifications"),
  15                            ("bv_le2extract", BOOL, True, "disassemble bvule to extract")

z3/src/params/fpa_rewriter_params.pyg:
  1: def_module_params(module_name='rewriter',
  2:                   class_name='fpa_rewriter_params',
  3:                   export=True,
  4:                   params=(("hi_fp_unspecified", BOOL, False, "use the 'hardware interpretation' for unspecified values in fp.to_ubv, fp.to_sbv, fp.to_real, and fp.to_ieee_bv"),
  5  ))

z3/src/params/fpa2bv_rewriter_params.pyg:
  1: def_module_params(module_name='rewriter',
  2:                   class_name='fpa2bv_rewriter_params',
  3:                   export=True,
  4:                   params=(("hi_fp_unspecified", BOOL, False, "use the 'hardware interpretation' for unspecified values in fp.min, fp.max, fp.to_ubv, fp.to_sbv, and fp.to_real"),
  5  ))

z3/src/params/pattern_inference_params_helper.pyg:
   1: def_module_params(class_name='pattern_inference_params_helper',
   2:                   module_name='pi',
   3:                   description='pattern inference (heuristics) for universal formulas (without annotation)',
   4:                   export=True,
   5:                   params=(('max_multi_patterns', UINT, 0, 'when patterns are not provided, the prover uses a heuristic to infer them, this option sets the threshold on the number of extra multi-patterns that can be created; by default, the prover creates at most one multi-pattern when there is no unary pattern'),
   6:                           ('block_loop_patterns', BOOL, True, 'block looping patterns during pattern inference'),
   7:                           ('arith', UINT, 1, '0 - do not infer patterns with arithmetic terms, 1 - use patterns with arithmetic terms if there is no other pattern, 2 - always use patterns with arithmetic terms'),
   8:                           ('use_database', BOOL, False, 'use pattern database'),
   9:                           ('arith_weight', UINT, 5, 'default weight for quantifiers where the only available pattern has nested arithmetic terms'),
  10:                           ('non_nested_arith_weight', UINT, 10, 'default weight for quantifiers where the only available pattern has non nested arithmetic terms'),
  11:                           ('pull_quantifiers', BOOL, True, 'pull nested quantifiers, if no pattern was found'),
  12:                           ('warnings', BOOL, False, 'enable/disable warning messages in the pattern inference module')))

z3/src/params/poly_rewriter_params.pyg:
  1: def_module_params(module_name='rewriter',
  2:                   class_name='poly_rewriter_params',
  3:                   export=True,
  4:                   params=(("som", BOOL, False, "put polynomials in sum-of-monomials form"),
  5:                           ("som_blowup", UINT, 10, "maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form"),
  6:                           ("hoist_mul", BOOL, False, "hoist multiplication over summation to minimize number of multiplications"),
  7:                           ("hoist_ite", BOOL, False, "hoist shared summands under ite expressions"),
  8:                           ("flat", BOOL, True, "create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor")))

z3/src/params/rewriter_params.pyg:
   1: def_module_params('rewriter',
   2:                   description='new formula simplification module used in the tactic framework, and new solvers',
   3:                   export=True,
   4:                   params=(max_memory_param(),
   5:                           max_steps_param(),
   6:                           ("push_ite_arith", BOOL, False, "push if-then-else over arithmetic terms."),
   7:                           ("push_ite_bv", BOOL, False, "push if-then-else over bit-vector terms."),
   8:                           ("pull_cheap_ite", BOOL, False, "pull if-then-else terms when cheap."),
   9:                           ("bv_ineq_consistency_test_max", UINT, 0, "max size of conjunctions on which to perform consistency test based on inequalities on bitvectors."),
  10                            ("cache_all", BOOL, False, "cache all intermediate results."),
  11:                           ("rewrite_patterns", BOOL, False, "rewrite patterns."),
  12:                           ("ignore_patterns_on_ground_qbody", BOOL, True, "ignores patterns on quantifiers that don't mention their bound variables.")))
  13  

z3/src/params/seq_rewriter_params.pyg:
  1: def_module_params(module_name='rewriter',
  2:                   class_name='seq_rewriter_params',
  3:                   export=True,
  4:                   params=(("coalesce_chars", BOOL, True, "coalesce characters into strings"),))

z3/src/params/solver_params.pyg:
   1  
   2: def_module_params('solver', 
   3:                   description='solver parameters',
   4:                   export=True,
   5:                   params=(('smtlib2_log', SYMBOL, '', "file to save solver interaction"),
   6:                           ('cancel_backup_file', SYMBOL, '', "file to save partial search state if search is canceled"),
   7                            ('timeout', UINT, UINT_MAX, "timeout on the solver object; overwrites a global timeout"),
   8:                           ('lemmas2console', BOOL, False, 'print lemmas during search'),
   9:                           ('instantiations2console', BOOL, False, 'print quantifier instantiations to the console'),
  10:                           ('axioms2files', BOOL, False, 'print negated theory axioms to separate files during search'),
  11:                           ('proof.check', BOOL, True, 'check proof logs'),
  12:                           ('proof.save', BOOL, False, 'save proof log into a proof object that can be extracted using (get-proof)'),
  13:                           ('proof.trim', BOOL, False, 'trim and save proof into a proof object that an be extracted using (get-proof)'),			  
  14                            ))

z3/src/params/tactic_params.pyg:
   1  
   2: def_module_params('tactic', 
   3:                   description='tactic parameters',
   4:                   export=True,
   5:                   params=(('solve_eqs.context_solve', BOOL, True, "solve equalities within disjunctions."),
   6                            ('solve_eqs.theory_solver', BOOL, True, "use theory solvers."),

   8                            ('solve_eqs.max_occs', UINT, UINT_MAX, "maximum number of occurrences for considering a variable for gaussian eliminations."),
   9:                           ('blast_term_ite.max_inflation', UINT, UINT_MAX, "multiplicative factor of initial term size."),
  10:                           ('blast_term_ite.max_steps', UINT, UINT_MAX, "maximal number of steps allowed for tactic."),
  11:                           ('propagate_values.max_rounds', UINT, 4, "maximal number of rounds to propagate values."),
  12                            ('default_tactic', SYMBOL, '', "overwrite default tactic in strategic solver"),
  13  
  14:                      #     ('aig.per_assertion', BOOL, True, "process one assertion at a time"),
  15                       #     ('add_bounds.lower, INT, -2, "lower bound to be added to unbounded variables."),
  16:                      #     ('add_bounds.upper, INT, 2, "upper bound to be added to unbounded variables."),
  17                       #     ('fm.real_only', BOOL, True, "consider only real variables for FM"),

  19                       #     ('fm.limit', UINT, 5000000, "maximal number of constraints, monomials, clauses visited during FM."),
  20:                      # etc: lia2card, factor, nla2bv, normalize_bounds, pb2bv, purify_arith, bit_blaster, bv_bounds
  21                            ))

z3/src/parsers/util/parser_params.pyg:
  1: def_module_params('parser', 
  2:                   export=True,
  3:                   params=(('ignore_user_patterns', BOOL, False, 'ignore patterns provided by the user'),
  4:                           ('ignore_bad_patterns',  BOOL, True, 'ignore malformed patterns'),
  5:                           ('error_for_visual_studio', BOOL, False, 'display error messages in Visual Studio format'),
  6                            ))

z3/src/sat/sat_asymm_branch_params.pyg:
  1: def_module_params(module_name='sat', 
  2:                   class_name='sat_asymm_branch_params',
  3:                   export=True,
  4:                   params=(('asymm_branch', BOOL, True, 'asymmetric branching'),
  5:                           ('asymm_branch.rounds', UINT, 2, 'maximal number of rounds to run asymmetric branch simplifications if progress is made'),
  6:                           ('asymm_branch.delay', UINT, 1, 'number of simplification rounds to wait until invoking asymmetric branch simplification'),
  7:                           ('asymm_branch.sampled', BOOL, True, 'use sampling based asymmetric branching based on binary implication graph'),
  8:                           ('asymm_branch.limit', UINT, 100000000, 'approx. maximum number of literals visited during asymmetric branching'),
  9:                           ('asymm_branch.all', BOOL, False, 'asymmetric branching on all literals per clause')))

z3/src/sat/sat_params.pyg:
    1: def_module_params('sat',
    2:                   export=True,
    3:                   description='propositional SAT solver',
    4:                   params=(max_memory_param(),
    5:                           ('phase', SYMBOL, 'caching', 'phase selection strategy: always_false, always_true, basic_caching, random, caching'),
    6:                           ('phase.sticky', BOOL, True, 'use sticky phase caching'),
    7:                           ('search.unsat.conflicts', UINT, 400, 'period for solving for unsat (in number of conflicts)'),
    8:                           ('search.sat.conflicts', UINT, 400, 'period for solving for sat (in number of conflicts)'),
    9:                           ('rephase.base', UINT, 1000, 'number of conflicts per rephase '),
   10:                           ('reorder.base', UINT, UINT_MAX, 'number of conflicts per random reorder '),
   11:                           ('reorder.itau', DOUBLE, 4.0, 'inverse temperature for softmax'),
   12:                           ('reorder.activity_scale', UINT, 100, 'scaling factor for activity update'),
   13:                           ('propagate.prefetch', BOOL, True, 'prefetch watch lists for assigned literals'),
   14                            ('restart', SYMBOL, 'ema', 'restart strategy: static, luby, ema or geometric'),

   16                            ('restart.max', UINT, UINT_MAX, 'maximal number of restarts.'),
   17:                           ('restart.fast', BOOL, True, 'use fast restart approach only removing less active literals.'),
   18                            ('restart.factor', DOUBLE, 1.5, 'restart increment factor for geometric strategy'),
   19                            ('restart.margin', DOUBLE, 1.1, 'margin between fast and slow restart factors. For ema'),
   20:                           ('restart.emafastglue', DOUBLE, 3e-2, 'ema alpha factor for fast moving average'),
   21:                           ('restart.emaslowglue', DOUBLE, 1e-5, 'ema alpha factor for slow moving average'),
   22:                           ('variable_decay', UINT, 110, 'multiplier (divided by 100) for the VSIDS activity increment'),
   23:                           ('inprocess.max', UINT, UINT_MAX, 'maximal number of inprocessing passes'),
   24:                           ('inprocess.out', SYMBOL, '', 'file to dump result of the first inprocessing step and exit'),
   25                            ('branching.heuristic', SYMBOL, 'vsids', 'branching heuristic vsids, chb'),
   26:                           ('branching.anti_exploration', BOOL, False, 'apply anti-exploration heuristic for branch selection'),
   27:                           ('random_freq', DOUBLE, 0.01, 'frequency of random case splits'),
   28                            ('random_seed', UINT, 0, 'random seed'),
   29:                           ('burst_search', UINT, 100, 'number of conflicts before first global simplification'),
   30:                           ('enable_pre_simplify', BOOL, False, 'enable pre simplifications before the bounded search'),
   31                            ('max_conflicts', UINT, UINT_MAX, 'maximum number of conflicts'),
   32:                           ('gc', SYMBOL, 'glue_psm', 'garbage collection strategy: psm, glue, glue_psm, dyn_psm'),
   33                            ('gc.initial', UINT, 20000, 'learned clauses garbage collection frequency'),
   34                            ('gc.increment', UINT, 500, 'increment to the garbage collection threshold'),
   35:                           ('gc.small_lbd', UINT, 3, 'learned clauses with small LBD are never deleted (only used in dyn_psm)'),
   36:                           ('gc.k', UINT, 7, 'learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm)'),
   37:                           ('gc.burst', BOOL, False, 'perform eager garbage collection during initialization'),
   38                            ('gc.defrag', BOOL, True, 'defragment clauses when garbage collecting'),
   39:                           ('simplify.delay', UINT, 0, 'set initial delay of simplification by a conflict count'),
   40:                           ('force_cleanup', BOOL, False, 'force cleanup to remove tautologies and simplify clauses'),
   41                            ('minimize_lemmas', BOOL, True, 'minimize learned clauses'),
   42:                           ('dyn_sub_res', BOOL, True, 'dynamic subsumption resolution for minimizing learned clauses'),
   43:                           ('core.minimize', BOOL, False, 'minimize computed core'),
   44:                           ('core.minimize_partial', BOOL, False, 'apply partial (cheap) core minimization'),
   45:                           ('backtrack.scopes', UINT, 100, 'number of scopes to enable chronological backtracking'),
   46                            ('backtrack.conflicts', UINT, 4000, 'number of conflicts before enabling chronological backtracking'),
   47:                           ('threads', UINT, 1, 'number of parallel threads to use'),
   48                            ('dimacs.core', BOOL, False, 'extract core from DIMACS benchmarks'),
   49                            ('drat.disable', BOOL, False, 'override anything that enables DRAT'),
   50:                           ('smt.proof', SYMBOL, '', 'add SMT proof to file'),
   51:                           ('smt.proof.check', BOOL, False, 'check SMT proof while it is created'),
   52:                           ('smt.proof.check_rup', BOOL, True, 'apply forward RUP proof checking'),
   53:                           ('drat.file', SYMBOL, '', 'file to dump DRAT proofs'),
   54:                           ('drat.binary', BOOL, False, 'use Binary DRAT output format'),
   55:                           ('drat.check_unsat', BOOL, False, 'build up internal proof and check'),
   56:                           ('drat.check_sat', BOOL, False, 'build up internal trace, check satisfying model'),
   57:                           ('drat.activity', BOOL, False, 'dump variable activities'),
   58                            ('cardinality.solver', BOOL, True, 'use cardinality solver'),
   59:                           ('pb.solver', SYMBOL, 'solver', 'method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver)'),
   60:                           ('pb.min_arity', UINT, 9, 'minimal arity to compile pb/cardinality constraints to CNF'),
   61:                           ('cardinality.encoding', SYMBOL, 'grouped', 'encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit'),
   62:                           ('pb.resolve', SYMBOL, 'cardinality', 'resolution strategy for boolean algebra solver: cardinality, rounding'),
   63:                           ('pb.lemma_format', SYMBOL, 'cardinality', 'generate either cardinality or pb lemmas'),
   64:                           ('euf', BOOL, False, 'enable euf solver (this feature is preliminary and not ready for general consumption)'),
   65                            ('ddfw_search', BOOL, False, 'use ddfw local search instead of CDCL'),
   66                            ('ddfw.init_clause_weight', UINT, 8, 'initial clause weight for DDFW local search'),
   67:                           ('ddfw.use_reward_pct', UINT, 15, 'percentage to pick highest reward variable when it has reward 0'),
   68:                           ('ddfw.restart_base', UINT, 100000, 'number of flips used a starting point for hessitant restart backoff'),
   69                            ('ddfw.reinit_base', UINT, 10000, 'increment basis for geometric backoff scheme of re-initialization of weights'),
   70:                           ('ddfw.threads', UINT, 0, 'number of ddfw threads to run in parallel with sat solver'),
   71:                           ('prob_search', BOOL, False, 'use probsat local search instead of CDCL'),
   72                            ('local_search', BOOL, False, 'use local search instead of CDCL'),

   74                            ('local_search_mode', SYMBOL, 'wsat', 'local search algorithm, either default wsat or qsat'),
   75:                           ('local_search_dbg_flips', BOOL, False, 'write debug information for number of flips'),
   76:                           ('binspr', BOOL, False, 'enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models'),
   77: 	                  ('anf', BOOL, False, 'enable ANF based simplification in-processing'),
   78: 	                  ('anf.delay', UINT, 2, 'delay ANF simplification by in-processing round'),
   79:                           ('anf.exlin', BOOL, False, 'enable extended linear simplification'), 
   80: 		          ('cut', BOOL, False, 'enable AIG based simplification in-processing'),
   81: 	                  ('cut.delay', UINT, 2, 'delay cut simplification by in-processing round'),
   82:                           ('cut.aig',   BOOL, False, 'extract aigs (and ites) from cluases for cut simplification'),
   83:                           ('cut.lut',   BOOL, False, 'extract luts from clauses for cut simplification'),
   84:                           ('cut.xor',   BOOL, False, 'extract xors from clauses for cut simplification'),
   85:                           ('cut.npn3',  BOOL, False, 'extract 3 input functions from clauses for cut simplification'),
   86                            ('cut.dont_cares', BOOL, True, 'integrate dont cares with cuts'),
   87                            ('cut.redundancies', BOOL, True, 'integrate redundancy checking of cuts'),
   88:                           ('cut.force', BOOL, False, 'force redoing cut-enumeration until a fixed-point'),
   89:                           ('lookahead.cube.cutoff', SYMBOL, 'depth', 'cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat'),
   90:                           # - depth: the maximal cutoff is fixed to the value of lookahead.cube.depth.
   91                            #          So if the value is 10, at most 1024 cubes will be generated of length 10.
   92                            # - freevars: cutoff based on a variable fraction of lookahead.cube.freevars.
   93:                           #          Cut if the number of current unassigned variables drops below a fraction of number of initial variables.
   94:                           # - psat:  Let psat_heur := (Sum_{clause C} (psat.clause_base ^ {-|C|+1})) / |freevars|^psat.var_exp
   95:                           #          Cut if the value of psat_heur exceeds psat.trigger
   96:                           # - adaptive_freevars: Cut if the number of current unassigned variables drops below a fraction of free variables
   97                            #          at the time of the last conflict. The fraction is increased every time the cutoff is created.
   98:                           # - adative_psat: Cut based on psat_heur in an adaptive way.
   99  
  100:                           ('lookahead.cube.fraction', DOUBLE, 0.4, 'adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat'),
  101:                           ('lookahead.cube.depth', UINT, 1, 'cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth.'),
  102                            ('lookahead.cube.freevars', DOUBLE, 0.8, 'cube free variable fraction. Used when lookahead.cube.cutoff is freevars'),
  103:                           ('lookahead.cube.psat.var_exp', DOUBLE, 1, 'free variable exponent for PSAT cutoff'),
  104:                           ('lookahead.cube.psat.clause_base', DOUBLE, 2, 'clause base for PSAT cutoff'),
  105:                           ('lookahead.cube.psat.trigger', DOUBLE, 5, 'trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat'),
  106:                           ('lookahead.preselect', BOOL, False, 'use pre-selection of subset of variables for branching'),
  107:                           ('lookahead_simplify', BOOL, False, 'use lookahead solver during simplification'),
  108                            ('lookahead_scores', BOOL, False, 'extract lookahead scores. A utility that can only be used from the DIMACS front-end'),

  110                            ('lookahead.use_learned', BOOL, False, 'use learned clauses when selecting lookahead literal'),
  111:                           ('lookahead_simplify.bca', BOOL, True, 'add learned binary clauses as part of lookahead simplification'),
  112:                           ('lookahead.global_autarky', BOOL, False, 'prefer to branch on variables that occur in clauses that are reduced'),
  113                            ('lookahead.delta_fraction', DOUBLE, 1.0, 'number between 0 and 1, the smaller the more literals are selected for double lookahead'),

  126                            # Each reward function also comes with its own variant of "mix_diff", which
  127:                           # is the function for combining reward metrics for the positive and negative variant of a literal.
  128                            )

z3/src/sat/sat_scc_params.pyg:
  1: def_module_params(module_name='sat', 
  2:                   class_name='sat_scc_params',
  3:                   export=True,
  4:                   params=(('scc', BOOL, True, 'eliminate Boolean variables by computing strongly connected components'),
  5:                           ('scc.tr', BOOL, True, 'apply transitive reduction, eliminate redundant binary clauses'), ))
  6  

z3/src/sat/sat_simplifier_params.pyg:
   1: def_module_params(module_name='sat',
   2:                   class_name='sat_simplifier_params',
   3:                   export=True,
   4:                   params=(('bce',  BOOL, False, 'eliminate blocked clauses'),
   5                            ('abce', BOOL, False, 'eliminate blocked clauses using asymmetric literals'),

   8                            ('acce', BOOL, False, 'eliminate covered clauses using asymmetric added literals'),
   9:                           ('bce_at', UINT, 2, 'eliminate blocked clauses only once at the given simplification round'),
  10                            ('bca', BOOL, False, 'blocked clause addition - add blocked binary clauses'),
  11:                           ('bce_delay', UINT, 2, 'delay eliminate blocked clauses until simplification round'),
  12                            ('retain_blocked_clauses', BOOL, True, 'retain blocked clauses as lemmas'),
  13                            ('blocked_clause_limit', UINT, 100000000, 'maximum number of literals visited during blocked clause elimination'),
  14:                           ('override_incremental', BOOL, False, 'override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused'),
  15:                           ('resolution.limit', UINT, 500000000, 'approx. maximum number of literals visited during variable elimination'),
  16:                           ('resolution.occ_cutoff', UINT, 10, 'first cutoff (on number of positive/negative occurrences) for Boolean variable elimination'),
  17:                           ('resolution.occ_cutoff_range1', UINT, 8, 'second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses'),
  18:                           ('resolution.occ_cutoff_range2', UINT, 5, 'second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2'),
  19:                           ('resolution.occ_cutoff_range3', UINT, 3, 'second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2'),
  20:                           ('resolution.lit_cutoff_range1', UINT, 700, 'second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses'),
  21:                           ('resolution.lit_cutoff_range2', UINT, 400, 'second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2'),
  22:                           ('resolution.lit_cutoff_range3', UINT, 300, 'second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2'),
  23:                           ('resolution.cls_cutoff1', UINT, 100000000, 'limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination'),
  24:                           ('resolution.cls_cutoff2', UINT, 700000000, 'limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination'),
  25:                           ('elim_vars', BOOL, True, 'enable variable elimination using resolution during simplification'),
  26:                           ('elim_vars_bdd', BOOL, True, 'enable variable elimination using BDD recompilation during simplification'),
  27:                           ('elim_vars_bdd_delay', UINT, 3, 'delay elimination of variables using BDDs until after simplification round'),
  28:                           ('probing', BOOL, True, 'apply failed literal detection during simplification'),
  29:                           ('probing_limit', UINT, 5000000, 'limit to the number of probe calls'),
  30:                           ('probing_cache', BOOL, True, 'add binary literals as lemmas'),
  31:                           ('probing_cache_limit', UINT, 1024, 'cache binaries unless overall memory usage exceeds cache limit'),
  32:                           ('probing_binary', BOOL, True, 'probe binary clauses'),
  33:                           ('subsumption', BOOL, True, 'eliminate subsumed clauses'),
  34:                           ('subsumption.limit', UINT, 100000000, 'approx. maximum number of literals visited during subsumption (and subsumption resolution)')))

z3/src/smt/params/smt_params_helper.pyg:
    1: def_module_params(module_name='smt',
    2:                   class_name='smt_params_helper',
    3:                   description='smt solver based on lazy smt',
    4:                   export=True,
    5:                   params=(('auto_config', BOOL, True, 'automatically configure solver'),
    6:                           ('logic', SYMBOL, '', 'logic used to setup the SMT solver'),
    7                            ('random_seed', UINT, 0, 'random seed for the smt solver'),
    8:                           ('relevancy', UINT, 2, 'relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant'),
    9                            ('macro_finder', BOOL, False, 'try to find universally quantified formulas that can be viewed as macros'),

   12                            ('ematching', BOOL, True, 'E-Matching based quantifier instantiation'),
   13:                           ('phase_selection', UINT, 3, 'phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory'),
   14: 	                  ('phase_caching_on', UINT, 400, 'number of conflicts while phase caching is on'),
   15: 	                  ('phase_caching_off', UINT, 100, 'number of conflicts while phase caching is off'),
   16                            ('restart_strategy', UINT, 1, '0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic'),
   17:                           ('restart_factor', DOUBLE, 1.1, 'when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold'),
   18:                           ('case_split', UINT, 1, '0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity'),
   19                            ('delay_units', BOOL, False, 'if true then z3 will not restart when a unit clause is learned'),
   20                            ('delay_units_threshold', UINT, 32, 'maximum number of learned unit clauses before restarting, ignored if delay_units is false'),
   21:                           ('pull_nested_quantifiers', BOOL, False, 'pull nested quantifiers'),
   22                            ('refine_inj_axioms', BOOL, True, 'refine injectivity axioms'),
   23: 	                  ('candidate_models', BOOL, False, 'create candidate models even when quantifier or theory reasoning is incomplete'),
   24:                           ('max_conflicts', UINT, UINT_MAX, 'maximum number of conflicts before giving up.'),
   25                            ('restart.max', UINT, UINT_MAX, 'maximal number of restarts.'),
   26: 	                  ('cube_depth', UINT, 1, 'cube depth.'),
   27:                           ('threads', UINT, 1, 'maximal number of parallel threads.'),
   28:                           ('threads.max_conflicts', UINT, 400, 'maximal number of conflicts between rounds of cubing for parallel SMT'),
   29                            ('threads.cube_frequency', UINT, 2, 'frequency for using cubing'), 
   30                            ('mbqi', BOOL, True, 'model based quantifier instantiation (MBQI)'),
   31:                           ('mbqi.max_cexs', UINT, 1, 'initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation'),
   32:                           ('mbqi.max_cexs_incr', UINT, 0, 'increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI'),
   33                            ('mbqi.max_iterations', UINT, 1000, 'maximum number of rounds of MBQI'),
   34:                           ('mbqi.trace', BOOL, False, 'generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied'),
   35:                           ('mbqi.force_template', UINT, 10, 'some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template'),
   36                            ('mbqi.id', STRING, '', 'Only use model-based instantiation for quantifiers with id\'s beginning with string'),
   37                            ('q.lift_ite', UINT, 0, '0 - don not lift non-ground if-then-else, 1 - use conservative ite lifting, 2 - use full lifting of if-then-else under quantifiers'),
   38:                           ('q.lite', BOOL, False, 'Use cheap quantifier elimination during pre-processing'),
   39:                           ('qi.profile', BOOL, False, 'profile quantifier instantiation'),
   40:                           ('qi.profile_freq', UINT, UINT_MAX, 'how frequent results are reported by qi.profile'),
   41                            ('qi.max_instances', UINT, UINT_MAX, 'maximum number of quantifier instantiations'),

   43                            ('qi.lazy_threshold', DOUBLE, 20.0, 'threshold for lazy quantifier instantiation'),
   44:                           ('qi.cost', STRING, '(+ weight generation)', 'expression specifying what is the cost of a given quantifier instantiation'),
   45:                           ('qi.max_multi_patterns', UINT, 0, 'specify the number of extra multi patterns'),
   46:                           ('qi.quick_checker', UINT, 0, 'specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances'),
   47                            ('induction', BOOL, False, 'enable generation of induction lemmas'),
   48                            ('bv.reflect', BOOL, True, 'create enode for every bit-vector term'),
   49:                           ('bv.enable_int2bv', BOOL, True, 'enable support for int2bv and bv2int operators'),
   50                            ('bv.watch_diseq', BOOL, False, 'use watch lists instead of eager axioms for bit-vectors'),
   51:                           ('bv.delay', BOOL, False, 'delay internalize expensive bit-vector operations'),
   52                            ('bv.eq_axioms', BOOL, True, 'enable redundant equality axioms for bit-vectors'),
   53:                           ('bv.size_reduce', BOOL, False, 'turn assertions that set the upper bits of a bit-vector to constants into a substitution that replaces the bit-vector with constant bits. Useful for minimizing circuits as many input bits to circuits are constant'),
   54:                           ('arith.random_initial_value', BOOL, False, 'use random initial values in the simplex-based procedure for linear arithmetic'),
   55:                           ('arith.solver', UINT, 6, 'arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver'),
   56:                           ('arith.nl', BOOL, True, '(incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2'),
   57:                           ('arith.nl.nra', BOOL, True, 'call nra_solver when incremental linearization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6'),
   58                            ('arith.nl.branching', BOOL, True, 'branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2'),

   60                            ('arith.nl.order', BOOL, True, 'run order lemmas'),
   61:                           ('arith.nl.expp', BOOL, False, 'expensive patching'),
   62                            ('arith.nl.tangents', BOOL, True, 'run tangent lemmas'),

   69                            ('arith.nl.grobner_eqs_growth', UINT, 10, 'grobner\'s number of equalities growth '),
   70:                           ('arith.nl.grobner_expr_size_growth', UINT, 2, 'grobner\'s maximum expr size growth'),
   71:                           ('arith.nl.grobner_expr_degree_growth', UINT, 2, 'grobner\'s maximum expr degree growth'),
   72:                           ('arith.nl.grobner_max_simplified', UINT, 10000, 'grobner\'s maximum number of simplifications'),
   73:                           ('arith.nl.grobner_cnfl_to_report', UINT, 1, 'grobner\'s maximum number of conflicts to report'),
   74                            ('arith.nl.gr_q', UINT, 10, 'grobner\'s quota'),

   76  	                  ('arith.nl.delay', UINT, 500, 'number of calls to final check before invoking bounded nlsat check'),                       
   77:                           ('arith.propagate_eqs', BOOL, True, 'propagate (cheap) equalities'),
   78:                           ('arith.propagation_mode', UINT, 1, '0 - no propagation, 1 - propagate existing literals, 2 - refine finite bounds'),
   79                            ('arith.branch_cut_ratio', UINT, 2, 'branch/cut ratio for linear integer arithmetic'),

   81                            ('arith.ignore_int', BOOL, False, 'treat integer variables as real'),
   82:                           ('arith.dump_lemmas', BOOL, False, 'dump arithmetic theory lemmas to files'),
   83:                           ('arith.greatest_error_pivot', BOOL, False, 'Pivoting strategy'),
   84                            ('arith.eager_eq_axioms', BOOL, True, 'eager equality axioms'),
   85:                           ('arith.auto_config_simplex', BOOL, False, 'force simplex solver in auto_config'),
   86:                           ('arith.rep_freq', UINT, 0, 'the report frequency, in how many iterations print the cost and other info'),
   87                            ('arith.min', BOOL, False, 'minimize cost'),
   88:                           ('arith.print_stats', BOOL, False, 'print statistic'),
   89:                           ('arith.simplex_strategy', UINT, 0, 'simplex strategy for the solver'),
   90                            ('arith.enable_hnf', BOOL, True, 'enable hnf (Hermite Normal Form) cuts'),
   91:                           ('arith.bprop_on_pivoted_rows', BOOL, True, 'propagate bounds on rows changed by the pivot operation'),
   92:                           ('arith.print_ext_var_names', BOOL, False, 'print external variable names'),
   93:                           ('pb.conflict_frequency', UINT, 1000, 'conflict frequency for Pseudo-Boolean theory'),
   94:                           ('pb.learn_complements', BOOL, True, 'learn complement literals for Pseudo-Boolean theory'),
   95                            ('array.weak', BOOL, False, 'weak array theory'),
   96                            ('array.extensional', BOOL, True, 'extensional array theory'),
   97:                           ('clause_proof', BOOL, False, 'record a clausal proof'),
   98:                           ('dack', UINT, 1, '0 - disable dynamic ackermannization, 1 - expand Leibniz\'s axiom if a congruence is the root of a conflict, 2 - expand Leibniz\'s axiom if a congruence is used during conflict resolution'),
   99                            ('dack.eq', BOOL, False, 'enable dynamic ackermannization for transtivity of equalities'),
  100:                           ('dack.factor', DOUBLE, 0.1, 'number of instance per conflict'),
  101:                           ('dack.gc', UINT, 2000, 'Dynamic ackermannization garbage collection frequency (per conflict)'),
  102                            ('dack.gc_inv_decay', DOUBLE, 0.8, 'Dynamic ackermannization garbage collection decay'),
  103:                           ('dack.threshold', UINT, 10, ' number of times the congruence rule must be used before Leibniz\'s axiom is expanded'),
  104:                           ('theory_case_split', BOOL, False, 'Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead.'),
  105:                           ('string_solver', SYMBOL, 'seq', 'solver for string/sequence theories. options are: \'z3str3\' (specialized string solver), \'seq\' (sequence solver), \'auto\' (use static features to choose best solver), \'empty\' (a no-op solver that forces an answer unknown if strings were used), \'none\' (no solver)'),
  106:                           ('core.validate', BOOL, False, '[internal] validate unsat core produced by SMT context. This option is intended for debugging'),
  107:                           ('seq.split_w_len', BOOL, True, 'enable splitting guided by length constraints'),
  108                            ('seq.validate', BOOL, False, 'enable self-validation of theory axioms created by seq theory'),
  109:                           ('seq.max_unfolding', UINT, 1000000000, 'maximal unfolding depth for checking string equations and regular expressions'),
  110:                           ('seq.min_unfolding', UINT, 1, 'initial bound for strings whose lengths are bounded by iterative deepening. Set this to a higher value if there are only models with larger string lengths'),
  111:                           ('str.strong_arrangements', BOOL, True, 'assert equivalences instead of implications when generating string arrangement axioms'),
  112:                           ('str.aggressive_length_testing', BOOL, False, 'prioritize testing concrete length values over generating more options'),
  113:                           ('str.aggressive_value_testing', BOOL, False, 'prioritize testing concrete string constant values over generating more options'),
  114:                           ('str.aggressive_unroll_testing', BOOL, True, 'prioritize testing concrete regex unroll counts over generating more options'),
  115                            ('str.fast_length_tester_cache', BOOL, False, 'cache length tester constants instead of regenerating them'),

  117                            ('str.string_constant_cache', BOOL, True, 'cache all generated string constants generated from anywhere in theory_str'),
  118:                           ('theory_aware_branching', BOOL, False, 'Allow the context to use extra information from theory solvers regarding literal branching prioritization.'),
  119:                           ('str.overlap_priority', DOUBLE, -0.1, 'theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true'),
  120                            ('str.regex_automata_difficulty_threshold', UINT, 1000, 'difficulty threshold for regex automata heuristics'),
  121                            ('str.regex_automata_intersection_difficulty_threshold', UINT, 1000, 'difficulty threshold for regex intersection heuristics'),
  122:                           ('str.regex_automata_failed_automaton_threshold', UINT, 10, 'number of failed automaton construction attempts after which a full automaton is automatically built'),
  123:                           ('str.regex_automata_failed_intersection_threshold', UINT, 10, 'number of failed automaton intersection attempts after which intersection is always computed'),
  124:                           ('str.regex_automata_length_attempt_threshold', UINT, 10, 'number of length/path constraint attempts before checking unsatisfiability of regex terms'),
  125                            ('str.fixed_length_refinement', BOOL, False, 'use abstraction refinement in fixed-length equation solver (Z3str3 only)'),
  126:                           ('str.fixed_length_naive_cex', BOOL, True, 'construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only)'),
  127:                           ('core.minimize', BOOL, False, 'minimize unsat core produced by SMT context'),
  128:                           ('core.extend_patterns', BOOL, False, 'extend unsat core with literals that trigger (potential) quantifier instances'),
  129:                           ('core.extend_patterns.max_distance', UINT, UINT_MAX, 'limits the distance of a pattern-extended unsat core'),
  130:                           ('core.extend_nonlocal_patterns', BOOL, False, 'extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier\'s body'),
  131                            ('lemma_gc_strategy', UINT, 0, 'lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none'),
  132:                           ('dt_lazy_splits', UINT, 1, 'How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy')
  133                            ))

z3/src/solver/combined_solver_params.pyg:
  1: def_module_params('combined_solver', 
  2:                   description='combines two solvers: non-incremental (solver1) and incremental (solver2)',
  3:                   export=True,
  4:                   params=(('solver2_timeout', UINT, UINT_MAX, "fallback to solver 1 after timeout even when in incremental model"),
  5                            ('ignore_solver1', BOOL, False, "if true, solver 2 is always used"),
  6:                           ('solver2_unknown', UINT, 1, "what should be done when solver 2 returns unknown: 0 - just return unknown, 1 - execute solver 1 if quantifier free problem, 2 - execute solver 1")
  7                            ))

z3/src/solver/parallel_params.pyg:
   1: def_module_params('parallel',
   2:                   description='parameters for parallel solver',
   3:                   class_name='parallel_params',
   4:                   export=True,
   5:                   params=(
   6:                           ('enable', BOOL, False, 'enable parallel solver by default on selected tactics (for QF_BV)'),
   7:                           ('threads.max', UINT, 10000, 'caps maximal number of threads below the number of processors'),
   8                            ('conquer.batch_size', UINT, 100, 'number of cubes to batch together for fast conquer'),
   9:                           ('conquer.restart.max', UINT, 5, 'maximal number of restarts during conquer phase'),
  10:                           ('conquer.delay', UINT, 10, 'delay of cubes until applying conquer'),
  11:                           ('conquer.backtrack_frequency', UINT, 10, 'frequency to apply core minimization during conquer'),
  12:                           ('simplify.exp', DOUBLE, 1, 'restart and inprocess max is multiplied by simplify.exp ^ depth'),
  13:                           ('simplify.max_conflicts', UINT, UINT_MAX, 'maximal number of conflicts during simplifcation phase'),
  14:                           ('simplify.restart.max', UINT, 5000, 'maximal number of restarts during simplification phase'),
  15:                           ('simplify.inprocess.max', UINT, 2, 'maximal number of inprocessing steps during simplification'),
  16                            ))

z3/src/tactic/sls/sls_params.pyg:
   1: def_module_params('sls', 
   2:                   export=True,
   3:                   description='Experimental Stochastic Local Search Solver (for QFBV only).',
   4:                   params=(max_memory_param(),
   5                          ('max_restarts', UINT, UINT_MAX, 'maximum number of restarts'),

  11                          ('walksat_ucb_noise', DOUBLE, 0.0002, 'add noise 0 <= 256 * ucb_noise to ucb score for assertion selection'),
  12:                         ('walksat_repick', BOOL, 1, 'repick assertion if randomizing in local minima'),
  13:                         ('scale_unsat', DOUBLE, 0.5, 'scale score of unsat expressions by this factor'),
  14:                         ('paws_init', UINT, 40, 'initial/minimum assertion weights'),
  15:                         ('paws_sp', UINT, 52, 'smooth assertion weights with probability paws_sp / 1024'),
  16:                         ('wp', UINT, 100, 'random walk with probability wp / 1024'),
  17:                         ('vns_mc', UINT, 0, 'in local minima, try Monte Carlo sampling vns_mc many 2-bit-flips per bit'),
  18:                         ('vns_repick', BOOL, 0, 'in local minima, try picking a different assertion (only for walksat)'),
  19:                         ('restart_base', UINT, 100, 'base restart interval given by moves per run'),
  20                          ('restart_init', BOOL, 0, 'initialize to 0 or random value (= 1) after restart'),
  21:                         ('early_prune', BOOL, 1, 'use early pruning for score prediction'),
  22                          ('random_offset', BOOL, 1, 'use random offset for candidate evaluation'),
  23:                         ('rescore', BOOL, 1, 'rescore/normalize top-level score every base restart interval'),
  24:                         ('track_unsat', BOOL, 0, 'keep a list of unsat assertions as done in SAT - currently disabled internally'),
  25                          ('random_seed', UINT, 0, 'random seed')

z3/src/tactic/smtlogics/qfufbv_tactic_params.pyg:
  1: def_module_params('ackermannization',
  2:                   description='tactics based on solving UF-theories via ackermannization (see also ackr module)',
  3:                   class_name='qfufbv_tactic_params',
  4:                   export=True,
  5:                   params=(
  6                            ('sat_backend', BOOL, False, 'use SAT rather than SMT in qfufbv_ackr_tactic'),
