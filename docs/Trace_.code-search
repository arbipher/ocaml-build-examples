# Query: Trace("
# Including: ./z3
# ContextLines: 1

6958 results - 551 files

z3/src/ackermannization/ackermannize_bv_tactic.cpp:
  37          fail_if_proof_generation("ackermannize", g);
  38:         TRACE("goal", g->display(tout << "in\n"););
  39  

  48          if (!success) { // Just pass on the input unchanged
  49:             TRACE("ackermannize", tout << "ackermannize not run due to limit" << std::endl;);
  50              result.reset();

  60          resg->inc_depth();
  61:         TRACE("goal", resg->display(tout << "out\n"););
  62      }

z3/src/ackermannization/ackr_bound_probe.cpp:
  73          double total = ackr_helper::calculate_lemma_bound(p.m_fun2terms, p.m_sel2terms);
  74:         TRACE("ackermannize", tout << "total=" << total << std::endl;);
  75          return result(total);

z3/src/ackermannization/ackr_model_converter.cpp:
   45      void operator()(model_ref & md) override {
   46:         TRACE("ackermannize", tout << (fixed_model? "fixed" : "nonfixed") << "\n";);
   47:         CTRACE("ackermannize", md, tout << *md << "\n");
   48:         CTRACE("ackermannize", fixed_model, tout << *abstr_model << "\n");
   49  

   98  void ackr_model_converter::convert_constants(model * source, model * destination) {
   99:     TRACE("ackermannize", tout << "converting constants\n";);
  100      obj_map<func_decl, func_interp*> interpretations;

  109          expr * value = source->get_const_interp(c);
  110:         TRACE("ackermannize", tout << mk_ismt2_pp(c, m) << " " << mk_ismt2_pp(term, m) << "\n";);
  111          if (!term) 

  162                                       obj_map<func_decl, func_interp*>& interpretations) {
  163:     TRACE("ackermannize", tout << "add_entry"
  164            << mk_ismt2_pp(term, m, 2)

  180      if (fi->get_entry(args.data()) == nullptr) {
  181:         TRACE("ackermannize",
  182                tout << mk_ismt2_pp(declaration, m) << " args: " << std::endl;

  189      else {
  190:         TRACE("ackermannize", tout << "entry already present\n";);
  191      }

z3/src/ackermannization/lackr_model_constructor.cpp:
  203              const bool b = eval_cached(to_app(args[i]), val); // TODO: OK conversion to_app?
  204:             CTRACE("model_constructor", m_conflicts.empty() && !b, tout << "fail arg val(\n" << mk_ismt2_pp(args[i], m, 2) << '\n'; );
  205              if (!b) {

  208              }
  209:             TRACE("model_constructor", tout <<
  210                    "arg val " << i << "(\n" << mk_ismt2_pp(args[i], m, 2)

  237              return true; // skip numerals
  238:         TRACE("model_constructor", tout << "mk_value(\n" << mk_ismt2_pp(a, m, 2) << ")\n";);
  239          SASSERT(!m_app2val.contains(a));

  242              return false;
  243:         TRACE("model_constructor",
  244                tout << "map term(\n" << mk_ismt2_pp(a, m, 2) << "\n->"
  245                << mk_ismt2_pp(result.get(), m, 2)<< ")\n"; );
  246:         CTRACE("model_constructor",
  247                 !is_val(result.get()),

  288              if (!ok) {
  289:                 TRACE("model_constructor",
  290                        tout << "already mapped by(\n" << mk_ismt2_pp(vi.source_term, m, 2) << "\n->"

  319          m_evaluator->operator() (term, result);
  320:         TRACE("model_constructor",
  321                tout << "eval(\n" << mk_ismt2_pp(term.get(), m, 2) << "\n->"

z3/src/ackermannization/lackr.cpp:
   65      }
   66:     CTRACE("ackermannize", rv == l_true, model_smt2_pp(tout << "abstr_model(\n", m, *(m_model.get()), 2); tout << ")\n"; );
   67      return rv;

  103  bool lackr::ackr(app * const t1, app * const t2) {
  104:     TRACE("ackermannize", tout << "ackr " << mk_ismt2_pp(t1, m, 2) << " , " << mk_ismt2_pp(t2, m, 2) << "\n";);
  105      const unsigned sz = t1->get_num_args();

  112          if (m.are_distinct(arg1, arg2)){ // quickly abort if there are two distinct (e.g. numerals)                    
  113:             TRACE("ackermannize", tout << "never eq\n";);
  114              return false;

  125      m_simp(cga);
  126:     TRACE("ackermannize", 
  127            tout << "abstr1 " << mk_ismt2_pp(a1, m, 2) << "\n";

  144  void lackr::eager_enc() {
  145:     TRACE("ackermannize", tout << "#funs: " << m_fun2terms.size() << "#sels: " << m_sel2terms.size() << std::endl;);
  146      for (auto const& kv : m_fun2terms) {

  228      push_abstraction();
  229:     TRACE("ackermannize", tout << "run sat 0\n"; );
  230      lbool rv0 = m_solver->check_sat(0, nullptr);

  237      m_solver->assert_expr(all);
  238:     TRACE("ackermannize", tout << "run sat all\n"; );
  239      return m_solver->check_sat(0, nullptr);

  249          checkpoint();
  250:         TRACE("ackermannize", tout << "lazy check: " << m_st.m_it << "\n";);
  251          const lbool r = m_solver->check_sat(0, nullptr);

z3/src/api/z3_replayer.cpp:
   32  void throw_invalid_reference() {
   33:     TRACE("z3_replayer", tout << "invalid argument reference\n";);
   34      throw z3_replayer_exception("invalid argument reference");

   74          if (pos >= m_args.size()) {
   75:             TRACE("z3_replayer", tout << "too few arguments " << m_args.size() << " expecting " << kind2string(k) << "\n";);
   76              throw z3_replayer_exception("invalid argument reference");

   81                   << pos << " but got " << kind2string(m_args[pos].m_kind);
   82:             TRACE("z3_replayer", tout << strm.str() << "\n";);
   83              throw z3_replayer_exception(strm.str());

  198                  }
  199:                 TRACE("z3_replayer_escape", tout << "val: " << val << "\n";);
  200                  m_string.push_back(static_cast<char>(val));

  302          if (!(('0' <= curr() && curr() <= '9') || ('A' <= curr() && curr() <= 'F') || ('a' <= curr() && curr() <= 'f'))) {
  303:             TRACE("invalid_ptr", tout << "curr: " << curr() << "\n";);
  304              throw z3_replayer_exception("invalid ptr");

  382          else if (k == OBJECT) {
  383:             TRACE("z3_replayer_bug",
  384                    tout << "args: "; display_args(tout); tout << "\n";

  429                  next();
  430:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "R\n";);
  431                  reset();

  435                  next(); skip_blank(); read_ptr();
  436:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "P " << m_ptr << "\n";);
  437                  if (m_ptr == 0) {

  444                      m_args.push_back(value(obj));
  445:                     TRACE("z3_replayer_bug", tout << "args after 'P':\n"; display_args(tout); tout << "\n";);
  446                  }

  451                  next(); skip_blank(); read_string();
  452:                 TRACE("z3_replayer", tout << "[" << m_line << "] "  << "S " << m_string.begin() << "\n";);
  453                  symbol sym(m_string.begin()); // save string

  459                  next();
  460:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "N\n";);
  461                  m_args.push_back(value(SYMBOL, symbol::null));

  465                  next(); skip_blank(); read_quoted_symbol();
  466:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "$ " << m_id << "\n";);
  467                  m_args.push_back(value(SYMBOL, m_id));

  472                  next(); skip_blank(); read_uint64();
  473:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "# " << m_uint64 << "\n";);
  474                  symbol sym(static_cast<unsigned>(m_uint64));

  480                  next(); skip_blank(); read_int64();
  481:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "I " << m_int64 << "\n";);
  482                  m_args.push_back(value(INT64, m_int64));

  486                  next(); skip_blank(); read_uint64();
  487:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "U " << m_uint64 << "\n";);
  488                  m_args.push_back(value(UINT64, m_uint64));

  492                  next(); skip_blank(); read_float();
  493:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "F " << m_float << "\n";);
  494                  m_args.push_back(value(FLOAT, m_float));

  498                  next(); skip_blank(); read_double();
  499:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "D " << m_double << "\n";);
  500                  m_args.push_back(value(DOUBLE, m_double));

  507                  next(); skip_blank(); read_uint64();
  508:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "A " << m_uint64 << "\n";);
  509                  if (c == 'p')

  520                  next(); skip_blank(); read_uint64();
  521:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "C " << m_uint64 << "\n";);
  522                  unsigned idx = static_cast<unsigned>(m_uint64);

  525                  try {
  526:                     TRACE("z3_replayer_cmd", tout << idx << ":" << m_cmds_names[idx] << "\n";);
  527                      m_cmds[idx](m_owner);

  540                  next(); skip_blank(); read_ptr();
  541:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "= " << m_ptr << "\n";);
  542                  m_heap.insert(m_ptr, m_result);

  548                  unsigned pos = static_cast<unsigned>(m_uint64);
  549:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "* " << m_ptr << " " << pos << "\n";);
  550                  check_arg(pos, OBJECT);

  563                  unsigned idx = static_cast<unsigned>(m_uint64);
  564:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "@ " << m_ptr << " " << pos << " " << idx << "\n";);
  565:                 TRACE("z3_replayer_bug", tout << "v[idx]: " << v[idx] << "\n";);
  566                  m_heap.insert(m_ptr, v[idx]);

  571                  next(); skip_blank(); read_string();
  572:                 TRACE("z3_replayer", tout << "[" << m_line << "] " << "M " << m_string.begin() << "\n";);
  573                  std::cout << m_string.begin() << "\n"; std::cout.flush();

  575              default:
  576:                 TRACE("z3_replayer", tout << "unknown command " << c << "\n";);
  577                  throw z3_replayer_exception("unknown log command");

  656          ptr_vector<void> const & v = m_obj_arrays[idx];
  657:         TRACE("z3_replayer_bug", tout << "pos: " << pos << ", idx: " << idx << " size(): " << v.size() << "\n";
  658                for (unsigned i = 0; i < v.size(); i++) tout << v[i] << " "; tout << "\n";);

z3/src/ast/arith_decl_plugin.cpp:
   44          m_amanager.set(m_nums[idx], val);
   45:         TRACE("algebraic2expr", tout << "mk_id -> " << idx << "\n"; m_amanager.display(tout, val); tout << "\n";);
   46          return idx;

   51          SASSERT(!m_amanager.is_zero(m_nums[idx]));
   52:         TRACE("algebraic2expr", tout << "recycling: " << idx << "\n";);
   53          m_id_gen.recycle(idx);

  647  bool arith_decl_plugin::are_distinct(app * a, app * b) const {
  648:     TRACE("are_distinct_bug", tout << mk_ismt2_pp(a, *m_manager) << "\n" << mk_ismt2_pp(b, *m_manager) << "\n";);
  649      if (decl_plugin::are_distinct(a,b)) {

z3/src/ast/array_decl_plugin.cpp:
   67      sort * range = to_sort(parameters[num_parameters - 1].get_ast());
   68:     TRACE("array_decl_plugin_bug", tout << mk_pp(range, *m_manager) << "\n";);
   69      if (!range->is_infinite() && !range->is_very_big() && (1 == range->get_num_elements().size())) {

  552              to_func_decl(parameters[0].get_ast())->get_arity() == 0) {
  553:             TRACE("array_bug",
  554                    tout << "num_parameters: " << num_parameters << std::endl;

z3/src/ast/ast_pp_dot.cpp:
  85      void pp_step(const proof * p) {
  86:         TRACE("pp_ast_dot_step", tout << " :kind " << p->get_kind() << " :num-args " << p->get_num_args() << "\n";);
  87          if (m().has_fact(p)) {

z3/src/ast/ast_smt2_pp.cpp:
  699              symbol a = next_alias();
  700:             TRACE("smt2_pp", tout << "a: " << a << " depth: " << f_info.m_depth << ", weight: " << f_info.m_weight
  701                    << ", lvl: " << f_info.m_lvl << " t: #" << t->get_id() << "\n" << mk_ll_pp(t, m())

  797          num_lets = sz - old_sz;
  798:         TRACE("pp_let", tout << "old_sz: " << old_sz << ", sz: " << sz << "\n";);
  799          if (old_sz == sz)

  809          }
  810:         TRACE("pp_let", tout << "decls.size(): " << decls.size() << "\n";);
  811          ptr_buffer<format> buf;

  821          }
  822:         TRACE("pp_let", tout << "num_op: " << num_op << "\n";);
  823          if (num_op == 0)

  838          SASSERT(m_aliased_exprs.size() == m_aliased_lvls_names.size());
  839:         TRACE("pp_scope", tout << "[begin-scope] sz: " << m_aliased_exprs.size() << ", m_root: " << m_root << "\n";);
  840          m_scopes.push_back(scope(m_aliased_exprs.size(), m_next_alias_idx, m_root));

  848      void end_scope() {
  849:         TRACE("pp_scope", tout << "[end-scope] before sz: " << m_aliased_exprs.size() << ", m_root: " << m_root << "\n";);
  850          m_expr2alias->reset();

  861          m_aliased_lvls_names.shrink(old_sz);
  862:         TRACE("pp_scope", tout << "[end-scope] after sz: " << m_aliased_exprs.size() << ", m_root: " << m_root << "\n";);
  863      }

z3/src/ast/ast_translation.cpp:
  187      }
  188:     TRACE("ast_translation", 
  189            tout << f->get_name() << " "; if (fi) tout << *fi; tout << "\n";

  217              ast * r;         
  218:             TRACE("ast_translation", tout << mk_ll_pp(n, m_from_manager, false) << "\n";);
  219              if (fr.m_idx == 0 && n->get_ref_count() > 1) {

  224                      m_frame_stack.pop_back();
  225:                     TRACE("ast_translation", tout << "hit\n";);
  226                      m_hit_count++;

z3/src/ast/ast.cpp:
  1551  void ast_manager::copy_families_plugins(ast_manager const & from) {
  1552:     TRACE("copy_families_plugins",
  1553            tout << "target:\n";

  1565              (void)new_fid;
  1566:             TRACE("copy_families_plugins", tout << "new target fid created: " << new_fid << " fid_name: " << fid_name << "\n";);
  1567          }

  1573          (void)fid_name;
  1574:         TRACE("copy_families_plugins", tout << "copying: " << fid_name << ", src fid: " << fid
  1575                << ", target has_family: " << m_family_manager.has_family(fid) << "\n";
  1576                if (m_family_manager.has_family(fid)) tout << get_family_id(fid_name) << "\n";);
  1577:         TRACE("copy_families_plugins", tout << "target fid: " << get_family_id(fid_name) << "\n";);
  1578          SASSERT(fid == get_family_id(fid_name));

  1702          if (compare_nodes(curr, n)) {
  1703:             TRACE("nondet_bug",
  1704                    tout << "id1:   " << curr->get_id() << ", id2: " << n->get_id() << "\n";

  1724      ++s_count;
  1725:     TRACE("ast", tout << s_count << "\n";);
  1726  //    SASSERT(s_count != 5);

  1761      
  1762: //    TRACE("ast", tout << (s_count++) << " Object " << n->m_id << " was created.\n";);
  1763:     TRACE("mk_var_bug", tout << "mk_ast: " << n->m_id << "\n";);
  1764      // increment reference counters

  1849  void ast_manager::delete_node(ast * n) {
  1850:     TRACE("delete_node_bug", tout << mk_ll_pp(n, *this) << "\n";);
  1851  

  1856  
  1857:         CTRACE("del_quantifier", is_quantifier(n), tout << "deleting quantifier " << n->m_id << " " << n << "\n";);
  1858:         TRACE("mk_var_bug", tout << "del_ast: " << " " << n->m_ref_count << "\n";);
  1859:         TRACE("ast_delete_node", tout << mk_bounded_pp(n, *this) << "\n";);
  1860  

  2278          else if (decl->is_chainable()) {
  2279:             TRACE("chainable", tout << "chainable...\n";);
  2280              ptr_buffer<expr> new_args;

  2290      SASSERT(r != 0);
  2291:     TRACE("app_ground", tout << "ground: " << r->is_ground() << " id: " << r->get_id() << "\n" << mk_ll_pp(r, *this) << "\n";);
  2292      return r;

  2450              for (unsigned i = 0; i < num_patterns; ++i) {
  2451:                 TRACE("ast", tout << i << " " << mk_pp(patterns[i], *this) << "\n";);
  2452                  SASSERT(is_pattern(patterns[i]));

  2571          return q;
  2572:     TRACE("update_quantifier_weight", tout << "#" << q->get_id() << " " << q->get_weight() << " -> " << w << "\n";);
  2573      return mk_quantifier(q->get_kind(),

  2638      app * r = mk_and(new_args.size(), new_args.data());
  2639:     TRACE("distinct", tout << "expanded distinct:\n" << mk_pp(r, *this) << "\n";);
  2640      return r;

  2744  proof * ast_manager::mk_asserted(expr * f) {
  2745:     CTRACE("mk_asserted_bug", !is_bool(f), tout << mk_ismt2_pp(f, *this) << "\nsort: " << mk_ismt2_pp(f->get_sort(), *this) << "\n";);
  2746      SASSERT(is_bool(f));

  2758      SASSERT(has_fact(p2));
  2759:     CTRACE("mk_modus_ponens", !(is_implies(get_fact(p2)) || is_eq(get_fact(p2)) || is_oeq(get_fact(p2))),
  2760             tout << mk_ll_pp(p1, *this) << "\n";

  2762      SASSERT(is_implies(get_fact(p2)) || is_eq(get_fact(p2)) || is_oeq(get_fact(p2)));
  2763:     CTRACE("mk_modus_ponens", to_app(get_fact(p2))->get_arg(0) != get_fact(p1),
  2764             tout << mk_pp(get_fact(p1), *this) << "\n" << mk_pp(get_fact(p2), *this) << "\n";);
  2765      SASSERT(!proofs_enabled() || to_app(get_fact(p2))->get_arg(0) == get_fact(p1));
  2766:     CTRACE("mk_modus_ponens", !is_ground(p2) && !has_quantifiers(p2), tout << "Non-ground: " << mk_pp(p2, *this) << "\n";);
  2767:     CTRACE("mk_modus_ponens", !is_ground(p1) && !has_quantifiers(p1), tout << "Non-ground: " << mk_pp(p1, *this) << "\n";);
  2768      if (is_reflexivity(p2))

  2836      SASSERT(to_app(get_fact(p2))->get_num_args() == 2);
  2837:     CTRACE("mk_transitivity", to_app(get_fact(p1))->get_decl() != to_app(get_fact(p2))->get_decl(),
  2838             tout << mk_pp(get_fact(p1), *this) << "\n\n" << mk_pp(get_fact(p2), *this) << "\n";

  2843                (is_eq(get_fact(p2)) || is_oeq(get_fact(p2)))));
  2844:     CTRACE("mk_transitivity", to_app(get_fact(p1))->get_arg(1) != to_app(get_fact(p2))->get_arg(0),
  2845             tout << mk_pp(get_fact(p1), *this) << "\n\n" << mk_pp(get_fact(p2), *this) << "\n";

  3050          args.append(num_proofs, (expr**)proofs);
  3051:         CTRACE("mk_unit_resolution_bug", !is_or(f1), tout << mk_ll_pp(f1, *this) << "\n";
  3052                 for (unsigned i = 1; i < num_proofs; ++i)

  3085                  for (unsigned i = 1; proofs_enabled() && i < num_proofs; i++) {
  3086:                 CTRACE("mk_unit_resolution_bug", !found.get(i, false),
  3087                         for (unsigned j = 0; j < num_proofs; j++) {

  3108      proof * pr = mk_app(basic_family_id, PR_UNIT_RESOLUTION, args.size(), args.data());
  3109:     TRACE("unit_resolution", tout << "unit_resolution generating fact\n" << mk_ll_pp(pr, *this););
  3110      return pr;

  3113  proof * ast_manager::mk_unit_resolution(unsigned num_proofs, proof * const * proofs, expr * new_fact) {
  3114:     TRACE("unit_bug",
  3115            for (unsigned i = 0; i < num_proofs; i++) tout << mk_pp(get_fact(proofs[i]), *this) << "\n";

  3131          unsigned cls_sz      = cls->get_num_args();
  3132:         CTRACE("unit_bug", !(num_proofs == cls_sz || (num_proofs == cls_sz + 1 && is_false(new_fact))),
  3133            for (unsigned i = 0; i < num_proofs; i++) tout << mk_pp(get_fact(proofs[i]), *this) << "\n";

  3150              if (j == num_proofs) {
  3151:                 CTRACE("unit_bug", new_fact != lit, tout << mk_pp(f1, *this) << "\n" << mk_ll_pp(new_fact, *this) << "\n" << mk_ll_pp(lit, *this) << "\n";);
  3152                  SASSERT(new_fact == lit);

  3160      proof * pr = mk_app(basic_family_id, PR_UNIT_RESOLUTION, args.size(), args.data());
  3161:     TRACE("unit_resolution", tout << "unit_resolution using fact\n" << mk_ll_pp(pr, *this););
  3162      return pr;

  3171      SASSERT(has_fact(p));
  3172:     CTRACE("mk_lemma", !is_false(get_fact(p)), tout << mk_ll_pp(p, *this) << "\n";);
  3173      SASSERT(is_false(get_fact(p)));

  3247      SASSERT(is_and(get_fact(p)));
  3248:     CTRACE("mk_and_elim", i >= to_app(get_fact(p))->get_num_args(), tout << "i: " << i << "\n" << mk_pp(get_fact(p), *this) << "\n";);
  3249      SASSERT(i < to_app(get_fact(p))->get_num_args());

  3329      for (unsigned i = 0; i < num_premises; ++i) {
  3330:         TRACE("hyper_res", tout << mk_pp(premises[i], *this) << "\n";);
  3331          fmls.push_back(get_fact(premises[i]));

  3344      }
  3345:     TRACE("hyper_res",
  3346            for (unsigned i = 0; i < params.size(); ++i) {

z3/src/ast/bv_decl_plugin.cpp:
  663      get_offset_term(b, b_term, b_offset);
  664:     TRACE("bv_are_distinct",
  665            tout << mk_ismt2_pp(a, *m_manager) << "\n" << mk_ismt2_pp(b, *m_manager) << "\n";

  803      bool result = (r == rational::power_of_two(bv_size) - rational(1));
  804:     TRACE("is_allone", tout << r << " " << result << "\n";);
  805      return result;

z3/src/ast/datatype_decl_plugin.cpp:
    92          sort_ref s(m);
    93:         TRACE("datatype", tout << "instantiate " << m_name << "\n";);
    94          if (!m_sort) {

   268                  if (k != DATATYPE_SORT) {
   269:                     TRACE("datatype", tout << "invalid kind parameter to datatype\n";);
   270                      throw invalid_datatype();

   272                  if (num_parameters < 1) {
   273:                     TRACE("datatype", tout << "at least one parameter expected to datatype declaration\n";);
   274                      throw invalid_datatype();                    

   277                  if (!name.is_symbol()) {
   278:                     TRACE("datatype", tout << "expected symol parameter at position " << 0 << " got: " << name << "\n";);
   279                      throw invalid_datatype();

   283                      if (!s.is_ast() || !is_sort(s.get_ast())) {
   284:                         TRACE("datatype", tout << "expected sort parameter at position " << i << " got: " << s << "\n";);
   285                          throw invalid_datatype();

   295                          sort* r = to_sort(parameters[i + 1].get_ast());
   296:                         TRACE("datatype", tout << "inserting " << mk_ismt2_pp(r, *m_manager) << " " << r->get_num_elements() << "\n";);
   297                          S.insert(d->params()[i], r->get_num_elements()); 

   299                      sort_size ts = d->sort_size()->eval(S);
   300:                     TRACE("datatype", tout << name << " has size " << ts << "\n";);
   301                      s->set_num_elements(ts);

   303                  else {
   304:                     TRACE("datatype", tout << "not setting size for " << name << "\n";);
   305                  }

   550                  def* d = nullptr;
   551:                 TRACE("datatype", tout << "declaring " << datatypes[i]->name() << "\n";);
   552                  if (m_defs.find(datatypes[i]->name(), d)) {
   553:                     TRACE("datatype", tout << "delete previous version for " << datatypes[i]->name() << "\n";);
   554                      u().reset();

   601          bool plugin::is_value_aux(bool unique, app * e) const {
   602:             TRACE("dt_is_value", tout << "checking\n" << mk_ismt2_pp(e, *m_manager) << "\n";);
   603              if (!u().is_constructor(e))

   612                  if (!is_value_visit(unique, arg, todo)) {
   613:                     TRACE("dt_is_value", tout << "not-value:\n" << mk_ismt2_pp(arg, *m_manager) << "\n";);
   614                      return false;

   622                      if (!is_value_visit(unique, arg, todo)) {
   623:                         TRACE("dt_is_value", tout << "not-value:\n" << mk_ismt2_pp(arg, *m_manager) << "\n";);
   624                          return false;

   839  
   840:         TRACE("datatype", for (auto const& s : names) tout << s << " "; tout << "\n";);
   841          svector<symbol> todo(names);

   844              symbol s = todo.back();
   845:             TRACE("datatype", tout << "Sort size for " << s << "\n";);
   846  

   878              if (is_infinite) {
   879:                 TRACE("datatype", tout << "infinite " << s << "\n";);
   880                  d.set_sort_size(param_size::size::mk_offset(sort_size::mk_infinite()));

   892              }
   893:             TRACE("datatype", tout << "set sort size " << s << "\n";);
   894              d.set_sort_size(param_size::size::mk_plus(s_add));

  1211          forbidden_set.push_back(ty);
  1212:         TRACE("util_bug", tout << "invoke get-non-rec: " << sort_ref(ty, m) << "\n";);
  1213          cd = get_non_rec_constructor_core(ty, forbidden_set);

  1235              return result;
  1236:         TRACE("util_bug", tout << "get-non-rec constructor: " << sort_ref(ty, m) << "\n";
  1237                tout << "forbidden: ";

  1244          for (func_decl * c : constructors) {
  1245:             TRACE("util_bug", tout << "non_rec_constructor c: " << func_decl_ref(c, m) << "\n";);
  1246              unsigned num_args = c->get_arity();

  1250                  sort * T_i = autil.get_array_range_rec(c->get_domain(i));
  1251:                 TRACE("util_bug", tout << "c: " << i << " " << sort_ref(T_i, m) << "\n";);
  1252                  if (!is_datatype(T_i)) {
  1253:                     TRACE("util_bug", tout << sort_ref(T_i, m) << " is not a datatype\n";);
  1254                      continue;

  1256                  if (std::find(forbidden_set.begin(), forbidden_set.end(), T_i) != forbidden_set.end()) {
  1257:                     TRACE("util_bug", tout << sort_ref(T_i, m) << " is in forbidden_set\n";);
  1258                      break;

  1265                      break;
  1266:                 TRACE("util_bug", tout << "nested_c: " << nested_c.first->get_name() << "\n";);
  1267                  max_depth = std::max(nested_c.second + 1, max_depth);

z3/src/ast/dl_decl_plugin.cpp:
  213          vector<parameter> ps;
  214:         TRACE("dl_decl_plugin", 
  215                  tout << mk_pp(r, m) << " ";

  626  
  627:         TRACE("dl_decl_plugin", tout << mk_pp(result, *m_manager) << "\n";);
  628          return result;

z3/src/ast/expr_abstract.cpp:
  112      abs(base, num_bound, bound, n, result);
  113:     TRACE("expr_abstract",
  114            tout << expr_ref(n, m) << "\n";

  129      }
  130:     TRACE("expr_abstract",
  131            tout << expr_ref(n, m) << "\n";

z3/src/ast/expr2polynomial.cpp:
  370                  app * a = fr.m_curr;
  371:                 TRACE("expr2polynomial", tout << "processing: " << fr.m_idx << "\n" << mk_ismt2_pp(a, m()) << "\n";);
  372                  unsigned num_args = a->get_num_args();

z3/src/ast/expr2var.cpp:
  28      if (!is_uninterp_const(n)) {
  29:         TRACE("expr2var", tout << "interpreted:\n" << mk_ismt2_pp(n, m()) << "\n";);
  30          m_interpreted_vars = true;

z3/src/ast/for_each_ast.h:
  48          curr = stack.back();
  49:         TRACE("for_each_ast", tout << "visiting node: " << curr->get_id() << ", kind: " << get_ast_kind_name(curr->get_kind())
  50                << ", stack size: " << stack.size() << "\n";);

z3/src/ast/fpa_decl_plugin.cpp:
  1074  bool fpa_util::is_considered_uninterpreted(func_decl * f, unsigned n, expr* const* args) {
  1075:     TRACE("fpa_util", expr_ref t(m().mk_app(f, n, args), m()); tout << mk_ismt2_pp(t, m()) << std::endl; );
  1076  

z3/src/ast/pp.cpp:
  54      unsigned s = space_upto_line_break(m, f).first;
  55:     TRACE("fits", tout << "s: " << s << " space_left " << space_left << "\n";);
  56      return s <= space_left;

z3/src/ast/recfun_decl_plugin.cpp:
  28  
  29: #define TRACEFN(x) TRACE("recfun", tout << x << '\n';)
  30  #define VALIDATE_PARAM(m, _pred_) if (!(_pred_)) m.raise_exception("invalid parameter to recfun "  #_pred_);

z3/src/ast/seq_decl_plugin.cpp:
    72      else {
    73:         TRACE("seq", tout << "Could not match " << mk_pp(s, *m_manager) << " and " << mk_pp(sP, *m_manager) << "\n";);
    74          return false;

  1630      m_infos.setx(e->get_id(), result, invalid_info);
  1631:     STRACE("re_info", tout << "compute_info(" << pp(u.re, e, false) << ")=" << result << std::endl;);
  1632      return result;

z3/src/ast/static_features.cpp:
  196                          rational k;
  197:                         TRACE("diff_term", tout << "diff_term: " << is_diff_term(arg, k) << "\n" << mk_pp(arg, m) << "\n";);
  198                          if (is_diff_term(arg, k)) {

  238          m_num_arith_ineqs++;
  239:         TRACE("diff_atom", tout << "diff_atom: " << is_diff_atom(e) << "\n" << mk_pp(e, m) << "\n";);
  240          if (is_diff_atom(e))

  255              m_num_arith_eqs++;
  256:             TRACE("diff_atom", tout << "diff_atom: " << is_diff_atom(e) << "\n" << mk_pp(e, m) << "\n";);
  257              if (is_diff_atom(e))

  330          if (m_arrayutil.is_array(e)) {
  331:             TRACE("sf_array", tout << mk_ismt2_pp(e, m) << "\n";);
  332              sort * ty = to_app(e)->get_decl()->get_range();

  358                              rational k;
  359:                             TRACE("diff_term", tout << "diff_term: " << is_diff_term(arg, k) << "\n" << mk_pp(arg, m) << "\n";);
  360                              if (is_diff_term(arg, k)) {

z3/src/ast/well_sorted.cpp:
  51              !decl->is_right_associative() && !decl->is_left_associative()) {
  52:             TRACE("ws", tout << "unexpected number of arguments.\n" << mk_ismt2_pp(n, m_manager););
  53              warning_msg("unexpected number of arguments.");

  61              if (expected_sort != actual_sort) {
  62:                 TRACE("tc", tout << "sort mismatch on argument #" << i << ".\n" << mk_ismt2_pp(n, m_manager);
  63                        tout << "Sort mismatch for argument " << i+1 << " of " << mk_ismt2_pp(n, m_manager, false) << "\n";

z3/src/ast/converters/equiv_proof_converter.cpp:
  30          p3 = m.mk_modus_ponens(p1, p2);
  31:         TRACE("proof_converter", tout << mk_pp(p3.get(), m) << "\n";);
  32          SASSERT(m.has_fact(p3));

z3/src/ast/converters/generic_model_converter.cpp:
  43  void generic_model_converter::operator()(model_ref & md) {
  44:     TRACE("model_converter", tout << "before generic_model_converter\n"; model_v2_pp(tout, *md); display(tout););
  45      

  59              ev(e.m_def, val);
  60:             TRACE("model_converter", tout << e.m_f->get_name() << " ->\n" << e.m_def << "\n==>\n" << val << "\n";);
  61              arity = e.m_f->get_arity();

  92      }
  93:     TRACE("model_converter", tout << "after generic_model_converter\n"; model_v2_pp(tout, *md););
  94  }

z3/src/ast/converters/horn_subsume_model_converter.cpp:
  110      }
  111:     TRACE("mc",
  112            tout << mk_pp(head, m) << " :- " << mk_pp(body, m) << "\n";

  153          (n->get_family_id() == null_family_id)) {
  154:         TRACE("mc", tout << "adding: " << n->get_decl()->get_name() << "\n";);
  155          if (n->get_decl()->get_arity() == 0) {

  182  
  183:     TRACE("mc", tout << m_funcs.size() << "\n"; model_smt2_pp(tout, m, *mr, 0););
  184      for (unsigned i = m_funcs.size(); i-- > 0; ) {

  190                  
  191:         TRACE("mc", tout << "eval: " << h->get_name() << "\n" << body << "\n";);
  192          body = (*mr)(body);
  193          
  194:         TRACE("mc", tout << "to:\n" << body << "\n";);
  195                  

z3/src/ast/converters/replace_proof_converter.cpp:
  68          replace.insert(f, e);
  69:         TRACE("proof_converter", tout << f->get_id() << " " << mk_pp(f, m) << 
  70                "\n|-> " << mk_pp(e, m) << "\n";);

  72      replace.apply(tmp);
  73:     TRACE("proof_converter", tout << mk_pp(source[0], m) << "\n";
  74                               tout << mk_pp(tmp.get(), m) << "\n";);

z3/src/ast/euf/euf_egraph.cpp:
  145      void egraph::add_th_eq(theory_id id, theory_var v1, theory_var v2, enode* c, enode* r) {
  146:         TRACE("euf_verbose", tout << "eq: " << v1 << " == " << v2 << "\n";);
  147          m_new_th_eqs.push_back(th_eq(id, v1, v2, c, r));

  154              return;
  155:         TRACE("euf_verbose", tout << "eq: " << v1 << " != " << v2 << "\n";);
  156          m_new_th_eqs.push_back(th_eq(id, v1, v2, eq));

  161      void egraph::add_literal(enode* n, bool is_eq) {
  162:         TRACE("euf_verbose", tout << "lit: " << n->get_expr_id() << "\n";);
  163          m_new_lits.push_back(enode_bool_pair(n, is_eq));

  173          enode* r2 = arg2->get_root();
  174:         TRACE("euf", tout << "new-diseq:  " << bpp(r1) << " " << bpp(r2) << ": " << r1->has_th_vars() << " " << r2->has_th_vars() << "\n";);
  175          if (r1 == r2) {

  298              force_push();
  299:             TRACE("euf", tout << bpp(n) << " := " << value << "\n";);
  300              n->set_value(value);

  429  
  430:         TRACE("euf", j.display(tout << "merge: " << bpp(n1) << " == " << bpp(n2) << " ", m_display_justification) << "\n" << bpp(r1) << " " << bpp(r2) << "\n";);
  431          IF_VERBOSE(20, j.display(verbose_stream() << "merge: " << bpp(n1) << " == " << bpp(n2) << " ", m_display_justification) << "\n";);

  488              p->unmark1();
  489:             TRACE("euf", tout << "reinsert " << bpp(r1) << " " << bpp(r2) << " " << bpp(p) << " " << p->merge_enabled() << "\n";);
  490              if (p->merge_enabled()) {

  492                  SASSERT(m_table.contains_ptr(p) == (p_other == p));
  493:                 TRACE("euf", tout << "other " << bpp(p_other) << "\n";);
  494                  if (p_other != p) 

  526          enode* r2 = r1->get_root();
  527:         TRACE("euf", tout << "undo-eq old-root: " << bpp(r1) << " current-root " << bpp(r2) << " node: " << bpp(n1) << "\n";);
  528          r2->dec_class_size(r1->class_size());

  532              enode* p = *it;
  533:             TRACE("euf", tout << "erase " << bpp(p) << "\n";);
  534              SASSERT(!p->merge_enabled() || m_table.contains_ptr(p));

  573          m_n2 = n2;
  574:         TRACE("euf", tout << "conflict " << bpp(n1) << " " << bpp(n2) << " " << j << "\n");
  575          m_justification = j;

  590          SASSERT(!n2->get_root()->m_target);
  591:         TRACE("euf_verbose", tout << "merge " << n1->get_expr_id() << " " << n2->get_expr_id() << " updates: " << m_updates.size() << "\n";);
  592      }

  594      void egraph::unmerge_justification(enode* n1) {
  595:         TRACE("euf_verbose", tout << "unmerge " << n1->get_expr_id() << " " << n1->m_target->get_expr_id() << "\n";);
  596          // r1 -> ..  -> n1 -> n2 -> ... -> r2

  661          }
  662:         TRACE("euf_verbose", tout << bpp(n1) << " " << bpp(n2) << "\n");
  663              

  720      void egraph::explain_eq(ptr_vector<T>& justifications, cc_justification* cc, enode* a, enode* b, justification const& j) {
  721:         TRACE("euf_verbose", tout << "explain-eq: " << bpp(a) << " == " << bpp(b) << " jst: " << j << "\n";);
  722          if (j.is_external())

  735          enode* lca = find_lca(a, b);
  736:         TRACE("euf_verbose", tout << "explain-eq: " << bpp(a) << " == " << bpp(b) << " lca: " << bpp(lca) << "\n";);
  737          push_to_lca(a, lca);

  767                  n->mark1();
  768:                 CTRACE("euf_verbose", m_display_justification, n->m_justification.display(tout << n->get_expr_id() << " = " << n->m_target->get_expr_id() << " ", m_display_justification) << "\n";);
  769                  explain_eq(justifications, cc, n, n->m_target, n->m_justification);

  786              if (n->merge_enabled() && n->num_args() > 0 && (!m_table.find(n) || n->get_root() != m_table.find(n)->get_root())) {
  787:                 CTRACE("euf", !m_table.find(n), tout << "node is not in table\n";);
  788:                 CTRACE("euf", m_table.find(n), tout << "root " << bpp(n->get_root()) << " table root " << bpp(m_table.find(n)->get_root()) << "\n";);
  789:                 TRACE("euf", display(tout << bpp(n) << " is not closed under congruence\n"););
  790                  UNREACHABLE();

z3/src/ast/euf/euf_enode.cpp:
  44                  }
  45:                 CTRACE("euf", !found, tout  << g.bpp(p) << " does not have a child with root: " << g.bpp(this) << "\n";);
  46                  VERIFY(found);

  57                      }
  58:                     CTRACE("euf", !found, tout << "parent " << g.bpp(p) << " of " << g.bpp(c) << " is not congruent to a parent of " << g.bpp(this) << "\n";);
  59                      VERIFY(found);

z3/src/ast/fpa/bv2fpa_converter.cpp:
  113  
  114:     TRACE("bv2fpa", tout << "[" << mk_ismt2_pp(sgn, m) <<
  115                              " " << mk_ismt2_pp(exp, m) <<

  191      expr_ref result(m);
  192:     TRACE("bv2fpa_rebuild", tout << "rebuild floats in " << mk_ismt2_pp(s, m) << " for ";
  193                      if (e) tout << mk_ismt2_pp(e, m);

  242      if (as_arr_mdl == 0) return am;
  243:     TRACE("bv2fpa", tout << "arity=0 func_interp for " << mk_ismt2_pp(f, m) << " := " << mk_ismt2_pp(as_arr_mdl, m) << std::endl;);
  244      SASSERT(arr_util.is_as_array(as_arr_mdl));

  287              m_th_rw(ft_fres);
  288:             TRACE("bv2fpa",
  289                    tout << "func_interp entry #" << i << ":" << std::endl;

  340              m_th_rw(ft_els);
  341:             TRACE("bv2fpa", tout << "else=" << mk_ismt2_pp(ft_els, m) << std::endl;);
  342              result->set_else(ft_els);

  412  
  413:         TRACE("bv2fpa", tout << var->get_name() << " == " << mk_ismt2_pp(cv, m) << std::endl;);
  414      }

  424          expr_ref fv = convert_bv2rm(mc, to_app(bvval));
  425:         TRACE("bv2fpa", tout << var->get_name() << " == " << mk_ismt2_pp(fv, m) << std::endl;);
  426          target_model->register_decl(var, fv);

  465          target_model->register_decl(f, flt_fi);
  466:         TRACE("bv2fpa", tout << "fp.min/fp.max special: " << std::endl <<
  467              mk_ismt2_pp(f, m) << " == " << mk_ismt2_pp(flt_fi->get_interp(), m) << std::endl;);

  510  
  511:     TRACE("bv2fpa", tout << "Target model: " << *target_model; );
  512  }

z3/src/ast/fpa/fpa2bv_converter.cpp:
    54  
    55:         TRACE("fpa2bv", tout << "mk_eq a=" << mk_ismt2_pp(a, m) << std::endl;
    56                          tout << "mk_eq b=" << mk_ismt2_pp(b, m) << std::endl;);

    86  
    87:         TRACE("fpa2bv", tout << "mk_eq_rm a=" << mk_ismt2_pp(a, m) << std::endl;
    88                          tout << "mk_eq_rm b=" << mk_ismt2_pp(b, m) << std::endl;);

   121          SASSERT(m_util.is_bv2rm(t) && m_util.is_bv2rm(f));
   122:         TRACE("fpa2bv", tout << "ite rm: t=" << mk_ismt2_pp(t, m) << " f=" << mk_ismt2_pp(f, m) << std::endl; );
   123          m_simp.mk_ite(c, to_app(t)->get_arg(0), to_app(f)->get_arg(0), result);

   206          result = m_util.mk_fp(bv_sgn, biased_exp, bv_sig);
   207:         TRACE("fpa2bv_dbg", tout << "value of [" << sign << " " << m_mpz_manager.to_string(sig) << " " << exp << "] is "
   208              << mk_ismt2_pp(result, m) << std::endl;);

   292          if (uv.contains(i)) {
   293:             TRACE("fpa2bv", tout << "uv[" << i << "] = " << mk_ismt2_pp(uv.get(i), m) << std::endl; );
   294              sort * s = uv.get(i);

   304      res = vsubst.operator()(e, nv, subst_map.data());
   305:     TRACE("fpa2bv", tout << "subst'd = " << mk_ismt2_pp(res, m) << std::endl; );
   306      res = m.mk_forall(nv, new_decl_sorts.data(), new_decl_names.data(), res);

   311  {
   312:     TRACE("fpa2bv", tout << "UF: " << mk_ismt2_pp(f, m) << std::endl; );
   313  

   348  
   349:     TRACE("fpa2bv", tout << "UF result: " << mk_ismt2_pp(result, m) << std::endl; );
   350      SASSERT(is_well_sorted(m, result));

   527      dbg_decouple("fpa2bv_add_eq_sgn", eq_sgn);
   528:     TRACE("fpa2bv_add_core", tout << "EQ_SGN = " << mk_ismt2_pp(eq_sgn, m) << std::endl; );
   529  

   720  
   721:     TRACE("fpa2bv_add", tout << "ADD = " << mk_ismt2_pp(result, m) << std::endl; );
   722  }

   902  
   903:     TRACE("fpa2bv_mul", tout << "MUL = " << mk_ismt2_pp(result, m) << std::endl; );
   904  }

  1057  
  1058:     TRACE("fpa2bv_div", tout << "DIV = " << mk_ismt2_pp(result, m) << std::endl; );
  1059  }

  1069  void fpa2bv_converter::mk_rem(sort * s, expr_ref & x, expr_ref & y, expr_ref & result) {
  1070:     TRACE("fpa2bv_rem", tout << "X = " << mk_ismt2_pp(x, m) << std::endl;
  1071                          tout << "Y = " << mk_ismt2_pp(y, m) << std::endl;);

  1289  
  1290:     TRACE("fpa2bv_rem", tout << "REM = " << mk_ismt2_pp(result, m) << std::endl; );
  1291  }

  1824  
  1825:     TRACE("fpa2bv_fma_", tout << "FMA = " << mk_ismt2_pp(result, m) << std::endl; );
  1826  }

  2232  
  2233:     TRACE("fpa2bv_round_to_integral", tout << "ROUND2INTEGRAL = " << mk_ismt2_pp(result, m) << std::endl; );
  2234  }

  2244  void fpa2bv_converter::mk_float_eq(sort * s, expr_ref & x, expr_ref & y, expr_ref & result) {
  2245:     TRACE("fpa2bv_float_eq", tout << "X = " << mk_ismt2_pp(x, m) << std::endl;
  2246                               tout << "Y = " << mk_ismt2_pp(y, m) << std::endl;);

  2274  
  2275:     TRACE("fpa2bv_float_eq", tout << "FLOAT_EQ = " << mk_ismt2_pp(result, m) << std::endl; );
  2276  }

  2431      result = m.mk_and(nt1, t2);
  2432:     TRACE("fpa2bv_is_negative", tout << "result = " << mk_ismt2_pp(result, m) << std::endl;);
  2433  }

  2444  void fpa2bv_converter::mk_to_fp(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
  2445:     TRACE("fpa2bv_to_fp", for (unsigned i=0; i < num; i++)
  2446          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl; );

  2682  void fpa2bv_converter::mk_to_fp_real(func_decl * f, sort * s, expr * rm, expr * x, expr_ref & result) {
  2683:     TRACE("fpa2bv_to_fp_real", tout << "rm: " << mk_ismt2_pp(rm, m) << std::endl <<
  2684          "x: " << mk_ismt2_pp(x, m) << std::endl;);

  2882  void fpa2bv_converter::mk_to_real(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
  2883:     TRACE("fpa2bv_to_real", for (unsigned i = 0; i < num; i++)
  2884          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl;);

  2962  
  2963:     TRACE("fpa2bv_to_real", tout << "rsig = " << mk_ismt2_pp(rsig, m) << std::endl;
  2964      tout << "exp2 = " << mk_ismt2_pp(exp2, m) << std::endl;);

  2975  void fpa2bv_converter::mk_to_fp_signed(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
  2976:     TRACE("fpa2bv_to_fp_signed", for (unsigned i = 0; i < num; i++)
  2977          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl;);

  3073  
  3074:     TRACE("fpa2bv_to_fp_signed", tout << "exp worst case sz: " << exp_worst_case_sz << std::endl;);
  3075  

  3111  void fpa2bv_converter::mk_to_fp_unsigned(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
  3112:     TRACE("fpa2bv_to_fp_unsigned", for (unsigned i = 0; i < num; i++)
  3113          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl;);

  3251  
  3252:     TRACE("fpa2bv_to_ieee_bv", tout << "result=" << mk_ismt2_pp(result, m) << std::endl;);
  3253      SASSERT(is_well_sorted(m, result));

  3283  
  3284:     TRACE("fpa2bv_to_ieee_bv_unspecified", tout << "result=" << mk_ismt2_pp(result, m) << std::endl;);
  3285      SASSERT(is_well_sorted(m, result));

  3294  void fpa2bv_converter::mk_to_bv(func_decl * f, unsigned num, expr * const * args, bool is_signed, expr_ref & result) {
  3295:     TRACE("fpa2bv_to_bv", for (unsigned i = 0; i < num; i++)
  3296          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl;);

  3464  void fpa2bv_converter::mk_to_ubv(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
  3465:     TRACE("fpa2bv_to_ubv", for (unsigned i = 0; i < num; i++)
  3466          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl;);

  3470  void fpa2bv_converter::mk_to_sbv(func_decl * f, unsigned num, expr * const * args, expr_ref & result) {
  3471:     TRACE("fpa2bv_to_sbv", for (unsigned i = 0; i < num; i++)
  3472          tout << "arg" << i << " = " << mk_ismt2_pp(args[i], m) << std::endl;);

  3511  
  3512:     TRACE("fpa2bv_to_bv_unspecified", tout << "result=" << mk_ismt2_pp(result, m) << std::endl;);
  3513      SASSERT(is_well_sorted(m, result));

  3540      result = m_util.mk_fp(args[0], args[1], args[2]);
  3541:     TRACE("fpa2bv_mk_fp", tout << "mk_fp result = " << mk_ismt2_pp(result, m) << std::endl;);
  3542  }

  3868  
  3869:     TRACE("fpa2bv_unpack", tout << "UNPACK SGN = " << mk_ismt2_pp(sgn, m) << std::endl; );
  3870:     TRACE("fpa2bv_unpack", tout << "UNPACK SIG = " << mk_ismt2_pp(sig, m) << std::endl; );
  3871:     TRACE("fpa2bv_unpack", tout << "UNPACK EXP = " << mk_ismt2_pp(exp, m) << std::endl; );
  3872  }

  3987  
  3988:     TRACE("fpa2bv_dbg", tout << "RND: " << std::endl <<
  3989          "ebits = " << ebits << std::endl <<

  4010  
  4011:     TRACE("fpa2bv_dbg", tout << "e_min = " << mk_ismt2_pp(e_min, m) << std::endl;
  4012                          tout << "e_max = " << mk_ismt2_pp(e_max, m) << std::endl;);

  4036  
  4037:     TRACE("fpa2bv_dbg", tout << "OVF1 = " << mk_ismt2_pp(OVF1, m) << std::endl;);
  4038      SASSERT(is_well_sorted(m, OVF1));

  4044  
  4045:     TRACE("fpa2bv_dbg", tout << "LZ = " << mk_ismt2_pp(lz, m) << std::endl;);
  4046  

  4054      dbg_decouple("fpa2bv_rnd_TINY", TINY);
  4055:     TRACE("fpa2bv_dbg", tout << "TINY = " << mk_ismt2_pp(TINY, m) << std::endl;);
  4056      SASSERT(is_well_sorted(m, TINY));

  4060  
  4061:     TRACE("fpa2bv_dbg", tout << "beta = " << mk_ismt2_pp(beta, m) << std::endl; );
  4062      SASSERT(is_well_sorted(m, beta));

  4074  
  4075:     TRACE("fpa2bv_dbg", tout << "Shift distance: " << mk_ismt2_pp(sigma, m) << std::endl;);
  4076      SASSERT(is_well_sorted(m, sigma));

  4135  
  4136:     TRACE("fpa2bv_dbg", tout << "sticky = " << mk_ismt2_pp(sticky, m) << std::endl;);
  4137  

  4282  
  4283:     TRACE("fpa2bv_round", tout << "ROUND = " << mk_ismt2_pp(result, m) << std::endl; );
  4284  }

  4309          m_uf2bvuf.insert(f, res);
  4310:         TRACE("fpa2bv", tout << "New UF func_decl: " << res->get_id() << std::endl << mk_ismt2_pp(res, m) << std::endl;);
  4311      }

  4434  
  4435:     TRACE("t_fpa", tout << "result: " << mk_ismt2_pp(result, m) << std::endl;);
  4436      return result;

  4501  
  4502:     TRACE("t_fpa", tout << mk_pp(a, m) << " " << mk_pp(b, m) << " " << mk_pp(c, m) << " result: [" <<
  4503            mpzm.to_string(sgn_z) << "," <<

z3/src/ast/fpa/fpa2bv_rewriter.cpp:
   56  br_status fpa2bv_rewriter_cfg::reduce_app(func_decl * f, unsigned num, expr * const * args, expr_ref & result, proof_ref & result_pr) {
   57:     TRACE("fpa2bv_rw", tout << "func: " << f->get_name() << std::endl;
   58                         tout << "args: " << std::endl;

   73          SASSERT(num == 2);
   74:         TRACE("fpa2bv_rw", tout << "(= " << mk_ismt2_pp(args[0], m()) << " " <<
   75              mk_ismt2_pp(args[1], m()) << ")" << std::endl;);

  160          default:
  161:             TRACE("fpa2bv", tout << "unsupported operator: " << f->get_name() << "\n";
  162                    for (unsigned i = 0; i < num; i++) tout << mk_ismt2_pp(args[i], m()) << std::endl;);

  179  {
  180:     TRACE("fpa2bv", tout << "pre_visit: " << mk_ismt2_pp(t, m()) << std::endl;);
  181  

  183          quantifier * q = to_quantifier(t);
  184:         TRACE("fpa2bv", tout << "pre_visit quantifier [" << q->get_id() << "]: " << mk_ismt2_pp(q->get_expr(), m()) << std::endl;);
  185          sort_ref_vector new_bindings(m_manager);

  241      m_bindings.shrink(old_sz);
  242:     TRACE("fpa2bv", tout << "reduce_quantifier[" << old_q->get_depth() << "]: " <<
  243            mk_ismt2_pp(old_q->get_expr(), m()) << std::endl <<

  274      result_pr = nullptr;
  275:     TRACE("fpa2bv", tout << "reduce_var: " << mk_ismt2_pp(t, m()) << " -> " << mk_ismt2_pp(result, m()) << std::endl;);
  276      return true;

  281  expr_ref fpa2bv_rewriter::convert_atom(th_rewriter& rw, expr * e) {
  282:     TRACE("t_fpa_detail", tout << "converting atom: " << mk_ismt2_pp(e, m_cfg.m()) << std::endl;);
  283      expr_ref res(m_cfg.m());

  300  
  301:     TRACE("t_fpa_detail", tout << "term: " << mk_ismt2_pp(e, m) << std::endl;
  302            tout << "converted term: " << mk_ismt2_pp(e_conv, m) << std::endl;);

  336      expr_ref res(m);
  337:     TRACE("t_fpa", tout << "converting " << mk_ismt2_pp(e, m) << std::endl;);
  338  

  347  
  348:     TRACE("t_fpa_detail", tout << "converted; caching:" << std::endl;
  349            tout << mk_ismt2_pp(e, m) << std::endl << " -> " << std::endl <<

z3/src/ast/macros/macro_finder.cpp:
   27          return false;
   28:     TRACE("macro_finder", tout << "processing: " << mk_pp(n, m) << "\n";);
   29      expr * body        = to_quantifier(n)->get_expr();

   91      //
   92:     TRACE("macro_finder", tout << "is_arith_macro: is_ge or is_le " << f->get_name() << "\n";);
   93      func_decl * k   = m.mk_fresh_func_decl(f->get_name(), symbol::null, f->get_arity(), f->get_domain(), f->get_range());

  163      // 
  164:     TRACE("macro_finder", tout << "is_arith_macro: is_ge or is_le\n";);
  165      func_decl * k   = m.mk_fresh_func_decl(f->get_name(), symbol::null, f->get_arity(), f->get_domain(), f->get_range());

  275  bool macro_finder::expand_macros(expr_ref_vector const& exprs, proof_ref_vector const& prs, expr_dependency_ref_vector const& deps,  expr_ref_vector & new_exprs, proof_ref_vector & new_prs, expr_dependency_ref_vector & new_deps) {
  276:     TRACE("macro_finder", tout << "starting expand_macros:\n";
  277            m_macro_manager.display(tout););

  291          if (is_macro(new_n, head, def) && m_macro_manager.insert(head->get_decl(), to_quantifier(new_n.get()), new_pr, new_dep)) {
  292:             TRACE("macro_finder", tout << "found new macro: " << head->get_decl()->get_name() << "\n" << new_n << "\n";);
  293              found_new_macro = true;

  295          else if (is_arith_macro(new_n, new_pr, deps_valid, new_dep, new_exprs, new_prs, new_deps)) {
  296:             TRACE("macro_finder", tout << "found new arith macro:\n" << new_n << "\n";);
  297              found_new_macro = true;

  299          else if (m_util.is_pseudo_predicate_macro(new_n, head, t, def)) {
  300:             TRACE("macro_finder", tout << "found new pseudo macro:\n" << head->get_decl()->get_name() << "\n" << t << "\n" << def << "\n";);
  301              pseudo_predicate_macro2macro(m, head, t, def, to_quantifier(new_n), new_pr, deps_valid, new_dep, new_exprs, new_prs, new_deps);

  318  void macro_finder::operator()(expr_ref_vector const& exprs, proof_ref_vector const & prs, expr_dependency_ref_vector const & deps, expr_ref_vector & new_exprs, proof_ref_vector & new_prs, expr_dependency_ref_vector & new_deps) {
  319:     TRACE("macro_finder", tout << "processing macros...\n";);
  320      expr_ref_vector   _new_exprs(m);

  347  bool macro_finder::expand_macros(unsigned num, justified_expr const * fmls, vector<justified_expr>& new_fmls) {
  348:     TRACE("macro_finder", tout << "starting expand_macros:\n";
  349            m_macro_manager.display(tout););

  359          if (is_macro(new_n, head, def) && m_macro_manager.insert(head->get_decl(), to_quantifier(new_n.get()), new_pr)) {
  360:             TRACE("macro_finder", tout << "found new macro: " << head->get_decl()->get_name() << "\n" << new_n << "\n";);
  361              found_new_macro = true;

  363          else if (is_arith_macro(new_n, new_pr, new_fmls)) {
  364:             TRACE("macro_finder", tout << "found new arith macro:\n" << new_n << "\n";);
  365              found_new_macro = true;

  367          else if (m_util.is_pseudo_predicate_macro(new_n, head, t, def)) { 
  368:             TRACE("macro_finder", tout << "found new pseudo macro:\n" << head << "\n" << t << "\n" << def << "\n";);
  369              pseudo_predicate_macro2macro(m, head, t, def, to_quantifier(new_n), new_pr, new_fmls);

  389      m_macro_manager.unsafe_macros().reset();
  390:     TRACE("macro_finder", tout << "processing macros...\n";);
  391      vector<justified_expr> _new_fmls;

z3/src/ast/macros/macro_manager.cpp:
  119  bool macro_manager::insert(func_decl * f, quantifier * q, proof * pr, expr_dependency* dep) {
  120:     TRACE("macro_insert", tout << "trying to create macro: " << f->get_name() << "\n" << mk_pp(q, m) << "\n";);
  121  

  123      if (m_decls.contains(f)) {
  124:         TRACE("macro_insert", tout << "we already have a macro for: " << f->get_name() << "\n";);
  125          return false;

  150  
  151:     TRACE("macro_insert", tout << "A macro was successfully created for: " << f->get_name() << "\n";);
  152  

  234      get_head_def(q, f, head, def, r);
  235:     TRACE("macro_bug",
  236            tout << f->get_name() << "\n" << mk_pp(head, m) << "\n" << mk_pp(q, m) << "\n";);

  301          func_decl * d  = n->get_decl(), *d2 = nullptr;
  302:         TRACE("macro_manager", tout << "trying to expand:\n" << mk_pp(n, m) << "\nd:\n" << d->get_name() << "\n";);
  303          if (mm.m_decl2macro.find(d, q)) {            

  309              SASSERT(head && def);
  310:             TRACE("macro_manager", tout << "expanding: " << mk_pp(n, m) << "\n" << mk_pp(head, m) << " " << mk_pp(def, m) << "\n";);
  311              ptr_buffer<expr> subst_args;

  381              SASSERT(!old_pr || m.get_fact(old_pr) == old_n);
  382:             TRACE("macro_manager_bug", tout << "expand_macros:\n" << mk_pp(n, m) << "\n";);
  383              proc(old_n, r, n_eq_r_pr);

z3/src/ast/macros/macro_util.cpp:
  314          mk_sub(rhs, tmp, def);
  315:     TRACE("macro_util", tout << def << "\n";);
  316      return true;

  353          return false;
  354:     TRACE("macro_util", tout << "processing: " << mk_pp(n, m) << "\n";);
  355      expr * body        = to_quantifier(n)->get_expr();

  487  void macro_util::mk_macro_interpretation(app * head, unsigned num_decls, expr * def, expr_ref & interp) const {
  488:     TRACE("macro_util", tout << mk_pp(head, m) << "\n" << mk_pp(def, m) << "\n";);
  489      SASSERT(is_macro_head(head, head->get_num_args()) ||

  509      unsigned num_args = head->get_num_args();
  510:     TRACE("macro_util",
  511            tout << "head: " << mk_pp(head, m) << "\n";

  528          var_subst subst(m, true);
  529:         TRACE("macro_util",
  530                tout << "head: " << mk_pp(head, m) << "\n";

  644  bool macro_util::is_poly_hint(expr * n, app * head, expr * exception) {
  645:     TRACE("macro_util", tout << "is_poly_hint n:\n" << mk_pp(n, m) << "\nhead:\n" << mk_pp(head, m) << "\nexception:\n";
  646            if (exception) tout << mk_pp(exception, m); else tout << "<null>";

  649      if (!is_hint_head(head, vars)) {
  650:         TRACE("macro_util", tout << "failed because head is not hint head\n";);
  651          return false;

  666          if (arg != exception && (occurs(f, arg) || !vars_of_is_subset(arg, vars))) {
  667:             TRACE("macro_util", tout << "failed because of:\n" << mk_pp(arg, m) << "\n";);
  668              return false;

  670      }
  671:     TRACE("macro_util", tout << "succeeded\n";);
  672      return true;

  725                                      bool hint, macro_candidates & r) {
  726:     TRACE("macro_util", tout << expr_ref(head, m) << "\n";);
  727      if (!is_macro_head(head, head->get_num_args())) {

  739              hint_to_macro_head(m, head, num_decls, new_head);
  740:             TRACE("macro_util",
  741                  tout << "hint macro head: " << mk_ismt2_pp(new_head, m) << std::endl;

  874  void macro_util::collect_arith_macro_candidates(expr * atom, unsigned num_decls, macro_candidates & r) {
  875:     TRACE("macro_util", tout << "collect_arith_macro_candidates:\n" << mk_pp(atom, m) << "\n";);
  876      if (!m.is_eq(atom) && !is_le_ge(atom))

  923  
  924:     TRACE("macro_util", tout << "Candidate check for: " << mk_ismt2_pp(atom, m) << std::endl;);
  925  

z3/src/ast/macros/quasi_macros.cpp:
  162      // f[X] contains all universally quantified variables, and f does not occur in T[X].
  163:     TRACE("quasi_macros", tout << "Checking for quasi macro: " << mk_pp(e, m) << std::endl;);
  164  

  278  bool quasi_macros::find_macros(unsigned n, expr * const * exprs) {
  279:     TRACE("quasi_macros", tout << "Finding quasi-macros in: " << std::endl;
  280                            for (unsigned i = 0 ; i < n ; i++)

  289  
  290:     TRACE("quasi_macros",
  291          tout << "Occurrences: " << std::endl;

  301              quasi_macro_to_macro(to_quantifier(exprs[i]), a, t, macro)) {
  302:             TRACE("quasi_macros", tout << "Found quasi macro: " << mk_pp(exprs[i], m) << std::endl;
  303                                    tout << "Macro: " << mk_pp(macro, m) << std::endl; );

  316  bool quasi_macros::find_macros(unsigned n, justified_expr const * exprs) {
  317:     TRACE("quasi_macros", tout << "Finding quasi-macros in: " << std::endl;
  318            for (unsigned i = 0; i < n; i++)

  327  
  328:     TRACE("quasi_macros", tout << "Occurrences: " << std::endl;
  329            for (auto kv : m_occurrences) 

  338              quasi_macro_to_macro(to_quantifier(exprs[i].get_fml()), a, t, macro)) {
  339:             TRACE("quasi_macros", tout << "Found quasi macro: " << mk_pp(exprs[i].get_fml(), m) << std::endl;
  340                                    tout << "Macro: " << mk_pp(macro, m) << std::endl; );

  392  bool quasi_macros::operator()(unsigned n, justified_expr const* fmls, vector<justified_expr>& new_fmls) {
  393:     TRACE("quasi_macros", m_macro_manager.display(tout););
  394      if (find_macros(n, fmls)) {

z3/src/ast/normal_forms/defined_names.cpp:
  168                          1, patterns);
  169:         TRACE("mk_definition_bug", tout << "before elim_unused_vars:\n" << mk_ismt2_pp(q, m) << "\n";);
  170          result = elim_unused_vars(m, q, params_ref());
  171:         TRACE("mk_definition_bug", tout << "after elim_unused_vars:\n" << result << "\n";);
  172      }

  247  bool defined_names::impl::mk_name(expr * e, expr_ref & new_def, proof_ref & new_def_pr, app_ref & n, proof_ref & pr) {
  248:     TRACE("mk_definition_bug", tout << "making name for:\n" << mk_ismt2_pp(e, m) << "\n";);
  249  

  251      if (m_expr2name.find(e, n_ptr)) {
  252:         TRACE("mk_definition_bug", tout << "name for expression is already cached..., returning false...\n";);
  253          n = n_ptr;

  268  
  269:         TRACE("mk_definition_bug", tout << "name: " << mk_ismt2_pp(n, m) << "\n";);
  270          // variables are in reverse order in quantifiers

  275  
  276:         TRACE("mk_definition_bug", tout << "new_def:\n" << mk_ismt2_pp(new_def, m) << "\n";);
  277  

z3/src/ast/normal_forms/elim_term_ite.cpp:
  35       
  36:     CTRACE("elim_term_ite_bug", new_def.get() == 0, tout << mk_ismt2_pp(r, m) << "\n";);
  37      m_new_defs.push_back(justified_expr(m, new_def, new_def_pr));

z3/src/ast/normal_forms/name_exprs.cpp:
   59          bool get_subst(expr * s, expr * & t, proof * & t_pr) {
   60:             TRACE("name_exprs", tout << "get_subst:\n" << mk_ismt2_pp(s, m) << "\n";);
   61              if (m_pred(s)) {

   83          m_rw(n, r, p);
   84:         TRACE("name_exprs", tout << mk_ismt2_pp(n, m_rw.m()) << "\n---->\n" << r << "\n";);
   85      }

  126          bool operator()(expr * t) override {
  127:             TRACE("name_exprs", tout << "name_nested_formulas::pred:\n" << mk_ismt2_pp(t, m) << "\n";);
  128              if (is_app(t)) 

  143          m_pred.m_root = n;
  144:         TRACE("name_exprs", tout << "operator()\n";);
  145          name_exprs_core::operator()(n, new_defs, new_def_proofs, r, p);

z3/src/ast/normal_forms/nnf.cpp:
   80          if (q->get_kind() == lambda_k) {
   81:             TRACE("nnf", tout << expr_ref(q, m) << "\n";);
   82              r = q;

   99  
  100:         TRACE("skolemizer", tout << "skid: " << q->get_skid() << "\n";);
  101          

  301  
  302:         TRACE("nnf", tout << "nnf-mode: " << m_mode << " " << mode_sym << "\n" << _p << "\n";);
  303  

  706      bool process_app(app * t, frame & fr) {
  707:         TRACE("nnf", tout << mk_ismt2_pp(t, m) << "\n";);
  708          SASSERT(m.is_bool(t));

  740      bool process_quantifier(quantifier * q, frame & fr) {
  741:         TRACE("nnf", tout << expr_ref(q, m) << "\n";);
  742          expr_ref  r(m);

  843      void process(expr * t, expr_ref & result, proof_ref & result_pr) {
  844:         TRACE("nnf", tout << "processing:\n" << mk_ismt2_pp(t, m) << "\n";);
  845          SASSERT(m.is_bool(t));

  909  nnf::nnf(ast_manager & m, defined_names & n, params_ref const & p) {
  910:     TRACE("nnf", tout << "nnf constructor: " << p << "\n";);
  911      m_imp = alloc(imp, m, n, p);

  919      m_imp->operator()(n, new_defs, new_def_proofs, r, p);
  920:     TRACE("nnf_result", tout << expr_ref(n, r.get_manager()) << "\nNNF result:\n" << new_defs << "\n" << r << "\n";);
  921  }

z3/src/ast/normal_forms/pull_quant.cpp:
  100                  unsigned          shift_amount = 0;
  101:                 TRACE("pull_quant", tout << "Result num decls:" << num_decls << "\n";);
  102                  for (unsigned i = 0; i < num_children; i++) {

  107                          m_shift(child, num_decls, adjusted_child);
  108:                         TRACE("pull_quant", tout << "shifted by: " << num_decls << "\n" << 
  109                                mk_pp(child, m) << "\n---->\n" << mk_pp(adjusted_child, m) << "\n";);

  129                                  adjusted_child);
  130:                         TRACE("pull_quant", tout << "shifted  bound: " << nested_q->get_num_decls() << " shift1: " << shift_amount <<
  131                                " shift2: " << (num_decls - nested_q->get_num_decls()) << "\n" << mk_pp(nested_q->get_expr(), m) << 

z3/src/ast/pattern/expr_pattern_match.cpp:
  104      }
  105:     TRACE("expr_pattern_match", tout << mk_pp(a, m_manager) << " " << num_bound << "\n";);
  106      inst_proc proc(m_manager, s, b, m_regs);

  275          case CHECK_BOUND:
  276:             TRACE("expr_pattern_match", tout << "check bound " << pc.m_num_bound << " " << pc.m_reg << "\n";);
  277              ok = m_bound_rng[pc.m_num_bound] == m_regs[pc.m_reg];

  281          case BIND_C: {
  282:             TRACE("expr_pattern_match", display(tout, pc);
  283                    tout << mk_pp(m_regs[pc.m_reg],m_manager) << "\n";);

  357          else {
  358:             TRACE("expr_pattern_match", tout << "backtrack\n";);
  359              pc = m_instrs[0];

z3/src/ast/pattern/pattern_inference.cpp:
   33      if (!m_cache.contains(e)) {
   34:         TRACE("smaller_pattern_proc", tout << "saving: " << p1->get_id() << " " << p2->get_id() << "\n";);
   35          m_cache.insert(e);

  130          unsigned delta = e.m_delta;
  131:         TRACE("collect", tout << "processing: " << n->get_id() << " " << delta << " kind: " << n->get_kind() << "\n";);
  132:         TRACE("collect_info", tout << mk_pp(n, m) << "\n";);
  133          if (visit_children(n, delta)) {

  250              (fid != m_afid || (fid == m_afid && !m_owner.m_nested_arith_only && (k == OP_DIV || k == OP_IDIV || k == OP_MOD || k == OP_REM || k == OP_MUL)))) {
  251:             TRACE("pattern_inference", tout << "potential candidate: \n" << mk_pp(new_node, m) << "\n";);
  252              m_owner.add_candidate(new_node, free_vars, size);

  353                      if (s1 == s2) {
  354:                         TRACE("pattern_inference", tout << mk_pp(n, m_owner.m) << "\nis bigger than\n" << mk_pp(to_app(curr), m_owner.m) << "\n";);
  355                          return true;

  473          }
  474:         TRACE("pattern_inference", tout << "m_pre_patterns.size(): " << m_pre_patterns.size() <<
  475                "\nnum_splits: " << num_splits << "\n";);

  492      if (m_params.m_pi_avoid_skolems && decl->is_skolem()) {
  493:         CTRACE("pattern_inference_skolem", decl->is_skolem(), tout << "ignoring: " << mk_pp(n, m) << "\n";);
  494          return true;

  509              if (i.m_free_vars.num_elems() == m_num_bindings) {
  510:                 TRACE("pattern_inference", tout << "found preferred pattern:\n" << mk_pp(candidate, m) << "\n";);
  511                  app * p = m.mk_pattern(candidate);

  530  
  531:     TRACE("pattern_inference",
  532            tout << mk_pp(n, m);

  541          filter_looping_patterns(m_tmp1);
  542:         TRACE("pattern_inference",
  543                tout << "candidates after removing looping-patterns:\n";

  550              SASSERT(!m_tmp2.empty());
  551:             TRACE("pattern_inference",
  552                    tout << "candidates after removing bigger patterns:\n";

  561                  std::stable_sort(m_tmp1.begin(), m_tmp1.end(), m_pattern_weight_lt);
  562:                 TRACE("pattern_inference",
  563                        tout << "candidates after sorting:\n";

  583  
  584:     TRACE("pattern_inference", tout << "processing:\n" << mk_pp(q, m) << "\n";);
  585      if (!is_forall(q)) {

  598                  // just update the weight...
  599:                 TRACE("pattern_inference", tout << "updating weight to: " << new_weight << "\n" << mk_pp(q, m) << "\n";);
  600                  result = m.update_quantifier_weight(q, new_weight);

  605                  result = m.update_quantifier_weight(tmp, new_weight);
  606:                 TRACE("pattern_inference", tout << "found patterns in database, weight: " << new_weight << "\n" << mk_pp(result, m) << "\n";);
  607              }

  698                  }
  699:                 TRACE("pattern_inference", tout << "pulled quantifier:\n" << mk_pp(new_q, m) << "\n";);
  700              }

  708          }
  709:         TRACE("pi_failed", tout << mk_pp(q, m) << "\n";);
  710      }

z3/src/ast/proofs/proof_checker.cpp:
   303      case PR_MONOTONICITY: {
   304:         TRACE("proof_checker", tout << mk_bounded_pp(p, m, 3) << "\n";);
   305          if (match_fact(p, fact) &&

   532                  if (!found) {
   533:                     TRACE("pr_lemma_bug",
   534                            tout << "i: " << i << "\n";

   540                  }
   541:                 TRACE("proof_checker", tout << "Matched:\n";
   542                        ast_ll_pp(tout, m, hypotheses[i].get());

   577                  if (!found) {
   578:                     TRACE("pr_unit_bug",
   579                            tout << "Parents:\n";

   793              fmls.push_back(premise.get());
   794:             TRACE("proof_checker",
   795                    tout << mk_pp(premise.get(), m) << "\n";

  1153      }
  1154:     TRACE("proof_checker",
  1155            {

  1402      }
  1403:     TRACE("proof_checker", 
  1404            for (unsigned i = 0; i < num_parents; i++) 

z3/src/ast/proofs/proof_utils.cpp:
  471          reset();
  472:         CTRACE("proof_utils", contains_hypothesis(pr),
  473              tout << "Contains hypothesis:\n";

  571              m_hyprefs.push_back(new_hyps);
  572:             TRACE("proof_utils",            
  573                      tout << "New lemma: " << mk_pp(m.get_fact(p), m) 

  745      reduce(pr);
  746:     CTRACE("proof_utils", !is_closed(m, pr), tout << mk_pp(pr, m) << "\n";);
  747  }

  987          if (q->get_num_decls() != sub.size()) {
  988:             TRACE("proof_utils", tout << "quantifier has different number of variables than substitution";
  989                    tout << mk_pp(q, m) << "\n";

z3/src/ast/proofs/proof_utils.h:
  223              todo.pop_back();
  224:             CTRACE("virtual",
  225                     p->get_decl_kind() == PR_TH_LEMMA &&

z3/src/ast/rewriter/arith_rewriter.cpp:
    95      }
    96:     CTRACE("arith_rewriter", st != BR_FAILED, tout << st << ": " << mk_pp(f, m());
    97             for (unsigned i = 0; i < num_args; ++i) tout << mk_pp(args[i], m()) << " ";

   521      br_status st = cancel_monomials(arg1, arg2, m_arith_ineq_lhs || m_arith_lhs, new_arg1, new_arg2);
   522:     TRACE("mk_le_bug", tout << "st: " << st << " " << new_arg1 << " " << new_arg2 << "\n";);
   523      if (st != BR_FAILED) {

   531          arg2 = new_new_arg2;
   532:         CTRACE("elim_to_real", m_elim_to_real, tout << "after_elim_to_real\n" << mk_ismt2_pp(arg1, m()) << "\n" << mk_ismt2_pp(arg2, m()) << "\n";);
   533          if (st == BR_FAILED)

   587          get_coeffs_gcd(arg1, g, first, num_consts);
   588:         TRACE("arith_rewriter_gcd", tout << "[step1] g: " << g << ", num_consts: " << num_consts << "\n";);
   589          if ((first || !g.is_one()) && num_consts <= 1)
   590              get_coeffs_gcd(arg2, g, first, num_consts);
   591:         TRACE("arith_rewriter_gcd", tout << "[step2] g: " << g << ", num_consts: " << num_consts << "\n";);
   592          g = abs(g);

  1025          }
  1026:         TRACE("div_bug", tout << "v1: " << v1 << ", v2: " << v2 << "\n";);
  1027          if (!v1.is_one() || !v2.is_one()) {

  1087              result = m_util.mk_add(m_util.mk_numeral(add, true), result);
  1088:             TRACE("div_bug", tout << "mk_div result: " << result << "\n";);
  1089              return BR_REWRITE3;

  1224      if (m_util.is_numeral(arg2, v2, is_int) && is_int && v2.is_pos() && (is_add(arg1) || is_mul(arg1))) {
  1225:         TRACE("mod_bug", tout << "mk_mod:\n" << mk_ismt2_pp(arg1, m()) << "\n" << mk_ismt2_pp(arg2, m()) << "\n";);
  1226          expr_ref_buffer args(m());

  1249          result = m_util.mk_mod(m().mk_app(to_app(arg1)->get_decl(), args.size(), args.data()), arg2);
  1250:         TRACE("mod_bug", tout << "mk_mod result: " << mk_ismt2_pp(result, m()) << "\n";);
  1251          return BR_REWRITE3;

  1295                              m_util.mk_uminus(mod));
  1296:         TRACE("elim_rem", tout << "result: " << mk_ismt2_pp(result, m()) << "\n";);
  1297          return BR_REWRITE3;

  1324  
  1325:     TRACE("arith", tout << mk_pp(arg1, m()) << " " << mk_pp(arg2, m()) << "\n";);
  1326      if (is_num_x && x.is_one()) {

  1649          }
  1650:         TRACE("tan", tout << "is_pi_integer " << mk_ismt2_pp(t, m()) << "\n";
  1651                tout << "a: " << mk_ismt2_pp(a, m()) << "\n";

  1680      rational k_prime = mod(floor(k), rational(2)) + k - floor(k);
  1681:     TRACE("sine", tout << "k: " << k << ", k_prime: " << k_prime << "\n";);
  1682      SASSERT(k_prime >= rational(0) && k_prime < rational(2));

z3/src/ast/rewriter/array_rewriter.cpp:
   76      }
   77:     CTRACE("array_rewriter", st != BR_FAILED, 
   78             tout << mk_pp(f, m()) << "\n";

  380          }
  381:         TRACE("array", tout << result << "\n";);
  382          return BR_REWRITE2;

  740  br_status array_rewriter::mk_eq_core(expr * lhs, expr * rhs, expr_ref & result) {
  741:     TRACE("array_rewriter", tout << mk_bounded_pp(lhs, m(), 2) << " " << mk_bounded_pp(rhs, m(), 2) << "\n";);
  742      expr* v = nullptr, *w = nullptr;

z3/src/ast/rewriter/bit2int.cpp:
   40      }
   41:     TRACE("bit2int", 
   42            tout << mk_pp(n, m) << "======>\n" << result << "\n";);

  223          else {
  224:             TRACE("bit2int", tout << "Not a poly: " << mk_pp(n, m) << "\n";);
  225              return false;

  409      const_cast<bit2int*>(this)->m_cache.get(n, r, p);
  410:     CTRACE("bit2int", !r, tout << mk_pp(n, m) << "\n";);
  411      return r;

  414  void bit2int::cache_result(expr * n, expr * r) { 
  415:     TRACE("bit2int_verbose", tout << "caching:\n" << mk_pp(n, m) <<
  416            "======>\n" << mk_ll_pp(r, m) << "\n";);

z3/src/ast/rewriter/bool_rewriter.cpp:
  710              r = try_ite_value(to_app(lhs), to_app(rhs), result);
  711:             CTRACE("try_ite_value", r != BR_FAILED,
  712                     tout << mk_bounded_pp(lhs, m()) << "\n" << mk_bounded_pp(rhs, m()) << "\n--->\n" << mk_bounded_pp(result, m()) << "\n";);

  715              r = try_ite_value(to_app(rhs), to_app(lhs), result);
  716:             CTRACE("try_ite_value", r != BR_FAILED,
  717                     tout << mk_bounded_pp(lhs, m()) << "\n" << mk_bounded_pp(rhs, m()) << "\n--->\n" << mk_bounded_pp(result, m()) << "\n";);

z3/src/ast/rewriter/bv_bounds.cpp:
   24  bv_bounds::conv_res bv_bounds::record(app * v, numeral lo, numeral hi, bool negated, vector<ninterval>& nis) {
   25:     TRACE("bv_bounds", tout << "record0 " << mk_ismt2_pp(v, m_m) << ":" << (negated ? "~[" : "[") << lo << ";" << hi << "]" << std::endl;);
   26      const unsigned bv_sz = m_bv_util.get_bv_size(v);

   56      if (hi_max) hi = vmax;
   57:     TRACE("bv_bounds", tout << "record1 " << mk_ismt2_pp(v, m_m) << ":" << (negated ? "~[" : "[") << lo << ";" << hi << "]" << std::endl;);
   58      if (lo > hi) return negated ? CONVERTED : UNSAT;

  102  bv_bounds::conv_res bv_bounds::convert(expr * e, vector<ninterval>& nis, bool negated) {
  103:     TRACE("bv_bounds", tout << "new constraint: " << (negated ? "~" : "" ) << mk_ismt2_pp(e, m_m) << std::endl;);
  104  

  283      for (unsigned i = 0; i < num && m_okay; ++i) {
  284:         TRACE("bv_bounds", tout << "check red: " << mk_ismt2_pp(args[i], m_m) << std::endl;);
  285          if (ignore[i]) {
  286:             TRACE("bv_bounds", tout << "unprocessed" << std::endl;);
  287              nargs.push_back(args[i]);

  301              if (!has_upper) th = (numeral::power_of_two(bv_sz) - one);
  302:             TRACE("bv_bounds", tout << "bounds: " << mk_ismt2_pp(v, m_m) << "[" << tl << "-" << th << "]" << std::endl;);
  303              is_singl = tl == th;

  307          has_singls |= is_singl;
  308:         CTRACE("bv_bounds", redundant, tout << "redundant: " << mk_ismt2_pp(args[i], m_m) << std::endl;);
  309          ++count;

  332  bool bv_bounds::add_constraint(expr* e) {
  333:     TRACE("bv_bounds", tout << "new constraint" << mk_ismt2_pp(e, m_m) << std::endl;);
  334      if (!m_okay) return false;

  452  bool bv_bounds::add_bound_unsigned(app * v, const numeral& a, const numeral& b, bool negate) {
  453:     TRACE("bv_bounds", tout << "bound_unsigned " << mk_ismt2_pp(v, m_m) << ": " << (negate ? "~[" : "[") << a << ";" << b << "]" << std::endl;);
  454      const unsigned bv_sz = m_bv_util.get_bv_size(v);

  475  bv_bounds::conv_res bv_bounds::convert_signed(app * v, const numeral& a, const numeral& b, bool negate, vector<ninterval>& nis) {
  476:     TRACE("bv_bounds", tout << "convert_signed " << mk_ismt2_pp(v, m_m) << ":" << (negate ? "~[" : "[") << a << ";" << b << "]" << std::endl;);
  477      const unsigned bv_sz = m_bv_util.get_bv_size(v);

  499  bool bv_bounds::add_bound_signed(app * v, const numeral& a, const numeral& b, bool negate) {
  500:     TRACE("bv_bounds", tout << "bound_signed " << mk_ismt2_pp(v, m_m) << ":" << (negate ? "~" : " ") << a << ";" << b << std::endl;);
  501      const unsigned bv_sz = m_bv_util.get_bv_size(v);

  523      SASSERT(in_range(v, l));
  524:     TRACE("bv_bounds", tout << "lower " << mk_ismt2_pp(v, m_m) << ":" << l << std::endl;);
  525      // l <= v

  534      SASSERT(in_range(v, u));
  535:     TRACE("bv_bounds", tout << "upper " << mk_ismt2_pp(v, m_m) << ":" << u << std::endl;);
  536      // v <= u

  544  bool bv_bounds::add_neg_bound(app * v, const numeral& a, const numeral& b) {
  545:     TRACE("bv_bounds", tout << "negative bound " << mk_ismt2_pp(v, m_m) << ":" << a << ";" << b << std::endl;);
  546      bv_bounds::interval negative_interval(a, b);

  599  void bv_bounds::record_singleton(app * v, numeral& singleton_value) {
  600:     TRACE("bv_bounds", tout << "singleton:" << mk_ismt2_pp(v, m_m) << ":" << singleton_value << std::endl;);
  601      SASSERT(!m_singletons.find(v, singleton_value));

  605  bool bv_bounds::is_sat(app * v) {
  606:     TRACE("bv_bounds", tout << "is_sat " << mk_ismt2_pp(v, m_m) << std::endl;);
  607      const bool rv = is_sat_core(v);
  608:     TRACE("bv_bounds", tout << "is_sat " << mk_ismt2_pp(v, m_m) << "\nres: " << rv << std::endl;);
  609      return rv;

  622      if (!has_upper) upper = (numeral::power_of_two(bv_sz) - one);
  623:     TRACE("bv_bounds", tout << "is_sat bound:" << lower << "-" << upper << std::endl;);
  624      intervals * negative_intervals(nullptr);

  643              }
  644:             TRACE("bv_bounds", tout << "is_sat new_lo, new_hi:" << new_lo << "-" << new_hi << std::endl;);
  645              ptr = negative_upper + one;
  646:             TRACE("bv_bounds", tout << "is_sat ptr, new_hi:" << ptr << "-" << new_hi << std::endl;);
  647              if (ptr > upper) break;

  657      if (new_lo > lower) bound_lo(v, new_lo);
  658:     TRACE("bv_bounds", tout << "is_sat new_lo, new_hi:" << new_lo << "-" << new_hi << std::endl;);
  659  

z3/src/ast/rewriter/bv_rewriter.cpp:
   525          if (cst != BR_FAILED) {
   526:             TRACE("le_extra", tout << (is_signed ? "bv_sle\n" : "bv_ule\n")
   527                        << mk_ismt2_pp(a, m(), 2) <<  "\n" << mk_ismt2_pp(b, m(), 2) <<  "\n--->\n"<< mk_ismt2_pp(result, m(), 2) << "\n";);

   534          if (cst != BR_FAILED) {
   535:             TRACE("le_extra", tout << (is_signed ? "bv_sle\n" : "bv_ule\n")
   536                        << mk_ismt2_pp(a, m(), 2) <<  "\n" << mk_ismt2_pp(b, m(), 2) <<  "\n--->\n"<< mk_ismt2_pp(result, m(), 2) << "\n";);

   787              result = m_mk_extract(high, low, ep_res);
   788:             TRACE("extract_prop", tout << mk_ismt2_pp(arg, m()) << "\n[" << high <<"," << low << "]\n" << ep_rm << "---->\n"
   789                                         << mk_ismt2_pp(result.get(), m()) << "\n";);

  1068  
  1069:     TRACE("bv_udiv", tout << "hi_div0: " << hi_div0 << "\n";);
  1070  

  1117  
  1118:     TRACE("bv_udiv", tout << mk_ismt2_pp(arg1, m()) << "\n" << mk_ismt2_pp(arg2, m()) << "\n---->\n" << mk_ismt2_pp(result, m()) << "\n";);
  1119      return BR_REWRITE2;

  1776          result = m_util.mk_concat(exs.size(), exs.data());
  1777:         TRACE("mask_bug",
  1778                tout << "(assert (distinct (bvor (_ bv" << old_v1 << " " << sz << ")\n" << mk_ismt2_pp(t, m()) << ")\n";

  2186      if (st != BR_FAILED && st != BR_DONE) {
  2187:         TRACE("bv", tout << result << "\n";);
  2188          return st;

  2441          return BR_FAILED;
  2442:     TRACE("blast_eq_value", tout << "sz: " << sz << "\n" << mk_ismt2_pp(lhs, m()) << "\n";);
  2443      if (is_numeral(lhs))

  2711      if (st != BR_FAILED) {
  2712:         TRACE("mk_mul_eq", tout << mk_ismt2_pp(lhs, m()) << "\n=\n" << mk_ismt2_pp(rhs, m()) << "\n----->\n" << mk_ismt2_pp(result,m()) << "\n";);
  2713          return st;

  2717      if (st != BR_FAILED) {
  2718:         TRACE("mk_mul_eq", tout << mk_ismt2_pp(lhs, m()) << "\n=\n" << mk_ismt2_pp(rhs, m()) << "\n----->\n" << mk_ismt2_pp(result,m()) << "\n";);
  2719          return st;

  2810  br_status bv_rewriter::mk_ite_core(expr * c, expr * t, expr * e, expr_ref & result) {
  2811:     TRACE("bv_ite", tout << "mk_ite_core:\n" << mk_ismt2_pp(c, m()) << "?\n"
  2812              << mk_ismt2_pp(t, m()) << "\n:" << mk_ismt2_pp(e, m()) << "\n";);

z3/src/ast/rewriter/cached_var_subst.cpp:
  67          result = entry->get_data().m_value;
  68:         SCTRACE("bindings", is_trace_enabled("coming_from_quant"), tout << "(cache)\n";
  69                  for (unsigned i = 0; i < num_bindings; i++) 

z3/src/ast/rewriter/der.cpp:
   50          t = s; 
   51:         TRACE("der", tout << mk_pp(e, m) << "\n";); 
   52          return true; 

   99  
  100:     TRACE("der", tout << mk_pp(q, m) << "\n";);
  101  

  180          else {
  181:             TRACE("der_bug", tout << "Did not find any diseq\n" << mk_pp(q, m) << "\n";);
  182              r = q;

  236                  if (fr.second == 0) {
  237:                     CTRACE("der_bug", vidx >= definitions.size(), tout << "vidx: " << vidx << "\n";);
  238                      // Remark: The size of definitions may be smaller than the number of variables occurring in the quantified formula.

  295  
  296:     TRACE("top_sort",
  297            tout << "DEFINITIONS: " << std::endl;

  307  
  308:     TRACE("der",
  309            tout << "Elimination m_order:" << "\n";

z3/src/ast/rewriter/distribute_forall.cpp:
  157      SASSERT(result!=0);
  158:     TRACE("distribute_forall", tout << mk_ll_pp(f, m_manager) << "======>\n"
  159            << mk_ll_pp(result, m_manager););

z3/src/ast/rewriter/elim_bounds.cpp:
  154      }
  155:     TRACE("elim_bounds", tout << "candidates:\n"; for (unsigned i = 0; i < candidates.size(); i++) tout << mk_pp(candidates[i], m) << "\n";);
  156      // remove candidates that have lower and upper bounds

  161      }
  162:     TRACE("elim_bounds", tout << "candidates after filter:\n"; for (unsigned i = 0; i < candidates.size(); i++) tout << mk_pp(candidates[i], m) << "\n";);
  163      if (candidate_set.empty()) {

  185          result_pr = m.mk_rewrite(q, result);
  186:         TRACE("elim_bounds", tout << mk_pp(q, m) << "\n" << result << "\n";);
  187          return true;

  198      result_pr = m.mk_rewrite(q, result);
  199:     TRACE("elim_bounds", tout << mk_pp(q, m) << "\n" << result << "\n";);
  200      return true;

z3/src/ast/rewriter/factor_equivs.cpp:
  88      }
  89:     TRACE("equiv",
  90            tout << "Rep: " << mk_pp(rep, m) << "\n";

z3/src/ast/rewriter/factor_rewriter.cpp:
   55      if (!extract_factors()) {
   56:         TRACE("factor_rewriter", tout << mk_pp(arg1, m()) << " = " << mk_pp(arg2, m()) << "\n";);
   57          return BR_FAILED;

   76      if (!extract_factors()) {
   77:         TRACE("factor_rewriter", tout << mk_pp(arg1, m()) << " <= " << mk_pp(arg2, m()) << "\n";);
   78          return BR_FAILED;

   89      result = m().mk_or(eqs.size(), eqs.data());
   90:     TRACE("factor_rewriter", 
   91            tout << mk_pp(arg1, m()) << " <= " << mk_pp(arg2, m()) << "\n";

  103      if (!extract_factors()) {
  104:         TRACE("factor_rewriter", tout << mk_pp(arg1, m()) << " < " << mk_pp(arg2, m()) << "\n";);
  105          return BR_FAILED;

  118      result = m().mk_and(eqs.size(), eqs.data());
  119:     TRACE("factor_rewriter", tout << mk_pp(result.get(), m()) << "\n";);
  120      return BR_DONE;

  165  
  166:         TRACE("factor_rewriter", tout << i << " " << mk_pp(_e, m_manager) << "\n";);
  167  

  197      }
  198:     TRACE("factor_rewriter",
  199          for (unsigned i = 0; i < m_adds.size(); ++i) {

  218      }
  219:     TRACE("factor_rewriter", 
  220          for (unsigned i = 0; i < m_muls.size(); ++i) {

  331      }
  332:     TRACE("factor_rewriter",
  333          for (unsigned i = 0; i < m_factors.size(); ++i) {

z3/src/ast/rewriter/fpa_rewriter.cpp:
  145              m_fm.set(v, ebits, sbits, !mpzm.is_zero(z), mpf_exp, sig);
  146:             TRACE("fp_rewriter",
  147                    tout << "sgn: " << !mpzm.is_zero(z) << std::endl;

  161              // rm + real -> float
  162:             TRACE("fp_rewriter", tout << "r: " << r1 << std::endl;);
  163              scoped_mpf v(m_fm);

  165              result = m_util.mk_value(v);
  166:             // TRACE("fp_rewriter", tout << "result: " << result << std::endl; );
  167              return BR_DONE;

  170              // rm + float -> float
  171:             TRACE("fp_rewriter", tout << "v: " << m_fm.to_string(v) << std::endl; );
  172              scoped_mpf vf(m_fm);

  174              result = m_util.mk_value(vf);
  175:             // TRACE("fp_rewriter", tout << "result: " << result << std::endl; );
  176              return BR_DONE;

  179              // rm + signed bv -> float
  180:             TRACE("fp_rewriter", tout << "r1: " << r1 << std::endl;);
  181              r1 = m_util.bu().norm(r1, bvs1, true);
  182:             TRACE("fp_rewriter", tout << "r1 norm: " << r1 << std::endl;);
  183              m_fm.set(v, ebits, sbits, rmv, r1.to_mpq());

  197  
  198:             TRACE("fp_rewriter", tout << "r1: " << r1 << ", r2: " << r2 << "\n";);
  199              m_fm.set(v, ebits, sbits, rmv, r2.to_mpq().numerator(), r1.to_mpq());

  211  
  212:             TRACE("fp_rewriter", tout << "r1: " << r1 << ", r2: " << r2 << "\n";);
  213              m_fm.set(v, ebits, sbits, rmv, r1.to_mpq().numerator(), r2.to_mpq());

  228                              r3.to_mpq().numerator());
  229:             TRACE("fp_rewriter", tout << "v = " << m_fm.to_string(v) << std::endl;);
  230              result = m_util.mk_value(v);

  702                          rsig.to_mpq().numerator());
  703:         TRACE("fp_rewriter", tout << "simplified (fp ...) to " << m_fm.to_string(v) << std::endl;);
  704          result = m_util.mk_value(v);

  767  br_status fpa_rewriter::mk_to_ieee_bv(func_decl * f, expr * arg, expr_ref & result) {
  768:     TRACE("fp_rewriter", tout << "to_ieee_bv of " << mk_ismt2_pp(arg, m()) << std::endl;);
  769      scoped_mpf v(m_fm);

  771      if (m_util.is_numeral(arg, v)) {
  772:         TRACE("fp_rewriter", tout << "to_ieee_bv numeral: " << m_fm.to_string(v) << std::endl;);
  773          bv_util bu(m());

z3/src/ast/rewriter/hoist_rewriter.cpp:
  129      result = mk_and(fmls);
  130:     TRACE("hoist", tout << ors << " => " << result << "\n";);
  131      return BR_DONE;

z3/src/ast/rewriter/inj_axiom.cpp:
   76                  if (found_vars && !has_free_vars(q)) {
   77:                     TRACE("inj_axiom", 
   78                            tout << "Cadidate for simplification:\n" << mk_ll_pp(q, m) << mk_pp(app1, m) << "\n" << mk_pp(app2, m) << "\n" <<

  129                                           0, symbol(), symbol(), 1, &p);
  130:                     TRACE("inj_axiom", tout << "new axiom:\n" << mk_pp(result, m) << "\n";);
  131                      SASSERT(is_well_sorted(m, result));

z3/src/ast/rewriter/maximize_ac_sharing.cpp:
  48  
  49:     TRACE("ac_sharing_detail", tout << "before-reuse: num_args: " << num_args << "\n";);
  50  

  53      // Try to reuse already created circuits.
  54:     TRACE("ac_sharing_detail", tout << "args: "; for (unsigned i = 0; i < num_args; i++) tout << mk_pp(_args[i], m) << "\n";);
  55      try_to_reuse:

  59                  if (contains(f, _args[i], _args[j])) {
  60:                     TRACE("ac_sharing_detail", tout << "reusing args: " << i << " " << j << "\n";);
  61                      _args[i] = m.mk_app(f, _args[i], _args[j]);

  75      while (true) {
  76:         TRACE("ac_sharing_detail", tout << "tree-loop: num_args: " << num_args << "\n";);
  77          unsigned j  = 0;

  94              }
  95:             TRACE("ac_sharing_detail", tout << "result: " << mk_pp(result, m) << "\n";);
  96              return BR_DONE;

z3/src/ast/rewriter/pb_rewriter_def.h:
   37      
   38:     TRACE("pb_verbose", display(tout << "pre-unique:", args, k, is_eq););
   39      for (unsigned i = 0; i < args.size(); ++i) {

   86      args.resize(i);
   87:     TRACE("pb_verbose", display(tout << "post-unique:", args, k, is_eq););
   88  }

   91  lbool pb_rewriter_util<PBU>::normalize(typename PBU::args_t& args, typename PBU::numeral& k, bool is_eq) {
   92:     TRACE("pb_verbose", display(tout << "pre-normalize:", args, k, is_eq););
   93  

  169      if (is_eq) {
  170:         TRACE("pb_verbose", display(tout << "post-normalize:", args, k, is_eq););
  171          return l_undef;

  267      }
  268:     TRACE("pb_verbose", display(tout << "post-normalize:", args, k, is_eq););
  269      return l_undef;

z3/src/ast/rewriter/pb_rewriter.cpp:
  325      }
  326:     TRACE("pb_verbose",
  327            expr_ref tmp(m);

  332      
  333:     TRACE("pb_validate",
  334            validate_rewrite(f, num_args, args, result););

z3/src/ast/rewriter/pb2bv_rewriter.cpp:
  159              expr * const* args = m_args.data();
  160:             TRACE("pb", 
  161                    for (unsigned i = 0; i < sz; ++i) {

  285              result = m.mk_not(bounded_addition(sz, args, k + 1));
  286:             TRACE("pb", tout << result << "\n";);
  287              return true;

  303              result = bounded_addition(sz, args, k);
  304:             TRACE("pb", tout << result << "\n";);
  305              return true;

  451              m_base = m_min_base;
  452:             TRACE("pb",
  453                    tout << "Base: ";

  467          expr_ref mod_ge(ptr_vector<expr> const& out, unsigned n, unsigned lim) {
  468:             TRACE("pb", for (unsigned i = 0; i < out.size(); ++i) tout << mk_pp(out[i], m) << " "; tout << "\n";
  469                    tout << "n:" << n << " lim: " << lim << "\n";);

  516                  }
  517:                 TRACE("pb", tout << "Carry: " << carry << "\n";
  518                        for (auto c : coeffs) tout << c << " ";

  527                  result = mk_or(gt, result);                
  528:                 TRACE("pb", tout << "b: " << b_i << " d: " << d_i << " gt: " << gt << " ge: " << ge << " " << result << "\n";);
  529  

  536              }
  537:             TRACE("pb", tout << "bound: " << bound << " Carry: " << carry << " result: " << result << "\n";);
  538              return true;

  687              }
  688:             CTRACE("pb", k.is_neg(), tout << expr_ref(m.mk_app(f, sz, args), m) << "\n";);
  689              SASSERT(!k.is_neg());

  924              }
  925:             TRACE("pb", tout << "full: " << full << " " << expr_ref(m.mk_app(f, sz, args), m) << " " << result << "\n";
  926                    );

z3/src/ast/rewriter/poly_rewriter_def.h:
  189              br_status st = mk_nflat_mul_core(flat_args.size(), flat_args.data(), result);
  190:             TRACE("poly_rewriter",
  191                    tout << "flat mul:\n";

  294              result = mk_add_app(new_add_args.size(), new_add_args.data());
  295:             TRACE("mul_bug", tout << "result: " << mk_bounded_pp(result, m(),5) << "\n";);
  296              return BR_REWRITE2;

  326          }
  327:         TRACE("poly_rewriter", 
  328                for (unsigned i = 0; i < new_args.size(); i++) {

  337              std::sort(new_args.begin(), new_args.end(), lt);
  338:         TRACE("poly_rewriter",
  339                    tout << "after sorting:\n";

  349          result = mk_mul_app(c, result);
  350:         TRACE("poly_rewriter", 
  351                for (unsigned i = 0; i < num_args; ++i)

  377      ptr_buffer<expr> m_args;
  378:     TRACE("som", tout << "starting som...\n";);
  379      do {
  380:         TRACE("som", for (unsigned i = 0; i < it.size(); i++) tout << it[i] << " ";
  381                tout << "\n";);

  566      SASSERT(m_sort_sums || ordered);
  567:     TRACE("rewriter", 
  568            tout << "ordered: " << ordered << " sort sums: " << m_sort_sums << "\n";

  617          if (m_sort_sums) {
  618:             TRACE("rewriter_bug", tout << "new_args.size(): " << new_args.size() << "\n";);
  619              if (c.is_zero())

  624          result = mk_add_app(new_args.size(), new_args.data());
  625:         TRACE("rewriter", tout << result << "\n";);
  626          if (hoist_multiplication(result)) {

  883      rhs_result = mk_add_app(new_rhs_monomials.size() - rhs_offset, new_rhs_monomials.data() + rhs_offset);
  884:     TRACE("le_bug", tout << lhs_result << " " << rhs_result << "\n";);
  885      return BR_DONE;

z3/src/ast/rewriter/push_app_ite.cpp:
  49      }
  50:     CTRACE("push_app_ite", found_ite, tout << "found target for push app ite:\n";
  51             tout << "conservative " << m_conservative << "\n";

  76      result = m.mk_ite(c, t_new, e_new);
  77:     TRACE("push_app_ite", tout << result << "\n";);
  78      if (m.proofs_enabled()) {

z3/src/ast/rewriter/quant_hoist.cpp:
  46          pull_quantifier(fml, qt, vars, result, use_fresh, rewrite_ok);
  47:         TRACE("qe_verbose", 
  48                tout << mk_pp(fml, m) << "\n";

  56          pull_quantifier(fml, qt, vars, result, use_fresh, rewrite_ok);
  57:         TRACE("qe_verbose", 
  58                tout << mk_pp(fml, m) << "\n";

  65          pull_quantifier(fml, qt, vars, result, use_fresh, rewrite_ok);
  66:         TRACE("qe_verbose", 
  67                tout << mk_pp(fml, m) << "\n";

z3/src/ast/rewriter/rewriter_def.h:
   36          set_new_child_flag(v);
   37:         TRACE("rewriter", tout << mk_ismt2_pp(v, m()) << " -> " << m_r << "\n";);
   38          m_r = nullptr;

   47      if (idx < m_bindings.size() && (index = m_bindings.size() - idx - 1, r = m_bindings[index])) {
   48:         CTRACE("rewriter", v->get_sort() != r->get_sort(),
   49                 tout << expr_ref(v, m()) << ":" << sort_ref(v->get_sort(), m()) << " != " << expr_ref(r, m()) << ":" << sort_ref(r->get_sort(), m());

   62                  result_stack().push_back(tmp);
   63:                 TRACE("rewriter", display_bindings(tout << "shift: " << shift_amount << " idx: " << idx << " --> " << tmp << "\n"););
   64                  cache_shifted_result(r, shift_amount, tmp);                    

   68              result_stack().push_back(r);
   69:             TRACE("rewriter", tout << idx << " " << mk_ismt2_pp(r, m()) << "\n";);
   70          }

   85      br_status st = m_cfg.reduce_app(t->get_decl(), 0, nullptr, m_r, m_pr);
   86:     TRACE("reduce_app",
   87            tout << "t0:" << mk_bounded_pp(t0, m()) << "\n";

   93            );
   94:     CTRACE("reduce_app", 
   95             st != BR_FAILED && m_r->get_sort() != t->get_sort(),

  143  bool rewriter_tpl<Config>::visit(expr * t, unsigned max_depth) {
  144:     TRACE("rewriter_visit", tout << "visiting\n" << mk_ismt2_pp(t, m()) << "\n";);
  145      expr *  new_t = nullptr;

  147      if (m_cfg.get_subst(t, new_t, new_t_pr)) {
  148:         TRACE("rewriter_subst", tout << "subst\n" << mk_ismt2_pp(t, m()) << "\n---->\n" << mk_ismt2_pp(new_t, m()) << "\n";);
  149          SASSERT(t->get_sort() == new_t->get_sort());

  198                  return true;
  199:             TRACE("rewriter_const", tout << "process const: " << mk_bounded_pp(t, m()) << " -> " << mk_bounded_pp(m_r, m()) << "\n";);
  200              if (!is_blocked(t)) {

  245              fr.m_state = REWRITE_BUILTIN;
  246:             TRACE("rewriter_step", tout << "step\n" << mk_ismt2_pp(t, m()) << "\n";);
  247              if (visit<false>(arg, fr.m_max_depth)) {

  252                  cache_result<false>(t, m_r, m_pr, fr.m_cache_result);
  253:                 TRACE("rewriter_step", tout << "step 1\n" << mk_ismt2_pp(m_r, m()) << "\n";);
  254                  frame_stack().pop_back();

  317          
  318:         CTRACE("reduce_app", true || st != BR_FAILED || new_t,
  319                 tout << mk_bounded_pp(t, m()) << "\n";

  427                      fr.m_state = EXPAND_DEF;
  428:                     TRACE("get_macro", tout << "f: " << f->get_name() << ", def: \n" << mk_ismt2_pp(def, m()) << "\n";
  429                            tout << "Args num: " << num_args << "\n";

  438                      result_stack().push_back(def);
  439:                     TRACE("get_macro", display_bindings(tout););
  440                      begin_scope();

  455              else {
  456:                 TRACE("rewriter_reuse", tout << "reusing:\n" << mk_ismt2_pp(t, m()) << "\n";);
  457                  m_r = t;

  559      if (rewrite_patterns()) {
  560:         TRACE("reduce_quantifier_bug", tout << "rewrite patterns\n";);
  561          expr * const * np  = it + 1;

  593          }
  594:         TRACE("reduce_quantifier_bug",if (m_pr) tout << mk_ismt2_pp(m_pr, m()) << "\n"; else tout << "m_pr is_null\n";);
  595          result_pr_stack().shrink(fr.m_spos);

  598      else {
  599:         TRACE("reduce_quantifier_bug", tout << mk_ismt2_pp(q, m()) << " " << mk_ismt2_pp(new_body, m()) << "\n";);
  600          if (!m_cfg.reduce_quantifier(q, new_body, new_pats.data(), new_no_pats.data(), m_r, m_pr)) {

  604              else {
  605:                 TRACE("rewriter_reuse", tout << "reusing:\n" << mk_ismt2_pp(q, m()) << "\n";);
  606                  m_r = q;

  686      }
  687:     TRACE("rewriter", display_bindings(tout););
  688:     SCTRACE("bindings", is_trace_enabled("coming_from_quant"), display_bindings(tout););
  689  }

  700      }
  701:     TRACE("rewriter", display_bindings(tout););
  702:     SCTRACE("bindings", is_trace_enabled("coming_from_quant"), display_bindings(tout););
  703  }

  747      }
  748:     TRACE("rewriter", tout << mk_ismt2_pp(t, m()) << "\n=>\n" << result << "\n";;);
  749  }

  767          expr * t   = fr.m_curr;
  768:         TRACE("rewriter_step", tout << "step\n" << mk_ismt2_pp(t, m()) << "\n";);
  769          m_num_steps++;

z3/src/ast/rewriter/rewriter.cpp:
  50  bool rewriter_core::rewrites_to(expr* t, proof* p) {
  51:     CTRACE("rewriter", p && !m().proofs_disabled() && to_app(m().get_fact(p))->get_arg(1) != t, 
  52             tout << mk_pp(p, m()) << "\n";

  65      
  66:     TRACE("rewriter_cache_result", tout << mk_ismt2_pp(k, m()) << "\n--->\n" << mk_ismt2_pp(v, m()) << "\n";);
  67  

z3/src/ast/rewriter/rewriter.h:
  108      void set_new_child_flag(expr * old_t) {
  109:         CTRACE("rewriter_bug", !is_child_of_top_frame(old_t), display_stack(tout, 3););
  110          SASSERT(is_child_of_top_frame(old_t));

z3/src/ast/rewriter/seq_axioms.cpp:
  193      void axioms::extract_axiom(expr* e) {
  194:         TRACE("seq", tout << mk_pp(e, m) << "\n";);
  195          expr* _s = nullptr, *_i = nullptr, *_l = nullptr;

  220          }
  221:         TRACE("seq", tout << s << " " << i << " " << l << "\n";);
  222          expr_ref x = m_sk.mk_pre(s, i);

  264          m_sk.decompose(s, head, tail);
  265:         TRACE("seq", tout << "tail " << mk_bounded_pp(e, m, 2) << " " << mk_bounded_pp(s, m, 2) << "\n";);
  266          expr_ref emp = mk_eq_empty(s);

  271      void axioms::drop_last_axiom(expr* e, expr* s) {
  272:         TRACE("seq", tout << "drop last " << mk_bounded_pp(e, m, 2) << " " << mk_bounded_pp(s, m, 2) << "\n";);
  273          expr_ref emp = mk_eq_empty(s);

  333      void axioms::extract_prefix_axiom(expr* e, expr* s, expr* l) {        
  334:         TRACE("seq", tout << "prefix " << mk_bounded_pp(e, m, 2) << " " << mk_bounded_pp(s, m, 2) << " " << mk_bounded_pp(l, m, 2) << "\n";);
  335          expr_ref le = mk_len(e);

  353      void axioms::extract_suffix_axiom(expr* e, expr* s, expr* i) {
  354:         TRACE("seq", tout << "suffix " << mk_bounded_pp(e, m, 2) << " " << mk_bounded_pp(s, m, 2) << "\n";);
  355          expr_ref x = m_sk.mk_pre(s, i);

  595      void axioms::at_axiom(expr* e) {
  596:         TRACE("seq", tout << "at-axiom: " << mk_bounded_pp(e, m) << "\n";);
  597          expr* _s = nullptr, *_i = nullptr;

  668          expr* n = nullptr;
  669:         TRACE("seq", tout << mk_pp(e, m) << "\n";);
  670          VERIFY(seq.str.is_itos(e, n));

  705      void axioms::stoi_axiom(expr* e) {
  706:         TRACE("seq", tout << mk_pp(e, m) << "\n";);
  707          expr_ref ge0 = mk_ge(e, 0);      

z3/src/ast/rewriter/seq_rewriter.cpp:
   253          bool_rewriter br(m);
   254:         TRACE("seq", display_expr1 disp(m); r->display(tout << mk_pp(e, m) << " -->\n", disp););
   255      }

   304              is_unit_char(e2, _stop)) {
   305:             TRACE("seq", tout << "Range: " << _start << " " << _stop << "\n";);
   306              a = alloc(eautomaton, sm, sym_expr::mk_range(_start, _stop));

   362          eautomaton* r = m_sa->mk_product(*a, *b);
   363:         TRACE("seq", display_expr1 disp(m); a->display(tout << "a:", disp); b->display(tout << "b:", disp); r->display(tout << "intersection:", disp););
   364          return r;

   366      else {        
   367:         TRACE("seq", tout << "not handled " << mk_pp(e, m) << "\n";);
   368      }

   765      }
   766:     CTRACE("seq_verbose", st != BR_FAILED, tout << expr_ref(m().mk_app(f, num_args, args), m()) << " -> " << result << "\n";);
   767      SASSERT(st == BR_FAILED || result->get_sort() == f->get_range());

   779          zstring s(ch);
   780:         TRACE("seq_verbose", tout << "rewrite seq.unit of 8-bit value " << ch << " to string constant \"" << s<< "\"" << std::endl;);
   781          result = str().mk_string(s);

   985              result = m().mk_ite(c, arg1, arg2);
   986:             TRACE("seq_verbose", tout << "lifting ite: " << mk_pp(result, m()) << std::endl;);
   987              return BR_REWRITE2;

  1128              result = str().mk_substr(t1, t2, c);
  1129:             TRACE("seq", tout << result << "\n";);
  1130              return true;

  1165              result = str().mk_concat(i + 1, as.data(), as[0]->get_sort());
  1166:             TRACE("seq", tout << result << "\n";);
  1167              return true;

  1177  
  1178:     TRACE("seq_verbose", tout << mk_pp(a, m()) << " " << mk_pp(b, m()) << " " << mk_pp(c, m()) << "\n";);
  1179      bool constantBase = str().is_string(a, s);

  1417      
  1418:     TRACE("seq", tout << mk_pp(a, m()) << " contains " << mk_pp(b, m()) << "\n";);
  1419     

  2201  br_status seq_rewriter::mk_seq_prefix(expr* a, expr* b, expr_ref& result) {
  2202:     TRACE("seq", tout << mk_pp(a, m()) << " " << mk_pp(b, m()) << "\n";);
  2203      zstring s1, s2;

  2208          result = m().mk_bool_val(s1.prefixof(s2));
  2209:         TRACE("seq", tout << result << "\n";);
  2210          return BR_DONE;

  2226                      result = m().mk_true();
  2227:                     TRACE("seq", tout << s1 << " " << s2 << " " << result << "\n";);
  2228                      return BR_DONE;

  2236                                                str().mk_concat(bs.size(), bs.data(), sort_a));
  2237:                 TRACE("seq", tout << s1 << " " << s2 << " " << result << "\n";);
  2238                  return BR_REWRITE_FULL;

  2241                  result = m().mk_false();
  2242:                 TRACE("seq", tout << s1 << " " << s2 << " " << result << "\n";);
  2243                  return BR_DONE;

  2249                      result = m().mk_false();
  2250:                     TRACE("seq", tout << s1 << " " << s2 << " " << result << "\n";);
  2251                      return BR_DONE;

  2259                                                str().mk_concat(bs.size()-1, bs.data()+1, sort_a));
  2260:                 TRACE("seq", tout << s1 << " " << s2 << " " << result << "\n";);
  2261                  return BR_REWRITE_FULL;                

  2264                  result = m().mk_false();
  2265:                 TRACE("seq", tout << s1 << " " << s2 << " " << result << "\n";);
  2266                  return BR_DONE;

  2290          result = mk_and(eqs);
  2291:         TRACE("seq", tout << result << "\n";);
  2292          return BR_REWRITE3;

  2299          result = mk_and(eqs);
  2300:         TRACE("seq", tout << result << "\n";);
  2301          return BR_REWRITE3;

  2308          result = mk_and(eqs);
  2309:         TRACE("seq", tout << result << "\n";);
  2310          return BR_REWRITE3;

  2368          result = mk_and(eqs);
  2369:         TRACE("seq", tout << result << "\n";);
  2370          return BR_REWRITE3;

  2377          result = mk_and(eqs);
  2378:         TRACE("seq", tout << result << "\n";);
  2379          return BR_REWRITE3;

  2387          result = mk_and(eqs);
  2388:         TRACE("seq", tout << result << "\n";);
  2389          return BR_REWRITE3;

  2829  expr_ref seq_rewriter::is_nullable(expr* r) {
  2830:     STRACE("seq_verbose", tout << "is_nullable: "
  2831                                 << mk_pp(r, m()) << std::endl;);

  2836      }
  2837:     STRACE("seq_verbose", tout << "is_nullable result: "
  2838                                 << result << std::endl;);

  3084      if (level == 3) { // top level
  3085:         STRACE("seq_verbose", tout
  3086              << "Checking derivative normal form invariant...";);

  3089      unsigned lo = 0, hi = 0;
  3090:     STRACE("seq_verbose", tout << " (level " << level << ")";);
  3091      int new_level = 0;

  3133      if (level == 3) {
  3134:         STRACE("seq_verbose", tout << " passed!" << std::endl;);
  3135      }

  3158          m_op_cache.insert(OP_RE_DERIVATIVE, e, r, path, result);
  3159:         STRACE("seq_regex", tout << "D(" << mk_pp(e, m()) << "," << mk_pp(r, m()) << "," << mk_pp(path, m()) << ")" << std::endl;);
  3160:         STRACE("seq_regex", tout << "= " << mk_pp(result, m()) << std::endl;);
  3161      }

  3784  bool seq_rewriter::pred_implies(expr* a, expr* b) {
  3785:     STRACE("seq_verbose", tout << "pred_implies: "
  3786                                 << "," << mk_pp(a, m())

  3845  expr_ref seq_rewriter::mk_der_op_rec(decl_kind k, expr* a, expr* b) {
  3846:     STRACE("seq_verbose", tout << "mk_der_op_rec: " << k
  3847                                 << "," << mk_pp(a, m())

  4009  expr_ref seq_rewriter::mk_der_compl(expr* r) {
  4010:     STRACE("seq_verbose", tout << "mk_der_compl: " << mk_pp(r, m())
  4011                                 << std::endl;);

  4048  expr_ref seq_rewriter::mk_der_cond(expr* cond, expr* ele, sort* seq_sort) {
  4049:     STRACE("seq_verbose", tout << "mk_der_cond: "
  4050             <<  mk_pp(cond, m()) << ", " << mk_pp(ele, m()) << std::endl;);

  4093      }
  4094:     STRACE("seq_verbose", tout << "mk_der_cond result: "
  4095          <<  mk_pp(result, m()) << std::endl;);

  4197              // Use mk_der_cond to normalize
  4198:             STRACE("seq_verbose", tout << "deriv to_re" << std::endl;);
  4199              result = m().mk_eq(ele, hd);

  4238                  // Use mk_der_cond to normalize
  4239:                 STRACE("seq_verbose", tout << "deriv reverse to_re" << std::endl;);
  4240                  result = m().mk_eq(ele, tl);

  4267                  // Use mk_der_cond to normalize
  4268:                 STRACE("seq_verbose", tout << "deriv range zstring" << std::endl;);
  4269                  expr_ref p1(u().mk_le(ch1, ele), m());

  4283              // Use mk_der_cond to normalize
  4284:             STRACE("seq_verbose", tout << "deriv range str" << std::endl;);
  4285              expr_ref p1(u().mk_le(e1, ele), m());

  4300          // Use mk_der_cond to normalize
  4301:         STRACE("seq_verbose", tout << "deriv of_pred" << std::endl;);
  4302          return mk_der_cond(result, ele, seq_sort);

  4480  
  4481:     STRACE("seq_verbose", tout << "mk_str_in_regexp: " << mk_pp(a, m())
  4482                                 << ", " << mk_pp(b, m()) << std::endl;);

  5320          result = m().mk_false();
  5321:         TRACE("seq_verbose", tout << result << "\n";);
  5322          return BR_DONE;

  5330      result = mk_and(res);
  5331:     TRACE("seq_verbose", tout << result << "\n";);
  5332      return BR_REWRITE3;

  5471                   str().is_string(r, s2)) {
  5472:             TRACE("seq", tout << s1 << " - " << s2 << " " << s1.length() << " " << s2.length() << "\n";);
  5473              unsigned min_l = std::min(s1.length(), s2.length());

  5475                  if (s1[i] != s2[i]) {
  5476:                     TRACE("seq", tout << "different at position " << i << " " << s1[i] << " " << s2[i] << "\n";);
  5477                      return false;

  5509  bool seq_rewriter::reduce_eq(expr_ref_vector& ls, expr_ref_vector& rs, expr_ref_pair_vector& eqs, bool& change) {
  5510:     TRACE("seq_verbose", tout << ls << "\n"; tout << rs << "\n";);
  5511      unsigned hash_l = ls.hash();

  5545      else {
  5546:         TRACE("seq", tout << mk_bounded_pp(l, m()) << " != " << mk_bounded_pp(r, m()) << "\n";);
  5547          return false;

  5561      str().get_concat(a, m_lhs);
  5562:     TRACE("seq", tout << expr_ref(a, m()) << " " << expr_ref(b, m()) << "\n";);
  5563      sort* sort_a = a->get_sort();

  5993          rs.reset();
  5994:         TRACE("seq", tout << "subsequence " << eqs << "\n";);
  5995      }

  6022          m_table.reset();
  6023:         STRACE("seq_regex", tout << "Op cache reset!" << std::endl;);
  6024:         STRACE("seq_regex_brief", tout << "(OP CACHE RESET) ";);
  6025:         STRACE("seq_verbose", tout << "Derivative op cache reset" << std::endl;);
  6026      }

z3/src/ast/rewriter/th_rewriter.cpp:
  585          bool first;
  586:         TRACE("push_ite", tout << "unifying:\n" << mk_ismt2_pp(t, m()) << "\n" << mk_ismt2_pp(e, m()) << "\n";);
  587          if (unify(t, e, f_prime, new_t, new_e, common, first)) {

  593          }
  594:         TRACE("push_ite", tout << "failed\n";);
  595          return BR_FAILED;

  669          if (st != BR_DONE && st != BR_FAILED) {
  670:             CTRACE("th_rewriter_step", st != BR_FAILED,
  671                     tout << f->get_name() << "\n";

  687          }
  688:         CTRACE("th_rewriter_step", st != BR_FAILED,
  689                 tout << f->get_name() << "\n";

  818              m_pinned.reset();
  819:             TRACE("reduce_quantifier", tout << mk_ismt2_pp(old_q, m()) << "\n----->\n" << mk_ismt2_pp(q1, m()) << "\n";);
  820              SASSERT(is_well_sorted(m(), q1));

  837  
  838:         TRACE("reduce_quantifier", tout << "after elim_unused_vars:\n" << result << " " << result_pr << "\n" ;);
  839  

z3/src/ast/rewriter/value_sweep.cpp:
  113              m_rewrite(new_value);
  114:             TRACE("value_sweep", tout << "propagate " << mk_pp(p, m) << " " << new_value << "\n";);
  115              set_value_core(p, new_value);

z3/src/ast/rewriter/var_subst.cpp:
   33          //There is no need to print the bindings here?
   34:         SCTRACE("bindings", is_trace_enabled("coming_from_quant"),
   35                  tout << "(ground)\n";

   62      SASSERT(is_well_sorted(m, result));
   63:     TRACE("var_subst_bug",
   64            tout << "m_std_order: " << m_std_order << "\n" << mk_ismt2_pp(n, m) << "\nusing\n";

   79      SASSERT(is_well_sorted(m, q));
   80:     TRACE("elim_unused_vars", tout << expr_ref(q, m) << "\n";);
   81      if (is_lambda(q)) {

  191      expr_ref result = el(q);
  192:     TRACE("elim_unused_vars", tout << expr_ref(q, m) << " -> " << result << "\n";);
  193      return result;

  199      new_expr = subst(q->get_expr(), q->get_num_decls(), exprs);
  200:     TRACE("var_subst", tout << mk_pp(q, m) << "\n" << new_expr << "\n";);
  201      inv_var_shifter shift(m);

  203      SASSERT(is_well_sorted(m, result));
  204:     TRACE("instantiate_bug", tout << mk_ismt2_pp(q, m) << "\nusing\n";
  205            for (unsigned i = 0; i < q->get_num_decls(); i++) tout << mk_ismt2_pp(exprs[i], m) << "\n";

z3/src/ast/rewriter/bit_blaster/bit_blaster_rewriter.cpp:
  380          result_pr = nullptr;
  381:         TRACE("bit_blaster", tout << f->get_name() << " ";
  382                for (unsigned i = 0; i < num; ++i) tout << mk_pp(args[i], m()) << " ";

  552              default:
  553:                 TRACE("bit_blaster", tout << "non-supported operator: " << f->get_name() << "\n";
  554                        for (unsigned i = 0; i < num; i++) tout << mk_ismt2_pp(args[i], m()) << std::endl;);

z3/src/ast/rewriter/bit_blaster/bit_blaster_tpl_def.h:
  427          }});
  428:     TRACE("bit_blaster",
  429            tout << "a: ";

  779  void bit_blaster_tpl<Cfg>::mk_rotate_left(unsigned sz, expr * const * a_bits, unsigned n, expr_ref_vector & out_bits) {
  780:     TRACE("bit_blaster", tout << n << ": " << sz << " ";
  781            for (unsigned i = 0; i < sz; ++i) {

z3/src/ast/rewriter/bit_blaster/bit_blaster.cpp:
  40  void bit_blaster_cfg::mk_xor3(expr * l1, expr * l2, expr * l3, expr_ref & r) {
  41:     TRACE("xor3", tout << "#" << l1->get_id() << " #" << l2->get_id() << " #" << l3->get_id(););
  42      sort_args(l1, l2, l3);
  43:     TRACE("xor3_sorted", tout << "#" << l1->get_id() << " #" << l2->get_id() << " #" << l3->get_id(););
  44      if (m_params.m_bb_ext_gates) {

  79  void bit_blaster_cfg::mk_carry(expr * l1, expr * l2, expr * l3, expr_ref & r) {
  80:     TRACE("carry", tout << "#" << l1->get_id() << " #" << l2->get_id() << " #" << l3->get_id(););
  81      sort_args(l1, l2, l3);
  82:     TRACE("carry_sorted", tout << "#" << l1->get_id() << " #" << l2->get_id() << " #" << l3->get_id(););
  83      if (m_params.m_bb_ext_gates) {

z3/src/ast/simplifiers/euf_completion.cpp:
  102              }
  103:             CTRACE("euf_completion", g != f, tout << mk_bounded_pp(f, m) << " -> " << mk_bounded_pp(g, m) << "\n");
  104          }

  264  
  265:             TRACE("euf_completion", tout << "rep " << m_egraph.bpp(n) << " -> " << m_egraph.bpp(rep) << "\n";
  266                           for (enode* k : enode_class(n)) tout << m_egraph.bpp(k) << "\n";);

z3/src/ast/simplifiers/solve_context_eqs.cpp:
  186          eqs.shrink(j);
  187:         TRACE("solve_eqs",
  188                for (auto const& eq : eqs)

z3/src/ast/simplifiers/solve_eqs.cpp:
  142  
  143:         TRACE("solve_eqs",
  144              tout << "after normalizing variables\n";

z3/src/ast/substitution/substitution_tree.cpp:
  108  void substitution_tree::process_args(app * in, app * out) {
  109:     CTRACE("subst_tree_bug", in->get_num_args() != out->get_num_args(), tout << mk_ismt2_pp(in, m_manager) << "\n" 
  110             << mk_ismt2_pp(out, m_manager) << "\n";);

  624      while (!m_bstack.empty()) {
  625:         TRACE("st", tout << "backtracking...\n";);
  626          m_subst->pop_scope();

  638  inline expr_offset substitution_tree::find(expr_offset p) {
  639:     TRACE("substitution_tree_bug", tout << "find...\n";);
  640      while (is_var(p.get_expr())) {
  641:         TRACE("substitution_tree_bug", tout << mk_pp(p.get_expr(), m_manager) << " " << p.get_offset() << "\n";);
  642          if (!m_subst->find(to_var(p.get_expr()), p.get_offset(), p))

  649  bool substitution_tree::bind_var(var * v, unsigned offset, expr_offset const & p) {
  650:     TRACE("st", tout << "bind_var: " << mk_pp(v, m_manager) << " " << offset << "\n" << 
  651            mk_pp(p.get_expr(), m_manager) << " " << p.get_offset() << "\n";);

  668      m_subst->insert(v, offset, p);
  669:     TRACE("st_bug", tout << "substitution updated\n"; m_subst->display(tout););
  670      return true;

  689              bool v2 = is_var(n2);
  690:             TRACE("st", 
  691                    tout << "n1: " << mk_pp(n1, m_manager) << " " << p1.get_offset() << "\n";

  760          subst const & s = *it;
  761:         TRACE("st", tout << "processing subst:\n"; display(tout, s); tout << "\n";);
  762          var *  rin  = s.first;

  780          node * n = m_bstack.back();
  781:         TRACE("st", tout << "push scope...\n";);
  782          m_subst->push_scope();
  783:         TRACE("st", tout << "processing node:\n"; display(tout, n->m_subst); tout << "\n";);
  784          if (visit<Mode>(n->m_subst)) {

  791                  else {
  792:                     TRACE("st_bug", tout << "found match:\n"; m_subst->display(tout); tout << "m_subst: " << m_subst << "\n";);
  793                      if (!st(n->m_expr)) {

z3/src/ast/substitution/substitution.cpp:
   41  void substitution::reset_cache() {
   42:     TRACE("subst_bug", tout << "substitution::reset_cache\n";
   43            for (unsigned i = 0; i < m_new_exprs.size(); i++) { tout << mk_pp(m_new_exprs.get(i), m_manager) << "\nref_count: " << m_new_exprs.get(i)->get_ref_count() << "\n"; });

   76      
   77:     TRACE("subst_bug", tout << "BEGIN substitution::apply\n";);
   78  

   97          expr_offset n = m_todo.back();
   98:         TRACE("subst_bug", tout << "n: " << mk_pp(n.get_expr(), m_manager) << " : " << n.get_offset() << "\n";);
   99          if (m_apply_cache.contains(n)) {

  103          expr_offset n_prime = n == s ? t : n;
  104:         TRACE("subst_bug", tout << "n_prime: " << mk_pp(n_prime.get_expr(), m_manager) << " : " << n_prime.get_offset() << "\n";);
  105          visited = true;

  111                  apply_visit(n1, visited);
  112:                 TRACE("subst_bug", tout << "visited: " << visited << ", n1: " << mk_pp(n1.get_expr(), m_manager) << " : " << n1.get_offset() << "\n";);
  113                  if (visited) {

  117                      m_apply_cache.insert(n, new_expr);
  118:                     TRACE("subst_bug", tout << "1. insert n: " << mk_pp(n.get_expr(), m_manager) << " : " << n.get_offset() 
  119                            << " --> " << mk_pp(new_expr, m_manager) << "\n";);

  131                  m_apply_cache.insert(n, new_expr);
  132:                 TRACE("subst_bug", tout << "2. insert n: " << mk_pp(n.get_expr(), m_manager) << " : " << n.get_offset() 
  133                        << " --> " << mk_pp(new_expr, m_manager) << "\n";);

  157                      m_apply_cache.insert(n, e);
  158:                     TRACE("subst_bug", tout << "3. insert n: " << mk_pp(n.get_expr(), m_manager) << " : " << n.get_offset() 
  159                            << " --> " << mk_pp(e, m_manager) << "\n";);

  164                      m_apply_cache.insert(n, new_expr);
  165:                     TRACE("subst_bug", tout << "3. insert n: " << mk_pp(n.get_expr(), m_manager) << " : " << n.get_offset() 
  166                            << " --> " << mk_pp(new_expr, m_manager) << "\n";);

  223      
  224:     TRACE("subst_bug", tout << "END substitution::apply\nresult:\n" << mk_pp(e, m_manager) << "\nref_count: " << e->get_ref_count() << "\n";);
  225  }

z3/src/ast/substitution/substitution.h:
  134      void insert(unsigned v_idx, unsigned offset, expr_offset const & t) {
  135:         TRACE("subst_insert", tout << "inserting: #" << v_idx << ":" << offset << " --> " << mk_pp(t.get_expr(), m_manager)
  136                << ":" << t.get_offset() << "\n";);

z3/src/ast/substitution/unifier.cpp:
  147  #if 1
  148:     TRACE("unifier", for (unsigned i = 0; i < num_exprs; ++i) tout << mk_pp(es[i], m_manager) << "\n";);
  149      for (unsigned i = s.get_num_bindings(); i > 0; ) {

  153          s.get_binding(i, bound, root);
  154:         TRACE("unifier", tout << bound.first << " |-> " << mk_pp(root.get_expr(), m_manager) << "\n";);
  155          if (is_var(root.get_expr())) {

z3/src/cmd_context/cmd_context.cpp:
    61  void func_decls::finalize(ast_manager & m) {
    62:     TRACE("cmd_context_detail", tout << "finalizing func_decls...\n";);
    63      if (GET_TAG(m_decls) == 0) {

    66      else {
    67:         TRACE("func_decls", tout << "finalize...\n";);
    68          func_decl_set * fs = UNTAG(func_decl_set *, m_decls);
    69          for (func_decl * f : *fs) {
    70:             TRACE("func_decls", tout << "dec_ref of " << f->get_name() << " ref_count: " << f->get_ref_count() << "\n";);
    71              m.dec_ref(f);

   788      if (!has_logic() && new_manager) {
   789:         TRACE("cmd_context", tout << "init manager " << m_logic << "\n";);
   790          // add list type only if the logic is not specified.

   830  bool cmd_context::set_logic(symbol const & s) {
   831:     TRACE("cmd_context", tout << s << "\n";);
   832      if (has_logic())

   880      if (s != f->get_name()) {
   881:         TRACE("func_decl_alias", tout << "adding alias for: " << f->get_name() << ", alias: " << s << "\n";);
   882          m_func_decl2alias.insert(f, s);

   886      }
   887:     TRACE("cmd_context", tout << "new function decl\n" << mk_pp(f, m()) << "\n";);
   888  }

   900      }
   901:     TRACE("cmd_context", tout << "new sort decl\n"; p->display(tout); tout << "\n";);
   902  }

   916      }
   917:     TRACE("insert_macro", tout << "new macro " << arity << "\n" << mk_pp(t, m()) << "\n";);
   918      insert_macro(s, arity, domain, t);

   991  
   992:     TRACE("recfun", tout<< "define recfun " << f->get_name()  << " = " << mk_pp(rhs, m()) << "\n";);
   993  

  1179      if (macros_find(s, num_args, args, coerced_args, _t)) {
  1180:         TRACE("macro_bug", tout << "well_sorted_check_enabled(): " << well_sorted_check_enabled() << "\n";
  1181                tout << "s: " << s << "\n";

  1651      init_manager();
  1652:     TRACE("before_check_sat", dump_assertions(tout););
  1653      unsigned timeout = m_params.m_timeout;

  2027                  evaluator(a, r);
  2028:                 TRACE("model_validate", tout << "checking\n" << mk_ismt2_pp(a, m()) << "\nresult: " << mk_ismt2_pp(r, m()) << "\n";);
  2029                  if (m().is_true(r))

  2031  
  2032:                 TRACE("model_validate", tout << *md << "\n";);
  2033  

  2051                  IF_VERBOSE(11, model_smt2_pp(verbose_stream(), *this, *md, 0););                
  2052:                 TRACE("model_validate", model_smt2_pp(tout, *this, *md, 0););
  2053                  invalid_model |= m().is_false(r);

  2255  format_ns::format * cmd_context::pp(sort * s) const {
  2256:     TRACE("cmd_context", tout << "pp(sort * s), s: " << mk_pp(s, m()) << "\n";);
  2257      return pm().pp(s);

  2363  void cmd_context::dt_eh::operator()(sort * dt, pdecl* pd) {
  2364:     TRACE("new_dt_eh", tout << "new datatype: "; m_owner.pm().display(tout, dt); tout << "\n";);
  2365      for (func_decl * c : *m_dt_util.get_datatype_constructors(dt)) {
  2366:         TRACE("new_dt_eh", tout << "new constructor: " << c->get_name() << "\n";);
  2367          m_owner.insert(c);

  2369          m_owner.insert(r);
  2370:         // TRACE("new_dt_eh", tout << "new recognizer: " << r->get_name() << "\n";);
  2371          for (func_decl * a : *m_dt_util.get_constructor_accessors(c)) {
  2372:             TRACE("new_dt_eh", tout << "new accessor: " << a->get_name() << "\n";);
  2373              m_owner.insert(a);

z3/src/cmd_context/pdecl.cpp:
  446  bool paccessor_decl::fix_missing_refs(dictionary<int> const & symbol2idx, symbol & missing) {
  447:     TRACE("fix_missing_refs", tout << "m_type.kind(): " << (int)m_type.kind() << "\n";
  448            if (m_type.kind() == ptype_kind::PTR_MISSING_REF) tout << m_type.get_missing_ref() << "\n";);

  484      m.inc_ref(num_accessors, accessors);
  485:     TRACE("pconstructor_decl", tout << "name: " << n << ", recognizer: " << r << "\n";);
  486  }

  631  bool pdatatype_decl::commit(pdecl_manager& m) {
  632:     TRACE("datatype", tout << m_name << "\n";);
  633      sort_ref_vector ps(m.m());

  665  bool pdatatypes_decl::fix_missing_refs(symbol & missing) {
  666:     TRACE("fix_missing_refs", tout << "pdatatypes_decl::fix_missing_refs\n";);
  667      dictionary<int> symbol2idx;

  677  sort* pdecl_manager::instantiate_datatype(psort_decl* p, symbol const& name, unsigned n, sort * const* s) {
  678:     TRACE("datatype", tout << name << " "; for (unsigned i = 0; i < n; ++i) tout << s[i]->get_name() << " "; tout << "\n";);
  679  

  896          del_decl_core(kv.m_value);
  897:         TRACE("pdecl_manager", tout << "orphan: " << mk_pp(kv.m_key, m()) << "\n";);
  898      }

  940  pdatatype_decl * pdecl_manager::mk_pdatatype_decl(unsigned num_params, symbol const & s, unsigned num, pconstructor_decl * const * cs) {
  941:     TRACE("datatype", tout << s << " has " << num_params << " parameters\n";);
  942      return new (a().allocate(sizeof(pdatatype_decl))) pdatatype_decl(m_id_gen.mk(), num_params, *this,

  983  void pdecl_manager::del_decl_core(pdecl * p) {
  984:     TRACE("pdecl_manager",
  985            tout << "del_decl_core:\n";

  996  void pdecl_manager::del_decl(pdecl * p) {
  997:     TRACE("pdecl_manager", tout << "del psort "; p->display(tout); tout << "\n";);
  998      if (p->is_psort()) {

z3/src/cmd_context/tactic_cmds.cpp:
  198          assert_exprs_from(ctx, *g);
  199:         TRACE("check_sat_using", g->display(tout););
  200          model_ref           md;

z3/src/math/automata/automaton.h:
  353          SASSERT(!m_delta.empty());
  354:         TRACE("seq", display(tout););
  355          for (unsigned i = 0; i < m_delta.size(); ++i) {

  445                      else {
  446:                         TRACE("seq", tout << "epsilon not removed " << out_degree(src) << " " << is_final_state(src) << " " << is_final_state(dst) << "\n";);
  447                          continue;

  466          sinkify_dead_states();
  467:         TRACE("seq", display(tout););
  468      }

  626          }
  627:         TRACE("seq", tout << "remove: " << dead_states << "\n"; 
  628                tout << "final: " << m_final_states << "\n";

  630          for (unsigned s : dead_states) {
  631:             CTRACE("seq", !m_delta[s].empty(), tout << "live state " << s << "\n";); 
  632              m_delta[s].reset();

z3/src/math/automata/symbolic_automata_def.h:
  299  
  300:     TRACE("seq", tout << "mk-deterministic " << flip_acceptance << " " << set << " " << a.is_final_configuration(set) << "\n";);    
  301      // adds non-final states of a to final if flipping and final otherwise

  349              if (is_new) {
  350:                 TRACE("seq", tout << "mk-deterministic " << flip_acceptance << " " << set << " " << a.is_final_configuration(set) << "\n";);    
  351                  if (a.is_final_configuration(set) != flip_acceptance) {

z3/src/math/dd/dd_bdd.cpp:
  307      go_up:
  308:         TRACE("bdd", tout << "sift up " << lvl << "\n";);
  309          while (lvl < max_lvl) {

  328      go_down:
  329:         TRACE("bdd", tout << "sift down " << lvl << "\n";);
  330          while (lvl > 0) {

  372              }
  373:             TRACE("bdd", tout << "remove " << n << "\n";);
  374              m_node_table.remove(m_nodes[n]);

  386              else {
  387:                 TRACE("bdd", tout << "set level " << n << " to " << lvl + 1 << "\n";);
  388                  m_node_table.insert(node);

  437              reorder_incref(bd);
  438:             TRACE("bdd", tout << "transform " << n << " " << " " << a << " " << b << " " << c << " " << d << " " << ac << " " << bd << "\n";);
  439              m_node_table.insert(m_nodes[n]);

  469          }
  470:         TRACE("bdd", tout << "sift " << lvl << "\n"; display(tout); );
  471          DEBUG_CODE(

  478          
  479:         TRACE("bdd", 
  480                for (unsigned i = 0; i < m_nodes.size(); ++i) {

  505          }
  506:         TRACE("bdd",
  507                display(tout);

z3/src/math/grobner/grobner.cpp:
  429  void grobner::merge_monomials(ptr_vector<monomial> & monomials) {
  430:     TRACE("grobner", tout << "before merging monomials:\n"; display_monomials(tout, monomials.size(), monomials.data()); tout << "\n";);
  431      unsigned j  = 0;

  461      del_monomials(to_delete);    
  462:     TRACE("grobner", tout << "after merging monomials:\n"; display_monomials(tout, monomials.size(), monomials.data()); tout << "\n";);
  463  }

  529                      rest.push_back(m2->m_vars[i2]);
  530:                 TRACE("grobner", 
  531                        tout << "monomial: "; display_monomial(tout, *m1); tout << " is a subset of "; 

  554      // is not subset
  555:     TRACE("grobner", tout << "monomial: "; display_monomial(tout, *m1); tout << " is not a subset of "; 
  556            display_monomial(tout, *m2); tout << "\n";);

  610  grobner::equation * grobner::simplify(equation const * source, equation * target) {
  611:     TRACE("grobner", tout << "simplifying: "; display_equation(tout, *target); tout << "using: "; display_equation(tout, *source););
  612      if (source->get_num_monomials() == 0)

  662      while (simplified && m_manager.inc());
  663:     TRACE("grobner", tout << "result: "; display_equation(tout, *target););
  664      return result ? target : nullptr;

  675      bool simplified;
  676:     TRACE("grobner", tout << "simplifying: "; display_equation(tout, *eq); tout << "using already processed equalities\n";);
  677      do {

  691      while (simplified);
  692:     TRACE("grobner", tout << "simplification result: "; display_equation(tout, *eq););
  693      return result ? eq : nullptr;

  728          m_to_process.erase(r);
  729:     TRACE("grobner", tout << "selected equation: "; if (!r) tout << "<null>\n"; else display_equation(tout, *r););
  730      return r;

  808  bool grobner::unify(monomial const * m1, monomial const * m2, ptr_vector<expr> & rest1, ptr_vector<expr> & rest2) {
  809:     TRACE("grobner", tout << "unifying: "; display_monomial(tout, *m1); tout << " "; display_monomial(tout, *m2); tout << "\n";);
  810      bool found_M = false;

  861      if (unify(eq1->m_monomials[0], eq2->m_monomials[0], rest1, rest2)) {
  862:         TRACE("grobner", tout << "superposing:\n"; display_equation(tout, *eq1); display_equation(tout, *eq2); 
  863                tout << "rest1: "; display_vars(tout, rest1.size(), rest1.data()); tout << "\n";

  871          simplify(new_monomials);
  872:         TRACE("grobner", tout << "resulting monomials: "; display_monomials(tout, new_monomials.size(), new_monomials.data()); tout << "\n";);
  873          if (new_monomials.empty())

  918      simplify_to_process(eq);
  919:     TRACE("grobner", tout << "end of iteration:\n"; display(tout););
  920      return false;

z3/src/math/grobner/pdd_simplifier.cpp:
   73                  DEBUG_CODE(s.invariant(););
   74:                 TRACE("dd.solver", s.display(tout););
   75              }

   90      bool simplifier::simplify_linear_step(bool binary) {
   91:         TRACE("dd.solver", tout << "binary " << binary << "\n";);
   92          IF_VERBOSE(2, verbose_stream() << "binary " << binary << "\n");

  126              equation_vector const& uses = use_list[v];
  127:             TRACE("dd.solver", 
  128                    s.display(tout << "uses of: ", *src) << "\n";

  185      bool simplifier::simplify_cc_step() {
  186:         TRACE("dd.solver", tout << "cc\n";);
  187          IF_VERBOSE(2, verbose_stream() << "cc\n");

  218      bool simplifier::simplify_leaf_step() {
  219:         TRACE("dd.solver", tout << "leaf\n";);
  220          IF_VERBOSE(2, verbose_stream() << "leaf\n");

  263      bool simplifier::simplify_elim_pure_step() {
  264:         TRACE("dd.solver", tout << "pure\n";);
  265          IF_VERBOSE(2, verbose_stream() << "pure\n");

  439          unsigned max_degree = 5;
  440:         TRACE("dd.solver", tout << "augment " << nv << "\n";
  441                for (auto const& o : orbits) tout << o.num_elems() << "\n";);

  488          eqs.append(n_eqs);
  489:         TRACE("dd.solver", for (pdd const& p : eqs) tout << p << "\n";);
  490      }

  583  
  584:         TRACE("dd.solver", tout << bm << "\n";);
  585          IF_VERBOSE(10, verbose_stream() << "bit-matrix solving\n");

  588  
  589:         TRACE("dd.solver", tout << bm << "\n";);
  590          IF_VERBOSE(10, verbose_stream() << "bit-matrix solved\n");

  616                  if (!p.is_zero()) {
  617:                     TRACE("dd.solver", tout << "new linear: " << p << "\n";);
  618                      simp_eqs.push_back(p);

z3/src/math/grobner/pdd_solver.cpp:
   96          init_saturate();
   97:         TRACE("dd.solver", display(tout););
   98          try {
   99              while (!done() && step()) {
  100:                 TRACE("dd.solver", display(tout););
  101                  DEBUG_CODE(invariant(););

  164  
  165:         TRACE("dd.solver", display(tout << "simplification result: ", eq););
  166      }

  238          }
  239:         TRACE("dd.solver", 
  240                tout << "reduce: " << dst.poly() << "\n";

  255          changed_leading_term = dst.state() == processed && m.different_leading_term(r, dst.poly());
  256:         TRACE("dd.solver", 
  257                tout << "reduce: " << dst.poly() << "\n";

  270      void solver::superpose(equation const& eq1, equation const& eq2) {
  271:         TRACE("dd.solver_d", display(tout << "eq1=", eq1); display(tout << "eq2=", eq2););
  272          pdd r(m);

  297          if (done()) return false;
  298:         TRACE("dd.solver", display(tout << "eq = ", eq););
  299          superpose(eq);

z3/src/math/hilbert/hilbert_basis.cpp:
   837      int_table support;
   838:     TRACE("hilbert_basis", display_ineq(tout, ineq, is_eq););
   839      iterator it = begin();

   851      }
   852:     TRACE("hilbert_basis", display(tout););
   853      // resolve passive into active

   859          offset_t idx = m_passive->pop();
   860:         TRACE("hilbert_basis", display(tout););
   861          if (is_subsumed(idx)) {

   890      m_zero.reset();
   891:     TRACE("hilbert_basis", display(tout););
   892      return m_basis.empty()?l_false:l_true;

   910      m_sos.reset();
   911:     TRACE("hilbert_basis", display_ineq(tout, ineq, is_eq););
   912      unsigned init_basis_size = 0;

   941  
   942:     TRACE("hilbert_basis", display(tout););
   943      // resolve passive into active

   946          offset_t sos, pas;
   947:         TRACE("hilbert_basis", display(tout); );
   948          unsigned offset = m_passive2->pop(sos, pas);

   982      m_zero.reset();
   983:     TRACE("hilbert_basis", display(tout););
   984      return m_basis.empty()?l_false:l_true;

  1091      }
  1092:     TRACE("hilbert_basis_verbose",
  1093            display(tout, i); 

  1119  bool hilbert_basis::add_goal(offset_t idx) {
  1120:     TRACE("hilbert_basis", display(tout, idx););
  1121      values v = vec(idx);

  1312      }
  1313:     CTRACE("hilbert_basis", r, 
  1314             display(tout, i);

z3/src/math/interval/dep_intervals.h:
  218          }
  219:         TRACE("dep_intervals", tout << "power of "; display(tout, a) << " = ";
  220                display(tout, b) << "\n"; );

  313          }
  314:         TRACE("dep_intervals", display(tout, i););
  315          dep = m_dep_manager.mk_join(dep, i.m_lower_dep);

  324              return false;
  325:         TRACE("dep_intervals", display(tout, i););
  326          dep = m_dep_manager.mk_join(dep, i.m_upper_dep);

z3/src/math/interval/interval_def.h:
   202      nth_root_pos(A, n, p, lo, hi);
   203:     STRACE("nth_root_trace",
   204             tout << "[nth-root] ("; m().display(tout, A); tout << ")^(1/" << n << ") >= "; m().display(tout, lo); tout << "\n";

   311              m().abs(d);
   312:             TRACE("nth_root",
   313                    tout << "A:       "; m().display(tout, A); tout << "\n";

   340          A_div_x_n(A, hi, n-1, true /* lo will be greater than the actual lower bound */, lo);
   341:         TRACE("nth_root_bug",
   342                tout << "Assuming upper\n";

   389          m().mul(aux, o, o);
   390:         TRACE("fact_bug", tout << "i: " << i << ", o: " << m().to_rational_string(o) << "\n";);
   391      }

   409      for (unsigned i = 3; i <= k; i+=2) {
   410:         TRACE("sine_bug", tout << "[begin-loop] o: " << m().to_rational_string(o) << "\ni: " << i << "\n";
   411                tout << "upper: " << upper << ", upper_factor: " << upper_factor << "\n";

   414          m().power(a, i, f);
   415:         TRACE("sine_bug", tout << "a^i " << m().to_rational_string(f) << "\n";);
   416          set_rounding(!upper_factor);
   417          fact(i, aux);
   418:         TRACE("sine_bug", tout << "i! " << m().to_rational_string(aux) << "\n";);
   419          set_rounding(upper_factor);
   420          m().div(f, aux, f);
   421:         TRACE("sine_bug", tout << "a^i/i! " << m().to_rational_string(f) << "\n";);
   422          set_rounding(upper);

   426              m().add(o, f, o);
   427:         TRACE("sine_bug", tout << "o: " << m().to_rational_string(o) << "\n";);
   428          sign         = !sign;

   434  void interval_manager<C>::sine(numeral const & a, unsigned k, numeral & lo, numeral & hi) {
   435:     TRACE("sine", tout << "sine(a), a: " << m().to_rational_string(a) << "\na: " << m().to_string(a) << "\n";);
   436      SASSERT(&lo != &hi);

   458      m().power(error, k+1, error);
   459:     TRACE("sine", tout << "a^(k+1): " << m().to_rational_string(error) << "\nk : " << k << "\n";);
   460      round_to_minus_inf();
   461      fact(k+1, aux);
   462:     TRACE("sine", tout << "(k+1)!: " << m().to_rational_string(aux) << "\n";);
   463      round_to_plus_inf();
   464      m().div(error, aux, error);
   465:     TRACE("sine", tout << "error: " << m().to_rational_string(error) << "\n";);
   466  

   482          // We must recompute the series with rounding to +oo
   483:         TRACE("sine", tout << "lo before -error: " << m().to_rational_string(lo) << "\n";);
   484          round_to_minus_inf();
   485          m().sub(lo, error, lo);
   486:         TRACE("sine", tout << "lo: " << m().to_rational_string(lo) << "\n";);
   487          if (m().lt(lo, m_minus_one)) {

   494          m().add(hi, error, hi);
   495:         TRACE("sine", tout << "hi: " << m().to_rational_string(hi) << "\n";);
   496      }

   533  void interval_manager<C>::cosine(numeral const & a, unsigned k, numeral & lo, numeral & hi) {
   534:     TRACE("cosine", tout << "cosine(a): "; m().display_decimal(tout, a, 32); tout << "\n";);
   535      SASSERT(&lo != &hi);

   561      m().div(error, aux, error);
   562:     TRACE("sine", tout << "error: "; m().display_decimal(tout, error, 32); tout << "\n";);
   563  

  1051              // a <= x <= b <= 0, c <= y <= d <= 0 --> x*y <= a*c  (we can use the fact that x or y is always negative (i.e., b is neg or d is neg))
  1052:             TRACE("interval_bug", tout << "(N, N) #" << call_id << "\n"; display(tout, i1); tout << "\n"; display(tout, i2); tout << "\n";
  1053                    tout << "a: "; m().display(tout, a); tout << "\n";

  1071              // a <= x <= b <= 0,  c <= y, c < 0 --> x*y <= a*c (uses the fact that b is not positive)
  1072:             TRACE("interval_bug", tout << "(N, M) #" << call_id << "\n";);
  1073  

  1084              // x <= b <= 0,  0 <= c <= y --> x*y <= b*c
  1085:             TRACE("interval_bug", tout << "(N, P) #" << call_id << "\n";);
  1086              SASSERT(is_P(i2));

  1101              // a < 0, a <= x,  c <= y <= d <= 0 --> x*y <= a*c (uses the fact that d is not positive)
  1102:             TRACE("interval_bug", tout << "(M, N) #" << call_id << "\n";);
  1103  

  1155              // b > 0, x <= b, 0 <= c <= y <= d --> x*y <= b*d (uses the fact that c is not negative)
  1156:             TRACE("interval_bug", tout << "(M, P) #" << call_id << "\n";);
  1157              SASSERT(is_P(i2));

  1172              // 0 <= a <= x,  y <= d <= 0  --> a*d <= x*y
  1173:             TRACE("interval_bug", tout << "(P, N) #" << call_id << "\n";);
  1174  

  1186              // 0 <= a <= x <= b,  y <= d --> x*y <= b*d (uses the fact that a is not negative)
  1187:             TRACE("interval_bug", tout << "(P, M) #" << call_id << "\n";);
  1188  

  1200              // x <= b, y <= d --> x*y <= b*d (uses the fact that x is pos (a is not negative) or y is pos (c is not negative))
  1201:             TRACE("interval_bug", tout << "(P, P) #" << call_id << "\n";);
  1202  

  1217      SASSERT(!(i1_contains_zero || i2_contains_zero) || contains_zero(r));
  1218:     TRACE("interval_bug", tout << "result: "; display(tout, r); tout << "\n";);
  1219  #ifdef _TRACE

  1338              // we need both bounds to justify upper bound
  1339:             TRACE("interval_bug", tout << "(M) #" << call_id << "\n"; display(tout, a); tout << "\nn:" << n << "\n";);
  1340  

  1385      }
  1386:     TRACE("interval_bug", tout << "result: "; display(tout, b); tout << "\n";);
  1387  #ifdef _TRACE

  1434      }
  1435:     TRACE("interval_nth_root", display(tout, a); tout << " --> "; display(tout, b); tout << "\n";);
  1436  }

  1466              // result is open if upper(y) is open and lo == hi
  1467:             TRACE("interval_xn_eq_y", tout << "x^n = "; display(tout, y); tout << "\n";
  1468                    tout << "sqrt(y) in "; m().display(tout, lo); tout << " "; m().display(tout, hi); tout << "\n";);

  1477              m().neg(lower(x));
  1478:             TRACE("interval_xn_eq_y", tout << "interval for x: "; display(tout, x); tout << "\n";);
  1479          }

  1529      SASSERT(!contains_zero(a));
  1530:     TRACE("interval_bug", tout << "(inv) #" << call_id << "\n"; display(tout, a); tout << "\n";);
  1531  

  1596      }
  1597:     TRACE("interval_bug", tout << "result: "; display(tout, b); tout << "\n";);
  1598  #ifdef _TRACE

  1678      if (is_zero(i1)) {
  1679:         TRACE("interval_bug", tout << "div #" << call_id << "\n"; display(tout, i1); tout << "\n"; display(tout, i2); tout << "\n";);
  1680  

  1703  
  1704:         TRACE("interval_bug", tout << "div #" << call_id << "\n"; display(tout, i1); tout << "\n"; display(tout, i2); tout << "\n";
  1705                tout << "a: "; m().display(tout, a); tout << "\n";

  1714                  // a <= x <= b <= 0,      y <= d < 0 -->        x/y <= a/d
  1715:                 TRACE("interval_bug", tout << "(N, N) #" << call_id << "\n";);
  1716  

  1734                  // x <= b <= 0,     0 < c <= y <= d  -->         x/y <= b/d
  1735:                 TRACE("interval_bug", tout << "(N, P) #" << call_id << "\n";);
  1736                  SASSERT(is_P1(i2));

  1757                  // 0 < a <= x <= b < 0,  y <= d < 0   -->        x/y <= a/d
  1758:                 TRACE("interval_bug", tout << "(M, N) #" << call_id << "\n";);
  1759  

  1773                      ::div(m(), a, a_k, d, d_k, new_u_val, new_u_kind);
  1774:                     TRACE("interval_bug", tout << "new_l_kind: " << new_l_kind << ", new_u_kind: " << new_u_kind << "\n";);
  1775                  }

  1780  
  1781:                 TRACE("interval_bug", tout << "(M, P) #" << call_id << "\n";);
  1782                  SASSERT(is_P1(i2));

  1805                  // 0 <= a <= x,        c <= y <= d < 0    -->         x/y  <= a/c
  1806:                 TRACE("interval_bug", tout << "(P, N) #" << call_id << "\n";);
  1807  

  1826                  // b > 0     x <= b, 0 < c <= y         -->          x/y <= b/c
  1827:                 TRACE("interval_bug", tout << "(P, P) #" << call_id << "\n";);
  1828  

  1850      }
  1851:     TRACE("interval_bug", tout << "result: "; display(tout, r); tout << "\n";);
  1852  #ifdef _TRACE

z3/src/math/lp/cross_nested.h:
   60      void run(nex *e) {
   61:         TRACE("nla_cn", tout << *e << "\n";);
   62          SASSERT(m_nex_creator.is_simplified(*e));

   65          m_e_clone = m_nex_creator.clone(m_e);
   66:         TRACE("nla_cn", tout << "m_e_clone = " <<  * m_e_clone << "\n";);
   67          

   74          nex** c = front.back();
   75:         TRACE("nla_cn", tout <<  **c << "\n";);
   76          front.pop_back();

   82          nex_sum* c = to_sum(e);
   83:         TRACE("nla_cn", tout << "c=" << *c << "\n"; tout << "occs:"; dump_occurences(tout, m_nex_creator.occurences_map()) << "\n";);
   84          unsigned size = c->size();

  102      static bool has_common_factor(const nex_sum* c) {
  103:         TRACE("nla_cn", tout << "c=" << *c << "\n";);
  104          auto & ch = *c;

  112              if (divides_the_rest) {
  113:                 TRACE("nla_cn_common_factor", tout << c << "\n";);
  114                  return true;

  120      bool proceed_with_common_factor(nex** c, vector<nex**>& front) {
  121:         TRACE("nla_cn", tout << "c=" << **c << "\n";);
  122          nex* f = extract_common_factor(*c);
  123          if (f == nullptr) {
  124:             TRACE("nla_cn", tout << "no common factor\n"; );
  125              return false;
  126          }
  127:         TRACE("nla_cn", tout << "common factor f=" << *f << "\n";);
  128          

  130          c_over_f = m_nex_creator.simplify(c_over_f);
  131:         TRACE("nla_cn", tout << "c_over_f = " << *c_over_f << std::endl;);
  132          nex_mul* cm; 
  133          *c = cm = m_nex_creator.mk_mul(f, c_over_f);
  134:         TRACE("nla_cn", tout << "common factor=" << *f << ", c=" << **c << "\ne = " << *m_e << "\n";);
  135          explore_expr_on_front_elem((*cm)[1].ee(),  front);

  139      static void push_to_front(vector<nex**>& front, nex** e) {
  140:         TRACE("nla_cn", tout << **e << "\n";);
  141          front.push_back(e);

  161      void explore_expr_on_front_elem_vars(nex** c, vector<nex**>& front, const svector<lpvar> & vars) {
  162:         TRACE("nla_cn", tout << "save c=" << **c << "; front:"; print_front(front, tout) << "\n";);           
  163          nex* copy_of_c = *c;

  175                  return;
  176:             TRACE("nla_cn", tout << "before restore c=" << **c << "\nm_e=" << *m_e << "\n";);
  177              *c = copy_of_c;

  179              pop_allocated(alloc_size);
  180:             TRACE("nla_cn", tout << "after restore c=" << **c << "\nm_e=" << *m_e << "\n";);   
  181          }

  204          remove_singular_occurences();
  205:         TRACE("nla_cn_details", tout << "e=" << *e << "\noccs="; dump_occurences(tout, m_nex_creator.occurences_map()) << "\n";);
  206      }

  212          m_random_bit = m_random() % 2;
  213:         TRACE("nla_cn", tout << "m_random_bit = " << m_random_bit << "\n";);
  214          std::sort(vars.begin(), vars.end(), [this](lpvar j, lpvar k)

  249  
  250:         TRACE("nla_cn", tout << "m_e=" << *m_e << "\nc=" << **c << ", c vars=";
  251                print_vector(vars, tout) << "; front:"; print_front(front, tout) << "\n";);

  254              if (front.empty()) {
  255:                 TRACE("nla_cn", tout << "got the cn form: =" << *m_e << "\n";);
  256                  m_done = m_call_on_result(m_e) || ++m_reported > 100;
  257   #ifdef Z3DEBUG
  258:                 TRACE("nla_cn", tout << "m_e_clone " << *m_e_clone << "\n";);
  259                  SASSERT(nex_creator::equal(m_e, m_e_clone));

  278      void explore_of_expr_on_sum_and_var(nex** c, lpvar j, vector<nex**> front) {
  279:         TRACE("nla_cn", tout << "m_e=" << *m_e << "\nc=" << **c << "\nj = " << nex_creator::ch(j) << "\nfront="; print_front(front, tout) << "\n";);
  280          if (!split_with_var(*c, j, front))
  281              return;
  282:         TRACE("nla_cn", tout << "after split c=" << **c << "\nfront="; print_front(front, tout) << "\n";);
  283          if (front.empty()) {
  284  #ifdef Z3DEBUG
  285:             TRACE("nla_cn", tout << "got the cn form: =" << *m_e <<  ", clone = " << *m_e_clone << "\n";);
  286  #endif

  318          }
  319:         TRACE("nla_cn_details", tout << "occs="; dump_occurences(tout, m_nex_creator.occurences_map()) << "\n";);
  320      }    

  350          remove_singular_occurences();
  351:         TRACE("nla_cn_details", tout << "e=" << *e << "\noccs="; dump_occurences(tout, m_nex_creator.occurences_map()) << "\n";);
  352          vector<std::pair<lpvar, occ>> ret;

  375      void pre_split(nex_sum * e, lpvar j, nex_sum const*& a, nex const*& b) {
  376:         TRACE("nla_cn_details", tout << "e = " << * e << ", j = " << m_nex_creator.ch(j) << std::endl;);
  377          SASSERT(m_nex_creator.is_simplified(*e));

  380          for (nex const* ce: *e) {
  381:             TRACE("nla_cn_details", tout << "ce = " << *ce << "\n";);
  382              if (is_divisible_by_var(ce, j)) {

  388          a = sf.mk();
  389:         TRACE("nla_cn_details", tout << "a = " << *a << "\n";);
  390          SASSERT(a->size() >= 2 && m_b_split_vec.size());

  394              b = m_b_split_vec[0];
  395:             TRACE("nla_cn_details", tout << "b = " << *b << "\n";);
  396          } else {

  398              b = m_nex_creator.mk_sum(m_b_split_vec);
  399:             TRACE("nla_cn_details", tout << "b = " << *b << "\n";);
  400          }

  403      void update_front_with_split_with_non_empty_b(nex* &e, lpvar j, vector<nex**> & front, nex_sum const* a, nex const* b) {
  404:         TRACE("nla_cn_details", tout << "b = " << *b << "\n";);
  405          e = m_nex_creator.mk_sum(m_nex_creator.mk_mul(m_nex_creator.mk_var(j), a), b); // e = j*a + b

  428          SASSERT(e->is_sum());
  429:         TRACE("nla_cn", tout << "e = " << *e << ", j=" << nex_creator::ch(j) << "\n";);
  430          nex_sum const* a; nex const* b;

  460      nex * normalize_mul(nex_mul* a) {
  461:         TRACE("nla_cn", tout << *a << "\n";);
  462          NOT_IMPLEMENTED_YET();

z3/src/math/lp/emonics.cpp:
   39  void emonics::push() {
   40:     TRACE("nla_solver_mons", display(tout << "push\n"););
   41      SASSERT(invariant());

   50  void emonics::pop(unsigned n) {
   51:     TRACE("nla_solver_mons", tout << "pop: " << n << "\n";);
   52      SASSERT(invariant());

   57              monic & m = m_monics[i];
   58:             TRACE("nla_solver_mons", display(tout << m << "\n"););
   59              remove_cg_mon(m);

  132  
  133:     TRACE("nla_solver_mons", 
  134            display(tout << "other: ", other_head) << "\n";

  148      }
  149:     TRACE("nla_solver_mons", 
  150            display(tout << "other: ", other_head) << "\n";

  172  void emonics::remove_cg(lpvar v) {
  173:     TRACE("nla_solver_mons", tout << "remove: " << v << "\n";);
  174: //    TRACE("nla_solver_mons", display(tout););
  175      cell* c = m_use_lists[v].m_head;

  231          c = c->m_next;
  232:         TRACE("nla_solver_mons", tout << "inserting v" << v << " for " << idx << "\n";);
  233          monic & m = m_monics[idx];

  239      while (c != first);
  240:     TRACE("nla_solver_mons", tout << "insert: " << v << "\n";);    
  241  }

  263          (void)it;
  264:         CTRACE("nla_solver_mons",  it->second != c,
  265                 tout << "m = " << m << "\n";

  286      lpvar v = m.var(), w;
  287:     TRACE("nla_solver_mons", tout << m << "\n";); //  hash: " << m_cg_hash(v) << "\n";);
  288      auto& vec = m_cg_table.insert_if_not_there(v, unsigned_vector());

  299              m_u_f.mk_var();
  300:         TRACE("nla_solver_mons", tout << "merge " << v << " idx " << v_idx << ", and " << w << " idx " << w_idx << "\n";);
  301          m_u_f.merge(v_idx, w_idx);

  303      else {
  304:         TRACE("nla_solver_mons", tout << "found "  << v << "\n";);
  305      }

  324  void emonics::add(lpvar v, unsigned sz, lpvar const* vs) {
  325:     TRACE("nla_solver_mons", tout << "v = " << v << "\n";);
  326      SASSERT(m_ve.is_root(v));

  351  void emonics::do_canonize(monic & m) const {
  352:     TRACE("nla_solver_mons", tout << m << "\n";);
  353      m.reset_rfields();

  357      m.sort_rvars();
  358:     TRACE("nla_solver_mons", tout << m << "\n";);
  359  }

  435  void emonics::after_merge_eh(signed_var r2, signed_var r1, signed_var v2, signed_var v1) {
  436:     TRACE("nla_solver_mons", tout << v2 << " <- " << v1 << " : " << r2 << " <- " << r1 << "\n";);
  437      if (r1.var() == r2.var() || m_ve.find(~r1) == m_ve.find(~r2)) { // the other sign has also been merged
  438:         TRACE("nla_solver_mons", 
  439                display_uf(tout << r2 << " <- " << r1 << "\n");

  448      if (r1.var() == r2.var() || m_ve.find(~r1) != m_ve.find(~r2)) { // the other sign has also been unmerged
  449:         TRACE("nla_solver_mons", tout << r2 << " -> " << r1 << "\n";);
  450          unmerge_cells(m_use_lists[r2.var()], m_use_lists[r1.var()]);            

  519  bool emonics::invariant() const {
  520:     TRACE("nla_solver_mons", display(tout););
  521      // the variable index contains exactly the active monomials

  528      if (m_monics.size() != mons) {
  529:         TRACE("nla_solver_mons", tout << "missmatch of monic vars\n";);
  530          return false;

  546                  }
  547:                 CTRACE("nla_solver_mons", !found, tout << "not found v" << v << ": " << m << "\n";);
  548                  SASSERT(found);

  569          while (c != c0 && !found);
  570:         CTRACE("nla_solver_mons", !found, tout << "m" << idx << " not found in use list for v" << v << "\n";);
  571          return found;

  574      for (auto const& m : m_monics) {
  575:         CTRACE("nla_solver_mons", !m_cg_table.contains(m.var()), tout << "removed " << m << "\n"; );
  576          SASSERT(m_cg_table.contains(m.var()));

  580              if (!find_index(v, idx)) {
  581:                 TRACE("nla_solver_mons", tout << "rooted var not found in monic use list" << v << "\n";);
  582                  return false;

  593          if (!v.empty() && v[0] != k.m_key) {
  594:             TRACE("nla_solver_mons", tout << "bad table entry: " << k.m_key << ": " << k.m_value << "\n";);
  595              return false;

z3/src/math/lp/emonics.h:
  136      void unmerge_eh(unsigned i, unsigned j) {
  137:         TRACE("nla_solver", tout << "unmerged " << i << " and " << j << "\n";);
  138      }

z3/src/math/lp/gomory.cpp:
   58          lp_assert(is_int(j) && m_fj.is_pos());
   59:         TRACE("gomory_cut_detail", 
   60                tout << " k = " << m_k;

   81          m_lcm_den = lcm(m_lcm_den, denominator(new_a));
   82:         TRACE("gomory_cut_detail", tout << "new_a = " << new_a << ", k = " << m_k << ", lcm_den = " << m_lcm_den << "\n";);
   83  #if SMALL_CUTS

   90      void real_case_in_gomory_cut(const mpq & a, unsigned j) {
   91:         TRACE("gomory_cut_detail_real", tout << "j = " << j << ", a = " << a << ", m_k = " << m_k << "\n";);
   92          mpq new_a;

  115          m_t.add_monomial(new_a, j);
  116:         TRACE("gomory_cut_detail_real", tout << "add " << new_a << "*v" << j << ", k: " << m_k << "\n";
  117                tout << "m_t =  "; lia.lra.print_term(m_t, tout) << "\nk: " << m_k << "\n";);

  137          if (pol.size() == 1) {
  138:             TRACE("gomory_cut_detail", tout << "pol.size() is 1" << std::endl;);
  139              unsigned v = pol[0].second;

  157              lp_assert(m_lcm_den.is_pos());
  158:             TRACE("gomory_cut_detail", tout << "pol.size() > 1 den: " << m_lcm_den << std::endl;);
  159              if (!m_lcm_den.is_one()) {

  169          }
  170:         TRACE("gomory_cut_detail", tout << "k = " << m_k << std::endl;);
  171          lp_assert(m_k.is_int());

  282      lia_move cut() {
  283:         TRACE("gomory_cut", dump(tout););
  284          

  290          mpq m_f  = fractional_part(get_value(m_inf_col));
  291:         TRACE("gomory_cut_detail", tout << "m_f: " << m_f << ", ";
  292                tout << "1 - m_f: " << 1 - m_f << ", get_value(m_inf_col).x - m_f = " << get_value(m_inf_col).x - m_f << "\n";);

  308                  lp_assert(p.coeff() == one_of_type<mpq>());
  309:                 TRACE("gomory_cut_detail", tout << "seeing basic var\n";);
  310                  continue;

  339              adjust_term_and_k_for_some_ints_case_gomory();
  340:         TRACE("gomory_cut_detail", dump_cut_and_constraints_as_smt_lemma(tout););
  341          lp_assert(lia.current_solution_is_inf_on_cut());  // checks that indices are columns
  342:         TRACE("gomory_cut", print_linear_combination_of_column_indices_only(m_t.coeffs_as_vector(), tout << "gomory cut:"); tout << " <= " << m_k << std::endl;);
  343          return lia_move::cut;

  369          if (!lia.is_base(j) && (!lia.at_bound(j) || !is_zero(lia.get_value(j).y))) {
  370:             TRACE("gomory_cut", tout << "row is not gomory cut target:\n";
  371                    lia.display_column(tout, j);

z3/src/math/lp/hnf_cutter.cpp:
  261          lia.settings().stats().m_hnf_cutter_calls++;
  262:         TRACE("hnf_cut", tout << "settings().stats().m_hnf_cutter_calls = " << lia.settings().stats().m_hnf_cutter_calls << "\n";
  263                for (unsigned i : constraints_for_explanation()) {

  277          if (r == lia_move::cut) {      
  278:             TRACE("hnf_cut",
  279                    lra.print_term(lia.m_t, tout << "cut:"); 

z3/src/math/lp/hnf.h:
  198      }
  199:     TRACE("hnf_calc", tout << "basis_rows = "; print_vector(basis_rows, tout); m_copy.print(tout, "m_copy = "););
  200      return gcd_of_row_starting_from_diagonal(m_copy, rank - 1);

  231         t = is_neg(t) ? t + m_R : t;       
  232:        CTRACE("hnf", is_neg(t), tout << "a=" << a << ", m_R= " << m_R << std::endl;);
  233         return t;

  466          if (!is_correct()) {
  467:             TRACE("hnf_calc",
  468                    tout << "m_H =            "; m_H.print(tout, 17);

  473          if (!is_correct_form()) {
  474:             TRACE("hnf_calc", tout << "is_correct_form() does not hold" << std::endl;);
  475              return false;

  607  #ifdef Z3DEBUG
  608:         CTRACE("hnf_calc", m_H != m_W,
  609                 tout << "A = "; m_A_orig.print(tout, 4); tout << std::endl;

z3/src/math/lp/horner.cpp:
   41  bool horner::row_is_interesting(const T& row) const {
   42:     TRACE("nla_solver_details", c().print_row(row, tout););
   43      if (row.size() > c().m_nla_settings.horner_row_length_limit) {
   44:         TRACE("nla_solver_details", tout << "disregard\n";);
   45          return false;

   70  bool horner::lemmas_on_expr(cross_nested& cn, nex_sum* e) {
   71:     TRACE("nla_horner", tout << "e = " << *e << "\n";);
   72      cn.run(e);

   83      nex* e =  m_nex_creator.simplify(m_row_sum.mk());
   84:     TRACE("nla_horner", tout << "e = " << * e << "\n";);
   85      if (e->get_degree() < 2)

  101      if (!c().m_nla_settings.run_horner) {
  102:         TRACE("nla_solver", tout << "not generating horner lemmas\n";);
  103          return false;

z3/src/math/lp/int_branch.cpp:
  33  lia_move int_branch::create_branch_on_column(int j) {
  34:     TRACE("check_main_int", tout << "branching" << std::endl;);
  35      lp_assert(lia.m_t.is_empty());

  46          
  47:     TRACE("int_solver",
  48            lia.display_column(tout << "branching v" << j << " = " << lia.get_value(j) << "\n", j);

z3/src/math/lp/int_cube.cpp:
  28          lia.settings().stats().m_cube_calls++;
  29:         TRACE("cube",
  30                for (unsigned j = 0; j < lra.number_of_vars(); j++)

  43          if (st != lp_status::FEASIBLE && st != lp_status::OPTIMAL) {
  44:             TRACE("cube", tout << "cannot find a feasible solution";);
  45              lra.pop();

  53          lp_assert(lia.settings().get_cancel_flag() || lia.is_feasible());
  54:         TRACE("cube", tout << "success";);
  55          lia.settings().stats().m_cube_success++;

  63          impq delta = get_cube_delta_for_term(*t);
  64:         TRACE("cube", lra.print_term_as_indices(*t, tout); tout << ", delta = " << delta << "\n";);
  65          if (is_zero(delta))

  72              if (!tighten_term_for_cube(i)) {
  73:                 TRACE("cube", tout << "cannot tighten";);
  74                  return false;

z3/src/math/lp/int_gcd_test.cpp:
   62          lia.settings().stats().m_gcd_calls++;
   63:         TRACE("int_solver", tout << "gcd-test " << lia.settings().stats().m_gcd_calls << "\n";);
   64          if (gcd_test()) {

   71              lia.settings().stats().m_gcd_conflicts++;
   72:             TRACE("gcd_test", tout << "gcd conflict\n";);
   73              return lia_move::conflict;

  156              SASSERT(m_least_coeff.is_int());
  157:             TRACE("gcd_test_bug", tout << "coeff: " << a << ", gcds: " << gcds 
  158                    << " least_coeff: " << m_least_coeff << " consts: " << m_consts << "\n";);

  169          if (!(m_consts / gcds).is_int()) {
  170:             TRACE("gcd_test", tout << "row failed the GCD test:\n"; lia.display_row_info(tout, i););
  171              fill_explanation_from_fixed_columns(A.m_rows[i]);

  187      bool int_gcd_test::ext_gcd_test(const row_strip<mpq> & row) {
  188:         TRACE("ext_gcd_test", tout << "row = "; lra.print_row(row, tout););
  189          mpq gcds(0);

  196              j = c.var();
  197:             TRACE("ext_gcd_test", tout << "col = "; lra.print_column_info(j, tout););
  198              const mpq & a = c.coeff();

  238              fill_explanation_from_fixed_columns(row);
  239:             TRACE("gcd_test", tout << "row failed the GCD test:\n"; lia.display_row(tout, row););
  240              return false;

  289              offset = modulus - offset;
  290:         TRACE("gcd_test", tout << least_idx << " modulus: " << modulus << " consts: " << m_consts << " sign " << least_sign << " offset: " << offset << "\n";);
  291  

z3/src/math/lp/int_solver.cpp:
   84      }
   85:     TRACE("patch_int",
   86            tout << "TARGET j" << j << " -> [";

   97          if (inf_u || l <= u) {
   98:             TRACE("patch_int",    tout << "patching with l: " << l << '\n';);
   99              lra.set_value_for_nbasic_column(j, l);

  102              --m_num_nbasic_patches;
  103:             TRACE("patch_int", tout << "not patching " << l << "\n";);
  104          }

  108          lra.set_value_for_nbasic_column(j, u);
  109:         TRACE("patch_int", tout << "patching with u: " << u << '\n';);
  110      }

  112          lra.set_value_for_nbasic_column(j, impq(0));
  113:         TRACE("patch_int", tout << "patching with 0\n";);
  114      }

  203      mpq sign = m_upper ? one_of_type<mpq>()  : -one_of_type<mpq>();
  204:     CTRACE("current_solution_is_inf_on_cut", v * sign <= impq(m_k) * sign,
  205             tout << "m_upper = " << m_upper << std::endl;

  331  
  332:     TRACE("random_update", display_column(tout, j) << ", is_int = " << column_is_int(j) << "\n";);
  333      impq const & xj = get_value(j);

  348      const auto & A = lra.A_r();
  349:     TRACE("random_update", tout <<  "m = " << m << "\n";);
  350  

  390  
  391:     TRACE("freedom_interval",
  392            tout << "freedom variable for:\n";

  597          return false;
  598:     TRACE("int_solver", tout << "a = " << a << ", b = " << b << ", r = " << r<< ", m = " << m << "\n";);
  599      if (r < mpq(range))

  603      impq new_val = x + m * impq(s);
  604:     TRACE("int_solver", tout << "new_val = " << new_val << "\n";);
  605      SASSERT(l <= new_val && new_val <= u);

z3/src/math/lp/lar_core_solver_def.h:
  141  void lar_core_solver::solve() {
  142:     TRACE("lar_solver", tout << m_r_solver.get_status() << "\n";);
  143      lp_assert(m_r_solver.non_basic_columns_are_set_correctly());
  144      lp_assert(m_r_solver.inf_set_is_correct());
  145: 	TRACE("find_feas_stats", tout << "infeasibles = " << m_r_solver.inf_set_size() << ", int_infs = " << get_number_of_non_ints() << std::endl;);
  146  	if (m_r_solver.current_x_is_feasible() && m_r_solver.m_look_for_feasible_solution_only) {
  147              m_r_solver.set_status(lp_status::OPTIMAL);
  148:             TRACE("lar_solver", tout << m_r_solver.get_status() << "\n";);
  149              return;

  154      if (need_to_presolve_with_double_solver()) {
  155:         TRACE("lar_solver", tout << "presolving\n";);
  156          prefix_d();

  170          if (!settings().use_tableau()) {
  171:             TRACE("lar_solver", tout << "no tablau\n";);
  172              bool snapped = m_r_solver.snap_non_basic_x_to_bound();   

  199  
  200:     TRACE("lar_solver", tout << m_r_solver.get_status() << "\n";);
  201  }

z3/src/math/lp/lar_solver.cpp:
   262      void lar_solver::pop(unsigned k) {
   263:         TRACE("lar_solver", tout << "k = " << k << std::endl;);
   264          m_crossed_bounds_column.pop(k);

   269          lp_assert(A_r().column_count() == n);
   270:         TRACE("lar_solver_details",
   271              for (unsigned j = 0; j < n; j++) {

   318          lp_status st = m_mpq_lar_core_solver.m_r_solver.get_status();
   319:         TRACE("lar_solver", tout << st << "\n";);
   320          SASSERT(m_mpq_lar_core_solver.m_r_solver.calc_current_x_is_feasible_include_non_basis());

   369      void lar_solver::prepare_costs_for_r_solver(const lar_term& term) {
   370:         TRACE("lar_solver", print_term(term, tout << "prepare: ") << "\n";);
   371          m_basic_columns_with_changed_cost.resize(m_mpq_lar_core_solver.m_r_x.size());

   463          bool ret = false;
   464:         TRACE("lar_solver", print_term(term, tout << "maximize: ") << "\n" << constraints() << ", strategy = " << (int)settings().simplex_strategy() << "\n";);
   465          switch (settings().simplex_strategy()) {

   510          impq& term_max) {
   511:         TRACE("lar_solver", print_values(tout););
   512          lar_term term = get_term_to_maximize(j_or_term);

   563          }
   564:         TRACE("lar_solver", print_values(tout););
   565          if (term_max == opt_val) {

   671          }
   672:         CTRACE("lar_solver", !is_zero(r), tout << "row = " << i << ", j = " << m_mpq_lar_core_solver.m_r_basis[i] << "\n";
   673          print_row(A_r().m_rows[i], tout);  tout << " = " << r << "\n";

   707                  m_mpq_lar_core_solver.m_r_solver.add_delta_to_x_and_track_feasibility(bj, -A_r().get_val(c) * delta);
   708:                 TRACE("change_x_del",
   709                      tout << "changed basis column " << bj << ", it is " <<

   925              if (!constraint_holds(c, var_map)) {
   926:                 TRACE("lar_solver",
   927                      m_constraints.display(tout, c) << "\n";

  1152  
  1153:         TRACE("lar_solver_model", tout << "delta = " << m_delta << "\nmodel:\n";
  1154                 for (auto p : variable_values) tout << this->get_variable_name(p.first) << " = " << p.second << "\n";);

  1180          } while (j != n);
  1181:         TRACE("lar_solver_model", tout << "delta = " << m_delta << "\nmodel:\n";);
  1182          return true;

  1326      void lar_solver::fill_var_set_for_random_update(unsigned sz, var_index const* vars, vector<unsigned>& column_list) {
  1327:         TRACE("lar_solver_rand", tout << "sz = " << sz << "\n";);
  1328          for (unsigned i = 0; i < sz; i++) {

  1595      var_index lar_solver::add_var(unsigned ext_j, bool is_int) {
  1596:         TRACE("add_var", tout << "adding var " << ext_j << (is_int ? " int" : " nonint") << std::endl;);
  1597          var_index local_j;

  1656          unsigned j = A_r().column_count();
  1657:         TRACE("add_var", tout << "j = " << j << std::endl;);
  1658          A_r().add_column();

  1753      var_index lar_solver::add_term(const vector<std::pair<mpq, var_index>>& coeffs, unsigned ext_i) {
  1754:         TRACE("lar_solver_terms", print_linear_combination_of_column_indices_only(coeffs, tout) << ", ext_i =" << ext_i << "\n";);
  1755          SASSERT(!m_var_register.external_is_used(ext_i));

  1779      void lar_solver::add_row_from_term_no_constraint(const lar_term* term, unsigned term_ext_index) {
  1780:         TRACE("dump_terms", print_term(*term, tout) << std::endl;);
  1781          register_new_ext_var_index(term_ext_index, term_is_int(term));

  1878  
  1879:         CTRACE("arith", !column_is_fixed(k), print_terms(tout););
  1880          // SASSERT(column_is_fixed(k));

  1883              equal_to_j = column_to_reported_index(k);
  1884:             TRACE("lar_solver", tout << "found equal column k = " << k <<
  1885                  ", external = " << equal_to_j << "\n";);

  1923      constraint_index lar_solver::mk_var_bound(var_index j, lconstraint_kind kind, const mpq& right_side) {
  1924:         TRACE("lar_solver", tout << "j = " << get_variable_name(j) << " " << lconstraint_kind_string(kind) << " " << right_side << std::endl;);
  1925          constraint_index ci;

  2322          auto& slv = m_mpq_lar_core_solver.m_r_solver;
  2323:         TRACE("cube", tout << "delta = " << delta << std::endl;
  2324                m_int_solver->display_column(tout, j); );

  2326              if (slv.m_upper_bounds[j] - delta < slv.m_lower_bounds[j] + delta) {
  2327:                 TRACE("cube", tout << "cannot tighten, delta = " << delta;);
  2328                  return false;

  2330          }
  2331:         TRACE("cube", tout << "can tighten";);
  2332          if (slv.column_has_upper_bound(j)) {

  2355                  continue;
  2356:             TRACE("cube", m_int_solver->display_column(tout, j););
  2357              impq flv = impq(floor(v));

  2366              m_incorrect_columns.insert(j);
  2367:             TRACE("cube", tout << "new val = " << v << " column: " << j << "\n";);
  2368          }

  2466          lar_term normalized_t = t.get_normalized_by_min_var(a);
  2467:         TRACE("lar_solver_terms", tout << "t="; print_term_as_indices(t, tout);
  2468          tout << ", normalized_t="; print_term_as_indices(normalized_t, tout) << "\n";);

  2472          else {
  2473:             TRACE("lar_solver_terms", tout << "the term has been seen already\n";);
  2474          }

  2477      void lar_solver::deregister_normalized_term(const lar_term& t) {
  2478:         TRACE("lar_solver_terms", tout << "deregister term ";
  2479          print_term_as_indices(t, tout) << "\n";);

  2486          if (!m_need_register_terms) {
  2487:             TRACE("nla_solver", tout << "registering " << m_terms.size() << " terms\n";);
  2488              for (unsigned k = 0; k < m_terms.size(); k++) {

  2497      bool lar_solver::fetch_normalized_term_column(const lar_term& c, std::pair<mpq, lpvar>& a_j) const {
  2498:         TRACE("lar_solver_terms", tout << "looking for term ";
  2499          print_term_as_indices(c, tout) << "\n";);

  2502          if (it != m_normalized_terms_to_columns.end()) {
  2503:             TRACE("lar_solver_terms", tout << "got " << it->second << "\n";);
  2504              a_j = it->second;

  2506          }
  2507:         TRACE("lar_solver_terms", tout << "have not found\n";);
  2508          return false;

z3/src/math/lp/lar_solver.h:
  446                  after(bj);
  447:                 TRACE("change_x_del",
  448                        tout << "changed basis column " << bj << ", it is " <<

  482          if (is_base(j)) {
  483:             TRACE("nla_solver", get_int_solver()->display_row_info(tout, row_of_basic_column(j)) << "\n";);
  484              remove_from_basis(j);

  489              return false;
  490:         TRACE("nla_solver", tout << "j" << j << " not blocked\n";);
  491          impq delta = get_column_value(j) - ival;

z3/src/math/lp/lp_bound_propagator.h:
  153          explain_fixed_in_row(r2, ex);
  154:         TRACE("eq", print_row(tout, r1); print_row(tout, r2); tout << v1 << " == " << v2 << " = " << val(v1) << "\n");
  155          add_eq_on_columns(ex, v1, v2, true);

  166         
  167:         TRACE("cheap_eq",
  168                tout << "v_j = "; lp().print_column_info(v_j, tout) << std::endl;

  190      
  191:         TRACE("cheap_eq", tout << "found j=" << j << " for v=";
  192                print_vert(tout, v) << "\n in m_vals_to_verts\n";);

  205          int polarity;
  206:         TRACE("cheap_eq_det", print_row(tout, row_index););
  207          if (!is_tree_offset_row(row_index, x, y, polarity)) {
  208:             TRACE("cheap_eq_det", tout << "not an offset row\n";);
  209              return;
  210          }
  211:         TRACE("cheap_eq", print_row(tout, row_index););
  212          m_root = alloc_v(x);

  361                      found_bound = implied_bound(v, j, is_low, coeff_before_j_is_pos, row_or_term_index, strict);
  362:                     TRACE("try_add_bound", m_imp.lp().print_implied_bound(found_bound, tout););
  363                  }

  367                  m_ibounds.push_back(implied_bound(v, j, is_low, coeff_before_j_is_pos, row_or_term_index, strict));
  368:                 TRACE("try_add_bound", m_imp.lp().print_implied_bound(m_ibounds.back(), tout););
  369              }

  375                      found_bound = implied_bound(v, j, is_low, coeff_before_j_is_pos, row_or_term_index, strict);
  376:                     TRACE("try_add_bound", m_imp.lp().print_implied_bound(found_bound, tout););
  377                  }

  381                  m_ibounds.push_back(implied_bound(v, j, is_low, coeff_before_j_is_pos, row_or_term_index, strict));
  382:                 TRACE("try_add_bound", m_imp.lp().print_implied_bound(m_ibounds.back(), tout););
  383              }

  431          set_fixed_vertex(v);
  432:         TRACE("cheap_eq", 
  433                tout << "polarity switch: " << polarity << "\nv = "; print_vert(tout , v) << "\nu = ";        tout << "fixed vertex explanation\n";

  462      vertex* get_child_from_row(unsigned row_index, vertex* parent) {
  463:         TRACE("cheap_eq_det", print_row(tout, row_index););
  464          unsigned x, y; int row_polarity;
  465          if (!is_tree_offset_row(row_index, x, y, row_polarity)) {
  466:             TRACE("cheap_eq_det", tout << "not an offset row\n"; );
  467              return nullptr;

  502      void check_for_eq_and_add_to_val_table(vertex* v,  map<mpq, const vertex*, obj_hash<mpq>, default_eq<mpq>>& table) {
  503:         TRACE("cheap_eq", tout << "v = "; print_vert(tout, v) << "\n";);
  504          const vertex *k; // the other vertex
  505          if (table.find(val(v), k)) {
  506:             TRACE("cheap_eq", tout << "found k " ; print_vert(tout, k) << "\n";);
  507              if (k->column() != v->column() &&

  512              else {
  513:                 TRACE("cheap_eq", tout << "no report\n";);
  514              }

  516          else {
  517:             TRACE("cheap_eq", tout << "registered: " << val(v) << " -> { "; print_vert(tout, v) << "} \n";);
  518              table.insert(val(v), v);

  522      void check_for_eq_and_add_to_val_tables(vertex* v) {
  523:         TRACE("cheap_eq_det", print_vert(tout, v) << "\n";);
  524          if (!fixed_phase()) {

  553          SASSERT(lp().get_column_value(v_i->column()) == lp().get_column_value(v_j->column()));
  554:         TRACE("cheap_eq", tout << v_i->column() << " = " << v_j->column() << "\nu = ";
  555                print_vert(tout, v_i) << "\nv = "; print_vert(tout, v_j) <<"\n");

  572          unsigned ke = lp().column_to_reported_index(k);
  573:         TRACE("cheap_eq", 
  574                tout << "reporting eq " << j  << ", " << k << "\n";

  607      void explain_fixed_in_row(unsigned row, explanation& ex) const {
  608:         TRACE("cheap_eq", tout << lp().get_row(row) << std::endl);
  609          for (const auto & c : lp().get_row(row)) 

  623          vector<edge> path;
  624:         TRACE("cheap_eq_details", tout << "u = " ; print_vert(tout, u); tout << "\nv = ";print_vert(tout, v) << "\n";); 
  625          vector<edge> v_branch;

  636          SASSERT(u->level() == v->level());
  637:         TRACE("cheap_eq_details", tout << "u = " ; print_vert(tout, u); tout << "\nv = "; print_vert(tout, v) << "\n";); 
  638          while (u != v) {

  646          }
  647:         TRACE("cheap_eq", print_path(path, tout););
  648          return path;

  694          reset_cheap_eq _reset(*this);
  695:         TRACE("cheap_eq_det", tout << "row_index = " << row_index << "\n";);
  696          if (!check_insert(m_visited_rows, row_index)) 

  701          
  702:         TRACE("cheap_eq", tout << "tree = "; print_tree(tout, m_root) << "\n";);        
  703          SASSERT(tree_is_correct());

  705          
  706:         TRACE("cheap_eq",
  707                tout << "done for row_index " << row_index << "\n";

  733      void set_fixed_vertex(vertex *v) {        
  734:         TRACE("cheap_eq", if (v) print_vert(tout, v); else tout << "set m_fixed_vertex to nullptr"; tout << "\n";);
  735          SASSERT(!m_fixed_vertex || v == nullptr);

z3/src/math/lp/lp_core_solver_base_def.h:
   501          if (!column_is_feasible(j)) {
   502:             TRACE("lar_solver", tout << "infeasible column: "; print_column_info(j, tout) << "\n";);
   503              return false;

   513          if (is_feas == belongs_to_set) {
   514:             TRACE("lp_core", tout << "incorrectly set column in inf set "; print_column_info(j, tout) << "\n";);
   515              return false;

  1005          if (!infeasibility_cost_is_correct_for_column(j)) {
  1006:             TRACE("lar_solver", tout << "incorrect cost for column " << j << std::endl;);
  1007              return false;

  1009          if (!is_zero(m_d[j])) {
  1010:             TRACE("lar_solver", tout << "non zero inf cost for basis j = " << j << std::endl;);
  1011              return false;

z3/src/math/lp/lp_core_solver_base.h:
   42      bool current_x_is_feasible() const {
   43:         TRACE("feas",
   44                if (m_inf_set.size()) {

  255                  if (m_d[j] != d) {
  256:                     TRACE("lar_solver", tout << "reduced costs are incorrect for column j = " << j << " should be " << d << " but we have m_d[j] = " << m_d[j] << std::endl;);
  257                      return false;

  490      void change_basis_unconditionally(unsigned entering, unsigned leaving) {
  491:         TRACE("lar_solver", tout << "entering = " << entering << ", leaving = " << leaving << "\n";);
  492          lp_assert(m_basis_heading[entering] < 0);

  510      void change_basis(unsigned entering, unsigned leaving) {
  511:         TRACE("lar_solver", tout << "entering = " << entering << ", leaving = " << leaving << "\n";);
  512          lp_assert(m_basis_heading[entering] < 0);

  561              if (!column_is_feasible(j)) {
  562:                 TRACE("lp_core", tout << "inf col "; print_column_info(j, tout) << "\n";);
  563                  return false;

  704      void update_x_with_feasibility_tracking(unsigned j, const X & v) {
  705:         TRACE("lar_solver", tout << "j = " << j << ", v = " << v << "\n";);
  706          m_x[j] = v;

  710      void add_delta_to_x_and_track_feasibility(unsigned j, const X & del) {
  711:         TRACE("lar_solver", tout << "del = " << del << ", was x[" << j << "] = " << m_x[j] << "\n";);
  712          m_x[j] += del;
  713:         TRACE("lar_solver", tout << "became x[" << j << "] = " << m_x[j] << "\n";);
  714          track_column_feasibility(j);

  717      void update_x(unsigned j, const X & v) {
  718:         TRACE("lar_solver", tout << "j = " << j << ", v = " << v << "\n";);
  719          m_x[j] = v;

  722      void add_delta_to_x(unsigned j, const X & delta) {
  723:         TRACE("lar_solver", tout << "j = " << j << ", delta = " << delta << "\n";);
  724          m_x[j] += delta;

  733      void insert_column_into_inf_set(unsigned j) {
  734:         TRACE("lar_solver", tout << "j = " << j << "\n";);
  735          m_inf_set.insert(j);

  738      void remove_column_from_inf_set(unsigned j) {
  739:         TRACE("lar_solver", tout << "j = " << j << "\n";);
  740          m_inf_set.erase(j);

  744      void resize_inf_set(unsigned size) {
  745:         TRACE("lar_solver",);
  746          m_inf_set.resize(size);

  749      void clear_inf_set() {
  750:         TRACE("lar_solver",);
  751          m_inf_set.clear();

z3/src/math/lp/lp_primal_core_solver_def.h:
  157      const T& dj = this->m_d[j];
  158:     TRACE("lar_solver", tout << "dj=" << dj << "\n";); 
  159      switch (this->m_column_types[j]) {

  780      if (leaving == -1) {
  781:         TRACE("lar_solver", tout << "non-leaving\n";);
  782          this->set_status(lp_status::UNBOUNDED);

  834          }
  835:         TRACE("lar_solver", tout << this->get_status() << "\n";);
  836          return;

  868  template <typename T, typename X> unsigned lp_primal_core_solver<T, X>::solve() {
  869:     TRACE("lar_solver", tout << "solve " << this->get_status() << "\n";);
  870      if (numeric_traits<T>::precise() && this->m_settings.use_tableau())

  888  
  889:         TRACE("lar_solver", tout << "one iteration: " << this->get_status() << "\n";);
  890          lp_assert(!this->using_infeas_costs() || this->costs_on_nbasis_are_zeros());

z3/src/math/lp/lp_primal_core_solver_tableau_def.h:
   39      if (leaving == -1) {
   40:         TRACE("lar_solver", tout << "nothing leaving " << entering << "\n";);
   41          this->set_status(lp_status::UNBOUNDED);

  122          }
  123:         TRACE("lar_solver", tout << "one iteration tableau " << this->get_status() << "\n";);
  124          switch (this->get_status()) {

z3/src/math/lp/monomial_bounds.cpp:
  64              lemma |= ineq(v, cmp, upper); 
  65:             TRACE("nla_solver", dep.display(tout << val << " > ", range) << "\n" << lemma << "\n";);
  66              return true;

  77              lemma |= ineq(v, cmp, lower); 
  78:             TRACE("nla_solver", dep.display(tout << val << " < ", range) << "\n" << lemma << "\n";);
  79              return true;

z3/src/math/lp/nex_creator.cpp:
   62  void nex_creator::simplify_children_of_mul(vector<nex_pow> & children, rational& coeff) {
   63:     TRACE("grobner_d", print_vector(children, tout << "children_of_mul: "); tout << "\n";);
   64      vector<nex_pow> to_promote;

   80      for (nex_pow & p : to_promote) {
   81:         TRACE("grobner_d", tout << p << "\n";);
   82          nex_mul &pm = p.e()->to_mul();
   83          for (nex_pow& pp : pm) {
   84:             TRACE("grobner_d", tout << pp << "\n";);
   85              if (!eat_scalar_pow(coeff, pp, p.pow()))

   92      
   93:     TRACE("grobner_d", print_vector(children, tout););    
   94  }

  125      }
  126:     TRACE("nex_gt", tout << "a = "; print_vector(a, tout) << (ret?" > ":" <= ") << b << "\n";);
  127      return ret;

  130  bool nex_creator::gt_on_mul_mul(const nex_mul& a, const nex_mul& b) const {
  131:     TRACE("grobner_d", tout << "a = " << a << " , b = " << b << "\n";);
  132      SASSERT(is_simplified(a) && is_simplified(b));

  192  bool nex_creator::gt_for_sort_join_sum(const nex* a, const nex* b) const {
  193:     TRACE("grobner_d_", tout << *a << " ? " << *b <<  "\n";);
  194      if (a == b)

  217      }
  218:     TRACE("grobner_d_", tout << *a << (ret?" < ":" >= ") << *b << "\n";);
  219      return ret;

  222  bool nex_creator::gt(const nex& a, const nex& b) const {
  223:     TRACE("grobner_d_", tout << a << " ? " << b <<  "\n";);
  224      if (&a == &b)

  245      }
  246:     TRACE("grobner_d_", tout << a << (ret?" < ":" >= ") << b << "\n";);
  247      return ret;

  252          if (!(gt_on_nex_pow(e[j], e[j+1]))) {
  253:             TRACE("grobner_d", tout << "not sorted e " << e << "\norder is incorrect " <<
  254                    e[j] << " >= " << e[j + 1]<< "\n";);

  262  bool nex_creator::mul_is_simplified(const nex_mul& e) const {
  263:     TRACE("nla_cn_", tout <<  "e = " << e << "\n";);
  264      if (e.size() == 0) {
  265:         TRACE("nla_cn", );
  266          return false; // it has to be a scalar

  268      if (e.size() == 1 && e.begin()->pow() == 1 && e.coeff().is_one()) { 
  269:         TRACE("nla_cn", );
  270          return false;

  275          if (p.pow() == 0) {
  276:             TRACE("nla_cn", tout << "not simplified " << *ee << "\n";);
  277              return false;

  279          if (ee->is_mul()) {
  280:             TRACE("nla_cn", tout << "not simplified " << *ee << "\n";);
  281              return false;

  283          if (ee->is_scalar() && to_scalar(ee)->value().is_one()) {
  284:             TRACE("nla_cn", tout << "not simplified " << *ee << "\n";);
  285              return false;

  291          } else {            
  292:             TRACE("nla_cn", tout << "not simplified " << *ee << "\n";);
  293              return false;

  299  nex * nex_creator::simplify_mul(nex_mul *e) {
  300:     TRACE("grobner_d", tout << *e << "\n";);
  301      rational& coeff = e->m_coeff;

  307          return mk_scalar(e->coeff());
  308:     TRACE("grobner_d", tout << *e << "\n";);
  309      SASSERT(is_simplified(*e));

  313  nex* nex_creator::simplify_sum(nex_sum *e) {
  314:     TRACE("grobner_d", tout << "was e = " << *e << "\n";);
  315      simplify_children_of_sum(*e);

  323      }
  324:     TRACE("grobner_d", tout << "became r = " << *r << "\n";);    
  325      return r;

  331      for (nex const* ee : e) {
  332:         TRACE("nla_cn_details", tout << "ee = " << *ee << "\n";);
  333          if (ee->is_sum()) {
  334:             TRACE("nla_cn", tout << "not simplified e = " << e << "\n"
  335                    << " has a child which is a sum " << *ee << "\n";);

  339              if (scalar) {
  340:                 TRACE("nla_cn", tout <<  "not simplified e = " << e << "\n"
  341                        << " have more than one scalar " << *ee << "\n";);

  346                  if (scalar) {
  347:                     TRACE("nla_cn", tout << "have a zero scalar " << *ee << "\n";);
  348                      

  382  bool nex_creator::register_in_join_map(std::map<nex const*, rational, nex_lt>& map, nex const* e, const rational& r) const{
  383:     TRACE("grobner_d",  tout << *e << ", r = " << r << std::endl;);
  384      auto map_it = map.find(e);

  386          map[e] = r;
  387:         TRACE("grobner_d",  tout << "inserting " << std::endl;);
  388          return false;

  390          map_it->second += r;
  391:         TRACE("grobner_d",  tout << "adding " << r << " , got " << map_it->second << std::endl;);
  392          return true;

  420  void nex_creator::sort_join_sum(nex_sum& sum) {
  421:     TRACE("grobner_d", tout << sum << "\n";);
  422      std::map<nex const*, rational, nex_lt> map([this](const nex *a , const nex *b)

  427  
  428:     TRACE("grobner_d", for (auto & p : map ) { tout << "(" << *p.first << ", " << p.second << ") ";});
  429      sum.m_children.reset();

  435      }
  436:     TRACE("grobner_d",
  437            tout << "map=";

  481      nex* r = sf.mk();
  482:     TRACE("grobner_d", tout << *r << "\n";);
  483      return r;

  490      for (auto& p_from_a : a) {
  491:         TRACE("grobner_d", tout << "p_from_a = " << p_from_a << "\n";);
  492          const nex* e = p_from_a.e();

  494              m_mk_mul *= nex_pow(clone(e), p_from_a.pow());
  495:             TRACE("grobner_d", tout << "processed scalar\n";);
  496              continue;

  522      nex* ret = m_mk_mul.mk_reduced();
  523:     TRACE("grobner_d", tout << *ret << "\n";);        
  524      return ret;

  538  nex * nex_creator::mk_div(const nex& a, const nex& b) {
  539:     TRACE("grobner_d", tout << a <<" / " << b << "\n";);
  540      if (b.is_var()) {

  547      nex* es;
  548:     TRACE("grobner_d", tout << *e << std::endl;);
  549      if (e->is_mul())

  554          es = e;
  555:     TRACE("grobner_d", tout << "simplified = " << *es << std::endl;);
  556      SASSERT(is_simplified(*es));

  561  void nex_creator::process_map_pair(nex*e, const rational& coeff, nex_sum & sum, std::unordered_set<nex const*>& allocated_nexs) {
  562:     TRACE("grobner_d", tout << "e=" << *e << " , coeff= " << coeff << "\n";);
  563      if (coeff.is_zero()) {
  564:         TRACE("grobner_d", tout << "did nothing\n";);   
  565          return;

  587  bool nex_creator::is_simplified(const nex& e) const {
  588:     TRACE("nla_cn_details", tout << "e = " << e << "\n";);
  589      if (e.is_mul())

  604  nex* nex_creator::canonize_mul(nex_mul *a) {    
  605:     TRACE("grobner_d", tout << "a = " << *a << "\n";);
  606      unsigned j = find_sum_in_mul(a);

  627      nex* r = sf.mk();
  628:     TRACE("grobner_d", tout << "canonized a = " <<  *r << "\n";);
  629      return canonize(r);

  642          t = simplify(&s);
  643:         TRACE("grobner_d", tout << *t << "\n";);
  644          return t;

  649  bool nex_creator::equal(const nex* a, const nex* b) {
  650:     TRACE("grobner_d", tout << *a << " against  " << *b << "\n";);
  651      nex_creator cn;

  664      nex * cb = cn.canonize(b);
  665:     TRACE("grobner_d", tout << "a = " << *a << ", canonized a = " << *ca << "\n";);
  666:     TRACE("grobner_d", tout << "b = " << *b << ", canonized b = " << *cb << "\n";);
  667      return !(cn.gt(ca, cb) || cn.gt(cb, ca));

z3/src/math/lp/nex_creator.h:
  135          m_allocated.push_back(r);
  136:         CTRACE("grobner_stats_d", m_allocated.size() % 1000 == 0, tout << "m_allocated.size() = " << m_allocated.size() << "\n";);
  137      }

  144          m_allocated.resize(sz);
  145:         TRACE("grobner_stats_d", tout << "m_allocated.size() = " << m_allocated.size() << "\n";);
  146      }

z3/src/math/lp/nex.h:
  235      void get_powers_from_mul(std::unordered_map<lpvar, unsigned> & r) const {
  236:         TRACE("nla_cn_details", tout << "powers of " << *this << "\n";);
  237          r.clear();

  244          }
  245:         TRACE("nla_cn_details", tout << "powers of " << *this << "\n"; print_vector(r, tout)<< "\n";);
  246      }

  290      bool is_linear() const override {
  291:         TRACE("nex_details", tout << *this << "\n";);
  292          for (auto  e : *this) {

  295          }
  296:         TRACE("nex_details", tout << "linear\n";); 
  297          return true;

  301      bool is_a_linear_term() const {
  302:         TRACE("nex_details", tout << *this << "\n";);
  303          unsigned number_of_non_scalars = 0;

  309          }
  310:         TRACE("nex_details", tout << (number_of_non_scalars > 1?"linear":"non-linear") << "\n";); 
  311          return number_of_non_scalars > 1;

  407      default:
  408:         TRACE("nla_cn_details", tout << e->type() << "\n";);
  409          SASSERT(false);

  432      default:
  433:         TRACE("nla_cn_details", tout << e->type() << "\n";);
  434          SASSERT(false);

z3/src/math/lp/nla_basics_lemmas.cpp:
   24          return false;
   25:     TRACE("nla_solver", tout << "sign contradiction:\nm = " << pp_mon(c(), m) << "n= " << pp_mon(c(), n) << "sign: " << sign << "\n";);
   26      generate_sign_lemma(m, n, sign);

   48      }
   49:     TRACE("nla_solver_details", tout << "zero_j = " << zero_j << ", sign = " << sign << "\n";);
   50      if (sign == 0) { // have to generate a non-convex lemma

   82      if (product_sign == 0) {
   83:         TRACE("nla_solver_bl", tout << "zero product sign: " << pp_mon(_(), m)<< "\n";);
   84          generate_zero_lemmas(m);

  115      const monic& m_v = c().emons()[v];
  116:     TRACE("nla_solver", tout << "m_v = " << pp_mon_with_vars(c(), m_v););
  117:     CTRACE("nla_solver", !c().emons().is_canonized(m_v),
  118             c().emons().display(c(), tout);

  123      for (auto const& m : c().emons().enum_sign_equiv_monics(v)) {
  124:         TRACE("nla_solver_details", tout << "m = " << pp_mon_with_vars(c(), m););
  125          SASSERT(m.rvars() == m_v.rvars());

  129  
  130:     TRACE("nla_solver_details", tout << "return false\n";);
  131      return false;

  152      new_lemma lemma(c(), "sign lemma");
  153:     TRACE("nla_solver",
  154            tout << "m = " << pp_mon_with_vars(_(), m);

  183  void basics::generate_strict_case_zero_lemma(const monic& m, unsigned zero_j, int sign_of_zj) {
  184:     TRACE("nla_solver_bl", tout << "sign_of_zj = " << sign_of_zj << "\n";);
  185      // we know all the signs

  202  void basics::negate_strict_sign(new_lemma& lemma, lpvar j) {
  203:     TRACE("nla_solver_details", tout << pp_var(c(), j) << " " << val(j).is_zero() << "\n";);
  204      if (!val(j).is_zero()) {

  227      }
  228:     TRACE("nla_solver", c().trace_print_monic_and_factorization(rm, f, tout););
  229      new_lemma lemma(c(), "xy = 0 -> x = 0 or y = 0");

  247      const auto& mon_inds_to_ref = c().m_to_refine;
  248:     TRACE("nla_solver", tout << "mon_inds_to_ref = "; print_vector(mon_inds_to_ref, tout) << "\n";);
  249      unsigned start = c().random();

  294  bool basics::basic_lemma_for_mon_non_zero_derived(const monic& rm, const factorization& f) {
  295:     TRACE("nla_solver", c().trace_print_monic_and_factorization(rm, f, tout););
  296      if (!c().var_is_separated_from_zero(var(rm)))

  316  bool basics::basic_lemma_for_mon_neutral_derived(const monic& rm, const factorization& f) {
  317:     TRACE("nla_solver",  c().trace_print_monic_and_factorization(rm, f, tout););
  318  
  319      lpvar mon_var =  c().emons()[rm.var()].var();
  320:     TRACE("nla_solver",  c().trace_print_monic_and_factorization(rm, f, tout); tout << "\nmon_var = " << mon_var << "\n";);
  321          

  417      SASSERT(!c().has_real(fc));
  418:     TRACE("nla_solver", tout << "factor_index = " << factor_index << ", m = "
  419            << pp_mon(c(), m);

  459  void basics::basic_lemma_for_mon_zero_model_based(const monic& rm, const factorization& f) {        
  460:     TRACE("nla_solver",  c().trace_print_monic_and_factorization(rm, f, tout););
  461      SASSERT(var_val(rm).is_zero() && !c().rm_check(rm));

  477  void basics::basic_lemma_for_mon_model_based(const monic& rm) {
  478:     TRACE("nla_solver_bl", tout << "rm = " << pp_mon(_(), rm) << "\n";);
  479      if (var_val(rm).is_zero()) {

  530      lpvar mon_var = c().emons()[rm.var()].var();
  531:     TRACE("nla_solver_bl", c().trace_print_monic_and_factorization(rm, f, tout); tout << "\nmon_var = " << mon_var << "\n";);
  532          

  583      sign = rational(1); 
  584:     //    TRACE("nla_solver_bl", tout << pp_mon_with_vars(_(), m) <<"\nf = " << c().pp(f) << "sign = " << sign << '\n';);
  585      not_one = null_lpvar;
  586      for (auto j : f) {
  587:         TRACE("nla_solver_bl", tout << "j = "; c().print_factor_with_vars(j, tout););
  588          auto v = val(j);

  611      if (not_one != null_lpvar && var_val(m) == val(not_one) * sign) {
  612:         TRACE("nla_solver", tout << "the whole is equal to the factor" << std::endl;);
  613          return false;        

  641              return false;
  642:     TRACE("nla_solver_bl", tout << "not_one = " << not_one << "\n";);
  643          

  648          if (not_one == var_j) continue;
  649:         TRACE("nla_solver_bl", tout << "j = "; c().print_factor_with_vars(j, tout););
  650          lemma |= ineq(var_j, llc::NE, val(var_j));

  658      lemma &= f;
  659:     TRACE("nla_solver", tout << "m = " << pp_mon_with_vars(c(), m););
  660      return true;

  664  void basics::basic_lemma_for_mon_non_zero_model_based(const monic& rm, const factorization& f) {
  665:     TRACE("nla_solver_bl", c().trace_print_monic_and_factorization(rm, f, tout););
  666      for (auto j : f) {

z3/src/math/lp/nla_common.cpp:
  103              mf *= cn.mk_var(k);
  104:             CTRACE("nla_grobner", c().is_monic_var(k), c().print_var(k, tout) << "\n";);
  105          }

  107      nex* e = mf.mk();
  108:     TRACE("nla_grobner", tout << *e;);
  109      return e;

  117  
  118:     TRACE("nla_horner", tout << "row="; m_core.print_row(row, tout) << "\n";);
  119      SASSERT(row.size() > 1);

z3/src/math/lp/nla_core.cpp:
   140  void core::push() {
   141:     TRACE("nla_solver_verbose", tout << "\n";);
   142      m_emons.push();

   146  void core::pop(unsigned n) {
   147:     TRACE("nla_solver_verbose", tout << "n = " << n << "\n";);
   148      m_emons.pop(n);

   163      bool ret = product_value(m) == m_lar_solver.get_column_value(m.var()).x; 
   164:     CTRACE("nla_solver_check_monic", !ret, print_monic(m, tout) << '\n';);
   165      return ret;

   405      m_evars.explain(signed_var(i, false), signed_var(j, sign), e);
   406:     TRACE("nla_solver", tout << "explained :"; m_lar_solver.print_term_as_indices(t, tout););
   407      return true;            

   410  void core::mk_ineq_no_expl_check(new_lemma& lemma, lp::lar_term& t, llc cmp, const rational& rs) {
   411:     TRACE("nla_solver_details", m_lar_solver.print_term_as_indices(t, tout << "t = "););
   412      lemma |= ineq(cmp, t, rs);
   413:     CTRACE("nla_solver", ineq_holds(ineq(cmp, t, rs)), print_ineq(ineq(cmp, t, rs), tout) << "\n";);
   414      SASSERT(!ineq_holds(ineq(cmp, t, rs)));

   432      lemma &= b;
   433:     TRACE("nla_solver", tout << "used constraints: " << lemma;);
   434      SASSERT(lemma.num_ineqs() == 0);

   446          s ^= root.sign();
   447:         TRACE("nla_solver_eq",
   448                tout << pp(v) << " mapped to " << pp(root.var()) << "\n";);

   523    unsigned_vector eq_vars(lpvar j) const {
   524:   TRACE("nla_solver_eq", tout << "j = " << pp(j) << "eqs = ";
   525    for(auto jj : m_evars.eq_vars(j)) tout << pp(jj) << " ";

   694          if (var_is_fixed_to_zero(j)) {
   695:             TRACE("nla_solver_mons", s.print_term_as_indices(*s.terms()[i], tout << "term = ") << "\n";);
   696              add_equivalence_maybe(s.terms()[i], s.get_column_upper_bound_witness(j), s.get_column_lower_bound_witness(j));

   806  void core::init_search() {
   807:     TRACE("nla_solver_mons", tout << "init\n";);
   808      SASSERT(m_emons.invariant());

   815  void core::insert_to_refine(lpvar j) {
   816:     TRACE("lar_solver", tout << "j=" << j << '\n';);
   817      m_to_refine.insert(j);

   820  void core::erase_from_to_refine(lpvar j) {
   821:     TRACE("lar_solver", tout << "j=" << j << '\n';);
   822      m_to_refine.erase(j);

   826  void core::init_to_refine() {
   827:     TRACE("nla_solver_details", tout << "emons:" << pp_emons(*this, m_emons););
   828      m_to_refine.clear();

   836      
   837:     TRACE("nla_solver", 
   838            tout << m_to_refine.size() << " mons to refine:\n";

   869      svector<lpvar> c_rvars = sorted_rvars(c);
   870:     TRACE("nla_solver_div", tout << "c_rvars = "; print_product(c_rvars, tout); tout << "\nbc_rvars = "; print_product(bc.rvars(), tout););
   871      if (!lp::is_proper_factor(c_rvars, bc.rvars()))

   874      auto b_rvars = lp::vector_div(bc.rvars(), c_rvars);
   875:     TRACE("nla_solver_div", tout << "b_rvars = "; print_product(b_rvars, tout););
   876      SASSERT(b_rvars.size() > 0);

   881          if (sv == nullptr) {
   882:             TRACE("nla_solver_div", tout << "not in rooted";);
   883              return false;

   891      b.sign() = canonize_sign(b) ^ canonize_sign(c) ^ canonize_sign(bc); 
   892:     TRACE("nla_solver", tout << "success div:" << pp(b) << "\n";);
   893      return true;

   956              r.push_back(factor(i, factor_type::MON));
   957:             TRACE("nla_solver", tout << "inserting factor = "; print_factor_with_vars(factor(i, factor_type::MON), tout); );
   958          }

   988                  bf = f;
   989:                 TRACE("nla_solver", tout << "found bf";
   990                        tout << ":m:" << pp_mon_with_vars(*this, m) << "\n";

  1017          if (find_bfc_to_refine_on_monic(*m, bf)) {
  1018:             TRACE("nla_solver",
  1019                    tout << "bf = "; print_factorization(bf, tout);

  1040      if (!c.explain_ineq(*this, ineq.term(), ineq.cmp(), ineq.rs())) {
  1041:         CTRACE("nla_solver", c.ineq_holds(ineq), c.print_ineq(ineq, tout) << "\n";);
  1042          SASSERT(!c.ineq_holds(ineq));

  1053      // code for checking lemma can be added here
  1054:     TRACE("nla_solver", tout << name << " " << (++i) << "\n" << *this; );
  1055  }

  1127      *this &= ex;
  1128:     TRACE("nla_solver", tout << j << ": " << *this << "\n";);
  1129      return *this;

  1229      if (is_monic_var(j) && !m_to_refine.contains(j)) {
  1230:         TRACE("nla_solver", tout << "j = " << j << ", m  = "; print_monic(emons()[j], tout) << "\n";);
  1231          return true; // changing the value of a correct monic

  1290  bool core::is_patch_blocked(lpvar u, const lp::impq& ival) const {
  1291:     TRACE("nla_solver", tout << "u = " << u << '\n';);
  1292      if (m_cautious_patching &&
  1293          (!m_lar_solver.inside_bounds(u, ival) || (var_is_int(u) && ival.is_int() == false))) {
  1294:         TRACE("nla_solver", tout << "u = " << u << " blocked, for feas or integr\n";);
  1295          return true; // block

  1298      if (u == m_patched_var) {
  1299:         TRACE("nla_solver", tout << "u == m_patched_var, no block\n";);
  1300          

  1304      if (m_patched_monic->contains_var(u) || u == var(*m_patched_monic)) {
  1305:         TRACE("nla_solver", tout << "u = " << u << " blocked as contained\n";);
  1306          return true; // block

  1309      if (var_breaks_correct_monic(u)) {
  1310:         TRACE("nla_solver", tout << "u = " << u << " blocked as used in a correct monomial\n";);
  1311          return true;

  1313      
  1314:     TRACE("nla_solver", tout << "u = " << u << ", m_patched_m  = "; print_monic(*m_patched_monic, tout) <<
  1315            ", not blocked\n";);

  1336          if (valid == m_to_refine.contains(j)) {
  1337:             TRACE("nla_solver", tout << "inconstency in m_to_refine : ";
  1338                    print_monic(emons()[j], tout) << "\n";

  1349      m_patched_var = j;
  1350:     TRACE("nla_solver", tout << "m = "; print_monic(*m_patched_monic, tout) << "\n";);
  1351      rational v = mul_val(*m_patched_monic);

  1361      // We could not patch j, now we try patching the factor variables.
  1362:     TRACE("nla_solver", tout << " trying squares\n";);
  1363      // handle perfect squares

  1368              if (!var_breaks_correct_monic(m_patched_var) && (try_to_patch(root) || try_to_patch(-root))) { 
  1369:                 TRACE("nla_solver", tout << "patched square\n";);
  1370                  return;

  1372          }
  1373:         TRACE("nla_solver", tout << " cannot patch\n";);
  1374          return;

  1381          SASSERT((*m_patched_monic).is_sorted());
  1382:         TRACE("nla_solver", tout << "r = " << r << ", v = " << v << "\n";);
  1383          for (unsigned l = 0; l < (*m_patched_monic).size(); l++) {

  1387                  try_to_patch(r * val(m_patched_var))) { // r * val(k) gives the right value of k
  1388:                 TRACE("nla_solver", tout << "patched  " << m_patched_var << "\n";);
  1389                  SASSERT(mul_val((*m_patched_monic)) == val(j));

  1407      }
  1408:     TRACE("nla_solver", tout << "sz = " << sz << ", m_to_refine = " << m_to_refine.size() <<
  1409            (sz > m_to_refine.size()? " less" : "same" ) << "\n";);

  1482      lp_settings().stats().m_nla_calls++;
  1483:     TRACE("nla_solver", tout << "calls = " << lp_settings().stats().m_nla_calls << "\n";);
  1484      m_lar_solver.get_rid_of_inf_eps();

  1487            m_lar_solver.get_status() == lp::lp_status::FEASIBLE)) {
  1488:         TRACE("nla_solver", tout << "unknown because of the m_lar_solver.m_status = " << m_lar_solver.get_status() << "\n";);
  1489          return l_undef;

  1557      
  1558:     TRACE("nla_solver", tout << "ret = " << ret << ", lemmas count = " << l_vec.size() << "\n";);
  1559      IF_VERBOSE(2, if(ret == l_undef) {verbose_stream() << "Monomials\n"; print_monics(verbose_stream());});
  1560:     CTRACE("nla_solver", ret == l_undef, tout << "Monomials\n"; print_monics(tout););
  1561      return ret;

  1600          if (lemma_holds(l)) {
  1601:             TRACE("nla_solver", print_lemma(l, tout););
  1602              return false;

z3/src/math/lp/nla_grobner.cpp:
   85  
   86:         TRACE("grobner", m_solver.display(tout));
   87          IF_VERBOSE(2, if (conflicts > 0) verbose_stream() << "grobner conflict\n");

  206              set_level2var();
  207:             TRACE("grobner",
  208                    tout << "base vars: ";

  224          }
  225:         TRACE("grobner", m_solver.display(tout));
  226      

  287          if (!di.separated_from_zero(i)) {
  288:             TRACE("grobner", m_solver.display(tout << "not separated from 0 ", e) << "\n";
  289                    eval.get_interval_distributed<dd::w_dep::without_deps>(e.poly(), i);

  305          if (di.check_interval_for_conflict_on_zero(i_wd, e.dep(), f)) {
  306:             TRACE("grobner", m_solver.display(tout << "conflict ", e) << "\n");
  307              return true;

  309          else {
  310:             TRACE("grobner", m_solver.display(tout << "no conflict ", e) << "\n");
  311              return false;

  350                  continue;
  351:             CTRACE("grobner", matrix.m_rows[row].size() > c().m_nla_settings.grobner_row_length_limit,
  352                     tout << "ignore the row " << row << " with the size " << matrix.m_rows[row].size() << "\n";); 

  475              sum += pdd_expr(p.coeff(), p.var(), dep);
  476:         TRACE("grobner", c().print_row(row, tout) << " " << sum << "\n");
  477          add_eq(sum, dep);

  483          svector<lpvar> q;
  484:         TRACE("grobner", for (lpvar j : c().m_to_refine) print_monic(c().emons()[j], tout) << "\n";);
  485            

  493          }
  494:         TRACE("grobner", tout << "vars in cluster: ";
  495                for (lpvar j : c().active_var_set()) tout << "j" << j << " "; tout << "\n";

  543  
  544:         TRACE("grobner",
  545              for (auto v : sorted_vars)

z3/src/math/lp/nla_intervals.cpp:
   98      interval_of_expr<e_with_deps::with_deps>(n, 1, interv_wd, f);
   99:     TRACE("nla_intervals", display_separating_interval(tout, n, interv_wd, initial_deps););    
  100      m_dep_intervals.check_interval_for_conflict_on_zero(interv_wd, initial_deps, f);

  104  void intervals::add_mul_of_degree_one_to_vector(const nex_mul* e, vector<std::pair<rational, lpvar>> &v) {
  105:     TRACE("nla_intervals_details", tout << *e << "\n";);
  106      SASSERT(e->size() == 1);

  113  void intervals::add_linear_to_vector(const nex* e, vector<std::pair<rational, lpvar>> &v) {
  114:     TRACE("nla_intervals_details", tout << *e << "\n";);
  115      switch (e->type()) {

  129  lp::lar_term intervals::expression_to_normalized_term(const nex_sum* e, rational& a, rational& b) {
  130:     TRACE("nla_intervals_details", tout << *e << "\n";);
  131      lpvar smallest_j = 0;

  147      }
  148:     TRACE("nla_intervals_details", tout << "a_index = " << a_index << ", v="; print_vector(v, tout) << "\n";);
  149      a = v[a_index].first;

  164      }
  165:     TRACE("nla_intervals_details", tout << a << "* (";
  166            lp::lar_solver::print_term_as_indices(t, tout) << ") + " << b << std::endl;);

  250  void intervals::set_var_interval(lpvar v, interval& b) {
  251:     TRACE("nla_intervals_details", m_core->print_var(v, tout) << "\n";);
  252      lp::constraint_index ci;

  291          }
  292:         TRACE("nla_intervals", tout << "explain_by_equiv\n";);
  293          return true;

  304  
  305:     TRACE("nla_intervals",
  306            m_core->m_lar_solver.print_column_info(j, tout) << "\n";

  321      for (unsigned k = 1; k < e.size(); k++) {
  322:         TRACE("nla_intervals_details", tout << "e[" << k << "]= " << *e[k] << "\n";);
  323          scoped_dep_interval  b(get_dep_intervals());

  328  
  329:         TRACE("nla_intervals_details", tout << "sdi = "; display(tout, sdi) << "\nb = "; display(tout, b) << "\n";);
  330          m_dep_intervals.add<wd>(sdi, b, c);        
  331          m_dep_intervals.set<wd>(sdi, c);
  332:         TRACE("nla_intervals_details", tout << *e[k] << ", ";
  333                display(tout, sdi); tout << "\n";);
  334      }
  335:     TRACE("nla_intervals_details", tout << "e=" << e << "\n";
  336            tout << " interv = "; display(tout, sdi););

  361  bool intervals::interval_of_sum(const nex_sum& e, scoped_dep_interval& a, const std::function<void (const T&)>& f) {
  362:     TRACE("nla_intervals_details", tout << "e=" << e << "\n";);
  363      if(! interval_of_sum_no_term<wd>(e, a, f)) {

  365      }
  366:     TRACE("nla_intervals_details", tout << "a = "; display(tout, a););
  367      if (e.is_a_linear_term()) {

  372              m_dep_intervals.intersect<wd>(a, i_from_term, r);
  373:             TRACE("nla_intervals_details", tout << "intersection="; display(tout, r) << "\n";);
  374              
  375              if (m_dep_intervals.is_empty(r)) {
  376:                 TRACE("nla_intervals_details", tout << "empty\n";);
  377                  if (wd == e_with_deps::with_deps) {

  401  bool intervals::interval_of_mul(const nex_mul& e, scoped_dep_interval& a, const std::function<void (const T&)>& f) {
  402:     TRACE("nla_intervals_details", tout << "e = " << e << "\n";);
  403      const nex* zero_interval_child = get_zero_interval_child(e);

  409              set_zero_interval_deps_for_mult(a);
  410:         TRACE("nla_intervals_details", tout << "zero_interval_child = " << *zero_interval_child << std::endl << "a = "; display(tout, a); );
  411           return true; // regural calculation: no conflict

  414      m_dep_intervals.set_interval_for_scalar(a, e.coeff());
  415:     TRACE("nla_intervals_details", tout << "a = "; display(tout, a); );
  416      for (const auto& ep : e) {

  419              return false;
  420:         TRACE("nla_intervals_details", tout << "ep = " << ep << ", "; display(tout, b); );
  421          scoped_dep_interval c(get_dep_intervals());
  422          m_dep_intervals.mul<wd>(a, b, c);
  423:         TRACE("nla_intervals_details", tout << "a "; display(tout, a););
  424:         TRACE("nla_intervals_details", tout << "c "; display(tout, c););
  425          m_dep_intervals.set<wd>(a, c);
  426:         TRACE("nla_intervals_details", tout << "part mult "; display(tout, a););
  427      }
  428:     TRACE("nla_intervals_details", tout << "e=" << e << "\n";
  429            tout << " return "; display(tout, a););

  471      default:
  472:         TRACE("nla_intervals_details", tout << e->type() << "\n";);
  473          UNREACHABLE();        

z3/src/math/lp/nla_order_lemmas.cpp:
   20  void order::order_lemma() {
   21:     TRACE("nla_solver", );
   22      if (!c().m_nla_settings.run_order) {
   23:         TRACE("nla_solver", tout << "not generating order lemmas\n";);
   24          return;

   40  void order::order_lemma_on_monic(const monic& m) {
   41:     TRACE("nla_solver_details",
   42            tout << "m = " << pp_mon(c(), m););

   58  void order::order_lemma_on_binomial(const monic& ac) {
   59:     TRACE("nla_solver", tout << pp_mon_with_vars(c(), ac););
   60      SASSERT(!check_monic(ac) && ac.size() == 2);

   95  void order::order_lemma_on_factor_binomial_explore(const monic& ac, bool k) {
   96:     TRACE("nla_solver", tout << "ac = " <<  pp_mon_with_vars(c(), ac););
   97      SASSERT(ac.size() == 2);    

  102              continue;
  103:         TRACE("nla_solver", tout << "bd = " << pp_mon_with_vars(_(), bd););
  104          order_lemma_on_factor_binomial_rm(ac, k, bd);

  112  void order::order_lemma_on_factor_binomial_rm(const monic& ac, bool k, const monic& bd) {
  113:     TRACE("nla_solver",
  114            tout << "ac=" << pp_mon_with_vars(_(), ac) << "\n";

  128      lpvar c = ac.vars()[k];
  129:     TRACE("nla_solver",  
  130            tout << "ac = " << pp_mon(_(), ac) << "a = " << pp_var(_(), a) << "c = " << pp_var(_(), c) << "\nbd = " << pp_mon(_(), bd) << "b = " << pp_fac(_(), b) << "d = " << pp_var(_(), d) << "\n";

  140      auto av_c_s = av*c_sign; auto bv_d_s = bv*d_sign;
  141:     TRACE("nla_solver",  
  142            tout << "acv = " << acv << ", av = " << av << ", c_sign = " << c_sign << ", d_sign = " << d_sign << ", bdv = " << bdv <<

  189                                       const monic& rm_bd) {
  190:     TRACE("nla_solver", 
  191            tout << "rm_ac = " << pp_mon_with_vars(_(), rm_ac) << "\n";

  211      const rational mv = rsign * var_val(m);
  212:     TRACE("nla_solver",
  213            tout << "ab.size()=" << ab.size() << "\n";

  232      const factor c = ac[k];
  233:     TRACE("nla_solver", tout << "c = "; _().print_factor_with_vars(c, tout); );
  234      if (c.is_var()) {
  235:         TRACE("nla_solver", tout << "var(c) = " << var(c););
  236          for (monic const& bc : _().emons().get_use_list(c.var())) {

  280      new_lemma lemma(_(), __FUNCTION__);
  281:     TRACE("nla_solver", _().trace_print_ol(ac, a, c, bc, b, tout););        
  282      IF_VERBOSE(10, verbose_stream() << var_val(ac) << "(" << mul_val(ac) << "): " << ac 

  346  void order::order_lemma_on_ab_lt(new_lemma& lemma, const monic& m, const rational& sign, lpvar a, lpvar b) {
  347:     TRACE("nla_solver", tout << "sign = " << sign << ", m = "; c().print_monic(m, tout) << ", a = "; c().print_var(a, tout) <<
  348            ", b = "; c().print_var(b, tout) << "\n";);

z3/src/math/lp/nla_tangent_lemmas.cpp:
   52          get_points();
   53:         TRACE("nla_solver", print_tangent_domain(tout << "tang domain = ") << std::endl;);
   54          generate_line1();

  115              delta = std::min(delta, abs(m_correct_v - m_v));
  116:         TRACE("nla_solver", tout << "delta = " << delta << "\n";);
  117          if (!m_below){

  142              point na = m_xy + del;
  143:             TRACE("nla_solver_tp", tout << "del = " << del << std::endl;);
  144              if (!plane_is_correct_cut(na)) {
  145:                 TRACE("nla_solver_tp", tout << "exit\n";);
  146                  return;

  157          get_initial_points();
  158:         TRACE("nla_solver", tout << "xy = " << m_xy << ", correct val = " << m_correct_v;
  159                print_tangent_domain(tout << "\ntang points:") << std::endl;);

  161          push_point(m_b);
  162:         TRACE("nla_solver",
  163                tout << "pushed a = " << m_a << std::endl 

  173      bool plane_is_correct_cut(const point& plane) const {
  174:         TRACE("nla_solver", tout << "plane = " << plane << "\n";
  175                tout << "tang_plane() = " << tang_plane(plane) << ", v = " << m_v << ", correct_v = " << m_correct_v << "\n";);

z3/src/math/lp/nra_solver.cpp:
   85          }
   86:         TRACE("nra", 
   87                m_nlsat->display(tout << r << "\n");

  101                  ex.push_back(idx);
  102:                 TRACE("arith", tout << "ex: " << idx << "\n";);
  103              }

z3/src/math/lp/random_updater_def.h:
  37          m_var_set.insert(j);
  38:     TRACE("lar_solver_rand", tout << "size = " << m_var_set.size() << "\n";);
  39  }

  59          if (!m_var_set.contains(j)) {
  60:             TRACE("lar_solver_rand", tout << "skipped " << j << "\n";);
  61              continue;

  75      }
  76:     TRACE("lar_solver_rand", tout << "m_var_set.size() = " << m_var_set.size() << "\n";);
  77  }

z3/src/math/lp/var_eqs.h:
  117          while (m_uf.get_num_vars() <= max_i) m_uf.mk_var();
  118:         TRACE("nla_solver_mons", tout << v1 << " == " << v2 << " " << m_uf.find(v1.index()) << " == " << m_uf.find(v2.index()) << "\n";);
  119          m_trail.push_back(std::make_pair(v1, v2));

z3/src/math/polynomial/algebraic_numbers.cpp:
   292                  return false; // we know for sure a is not a rational
   293:             TRACE("algebraic_bug", tout << "is_rational(a):\n"; display_root(tout, a); tout << "\n"; display_interval(tout, a); tout << "\n";);
   294              algebraic_cell * c = a.to_algebraic();

   304  
   305:             TRACE("algebraic_bug", tout << "abs(an): " << qm().to_string(abs_a_n) << ", k: " << k << "\n";);
   306  

   312  
   313:             TRACE("algebraic_bug", tout << "interval after refinement: "; display_interval(tout, a); tout << "\n";);
   314  

   512              }
   513:             TRACE("algebraic", tout << "a: "; display_root(tout, a); tout << "\n";);
   514          }

   557                  upm().square_free(up.size(), up.data(), up_sqf);
   558:                 TRACE("algebraic", upm().display(tout, up_sqf.size(), up_sqf.data()); tout << "\n";);
   559                  r.push_back(up_sqf, 1);

   587                          // b < a or c < b or !(c < a)
   588:                         CTRACE("algebraic_bug", 
   589                                 (!b_lt_a && !c_lt_b && c_lt_a),

   606          void isolate_roots(scoped_upoly const & up, numeral_vector & roots) {
   607:             TRACE("algebraic", upm().display(tout, up); tout << "\n";);
   608              if (up.empty())

   627                  unsigned d = upm().degree(f);
   628:                 TRACE("algebraic", tout << "factor " << i << " degree: " << d << "\n";);
   629                  if (d == 0)

   632                  if (d == 1) {
   633:                     TRACE("algebraic", tout << "linear polynomial...\n";);
   634                      // f is a linear polynomial ax + b

   645                  unsigned sz = m_isolate_roots.size();
   646:                 TRACE("algebraic", tout << "isolated roots: " << sz << "\n";);
   647                  for (unsigned i = 0; i < sz; i++) {

   675              SASSERT(is_univariate(p));
   676:             TRACE("algebraic", tout << "isolating roots of: " << p << "\n";);
   677              if (::is_zero(p))

   693              unsigned num_roots = roots.size();
   694:             TRACE("algebraic", tout << "num-roots: " << num_roots << "\n";
   695                    for (unsigned i = 0; i < num_roots; i++) {

   706              SASSERT(is_univariate(p));
   707:             TRACE("algebraic", tout << "isolating roots of: " << p << "\n";);
   708              scoped_upoly & up     = m_isolate_tmp1;

   716              sexpr2upolynomial(upm(), p, up);
   717:             TRACE("algebraic", tout << "mk_root " << i << "\n"; upm().display(tout, up); tout << "\n";);
   718              mk_root(up, i, r);

   990          void set_core(numeral & c, scoped_upoly & p, mpbqi & r_i, upolynomial::scoped_upolynomial_sequence & seq, int lV, int uV, bool minimal) {
   991:             TRACE("algebraic", tout << "set_core p: "; upm().display(tout, p); tout << "\n";);
   992              if (bqim().contains_zero(r_i)) {

   996                      reset(c);
   997:                     TRACE("algebraic", tout << "resetting\nresult: "; display_root(tout, c); tout << "\n";);
   998                      return;

  1029              else {
  1030:                 TRACE("algebraic", tout << "set_core...\n";);
  1031                  set(c, nz_p.size(), nz_p.data(), r_i.lower(), r_i.upper(), minimal);

  1057              mk_poly(cell_a, cell_b, p);
  1058:             TRACE("anum_mk_binary", tout << "a: "; display_root(tout, a); tout << "\nb: "; display_root(tout, b); tout << "\np: ";
  1059                    upm().display(tout, p); tout << "\n";);

  1064              for (unsigned i = 0; i < num_fs; i++) {
  1065:                 TRACE("anum_mk_binary", tout << "factor " << i << "\n"; upm().display(tout, fs[i]); tout << "\n";);
  1066                  typename upolynomial::scoped_upolynomial_sequence * seq = alloc(typename upolynomial::scoped_upolynomial_sequence, upm());

  1087                          continue; // sequence was discarded because it does not contain the root.
  1088:                     TRACE("anum_mk_binary", tout << "sequence " << i << "\n"; upm().display(tout, *(seqs[i])); tout << "\n";);
  1089                      int lV = upm().sign_variations_at(*(seqs[i]), r_i.lower());

  1091                      int V  = lV - uV;
  1092:                     TRACE("algebraic", tout << "r_i: "; bqim().display(tout, r_i); tout << "\n";
  1093                            tout << "lV: " << lV << ", uV: " << uV << "\n";

  1113                      // found isolating interval
  1114:                     TRACE("anum_mk_binary", tout << "target_i: " << target_i << "\n";);
  1115                      saved_a.restore_if_too_small();

  1168                      int V  = lV - uV;
  1169:                     TRACE("algebraic", tout << "r_i: "; bqim().display(tout, r_i); tout << "\n";
  1170                            tout << "lV: " << lV << ", uV: " << uV << "\n";

  1324                  // the result is rational
  1325:                 TRACE("root_core", tout << "r_a_val: " << r_a_val << " a_val: "; qm().display(tout, a_val); tout << "\n";);
  1326                  set(b, r_a_val);

  1365              SASSERT(bqm().lt(lower, upper));
  1366:             TRACE("algebraic", tout << "root_core:\n"; upm().display(tout, p.size(), p.data()); tout << "\n";);
  1367              // p is not necessarily a minimal polynomial.

  1439          void add(algebraic_cell * a, basic_cell * b, numeral & c) {
  1440:             TRACE("algebraic", tout << "adding algebraic and basic cells:\n";
  1441                    tout << "a: "; upm().display(tout, a->m_p_sz, a->m_p); tout << " "; bqim().display(tout, a->m_interval); tout << "\n";

  1462                  to_mpq(qm(), i.upper(), iu);
  1463:                 TRACE("algebraic",
  1464                        tout << "nbv: " << nbv << "\n";

  1469                  if (!upm().convert_q2bq_interval(m_add_tmp.size(), m_add_tmp.data(), il, iu, bqm(), l, u)) {
  1470:                     TRACE("algebraic", tout << "conversion failed\n");
  1471                  }

  1473              }
  1474:             TRACE("algebraic",
  1475                    upm().display(tout, m_add_tmp.size(), m_add_tmp.data());

  1546          void mul(algebraic_cell * a, basic_cell * b, numeral & c) {
  1547:             TRACE("algebraic", tout << "mult algebraic and basic cells:\n";
  1548                    tout << "a: "; upm().display(tout, a->m_p_sz, a->m_p); tout << " "; bqim().display(tout, a->m_interval); tout << "\n";

  1573                  to_mpq(qm(), i.upper(), iu);
  1574:                 TRACE("algebraic",
  1575                        tout << "nbv: " << nbv << "\n";

  1582                  if (!upm().convert_q2bq_interval(mulp.size(), mulp.data(), il, iu, bqm(), l, u)) {
  1583:                     TRACE("algebraic", tout << "conversion failed\n");
  1584                  }
  1585              }
  1586:             TRACE("algebraic",
  1587                    upm().display(tout, mulp.size(), mulp.data());

  1684              else {
  1685:                 TRACE("algebraic_bug", tout << "before inv: "; display_root(tout, a); tout << "\n"; display_interval(tout, a); tout << "\n";);
  1686                  algebraic_cell * cell_a = a.to_algebraic();

  1695                  qm().swap(inv_lower, inv_upper);
  1696:                 TRACE("algebraic_bug", tout << "inv new_bounds: " << qm().to_string(inv_lower) << ", " << qm().to_string(inv_upper) << "\n";);
  1697                  // convert isolating interval back as a binary rational bound
  1698                  if (!upm().convert_q2bq_interval(cell_a->m_p_sz, cell_a->m_p, inv_lower, inv_upper, bqm(), lower(cell_a), upper(cell_a))) {
  1699:                     TRACE("algebraic_bug", tout << "root isolation failed\n");                    
  1700                      throw algebraic_exception("inversion of algebraic number failed");
  1701                  }
  1702:                 TRACE("algebraic_bug", tout << "after inv: "; display_root(tout, a); tout << "\n"; display_interval(tout, a); tout << "\n";);
  1703                  update_sign_lower(cell_a);

  1797  
  1798:             TRACE("algebraic", tout << "comparing\n";
  1799                    tout << "a: "; upm().display(tout, cell_a->m_p_sz, cell_a->m_p); tout << "\n"; bqim().display(tout, cell_a->m_interval);

  1898              int V =  V1 - V2;
  1899:             TRACE("algebraic", tout << "comparing using sturm\n"; 
  1900                    display_interval(tout, a) << "\n"; 

  1948          ::sign compare(numeral & a, numeral & b) {
  1949:             TRACE("algebraic", tout << "comparing: "; display_interval(tout, a); tout << " "; display_interval(tout, b); tout << "\n";);
  1950              if (a.is_basic()) {

  2063                  SASSERT(v.is_basic());
  2064:                 TRACE("var2basic", tout << "getting value of x" << x << " -> " << m().to_string(m_imp.basic_value(v)) << "\n";);
  2065                  return m_imp.basic_value(v);

  2087              polynomial::manager & ext_pm = p.m();
  2088:             TRACE("anum_eval_sign", tout << "evaluating sign of: " << p << "\n";);
  2089              while (true) {

  2095                      ext_pm.eval(p, x2v_basic, r);
  2096:                     TRACE("anum_eval_sign", tout << "all variables are assigned to rationals, value of p: " << r << "\n";);
  2097                      return ::to_sign(qm().sign(r));

  2106                  p_prime = ext_pm.substitute(p, x2v_basic);
  2107:                 TRACE("anum_eval_sign", tout << "p after eliminating rationals: " << p_prime << "\n";);
  2108  

  2130                      ext_pm.eval(p_prime, x2v_interval, ri);
  2131:                     TRACE("anum_eval_sign", tout << "evaluating using intervals: " << ri << "\n";);
  2132                      if (!bqim().contains_zero(ri)) {

  2149                              }
  2150:                             TRACE("anum_eval_sign", tout << "refined algebraic interval\n";);
  2151                              SASSERT(!v.is_basic());

  2163                      // So, restarting the whole process
  2164:                     TRACE("anum_eval_sign", tout << "restarting some algebraic_cell became basic\n";);
  2165                      continue;

  2179                  ext_pm.eval(p_prime, x2v, ra);
  2180:                 TRACE("anum_eval_sign", tout << "value of p as algebraic number " << ra << "\n";);
  2181                  if (is_zero(ra))

  2239                  unsigned k = upm().nonzero_root_lower_bound(_R.size(), _R.data());
  2240:                 TRACE("anum_eval_sign", tout << "R: " << R << "\nk: " << k << "\nri: "<< ri << "\n";);
  2241                  scoped_mpbq mL(bqm()), L(bqm());

  2266                      ext_pm.eval(p_prime, x2v_interval, ri);
  2267:                     TRACE("anum_eval_sign", tout << "evaluating using intervals: " << ri << "\n";
  2268                            tout << "zero lower bound is: " << L << "\n";);

  2284                          }
  2285:                         TRACE("anum_eval_sign", tout << "refined algebraic interval\n";);
  2286                          SASSERT(!v.is_basic());

  2337          void filter_roots(polynomial_ref const & p, polynomial::var2anum const & x2v, polynomial::var x, numeral_vector & roots) {
  2338:             TRACE("isolate_roots", tout << "before filtering roots, x: x" << x << "\n";
  2339                    for (unsigned i = 0; i < roots.size(); i++) {

  2347                  ext_var2num ext_x2v(m_wrapper, x2v, x, roots[i]);
  2348:                 TRACE("isolate_roots", tout << "filter_roots i: " << i << ", ext_x2v: x" << x << " -> "; display_root(tout, roots[i]); tout << "\n";);
  2349                  sign sign = eval_sign_at(p, ext_x2v);
  2350:                 TRACE("isolate_roots", tout << "filter_roots i: " << i << ", result sign: " << sign << "\n";);
  2351                  if (sign != 0)

  2360  
  2361:             TRACE("isolate_roots", tout << "after filtering roots:\n";
  2362                    for (unsigned i = 0; i < roots.size(); i++) {

  2386          void isolate_roots(polynomial_ref const & p, polynomial::var2anum const & x2v, numeral_vector & roots, bool nested_call = false) {
  2387:             TRACE("isolate_roots", tout << "isolating roots of: " << p << "\n";);
  2388              SASSERT(roots.empty());

  2390              if (ext_pm.is_zero(p) || ext_pm.is_const(p)) {
  2391:                 TRACE("isolate_roots", tout << "p is zero or the constant polynomial\n";);
  2392                  return;

  2395              if (ext_pm.is_univariate(p)) {
  2396:                 TRACE("isolate_roots", tout << "p is univariate, using univariate procedure\n";);
  2397                  isolate_roots(p, roots);

  2404              p_prime = ext_pm.substitute(p, x2v_basic);
  2405:             TRACE("isolate_roots", tout << "p after applying (rational fragment of) x2v:\n" << p_prime << "\n";);
  2406  
  2407              if (ext_pm.is_zero(p_prime) || ext_pm.is_const(p_prime)) {
  2408:                 TRACE("isolate_roots", tout << "p is zero or the constant polynomial after applying (rational fragment of) x2v\n";);
  2409                  return;

  2418                  }
  2419:                 TRACE("isolate_roots", tout << "p is univariate after applying (rational fragment of) x2v... using univariate procedure\n";);
  2420                  isolate_roots(p_prime, roots);

  2430              std::stable_sort(xs.begin(), xs.end(), var_degree_lt(*this, x2v));
  2431:             TRACE("isolate_roots", tout << "there are " << (xs.size() - 1) << " variables assigned to nonbasic numbers...\n";);
  2432  

  2458                  ext_pm.resultant(q, p_y, y, q);
  2459:                 TRACE("isolate_roots", tout << "resultant loop i: " << i << ", y: x" << y << "\np_y: " << p_y << "\n";
  2460                        tout << "q: " << q << "\n";);

  2467              if (ext_pm.is_zero(q)) {
  2468:                 TRACE("isolate_roots", tout << "q vanished\n";);
  2469                  // q may vanish at some of the other roots of the polynomial defining the values.

  2478                      // p_prime is linear on p, so we just evaluate the coefficients...
  2479:                     TRACE("isolate_roots", tout << "p is linear after applying (rational fragment) of x2v\n";);
  2480                      polynomial_ref c0(ext_pm);

  2489                      if (is_zero(a1)) {
  2490:                         TRACE("isolate_roots", tout << "coefficient of degree 1 vanished, so p does not have roots at x2v\n";);
  2491                          // p_prime does not have any root

  2496                      neg(roots[0]);
  2497:                     TRACE("isolate_roots", tout << "after trivial solving p has only one root:\n"; display_root(tout, roots[0]); tout << "\n";);
  2498                  }

  2511                          // the polynomial has no roots
  2512:                         TRACE("isolate_roots", tout << "all coefficients vanished... polynomial does not have roots\n";);
  2513                          return;

  2532                      q2 = z_p*xi_p + q2;
  2533:                     TRACE("isolate_roots", tout << "invoking isolate_roots with q2:\n" << q2 << "\n";
  2534                            tout << "z: x" << z << " -> "; display_root(tout, a); tout << "\n";);

  2541                  // q does not have any roots, so p_prime also does not have roots at x2v.
  2542:                 TRACE("isolate_roots", tout << "q is the constant polynomial, so p does not contain any roots at x2v\n";);
  2543              }

  2621          void select(numeral & prev, numeral & curr, numeral & result) {
  2622:             TRACE("algebraic_select",
  2623                    tout << "prev: "; display_interval(tout, prev); tout << "\n";

  2676              else {
  2677:                 TRACE("isolate_roots_bug", tout << "p: " << p << "\n";
  2678                        polynomial::var_vector xs;

  2696                  int_lt(roots[0], w);
  2697:                 TRACE("isolate_roots_bug", tout << "w: "; display_root(tout, w); tout << "\n";);
  2698                  {

  2998      void manager::power(numeral const & a, unsigned k, numeral & b) {
  2999:         TRACE("anum_detail", display_root(tout, a); tout << "^" << k << "\n";);
  3000          m_imp->power(const_cast<numeral&>(a), k, b);
  3001:         TRACE("anum_detail", tout << "^ result: "; display_root(tout, b); tout << "\n";);
  3002      }

  3004      void manager::add(numeral const & a, numeral const & b, numeral & c) {
  3005:         TRACE("anum_detail", display_root(tout, a); tout << " + "; display_root(tout, b); tout << "\n";);
  3006          m_imp->add(const_cast<numeral&>(a), const_cast<numeral&>(b), c);
  3007:         TRACE("anum_detail", tout << "+ result: "; display_root(tout, c); tout << "\n";);
  3008      }

  3016      void manager::sub(numeral const & a, numeral const & b, numeral & c) {
  3017:         TRACE("anum_detail", display_root(tout, a); tout << " - "; display_root(tout, b); tout << "\n";);
  3018          m_imp->sub(const_cast<numeral&>(a), const_cast<numeral&>(b), c);
  3019:         TRACE("anum_detail", tout << "- result: "; display_root(tout, c); tout << "\n";);
  3020      }

  3022      void manager::mul(numeral const & a, numeral const & b, numeral & c) {
  3023:         TRACE("anum_detail", display_root(tout, a); tout << " * "; display_root(tout, b); tout << "\n";);
  3024          m_imp->mul(const_cast<numeral&>(a), const_cast<numeral&>(b), c);
  3025:         TRACE("anum_detail", tout << "* result: "; display_root(tout, c); tout << "\n";);
  3026      }

z3/src/math/polynomial/linear_eq_solver.h:
   88          for (unsigned k = 0; k < n; k++) {
   89:             TRACE("linear_eq_solver", tout << "iteration " << k << "\n"; display(tout););
   90              // find pivot 

  122              --k;
  123:             TRACE("linear_eq_solver", tout << "iteration " << k << "\n"; display(tout););
  124              SASSERT(m.is_one(A[k][k]));

z3/src/math/polynomial/polynomial.cpp:
   361                      if (get_var(i) < x) {
   362:                         CTRACE("poly_bug", !(y != null_var && get_var(i) <= y),
   363                                 tout << "m: "; display(tout); tout << "\n";

   683          bool operator()(monomial * m1, monomial * m2) const {
   684:             TRACE("lex_bug", tout << "min: x" << m_min << "\n"; m1->display(tout); tout << "\n"; m2->display(tout); tout << "\n";);
   685              return lex_compare2(m1, m2, m_min) < 0;

   795              dec_ref(m_unit);
   796:             CTRACE("polynomial", !m_monomials.empty(),
   797                     tout << "monomials leaked (can happen during cancelation)\n";

   963              product_tmp.set_size(j);
   964:             TRACE("monomial_mul_bug",
   965                    tout << "before mk_monomial\n";

   970              monomial * r = mk_monomial(product_tmp);
   971:             TRACE("monomial_mul_bug",
   972                    tout << "j: " << j << "\n";

  1454                  for (unsigned i = 0; i < m_size - 1; i++) {
  1455:                     CTRACE("poly_bug", lex_compare(m_ms[i], m_ms[i+1]) <= 0,
  1456                             tout << "i: " << i << "\npoly: "; display(tout, nm); tout << "\n";);

  2374              m_mgcd_skeletons.reset();
  2375:             CTRACE("polynomial", !m_polynomials.empty(), 
  2376                     tout << "leaked polynomials\n";

  2434          void del(polynomial * p) {
  2435:             TRACE("polynomial", tout << "deleting: "; p->display(tout, m_manager); tout << "\n";);
  2436              if (m_del_eh != nullptr) {

  2875              void add(numeral const & input, polynomial const * output) {
  2876:                 TRACE("newton", tout << m().to_string(input) << " -> "; output->display(tout, m()); tout << "\n";);
  2877                  SASSERT(m().modular());

  2893                      m_invs.push_back(product);
  2894:                     TRACE("newton", tout << "invs[" << k << "]: " << product << "\n";);
  2895                      SASSERT(m().eq(m_inputs[k], input));

  2913                      m_vs.push_back(aux_poly);
  2914:                     TRACE("newton", tout << "vs[" << k << "]: " << aux_poly << "\n";);
  2915                  }

  2932                  for (int k = d - 1; k >= 0; k--) {
  2933:                     TRACE("newton", tout << "u: " << u << "\n";);
  2934                      // create polynomial (x - inputs[k])

  2938                      aux_poly = pm.mk_linear(1, &one, &x, c);
  2939:                     TRACE("newton", tout << "(x - inputs[k]): " << aux_poly << "\n";);
  2940                      // u <- u * (x - inputs[k]) + vs[k]

  2943                  }
  2944:                 TRACE("newton", tout << "result u: " << u << "\n";);
  2945                  r = u;

  3054                  }
  3055:                 TRACE("skeleton",
  3056                        tout << "x: x" << m_x << "\n";

  3199                          unsigned output_idx = e.m_first_power_idx + i;
  3200:                         TRACE("sparse_interpolator", tout << "adding new equation:\n";
  3201                                for (unsigned i = 0; i < num_pws; i++) {

  3206                      }
  3207:                     TRACE("sparse_interpolator",
  3208                            tout << "find coefficients of:\n";

  3309              SASSERT(m_cheap_som_buffer.empty());
  3310:             TRACE("coeff_bug", tout << "p: "; p->display(tout, m_manager); tout << "\nx: " << x << ", k: " << k << "\n";);
  3311              unsigned sz = p->size();

  3496          void iccp(polynomial const * p, var x, numeral & i, polynomial_ref & c, polynomial_ref & pp) {
  3497:             TRACE("polynomial", tout << "iccp x" << x << "\n"; p->display(tout, m_manager); tout << "\n";);
  3498              if (is_zero(p)) {

  3535                  unsigned   k = m->degree_of(x);
  3536:                 TRACE("polynomial", tout << "degree of x" << x << " at "; m->display(tout); tout << " is " << k << "\n";);
  3537                  if (iccp_filter[k] == 0)

  3555              ic(p, i, pp);
  3556:             TRACE("polynomial", tout << "p: "; p->display(tout, m_manager); tout << "\ni: " << m_manager.to_string(i) << "\npp: " << pp << "\n";);
  3557              // Compute c using the gcd of coeffs of x^k for k's in iccp_powers

  3570              flip_sign_if_lm_neg(c);
  3571:             TRACE("polynomial", tout << "pp: " << pp << "\nc: " << c << "\n";);
  3572              pp = exact_div(pp, c);

  3598          void gcd_prs(polynomial const * u, polynomial const * v, var x, polynomial_ref & r) {
  3599:             TRACE("polynomial_gcd", tout << "gcd prs with x" << x << " for\nu: ";
  3600                    u->display(tout, m_manager); tout << "\nv: "; v->display(tout, m_manager); tout << "\n";);

  3614              m_manager.gcd(i_u, i_v, d_a);
  3615:             TRACE("polynomial_gcd_detail",
  3616                    tout << "After GCD of the content\n";

  3633                  unsigned delta = degree(pp_u, x) - degree(pp_v, x);
  3634:                 TRACE("polynomial_gcd_detail",
  3635                        tout << "iteration: " << counter << "\n";

  3639                  if (is_zero(rem)) {
  3640:                     TRACE("polynomial", tout << "rem is zero...\npp_v: " << pp_v << "\n";);
  3641                      flip_sign_if_lm_neg(pp_v);

  3646                  if (is_const(rem)) {
  3647:                     TRACE("polynomial", tout << "rem is a constant: " << rem << "\nr: " << d_r << "\nd_a: " << d_a << "\n";);
  3648                      r = mul(d_a, d_r);

  3683              SASSERT(m().modular());
  3684:             CTRACE("mgcd", !is_univariate(u) || !is_univariate(v),
  3685                     tout << "euclid_gcd, polynomials are not univariate\n"; u->display(tout, m()); tout << "\n"; v->display(tout, m()); tout << "\n";);

  3720              lex_sort(C2);
  3721:             TRACE("CRA", tout << "C1: "; C1->display(tout, m()); tout << "\nC2: "; C2->display(tout, m()); tout << "\n";);
  3722              SASSERT(m_cheap_som_buffer.empty());

  3730              SASSERT(m().is_one(g));
  3731:             TRACE("CRA", tout << "b1: " << b1 << ", b2: " << b2 << ", inv1: " << inv1 << ", inv2: " << inv2 << "\n";);
  3732              // b1*inv1 + b2.inv2 = 1

  3736              m().m().mod(inv2, b1, inv2);
  3737:             TRACE("CRA", tout << "inv1: " << inv1 << ", inv2: " << inv2 << "\n";);
  3738              scoped_numeral a1(m());

  3741              m().mul(b1, inv1, a2); // a2 is the multiplicator for coefficients of C2
  3742:             TRACE("CRA", tout << "a1: " << a1 << ", a2: " << a2 << "\n";);
  3743              // new bound

  3751              m().neg(lower);
  3752:             TRACE("CRA", tout << "lower: " << lower << ", upper: " << upper << "\n";);
  3753  

  3771                      while (i2 < sz2) {
  3772:                         TRACE("CRA", tout << "adding C2 rest\n";);
  3773                          ADD(zero, C2->a(i2), C2->m(i2));

  3779                      while (i1 < sz1) {
  3780:                         TRACE("CRA", tout << "adding C1 rest\n";);
  3781                          ADD(C1->a(i1), zero, C1->m(i1));

  3790                      ADD(C1->a(i1), C2->a(i2), m1);
  3791:                     TRACE("CRA",
  3792                            tout << "C1->a(i1): " << m().to_string(C1->a(i1)) << ", C2->a(i2): " << m().to_string(C2->a(i2)) << ", new_a: " << new_a << "\n";

  3797                  else if (s > 0) {
  3798:                     TRACE("CRA", tout << "C1 mon biggerr, adding it...\n";);
  3799                      ADD(C1->a(i1), zero, m1);

  3802                  else {
  3803:                     TRACE("CRA", tout << "C2 mon bigger, adding it...\n";);
  3804                      ADD(zero, C2->a(i2), m2);

  3812          void uni_mod_gcd(polynomial const * u, polynomial const * v, polynomial_ref & r) {
  3813:             TRACE("mgcd", tout << "univ_modular_gcd\nu: "; u->display(tout, m_manager); tout << "\nv: "; v->display(tout, m_manager); tout << "\n";);
  3814              SASSERT(!m().modular());

  3847                  m().set(p, g_big_primes[i]);
  3848:                 TRACE("mgcd", tout << "trying prime: " << p << "\n";);
  3849                  {

  3853                      if (degree(u_Zp, x) < d_u) {
  3854:                         TRACE("mgcd", tout << "bad prime, leading coefficient vanished\n";);
  3855                          continue; // bad prime

  3857                      if (degree(v_Zp, x) < d_v) {
  3858:                         TRACE("mgcd", tout << "bad prime, leading coefficient vanished\n";);
  3859                          continue; // bad prime

  3867                  }
  3868:                 TRACE("mgcd", tout << "new q:\n" << q << "\n";);
  3869                  if (is_const(q)) {
  3870:                     TRACE("mgcd", tout << "done, modular gcd is one\n";);
  3871                      if (m().is_one(d_a))

  3883                          // discard accumulated image, it was affected by unlucky primes
  3884:                         TRACE("mgcd", tout << "discarding image\n";);
  3885                          C_star = q;

  3889                          CRA_combine_images(q, p, C_star, bound, C_star);
  3890:                         TRACE("mgcd", tout << "new combined:\n" << C_star << "\n";);
  3891                      }

  3893                  candidate = pp(C_star, x);
  3894:                 TRACE("mgcd", tout << "candidate:\n" << candidate << "\n";);
  3895                  scoped_numeral lc_candidate(m());

  3899                      divides(candidate, pp_v)) {
  3900:                     TRACE("mgcd", tout << "found GCD\n";);
  3901                      r = mul(d_a, candidate);
  3902                      flip_sign_if_lm_neg(r);
  3903:                     TRACE("mgcd", tout << "r: " << r << "\n";);
  3904                      return;

  3920              SASSERT(m().modular());
  3921:             TRACE("mgcd_detail", tout << "iccp_ZpX, p: "; p->display(tout, m()); tout << "\nvar x" << x << "\n";);
  3922              if (is_zero(p)) {
  3923:                 TRACE("mgcd_detail", tout << "iccp_ZpX, p is zero\n";);
  3924                  m_manager.set(ci, 0);

  3929              if (is_const(p)) {
  3930:                 TRACE("mgcd_detail", tout << "iccp_ZpX, p is constant\n";);
  3931                  m_manager.set(ci, p->a(0));

  3937              if (d == 0) {
  3938:                 TRACE("mgcd_detail", tout << "iccp_ZpX, degree(p, x) == 0\n";);
  3939                  ic(p, ci, pp);

  3964                  // divide by x^min_degree
  3965:                 TRACE("mgcd_detail", tout << "iccp_ZpX, all monomials contain x" << x << ", dividing by x" << x << "^" << min_degree << "\n";);
  3966                  polynomial_ref xmin(m_wrapper);

  3996                      m_m2pos.reset(no_x_ms[i]);
  3997:                 TRACE("mgcd_detail", tout << "iccp_ZpX, cheap case... invoking ic\n";);
  3998                  ic(p, ci, pp);

  4044              if (!is_const(g)) {
  4045:                 CTRACE("content_bug", !divides(g, pp),
  4046                         tout << "GF(" << m().m().to_string(m().p()) << ")\n";

  4084              SASSERT(!m_som_buffer.empty());
  4085:             TRACE("mgcd_detail", tout << "maximal monomial: "; max_m->display(tout); tout << "\n";);
  4086              return m_som_buffer.mk();

  4120                           unsigned idx, var_buffer const & vars, polynomial_ref & r) {
  4121:             TRACE("mgcd", tout << "mod_gcd_rec\nu: "; u->display(tout, m_manager, true); tout << "\nv: "; v->display(tout, m_manager, true); tout << "\n";);
  4122              unsigned num_vars = vars.size();

  4127                  euclid_gcd(u, v, r);
  4128:                 TRACE("mgcd", tout << "mod_gcd_rec result: "; r->display(tout, m_manager, true); tout << "\n";);
  4129                  return;

  4142              polynomial_ref lc_g(m_wrapper);
  4143:             TRACE("mgcd_detail",
  4144                    tout << "idx: " << idx << "\n";

  4156              euclid_gcd(lc_u, lc_v, lc_g);
  4157:             TRACE("mgcd_detail",
  4158                    tout << "c_g = "; c_g->display(tout, m_manager, true); tout << "\n";

  4183                  }
  4184:                 TRACE("mgcd", tout << "x" << x << " -> " << val << "\n";);
  4185                  u1 = substitute(pp_u, 1, &x, &(val.get()));

  4191                  unsigned deg_q = q_var == null_var ? 0 : degree(q, q_var);
  4192:                 TRACE("mgcd_detail", tout << "counter: " << counter << "\nidx: " << idx << "\nq: " << q << "\ndeg_q: " << deg_q << "\nmin_deg_q: " <<
  4193                        min_deg_q << "\nnext_x: x" << vars[idx+1] << "\nmax_var(q): " << q_var << "\n";);
  4194                  if (deg_q < min_deg_q) {
  4195:                     TRACE("mgcd_detail", tout << "resetting...\n";);
  4196                      counter   = 0;

  4209                  else if (deg_q == min_deg_q) {
  4210:                     TRACE("mgcd_detail", tout << "adding sample point...\n";);
  4211                      if (sk == nullptr) {

  4219                  else {
  4220:                     TRACE("mgcd", tout << "skipping q...\n";);
  4221                      continue;

  4226                      interpolator.mk(x, H);
  4227:                     TRACE("mgcd_detail", tout << "idx: " << idx << "\ncandidate H: " << H << "\n";);
  4228                      lc_H = lc_glex_ZpX(H, x);
  4229:                     TRACE("mgcd_detail", tout << "idx: " << idx << "\nlc_H: " << lc_H << "\nlc_g: " << lc_g << "\n";);
  4230                      if (eq(lc_H, lc_g)) {

  4247                          C = normalize(H);
  4248:                     TRACE("mgcd_detail", tout << "C: " << C << "\npp_u: " << pp_u << "\npp_v: " << pp_v << "\ndivides(C, pp_u): " <<
  4249                            divides(C, pp_u) << "\ndivides(C, pp_v): " << divides(C, pp_v) << "\n";);

  4265                  if (done) {
  4266:                     TRACE("mgcd", tout << "idx: " << idx << "\nresult: " << r << "\n";);
  4267                      if (sk == nullptr && m_use_sparse_gcd) {

  4281              m_mgcd_iterpolators.set_owner(this);
  4282:             TRACE("mgcd", tout << "mod_gcd\nu: "; u->display(tout, m_manager, true); tout << "\nv: "; v->display(tout, m_manager, true); tout << "\n";);
  4283:             TRACE("mgcd_call", tout << "mod_gcd\nu: "; u->display(tout, m_manager, true); tout << "\nv: "; v->display(tout, m_manager, true); tout << "\n";);
  4284              SASSERT(!m().modular());

  4330                  m().set(p, g_big_primes[i]);
  4331:                 TRACE("mgcd", tout << "trying prime: " << p << "\n";);
  4332                  {

  4335                      if (u_Zp->size() != pp_u->size()) {
  4336:                         TRACE("mgcd", tout << "bad prime, coefficient(s) vanished\n";);
  4337                          continue; // bad prime some monomial vanished

  4340                      if (v_Zp->size() != pp_v->size()) {
  4341:                         TRACE("mgcd", tout << "bad prime, coefficient(s) vanished\n";);
  4342                          continue; // bad prime some monomial vanished
  4343                      }
  4344:                     TRACE("mgcd", tout << "u_Zp: " << u_Zp << "\nv_Zp: " << v_Zp << "\n";);
  4345                      mod_gcd_rec(u_Zp, v_Zp, g_big_primes[i], 0, vars, q);

  4350                  }
  4351:                 TRACE("mgcd", tout << "new q:\n" << q << "\n";);
  4352                  if (is_const(q)) {
  4353:                     TRACE("mgcd", tout << "done, modular gcd is one\n";);
  4354                      r = mk_const(d_a);

  4366                          // maximal monomial of q is smaller than maximal monomial of C_star
  4367:                         TRACE("mgcd", tout << "discarding image\n";);
  4368                          C_star = q;

  4372                          CRA_combine_images(q, p, C_star, bound, C_star);
  4373:                         TRACE("mgcd", tout << "new combined:\n" << C_star << "\n";);
  4374                      }

  4376                  candidate = normalize(C_star);
  4377:                 TRACE("mgcd", tout << "candidate:\n" << candidate << "\n";);
  4378                  scoped_numeral lc_candidate(m());

  4382                      divides(candidate, pp_v)) {
  4383:                     TRACE("mgcd", tout << "found GCD\n";);
  4384                      r = mul(d_a, candidate);
  4385                      flip_sign_if_lm_neg(r);
  4386:                     TRACE("mgcd", tout << "r: " << r << "\n";);
  4387                      return;

  4397              power_buffer v_var_degrees;
  4398:             TRACE("gcd_calls", tout << "gcd\nu: "; u->display(tout, m_manager); tout << "\nv: "; v->display(tout, m_manager); tout << "\n";);
  4399:             TRACE("polynomial_gcd",
  4400                    tout << "gcd\nu: "; u->display(tout, m_manager); tout << "\nv: "; v->display(tout, m_manager);

  4432  
  4433:             TRACE("polynomial_gcd",
  4434                    tout << "u var info\n"; for (unsigned i = 0; i < u_var_degrees.size(); i++) tout << u_var_degrees[i] << " "; tout << "\n";

  4533                              gcd_prs(orig_u, orig_v, x, r2);
  4534:                             CTRACE("mgcd_bug", !eq(r, r2), tout << "u: " << orig_u << "\nv: " << orig_v << "\nr1: " << r << "\nr2: " << r2 << "\n";);
  4535                              SASSERT(eq(r, r2));

  4560                  unsigned   d = m->degree_of(x);
  4561:                 TRACE("polynomial", m->display(tout); tout << " degree_of x" << x << ": " << d << "\n";);
  4562                  if (d > 0) {

  4907              polynomial * p = mk_univariate(x, 1, as);
  4908:             TRACE("polynomial", tout << "x - c: "; p->display(tout, m_manager); tout << "\n";);
  4909              m_manager.del(as[0]);

  4951              SASSERT(!ModD || x2d != 0);
  4952:             TRACE("polynomial", tout << "pseudo_division\np: "; p->display(tout, m_manager);
  4953                    tout << "\nq: "; q->display(tout, m_manager); tout << "\nx: " << x << "\n";);

  4997                  checkpoint();
  4998:                 TRACE("polynomial",
  4999                        tout << "A: "; A->display(tout, m_manager); tout << "\n";

  5015                              pw(l_B, e, l_B_e);
  5016:                             TRACE("polynomial", tout << "l_B_e: " << l_B_e << "\n";);
  5017                              if (Quotient) {

  5053                          m_prime = div_x_k(m, x, deg_B);
  5054:                         CTRACE("polynomial", m->degree_of(x) != deg_R - deg_B,
  5055                                 tout << "deg_R: " << deg_R << ", deg_B: " << deg_B << ", x: " << x << "\n";

  5114              bool is_eq = eq(lhs, rhs);
  5115:             TRACE("pseudo_remainder",
  5116                    tout << "pseudo_division bug\n";

  5159          polynomial * exact_div(polynomial const * p, polynomial const * q) {
  5160:             TRACE("polynomial", tout << "exact division\np: "; p->display(tout, m_manager); tout << "\nq: "; q->display(tout, m_manager); tout << "\n";);
  5161              if (is_zero(p))

  5185                  VERIFY(div(m_r, m_q, m_r_q));
  5186:                 TRACE("polynomial", tout << "m_r: "; m_r->display(tout); tout << "\nm_q: "; m_q->display(tout); tout << "\n";
  5187                        if (m_r_q) { tout << "m_r_q: "; m_r_q->display(tout); tout << "\n"; });

  5197          bool divides(polynomial const * q, polynomial const * p) {
  5198:             TRACE("polynomial", tout << "divides\nq: "; q->display(tout, m_manager); tout << "\np: "; p->display(tout, m_manager); tout << "\n";);
  5199:             TRACE("divides", tout << "divides\nq: "; q->display(tout, m_manager); tout << "\np: "; p->display(tout, m_manager); tout << "\n";);
  5200              if (is_zero(p))

  5223                  m_r_q_ref = m_r_q;
  5224:                 TRACE("polynomial", tout << "m_r: "; m_r->display(tout); tout << "\nm_q: "; m_q->display(tout); tout << "\n";
  5225                        if (m_r_q) { tout << "m_r_q: "; m_r_q->display(tout); tout << "\n"; });

  5298                  pseudo_remainder(h_0, h_1, x, d, h_2);
  5299:                 TRACE("polynomial", tout << "h_0: " << h_0 << "\nh_1: " << h_1 << "\nh_2: " << h_2 << "\n";);
  5300                  SASSERT(degree(h_2, x) < degree(h_1, x));

  5404              B = const_cast<polynomial*>(q);
  5405:             TRACE("resultant", tout << "resultant(A, B, x)\nA: " << A << "\nB: " << B << "\nx: " << x << "\n";);
  5406              // Res(0, B) = Res(A, 0) = 0

  5444              //
  5445:             TRACE("resultant", tout << "resultant(A, B, x) after normalization\nA: " << A << "\nB: " << B << "\nx: " << x << "\n";
  5446                    tout << "t: " << t << "\n";);

  5466              while (true) {
  5467:                 TRACE("resultant", tout << "A: " << A << "\nB: " << B << "\n";);
  5468                  degA = degree(A, x);

  5525              bool sign = (static_cast<uint64_t>(m) * static_cast<uint64_t>(m-1))%4 != 0;
  5526:             TRACE("resultant", tout << "discriminant sign: " << sign << "\n";);
  5527              scoped_numeral lc(m_manager);

  5572                      exact_pseudo_remainder(sRes.get(j+1), sRes.get(j), x, prem);
  5573:                     TRACE("psc", tout << "j: " << j << "\nsRes_j+1: "; sRes.get(j+1)->display(tout, m_manager);
  5574                            tout << "\nsRes_j: "; sRes.get(j)->display(tout, m_manager);

  5619              unsigned sz = S.size();
  5620:             TRACE("psc", tout << "subresultant_chain\n";
  5621                    for (unsigned i = 0; i < sz; i++) { tout << "i: " << i << " "; S.get(i)->display(tout, m_manager); tout << "\n"; });

  5703              unsigned n = d - degree(S_d_1, x) - 1;
  5704:             TRACE("Lazard", tout << "lc_S_d: "; lc_S_d->display(tout, m_manager); tout << "\nS_d_1: "; S_d_1->display(tout, m_manager);
  5705                    tout << "\nn: " << n << "\n";);

  5713              unsigned a = 1 << log2(n);
  5714:             TRACE("Lazard", tout << "a: " << a << "\n";);
  5715              SASSERT(a <= n);

  5724                  C = exact_div(C, Y);
  5725:                 TRACE("Lazard", tout << "loop a: " << a << "\nC : " << C << "\n";);
  5726                  if (n >= a) {

  5730                      n = n - a;
  5731:                     TRACE("Lazard", tout << "if, C: " << C << "\n";);
  5732                  }
  5733              }
  5734:             TRACE("Lazard", tout << "C: " << C << "\nY: " << Y << "\n";);
  5735              S_e = mul(C, S_d_1);

  5794          void psc_chain_optimized_core(polynomial const * P, polynomial const * Q, var x, polynomial_ref_vector & S) {
  5795:             TRACE("psc_chain_classic", tout << "P: "; P->display(tout, m_manager); tout << "\nQ: "; Q->display(tout, m_manager); tout << "\n";);
  5796              unsigned degP = degree(P, x);

  5814                      return;
  5815:                 TRACE("psc_chain_classic", tout << "A: " << A << "\nB: " << B << "\ns: " << s << "\nd: " << d << ", e: " << e << "\n";);
  5816                  // B is S_{d-1}

  5861          void psc_chain_classic_core(polynomial const * P, polynomial const * Q, var x, polynomial_ref_vector & S) {
  5862:             TRACE("psc_chain_classic", tout << "P: "; P->display(tout, m_manager); tout << "\nQ: "; Q->display(tout, m_manager); tout << "\n";);
  5863              unsigned degP = degree(P, x);

  5882                      return;
  5883:                 TRACE("psc_chain_classic", tout << "A: " << A << "\nB: " << B << "\ns: " << s << "\nd: " << d << ", e: " << e << "\n";);
  5884                  // B is S_{d-1}

  6014              scoped_numeral a(m_manager);
  6015:             TRACE("sqrt_bug",
  6016                    tout << "sqrt:    "; p->display(tout, m_manager); tout << "\n";

  6075                  checkpoint();
  6076:                 TRACE("sqrt_bug", tout << "R: "; R.display(tout); tout << "C: "; C.display(tout););
  6077                  unsigned curr_max = C.graded_lex_max_pos();

  6115          void rename(unsigned sz, var const * xs) {
  6116:             TRACE("rename", for (unsigned i = 0; i < sz; i++) tout << xs[i] << " "; tout << "\n";
  6117                    tout << "polynomials before rename\n";

  6131              }
  6132:             TRACE("rename",
  6133                    tout << "polynomials after rename\n";

  6404          polynomial * substitute(polynomial const * p, unsigned xs_sz, var const * xs, numeral const * vs) {
  6405:             TRACE("polynomial", tout << "substitute num_vars: " << xs_sz << "\n";
  6406                    for (unsigned i = 0; i < xs_sz; i++) { tout << "x" << xs[i] << " -> " << m_manager.to_string(vs[i]) << "\n"; });

  6434                  new_m.set_size(new_msz);
  6435:                 TRACE("polynomial", tout << "processing " << m_manager.to_string(p->a(i)) << " "; m->display(tout); tout << "\n";
  6436                        tout << "new_a: " << m_manager.to_string(new_a) << " "; mk_monomial(new_m)->display(tout); tout << "\n";);

  6478                           unsigned start, unsigned end, var x, typename ValManager::numeral & r) {
  6479:             TRACE("eval_bug", tout << "p: "; p->display(tout, m()); tout << "\n";
  6480                    tout << "start: " << start << ", end: " << end << ", x: " << x << "\n";);

  6544              }
  6545:             TRACE("eval_bug", tout << "result for start: " << start << ", end: " << end << ", x: " << x << "\n";
  6546                    tout << "r: "; vm.display(tout, r); tout << "\n";);

  6618          void acc_constant(factors & r, numeral const & c) {
  6619:             TRACE("factor_bug", tout << "acc_constant, c: "; m_manager.display(tout, c); tout << "\n";);
  6620              scoped_numeral new_c(m_manager);

  6635              SASSERT(is_square_free(p, x));
  6636:             TRACE("factor", tout << "factor square free (degree == 1):\n"; p->display(tout, m_manager); tout << "\n";);
  6637              // easy case

  6644              SASSERT(is_square_free(p, x));
  6645:             TRACE("factor", tout << "factor square free (degree == 2):\n"; p->display(tout, m_manager); tout << "\n";);
  6646  

  6652              c = coeff(p, x, 0);
  6653:             TRACE("factor", tout << "a: " << a << "\nb: " << b << "\nc: " << c << "\n";);
  6654              // make sure the leading monomoal of a is positive

  6676              polynomial_ref disc_sqrt(pm());
  6677:             TRACE("factor", tout << "disc: " << disc << "\n";);
  6678              if (!sqrt(disc, disc_sqrt)) {

  6692              });
  6693:             TRACE("factor", tout << "disc_sqrt: " << disc_sqrt << "\n";);
  6694              // p = cont*(2*a*x + b - disc_sqrt)*(2*a*x + b + disc_sqrt)

  6706              f2 = add(f2, disc_sqrt);
  6707:             TRACE("factor", tout << "before pp\nf1: " << f1 << "\nf2: " << f2 << "\n";
  6708                    polynomial_ref cf1(pm()); m_wrapper.content(f1, x, cf1);

  6712              f2 = pp(f2, x);
  6713:             TRACE("factor", tout << "f1: " << f1 << "\nf2: " << f2 << "\n";);
  6714              DEBUG_CODE({

  6729              SASSERT(!is_zero(p));
  6730:             TRACE("factor", tout << "factor square free univariate:\n"; p->display(tout, m_manager); tout << "\n";);
  6731  

  6747                  // Convert factors back into polynomial objects
  6748:                 TRACE("factor_bug", tout << "factoring fs constant: " << m().to_string(fs.get_constant()) << "\np:\n";
  6749                        p->display(tout, m()); tout << "\n";);

  6755                      f = to_polynomial(f1.size(), f1.data(), x);
  6756:                     TRACE("factor_bug",
  6757                            tout << "uni-factor:\n"; upm().display(tout, f1); tout << "\n";

  6760                  }
  6761:                 TRACE("factor_bug", tout << "end-factors...\n";);
  6762                  SASSERT(m().is_one(fs.get_constant()) || m().is_minus_one(fs.get_constant()));

  6771              SASSERT(is_square_free(p, x));
  6772:             TRACE("factor", tout << "factor square free (degree > 2):\n"; p->display(tout, m_manager); tout << "\n";);
  6773  

  6795          void factor_core(polynomial const * p, factors & r, factor_params const & params) {
  6796:             TRACE("factor", tout << "factor_core\np: "; p->display(tout, m_manager); tout << "\n";);
  6797:             TRACE("factor_bug", tout << "factors r.get_constant(): " << m_manager.to_string(r.get_constant()) << "\n";);
  6798              SASSERT(!is_zero(p));

  6809              iccp(p, x, i, c, pp);
  6810:             TRACE("factor", tout << "i: " << i << "\n";);
  6811              acc_constant(r, i);

  6835                      checkpoint();
  6836:                     TRACE("factor", tout << "factor_core main loop j: " << j << "\nA: " << A << "\nB: " << B << "\n";);
  6837                      // A is of the form       P_j * P_{j+1} * P_{j+2}   * ... * P_k

  6847                      else {
  6848:                         TRACE("factor", tout << "const C: " << C << "\n";);
  6849                          SASSERT(C->size() == 1);

  6869              factor_core(p, r, params);
  6870:             TRACE("factor_bug", tout << "[factor] end, r.get_constant(): " << m_manager.to_string(r.get_constant()) << "\n";);
  6871          }

z3/src/math/polynomial/upolynomial_factorization.cpp:
    96  
    97:         TRACE("polynomial::factorization::bughunt", tout << "polynomial::berlekamp_matrix("; m_upm.display(tout, f); tout << ", " << p << ")" << endl;);
    98  

   141  
   142:         TRACE("polynomial::factorization::bughunt", tout << "polynomial::berlekamp_matrix():" << endl; display(tout); tout << endl;);
   143      }

   197      
   198:         TRACE("polynomial::factorization::bughunt", tout << "polynomial::diagonalize():" << endl; display(tout); tout << endl;);
   199          

   255  
   256:     TRACE("polynomial::factorization", tout << "polynomial::square_free_factor("; upm.display(tout, f); tout << ") over Z_" << p << endl;);    
   257  

   267      sq_free_factors.set_constant(constant);
   268:     TRACE("polynomial::factorization::bughunt", 
   269          tout << "Initial factors: " << sq_free_factors << endl;

   284          unsigned k = 0;
   285:         TRACE("polynomial::factorization::bughunt", tout << "k = 0" << endl;);    
   286  

   288          upm.derivative(T_0.size(), T_0.data(), T_0_d);
   289:         TRACE("polynomial::factorization::bughunt", 
   290              tout << "T_0_d = T_0.derivative(x)" << endl;    

   295          upm.gcd(T_0.size(), T_0.data(), T_0_d.size(), T_0_d.data(), T);
   296:         TRACE("polynomial::factorization::bughunt", 
   297              tout << "T = T_0.gcd(T_0_d)" << endl;

   302          upm.div(T_0.size(), T_0.data(), T.size(), T.data(), V);
   303:         TRACE("polynomial::factorization::bughunt", 
   304              tout << "V = T_0.quo_rem(T)[0]" << endl;

   313                  upm.div(T.size(), T.data(), V.size(), V.data(), T);
   314:                 TRACE("polynomial::factorization::bughunt", 
   315                      tout << "T = T.quo_rem(V)[0]" << endl;

   323              upm.gcd(T.size(), T.data(), V.size(), V.data(), W);
   324:             TRACE("polynomial::factorization::bughunt", 
   325                  tout << "W = T.gcd(V)" << endl;

   330              upm.div(V.size(), V.data(), W.size(), W.data(), A_ek);
   331:             TRACE("polynomial::factorization::bughunt", 
   332                  tout << "A_ek = V.quo_rem(W)[0]" << endl;

   337              V.swap(W);
   338:             TRACE("polynomial::factorization::bughunt", 
   339                  tout << "V = W" << endl;    

   344              upm.div(T.size(), T.data(), V.size(), V.data(), T);
   345:             TRACE("polynomial::factorization::bughunt", 
   346                  tout << "T = T.quo_rem(V)[0]" << endl;

   351              if (A_ek.size() > 1) {
   352:                 TRACE("polynomial::factorization::bughunt", tout << "Factor: ("; upm.display(tout, A_ek); tout << ")^" << e*k << endl;);    
   353                  sq_free_factors.push_back(A_ek, e*k);

   363          }
   364:         TRACE("polynomial::factorization::bughunt", 
   365              tout << "T_0 = "; upm.display(tout, T_0); tout << endl;

   368  
   369:     TRACE("polynomial::factorization", tout << "polynomial::square_free_factor("; upm.display(tout, f); tout << ") => " << sq_free_factors << endl;);    
   370  }

   374  
   375:     TRACE("polynomial::factorization", 
   376            unsigned p = get_p_from_manager(upm.m());

   398  
   399:     TRACE("polynomial::factorization", tout << "polynomial::factor("; upm.display(tout, f); tout << ") => " << factors << endl;);    
   400  

   413      
   414:     TRACE("polynomial::factorization", tout << "upolynomial::factor_square_free_berlekamp("; upm.display(tout, f); tout << ", " << p << ")" << endl;);    
   415      SASSERT(zpm.is_one(f.back()));

   427          // since r == 1 == number of factors, then f is irreducible
   428:         TRACE("polynomial::factorization", tout << "upolynomial::factor_square_free_berlekamp("; upm.display(tout, f); tout << ", " << p << ") => " << factors << endl;);    
   429          return false;

   431  
   432:     TRACE("polynomial::factorization::bughunt", tout << "upolynomial::factor_square_free_berlekamp(): computing factors, expecting " << r << endl;);        
   433  

   442  
   443:         TRACE("polynomial::factorization::bughunt", 
   444              tout << "null vector: "; 

   451          upm.trim(v_k);
   452:         // TRACE("polynomial::factorization", tout << "v_k = "; upm.display(tout, v_k); tout << endl;);    
   453          

   481  
   482:                     TRACE("polynomial::factorization::bughunt", 
   483                          tout << "current_factor = "; upm.display(tout, current_factor); tout << endl;

   497                  if (factors.distinct_factors() - first_factor == r) {
   498:                     TRACE("polynomial::factorization", tout << "polynomial::factor("; upm.display(tout, f); tout << ", " << p << ") => " << factors << " of degree " << factors.get_degree() << endl;);    
   499                      return true;

   535      if (!test1.empty()) {
   536:         TRACE("polynomial::factorization::bughunt", 
   537              tout << "sage: R.<x> = ZZ['x']" << endl;

   588      
   589:     TRACE("polynomial::factorization::bughunt", 
   590          tout << "polynomial::hensel_lift(";

   613      to_zp_manager(r_upm, f);
   614:     TRACE("polynomial::factorization", 
   615          tout << "f = "; upm.display(tout, f); tout << endl;

   636      scoped_numeral_vector Vf(r_upm.m()), t(r_upm.m()), S(r_upm.m());
   637:     TRACE("polynomial::factorization::bughunt", 
   638          tout << "V == "; upm.display(tout, V); tout << endl;

   640      r_upm.mul(V.size(), V.data(), f.size(), f.data(), Vf);
   641:     TRACE("polynomial::factorization::bughunt", 
   642          tout << "Vf = V*f" << endl; 

   645      r_upm.div_rem(Vf.size(), Vf.data(), A.size(), A.data(), t, S);    
   646:     TRACE("polynomial::factorization::bughunt", 
   647          tout << "[t, S] = Vf.quo_rem(A)" << endl; 

   652      r_upm.mul(U.size(), U.data(), f.size(), f.data(), T); // T = fU
   653:     TRACE("polynomial::factorization::bughunt", 
   654          tout << "T == U*f" << endl; 

   657      r_upm.mul(B.size(), B.data(), t.size(), t.data(), tmp); // tmp = Bt
   658:     TRACE("polynomial::factorization::bughunt", 
   659          tout << "tmp = B*t" << endl; 

   662      r_upm.add(T.size(), T.data(), tmp.size(), tmp.data(), T); // T = Uf + Bt
   663:     TRACE("polynomial::factorization::bughunt", 
   664          tout << "T = B*tmp" << endl; 

   687      if (one.size() != 1 || !nm.is_one(one[0])) {
   688:         TRACE("polynomial::factorization::bughunt", 
   689              tout << "sage: R.<x> = Zmod(" << nm.to_string(zpe_upm.m().p()) << ")['x']" << endl;

   712  
   713:     TRACE("polynomial::factorization::bughunt", 
   714          tout << "polynomial::hansel_lift_quadratic(";

   743          // now we have C = AB (mod b*r)
   744:         TRACE("polynomial::factorization::bughunt", 
   745              tout << "A_lifted = "; upm.display(tout, A_lifted); tout << endl;

   770          to_zp_manager(zpe_upm, g);
   771:         TRACE("polynomial::factorization::bughunt", 
   772              tout << "g = (1 - A_lifted*U - B_lifted*V)/" << nm.to_string(pe) << endl;

   825      if (!upm.eq(mult_zp, f_zp)) {
   826:         TRACE("polynomial::factorization::bughunt", 
   827              tout << "f = "; upm.display(tout, f); tout << endl;

   847      if (!upm.eq(mult_zpe, f_zpe)) {
   848:         TRACE("polynomial::factorization::bughunt", 
   849              tout << "f = "; upm.display(tout, f); tout << endl;

   885      
   886:     TRACE("polynomial::factorization::bughunt", 
   887          tout << "polynomial::hansel_lift("; upm.display(tout, f); tout << ", " << zp_fs << ")" << endl;

   905          zp_upm.set(zp_fs[i].size(), zp_fs[i].data(), A);
   906:         TRACE("polynomial::factorization::bughunt", 
   907              tout << "A = "; upm.display(tout, A); tout << endl;

   920          }
   921:         TRACE("polynomial::factorization::bughunt", 
   922              tout << "C = "; upm.display(tout, C); tout << endl;

   926          zp_upm.div(C.size(), C.data(), A.size(), A.data(), B);
   927:         TRACE("polynomial::factorization::bughunt", 
   928              tout << "B = "; upm.display(tout, B); tout << endl;

   934          CASSERT("polynomial::factorizatio::bughunt", check_individual_lift(zp_upm, zp_fs[i], zpe_upm, A));
   935:         TRACE("polynomial::factorization", 
   936              tout << "lifted to " << nm.to_string(zpe_upm.m().p()) << endl;        

   959  
   960:     TRACE("polynomial::factorization::bughunt", 
   961          tout << "polynomial::hansel_lift("; upm.display(tout, f); tout << ", " << zp_fs << ") => " << zpe_fs << endl;

  1019  bool factor_square_free(z_manager & upm, numeral_vector const & f, factors & fs, unsigned k, factor_params const & params) {
  1020:     TRACE("polynomial::factorization::bughunt", 
  1021          tout << "sage: f = "; upm.display(tout, f); tout << endl;

  1051  
  1052:     TRACE("polynomial::factorization::bughunt", 
  1053          tout << "sage: f_pp = "; upm.display(tout, f_pp); tout << endl;

  1074      unsigned trials = 0;
  1075:     TRACE("polynomial::factorization::bughunt", tout << "trials: " << params.m_p_trials << "\n";);
  1076      while (trials <= params.m_p_trials) {

  1088          nm.gcd(p, f_pp.back(), gcd_tmp);
  1089:         TRACE("polynomial::factorization::bughunt", 
  1090              tout << "sage: if (not (gcd(" << nm.to_string(p) << ", " << nm.to_string(f_pp.back()) << ")) == " << 

  1100  
  1101:         TRACE("polynomial::factorization::bughunt", 
  1102              tout << "sage: Rp.<x_p> = GF(" << nm.to_string(p) << ")['x_p']"; tout << endl;

  1141  
  1142:             TRACE("polynomial::factorization::bughunt", 
  1143                  tout << "best zp factorization (Z_" << nm.to_string(zp_fs_p) << "): ";

  1155      
  1156:     TRACE("polynomial::factorization::bughunt", 
  1157            tout << "best zp factorization (Z_" << nm.to_string(zp_fs_p) << "): " << zp_fs << endl;

  1163      unsigned e = mignotte_bound(upm, f_pp, zp_fs_p);
  1164:     TRACE("polynomial::factorization::bughunt", 
  1165            tout << "out p = " << nm.to_string(zp_fs_p) << ", and we'll work p^e for e = " << e << endl;

  1192      scoped_numeral trial_factor_cont(nm);
  1193:     TRACE("polynomial::factorization::bughunt", 
  1194            tout << "STARTING TRIAL DIVISION" << endl;

  1239          zpe_upm.mul(trial_factor, f_pp_lc);
  1240:         TRACE("polynomial::factorization::bughunt", 
  1241              tout << "f_pp*lc(f_pp) = "; upm.display(tout, f_pp); tout << endl;

  1246          
  1247:         TRACE("polynomial::factorization::bughunt", 
  1248              tout << "trial_factor = "; upm.display(tout, trial_factor); tout << endl;    

  1274          }
  1275:         TRACE("polynomial::factorization::bughunt", 
  1276              tout << "factors = " << fs << endl;

z3/src/math/polynomial/upolynomial.cpp:
   388              m().mul(g, p[i], tmp);
   389:             CTRACE("div_bug", !m().eq(tmp, old_p_i), tout << "old(p[i]): " << m().to_string(old_p_i) << ", g: " << m().to_string(g) << ", p[i]: " <<
   390                     m().to_string(p[i]) << ", tmp: " << m().to_string(tmp) << "\n";);

   405          for (unsigned i = 0; i < sz; i++) {
   406:             CTRACE("upolynomial", !m().divides(b, p[i]), tout << "b: " << m().to_string(b) << ", p[i]: " << m().to_string(p[i]) << "\n";);
   407              SASSERT(m().divides(b, p[i]));

   529          while (m_limit.inc()) {			
   530:             TRACE("rem_bug", tout << "rem loop, p2:\n"; display(tout, sz2, p2); tout << "\nbuffer:\n"; display(tout, buffer); tout << "\n";);
   531              sz1 = buffer.size();
   532              if (sz1 < sz2) {
   533:                 TRACE("rem_bug", tout << "finished\n";);
   534                  return;

   548                  m().set(a_m, buffer[sz1 - 1]);
   549:                 TRACE("rem_bug", tout << "a_m: " << m().to_string(a_m) << ", b_n: " << m().to_string(b_n) << "\n";);
   550                  // don't need to update position sz1 - 1, since it will become 0

   621          // std::cerr << "dividing with "; display(std::cerr, _p1); std::cerr << std::endl;
   622:         TRACE("factor_bug", tout << "sz1: " << sz1 << " p1: " << p1 << ", _p1.c_ptr(): " << _p1.data() << ", _p1.size(): " << _p1.size() << "\n";);
   623          set(sz1, p1, _p1);

   625          while (true) {
   626:             TRACE("upolynomial", tout << "exact_div loop...\n"; display(tout, _p1); tout << "\n"; display(tout, _r); tout << "\n";);
   627              // std::cerr << "dividing with "; display(std::cerr, _p1); std::cerr << std::endl;

   674          m().m().mod(inv2, b1, inv2);
   675:         TRACE("CRA", tout << "inv1: " << inv1 << ", inv2: " << inv2 << "\n";);
   676          scoped_numeral a1(m());

   679          m().mul(b1, inv1, a2); // a2 is the multiplicator for coefficients of C2
   680:         TRACE("CRA", tout << "a1: " << a1 << ", a2: " << a2 << "\n";);
   681          // new bound

   689          m().neg(lower);
   690:         TRACE("CRA", tout << "lower: " << lower << ", upper: " << upper << "\n";);
   691  

   723                                 numeral_vector & result) {
   724:         TRACE("mgcd", tout << "u: "; display_star(tout, sz_u, u); tout << "\nv: "; display_star(tout, sz_v, v); tout << "\n";);
   725          SASSERT(sz_u > 0 && sz_v > 0);

   749              m().set(p, polynomial::g_big_primes[i]);
   750:             TRACE("mgcd", tout << "trying prime: " << p << "\n";);
   751              {

   755                  if (degree(u_Zp) < d_u) {
   756:                     TRACE("mgcd", tout << "bad prime, leading coefficient vanished\n";);
   757                      continue; // bad prime

   759                  if (degree(v_Zp) < d_v) {
   760:                     TRACE("mgcd", tout << "bad prime, leading coefficient vanished\n";);
   761                      continue; // bad prime

   769              }
   770:             TRACE("mgcd", tout << "new q:\n"; display_star(tout, q); tout << "\n";);
   771              if (is_const(q)) {
   772:                 TRACE("mgcd", tout << "done, modular gcd is one\n";);
   773                  reset(result);

   783                  // discard accumulated image, it was affected by unlucky primes
   784:                 TRACE("mgcd", tout << "discarding image\n";);
   785                  set(q.size(), q.data(), C);

   789                  CRA_combine_images(q, p, C, bound);
   790:                 TRACE("mgcd", tout << "new combined:\n"; display_star(tout, C); tout << "\n";);
   791              }

   793              get_primitive(C, candidate);
   794:             TRACE("mgcd", tout << "candidate:\n"; display_star(tout, candidate); tout << "\n";);
   795              SASSERT(candidate.size() > 0);

   799                  divides(pp_v, candidate)) {
   800:                 TRACE("mgcd", tout << "found GCD\n";);
   801                  mul(candidate, c_g);

   803                  candidate.swap(result);
   804:                 TRACE("mgcd", tout << "r: "; display_star(tout, result); tout << "\n";);
   805                  return;

   830          set(sz2, p2, B);
   831:         TRACE("upolynomial", tout << "sz1: " << sz1 << ", p1: " << p1 << ", sz2: " << sz2 << ", p2: " << p2 << "\nB.size(): " << B.size() <<
   832                ", B.c_ptr(): " << B.data() << "\n";);
   833          while (m_limit.inc()) {
   834:             TRACE("upolynomial", tout << "A: "; display(tout, A); tout <<"\nB: "; display(tout, B); tout << "\n";);
   835              if (B.empty()) {

   844                  }
   845:                 TRACE("upolynomial", tout << "GCD\n"; display(tout, sz1, p1); tout << "\n"; display(tout, sz2, p2); tout << "\n--->\n";
   846                        display(tout, buffer); tout << "\n";);

   901              SASSERT(A.size() >= B.size());
   902:             TRACE("upolynomial", tout << "A: "; display(tout, A); tout <<"\nB: "; display(tout, B); tout << "\n";
   903                    tout << "g: " << m().to_string(g) << ", h: " << m().to_string(h) << "\n";);

   913                  }
   914:                 TRACE("upolynomial", tout << "subresultant GCD\n"; display(tout, sz1, p1); tout << "\n"; display(tout, sz2, p2); tout << "\n--->\n";
   915                        display(tout, buffer); tout << "\n";);

   929              d = pseudo_div_d;
   930:             TRACE("upolynomial", tout << "R: "; display(tout, R); tout << "\nd: " << d << "\n";);
   931              // aux <- g*h^d

  1409              //   p2(x) = p1((b-a)*x)
  1410:             TRACE("upolynomial", tout << "pos interval... " << bqm.to_string(a) << ", " << bqm.to_string(b) << "\n"; display(tout, sz, p); tout << "\n";);
  1411              numeral_vector & p_aux = m_dbab_tmp1;
  1412              translate_bq(sz, p, a, p_aux);
  1413:             TRACE("upolynomial", tout << "after translation\n"; display(tout, p_aux); tout << "\n";);
  1414              scoped_mpbq b_a(bqm);

  1416              compose_p_b_x(p_aux.size(), p_aux.data(), b_a);
  1417:             TRACE("upolynomial", tout << "after composition: " << bqm.to_string(b_a) << "\n"; display(tout, p_aux); tout << "\n";);
  1418              unsigned result = descartes_bound_0_1(p_aux.size(), p_aux.data());

  1540          compose_2kn_p_x_div_2k(sz, p, b.k());
  1541:         TRACE("upolynomial", tout << "after compose 2kn_p_x_div_2k\n"; display(tout, sz, p); tout << "\n";);
  1542          // Step 2

  1553          }
  1554:         TRACE("upolynomial", tout << "after special translation\n"; display(tout, sz, p); tout << "\n";);
  1555      }

  1562          compose_an_p_x_div_a(sz, p, b.denominator());
  1563:         TRACE("upolynomial", tout << "after compose_an_p_x_div_a\n"; display(tout, sz, p); tout << "\n";);
  1564          // Step 2

  1575          }
  1576:         TRACE("upolynomial", tout << "after special translation\n"; display(tout, sz, p); tout << "\n";);
  1577      }

  2148              drs_frame const & fr = frame_stack[idx];
  2149:             TRACE("upolynomial",
  2150                    tout << "normalizing...\n";

  2163          }
  2164:         TRACE("upolynomial", tout << "adding normalized interval (" << bqm.to_string(l) << ", " << bqm.to_string(u) << ")\n";);
  2165          lowers.push_back(mpbq());

  2189          }
  2190:         TRACE("upolynomial", tout << "adding normalized root: " << bqm.to_string(u) << "\n";);
  2191          roots.push_back(mpbq());

  2196      void manager::drs_isolate_0_1_roots(unsigned sz, numeral const * p, mpbq_manager & bqm, mpbq_vector & roots, mpbq_vector & lowers, mpbq_vector & uppers) {
  2197:         TRACE("upolynomial", tout << "isolating (0,1) roots of:\n"; display(tout, sz, p); tout << "\n";);
  2198          unsigned k = descartes_bound_0_1(sz, p);

  2200          if (k == 0) {
  2201:             TRACE("upolynomial", tout << "polynomial does not have any roots\n";);
  2202              return;

  2204          if (k == 1) {
  2205:             TRACE("upolynomial", tout << "polynomial has one root in (0, 1)\n";);
  2206              lowers.push_back(mpbq(0));

  2209          }
  2210:         TRACE("upolynomial", tout << "polynomial has more than one root in (0, 1), starting search...\n";);
  2211          scoped_numeral_vector  q(m());

  2214          if (has_one_half_root(sz, p)) {
  2215:             TRACE("upolynomial", tout << "polynomial has a 1/2 root\n";);
  2216              roots.push_back(mpbq(1, 1));

  2229              numeral const * p = p_stack.data() + p_stack.size() - sz;
  2230:             TRACE("upolynomial", tout << "processing frame #" << frame_stack.size() - 1 << "\n"
  2231                    << "first: " << fr.m_first << ", left: " << fr.m_left << ", sz: " << fr.m_size << ", parent_idx: ";

  2240              if (k == 0) {
  2241:                 TRACE("upolynomial", tout << "(0, 1) does not have roots\n";);
  2242                  pop_top_frame(p_stack, frame_stack);

  2245              if (k == 1) {
  2246:                 TRACE("upolynomial", tout << "(0, 1) is isolating interval\n";);
  2247                  add_isolating_interval(frame_stack, bqm, lowers, uppers);

  2250              }
  2251:             TRACE("upolynomial", tout << "polynomial has more than one root in (0, 1) creating child frames...\n";);
  2252              if (has_one_half_root(sz, p)) {
  2253:                 TRACE("upolynomial", tout << "1/2 is a root\n";);
  2254                  add_root(frame_stack, bqm, roots);

  2297          // Since the desired positive roots of p(x) are in (0, 2^pos_k),
  2298:         TRACE("upolynomial", tout << "searching at (0, 1)\n";);
  2299          unsigned old_roots_sz  = roots.size();

  2310          compose_p_2k_x(sz, p, neg_k);
  2311:         TRACE("upolynomial", tout << "searching at (-1, 0) using:\n"; display(tout, sz, p); tout << "\n";);
  2312          old_roots_sz  = roots.size();

  2330  
  2331:         TRACE("upolynomial",
  2332                scoped_numeral U(m());

  2397          ss_frame_stack s(bqm);
  2398:         TRACE("upolynomial", tout << "p: "; display(tout, sz, p); tout << "\nSturm seq:\n"; display(tout, seq); tout << "\n";);
  2399  

  2451              bqm.div2(mid);
  2452:             TRACE("upolynomial",
  2453                    tout << "depth: " << s.size() << "\n";

  2497              remove_zero_roots(sz, p, nz_p);
  2498:             TRACE("upolynomial", tout << "after removing zero root:\n"; display(tout, nz_p); tout << "\n";);
  2499              SASSERT(!has_zero_roots(nz_p.size(), nz_p.data()));

  2508          SASSERT(sz > 0);
  2509:         TRACE("upolynomial", tout << "isolating roots of:\n"; display(tout, sz, p); tout << "\n";);
  2510          scoped_numeral_vector sqf_p(m());
  2511          square_free(sz, p, sqf_p);
  2512:         TRACE("upolynomial", tout << "square free part:\n"; display(tout, sqf_p); tout << "\n";);
  2513          sqf_isolate_roots(sqf_p.size(), sqf_p.data(), bqm, roots, lowers, uppers);

  2598          int sign_b = eval_sign_at(sz, p, b);
  2599:         TRACE("upolynomial", tout << "sign_a: " << sign_a << ", sign_b: " << sign_b << "\n";);
  2600          if (sign_a != 0 && sign_b != 0) {

  2611              while (true) {
  2612:                 TRACE("upolynomial", tout << "CASE 2, a: " << bqm.to_string(a) << ", b: " << bqm.to_string(b) << ", new_a: " << bqm.to_string(new_a) << "\n";);
  2613                  int sign_new_a = eval_sign_at(sz, p, new_a);

  2636              while (true) {
  2637:                 TRACE("upolynomial", tout << "CASE 3, a: " << bqm.to_string(a) << ", b: " << bqm.to_string(b) << ", new_b: " << bqm.to_string(new_b) << "\n";);
  2638                  int sign_new_b = eval_sign_at(sz, p, new_b);

  2689          while (true) {
  2690:             TRACE("upolynomial",
  2691                    tout << "CASE 4\na1: " << bqm.to_string(a1) << ", b1: " << bqm.to_string(b1) << ", new_a1: " << bqm.to_string(new_a1) << "\n";

  2816          bool found_d = false;
  2817:         TRACE("convert_bug",
  2818                tout << "a: " << m().to_string(a.numerator()) << "/" << m().to_string(a.denominator()) << "\n";

  2823          if (bqm.to_mpbq(a, lower)) {
  2824:             TRACE("convert_bug", tout << "found c: " << lower << "\n";);
  2825              // found c

  2834                  ::swap(lower, upper);
  2835:             TRACE("convert_bug",
  2836                    tout << "a: "; m().display(tout, a.numerator()); tout << "/"; m().display(tout, a.denominator()); tout << "\n";

  2960          SASSERT(p.size() == 3); // p has degree 2
  2961:         TRACE("factor", tout << "factor square free (degree == 2):\n"; display(tout, p); tout << "\n";);
  2962  

  2965          numeral const & c = p[0];
  2966:         TRACE("factor", tout << "a: " << m().to_string(a) << "\nb: " << m().to_string(b) << "\nc: " << m().to_string(c) << "\n";);
  2967          // Create the discriminant: b^2 - 4*a*c

  2981          }
  2982:         TRACE("factor", tout << "disc_sqrt: " << m().to_string(disc_sqrt) << "\n";);
  2983          // p = cont*(2*a*x + b - disc_sqrt)*(2*a*x + b + disc_sqrt)

  2994          normalize(f2);
  2995:         TRACE("factor", tout << "f1: "; display(tout, f1); tout << "\nf2: "; display(tout, f2); tout << "\n";);
  2996          DEBUG_CODE({

  3066              VERIFY(exact_div(C, B, A));
  3067:             TRACE("factor_bug", tout << "C: "; display(tout, C); tout << "\nB: "; display(tout, B); tout << "\nA: "; display(tout, A); tout << "\n";);
  3068              // A is of the form P_1 * P_2 * ... * P_k

  3071                  checkpoint();
  3072:                 TRACE("factor", tout << "factor_core main loop j: " << j << "\nA: "; display(tout, A); tout << "\nB: "; display(tout, B); tout << "\n";);
  3073                  // A is of the form       P_j * P_{j+1} * P_{j+2}   * ... * P_k

  3084                  else {
  3085:                     TRACE("factor", tout << "const C: "; display(tout, C); tout << "\n";);
  3086                      SASSERT(C.size() == 1);

  3090                  }
  3091:                 TRACE("factor_bug", tout << "B: "; display(tout, B); tout << "\nD: "; display(tout, D); tout << "\n";);
  3092                  VERIFY(exact_div(B, D, B));

  3097              }
  3098:             TRACE("factor_bug", tout << "A: "; display(tout, A); tout << "\n";);
  3099              SASSERT(A.size() == 1 && m().is_one(A[0]));

z3/src/math/realclosure/mpz_matrix.cpp:
  223      for (unsigned k = 0; k < A.m(); k++) {
  224:         TRACE("mpz_matrix", 
  225                tout << "k: " << k << "\n" << A;

  364      for (unsigned k1 = 0, k2 = 0; k1 < A.m(); k1++) {
  365:         TRACE("mpz_matrix", tout << "k1: " << k1 << ", k2: " << k2 << "\n" << A;);
  366          // find pivot

z3/src/math/realclosure/realclosure.cpp:
  1304              int m = magnitude(i);
  1305:             TRACE("rcf_transcendental",
  1306                    tout << "refine_transcendental_interval rational: " << m << "\nrational interval: ";

  1322              while (!check_precision(t->interval(), prec)) {
  1323:                 TRACE("rcf_transcendental", tout << "refine_transcendental_interval: " << magnitude(t->interval()) << std::endl;);
  1324                  checkpoint();

  1679                                    value_ref_buffer & q2) {
  1680:             TRACE("rcf_count_signs",
  1681                    tout << "p: "; display_poly(tout, p_sz, p); tout << "\n";

  1993                  SASSERT(M_s.m() == scs.size());
  1994:                 TRACE("rcf_sign_det",
  1995                        tout << M_s;

  2011                  count_signs_at_zeros(p_sz, p, q_sz, q, iso_interval, num_roots, q_eq_0, q_gt_0, q_lt_0, q2);
  2012:                 TRACE("rcf_sign_det",
  2013                        tout << "q: "; display_poly(tout, q_sz, q); tout << "\n";

  2032                  VERIFY(mm().solve(new_M_s, sc_cardinalities.data(), new_taqrs.data()));
  2033:                 TRACE("rcf_sign_det", tout << "solution: "; for (unsigned i = 0; i < sc_cardinalities.size(); i++) { tout << sc_cardinalities[i] << " "; } tout << "\n";);
  2034                  // The solution must contain only positive values <= num_roots

  2089              }
  2090:             TRACE("rcf_sign_det",
  2091                    tout << "Final state\n";

  2288              bool has_pos_upper = pos_root_upper_bound(n, p, pos_upper_N);
  2289:             TRACE("rcf_isolate",
  2290                    display_poly(tout, n, p); tout << "\n";

  2306              int num_pos_roots    = num_sv_zero      - num_sv_plus_inf;
  2307:             TRACE("rcf_isolate",
  2308                    tout << "num_neg_roots: " << num_neg_roots << "\n";

  2396          void nz_isolate_roots(unsigned n, value * const * p, numeral_vector & roots) {
  2397:             TRACE("rcf_isolate",
  2398                    tout << "nz_isolate_roots\n";

  2414          void isolate_roots(unsigned n, numeral const * p, numeral_vector & roots) {
  2415:             TRACE("rcf_isolate_bug", tout << "isolate_roots: "; for (unsigned i = 0; i < n; i++) { display(tout, p[i]); tout << " "; } tout << "\n";);
  2416              SASSERT(n > 0);

  2878              SASSERT(p2 != r.data());
  2879:             TRACE("rcf_rem",
  2880                    tout << "rem\n";

  2897                  if (sz1 < sz2) {
  2898:                     TRACE("rcf_rem", tout << "rem result\n"; display_poly(tout, r.size(), r.data()); tout << "\n";);
  2899                      return;

  2922              SASSERT(p2 != r.data());
  2923:             TRACE("rcf_prem",
  2924                    tout << "prem\n";

  2942                  if (sz1 < sz2) {
  2943:                     TRACE("rcf_prem", tout << "prem result\n"; display_poly(tout, r.size(), r.data()); tout << "\n";);
  2944                      return;

  3145              INC_DEPTH();
  3146:             TRACE("rcf_clean", tout << "clean_denominators_core [" << m_exec_depth << "]\na: "; display(tout, a, false); tout << "\n";);
  3147              p.reset(); q.reset();

  3273                          for (unsigned j = 0; j < p_sz; j++) {
  3274:                             TRACE("rcf_clean_bug", tout << "j: " << j << " "; display(tout, m, false); tout << "\n";);
  3275                              if (!dens[j])

  3493              INC_DEPTH();
  3494:             TRACE("rcf_gcd", tout << "GCD [" << m_exec_depth << "]\n";
  3495                    display_poly(tout, sz1, p1); tout << "\n";

  3511                  while (true) {
  3512:                     TRACE("rcf_gcd",
  3513                            tout << "A: "; display_poly(tout, A.size(), A.data()); tout << "\n";

  3517                          r = A;
  3518:                         TRACE("rcf_gcd",
  3519                                tout << "gcd result: "; display_poly(tout, r.size(), r.data()); tout << "\n";);

  3538              INC_DEPTH();
  3539:             TRACE("rcf_gcd", tout << "prem-GCD [" << m_exec_depth << "]\n";
  3540                    display_poly(tout, sz1, p1); tout << "\n";

  3558                  while (true) {
  3559:                     TRACE("rcf_gcd",
  3560                            tout << "A: "; display_poly(tout, A.size(), A.data()); tout << "\n";

  3565                          r = A;
  3566:                         TRACE("rcf_gcd",
  3567                                tout << "gcd result: "; display_poly(tout, r.size(), r.data()); tout << "\n";);

  3635              SASSERT(seq.size() >= 2);
  3636:             TRACE("rcf_sturm_seq",
  3637                    unsigned sz = seq.size();

  3650                  }
  3651:                 TRACE("rcf_sturm_seq",
  3652                        tout << "sturm_seq_core [" << m_exec_depth << "], new polynomial\n";

  4038              INC_DEPTH();
  4039:             TRACE("rcf_TaQ", tout << "TaQ [" << m_exec_depth << "]\n";
  4040                    display_poly(tout, p_sz, p); tout << "\n";

  4054              INC_DEPTH();
  4055:             TRACE("rcf_TaQ", tout << "TaQ_1 [" << m_exec_depth << "]\n";
  4056                    display_poly(tout, p_sz, p); tout << "\n";);

  4154  
  4155:                 TRACE("rcf_transcendental", tout << "after update_rf_interval: " << magnitude(v->interval()) << " ";
  4156                        bqim().display(tout, v->interval()); tout << std::endl;);

  4301                  update_rf_interval(v, prec);
  4302:                 TRACE("rcf_algebraic", tout << "after update_rf_interval: " << magnitude(v->interval()) << " "; bqim().display(tout, v->interval()); tout << std::endl;);
  4303                  if (check_precision(v->interval(), prec))

  4743              SASSERT(v->ext()->is_algebraic());
  4744:             TRACE("rcf_algebraic_sign",
  4745                    tout << "expensive_determine_algebraic_sign\n"; display(tout, v, false);

  4803              }
  4804:             TRACE("rcf_determine_sign_bug",
  4805                    tout << "result: " << r << "\n";

  4829              INC_DEPTH();
  4830:             TRACE("rcf_arith", tout << "normalize [" << m_exec_depth << "]\n";
  4831                    display_poly(tout, sz1, p1); tout << "\n";

  4853              }
  4854:             TRACE("normalize_fraction_bug",
  4855                    display_poly(tout, sz1, p1); tout << "\n";

  5062                  INC_DEPTH();
  5063:                 TRACE("rcf_arith", tout << "add [" << m_exec_depth << "]\n";
  5064                        display(tout, a, false); tout << "\n";

  5270                  INC_DEPTH();
  5271:                 TRACE("rcf_arith", tout << "mul [" << m_exec_depth << "]\n";
  5272                        display(tout, a, false); tout << "\n";

  5327          bool inv_algebraic(unsigned q_sz, value * const * q, unsigned p_sz, value * const * p, value_ref_buffer & g, value_ref_buffer & h) {
  5328:             TRACE("inv_algebraic",
  5329                    tout << "q: "; display_poly(tout, q_sz, q); tout << "\n";

  5347                  //   Q(alpha) * h(alpha) = R(alpha)
  5348:                 TRACE("inv_algebraic",
  5349                        tout << "Q: "; display_poly(tout, Q.size(), Q.data()); tout << "\n";

  5355                      div(R.size(), R.data(), Q[0], h);
  5356:                     TRACE("inv_algebraic", tout << "h: "; display_poly(tout, h.size(), h.data()); tout << "\n";);
  5357                      // g <- 1

z3/src/math/simplex/model_based_opt.cpp:
   248  
   249: #define PASSERT(_e_) { CTRACE("qe", !(_e_), display(tout, r); display(tout);); SASSERT(_e_); }
   250  

   295          unsigned_vector bound_trail, bound_vars;
   296:         TRACE("opt", display(tout << "tableau\n"););
   297          while (!objective().m_vars.empty()) {

   304                  SASSERT(!bound_coeff.is_zero());
   305:                 TRACE("opt", display(tout << "update: " << v << " ", objective());
   306                        for (unsigned above : m_above) {

   325              else {
   326:                 TRACE("opt", display(tout << "unbound: " << v << " ", objective()););
   327                  update_values(bound_vars, bound_trail);

   409              }
   410:             TRACE("opt", display(tout << "v" << x 
   411                                   << " coeff_x: " << x_coeff 

   598              if (is_int(x)) {
   599:                 TRACE("opt", 
   600                        tout << x << ": " << a1 << " " << a2 << ": ";

   609                  }
   610:                 TRACE("opt", display(tout << "result ", m_rows[row_dst]););
   611                  normalize(row_dst);

   661          if (use_case1) {
   662:             TRACE("opt", tout << "slack: " << slack << " " << src_c << " " << dst_val << " " << dst_c << " " << src_val << "\n";);
   663              // dst <- abs_src_c*dst + abs_dst_c*src + slack

   736  
   737:         TRACE("qe", tout << "finite disjunction " << distance << " " << src_c << " " << dst_c << "\n";); 
   738          vector<var> coeffs;

  1301          SASSERT(!div_rows.empty() || !mod_rows.empty());
  1302:         TRACE("opt", display(tout << "solve_div v" << x << "\n"));
  1303  

  1494              m_var2value[x] = eval(result);
  1495:             TRACE("opt", tout << y << " := " << y_def << "\n";
  1496                           tout << z << " := " << z_def << "\n";

  1498          }
  1499:         TRACE("opt", display(tout << "solve_div done v" << x << "\n"));
  1500          return result;

  1527          if (D.is_neg()) D = abs(D);
  1528:         TRACE("opt1", display(tout << "lcm: " << D << " x: v" << x << " tableau\n"););
  1529          rational val_x = m_var2value[x];

  1536          }
  1537:         TRACE("opt1", display(tout << "tableau after replace x under mod\n"););
  1538          //

  1559          }
  1560:         TRACE("opt1", display(tout << "tableau after replace x by y := v" << y << "\n"););
  1561          def result = project(y, compute_def);

  1565          }
  1566:         TRACE("opt1", display(tout << "tableau after project y" << y << "\n"););
  1567  	

  1631      model_based_opt::def model_based_opt::solve_for(unsigned row_id1, unsigned x, bool compute_def) {
  1632:         TRACE("opt", tout << "v" << x << " := " << eval(x) << "\n" << m_rows[row_id1] << "\n";
  1633          display(tout));

  1690              m_var2value[x] = eval(result);
  1691:             TRACE("opt1", tout << "updated eval " << x << " := " << eval(x) << "\n";);
  1692          }
  1693          retire_row(row_id1);
  1694:         TRACE("opt", display(tout << "solved v" << x << "\n"));
  1695          return result;

  1707              eliminate(vars[i], m_result.back());
  1708:             TRACE("opt", display(tout << "After projecting: v" << vars[i] << "\n"););
  1709          }

z3/src/math/simplex/network_flow_def.h:
  131          }
  132:         TRACE("network_flow", {
  133              tout << "Difference logic optimization:" << std::endl;

  145      void network_flow<Ext>::initialize() {
  146:         TRACE("network_flow", tout << "initialize...\n";);
  147          // Create an artificial root node to construct initial spanning tree

  182  
  183:         TRACE("network_flow", 
  184                tout << pp_vector("Potentials", m_potentials);

  208          SASSERT(m_tree->in_subtree_t2(start));
  209:         TRACE("network_flow", tout << "update_potentials of T_" << start << " with change = " << change << "...\n";);
  210          svector<node> descendants;

  216          }
  217:         TRACE("network_flow", tout << pp_vector("Potentials", m_potentials););
  218      }

  232          }
  233:         TRACE("network_flow", tout << pp_vector("Flows", m_flows););
  234      }

  290              vector<edge>const& es = m_graph.get_all_edges();
  291:             TRACE("network_flow",
  292                    {

  312                  update_potentials();                
  313:                 TRACE("network_flow", 
  314                        tout << "Spanning tree:\n"; 

  321          }
  322:         TRACE("network_flow", 
  323                tout << "Spanning tree:\n"; 

  328          if (is_infeasible()) return INFEASIBLE;
  329:         TRACE("network_flow", tout << "Found optimal solution.\n";);
  330          SASSERT(check_optimal());

  420          }    
  421:         TRACE("network_flow", tout << "Total balance: " << total_balance << ", total cost: " << total_cost << std::endl;);
  422          return total_cost == total_balance;

z3/src/math/simplex/simplex_def.h:
    53              m.lcm(a, b, c);
    54:             TRACE("simplex",
    55                    m.display(tout << " a: ", a);

    71              M.add(r, a, row(m_vars[v].m_base2row));
    72:             TRACE("simplex", M.display_row(tout, r););
    73          }

    89          SASSERT(!m.is_zero(base_coeff));
    90:         TRACE("simplex", 
    91                for (unsigned i = 0; i < num_vars; ++i) {

   134          if (outside_bounds(v)) {
   135:             TRACE("simplex", tout << "Add patch: v" << v << "\n";);
   136              m_to_patch.insert(v);

   153      void simplex<Ext>::del_row(var_t var) {
   154:         TRACE("simplex", tout << var << "\n";);
   155          row r;

   184          del_row(r);
   185:         TRACE("simplex", display(tout););
   186          SASSERT(well_formed());

   205          vi.m_lower_valid = true;
   206:         TRACE("simplex", em.display(tout << "v" << var << " lower: ", b);
   207                em.display(tout << " value: ", vi.m_value););

   341          while ((v = select_var_to_fix()) != null_var) {
   342:             TRACE("simplex", display(tout << "v" << v << "\n"););
   343              if (!m_limit.inc() || num_iterations > m_max_iterations) {

   688              }
   689:             TRACE("simplex", tout << "x_i: v" << x_i << " x_j: v" << x_j << "\n";);
   690              var_info& vj = m_vars[x_j];

   716              pivot(x_i, x_j, a_ij);
   717:             TRACE("simplex", display(tout << "after pivot\n"););
   718              move_to_bound(x_i, !inc_x_i);
   719              SASSERT(well_formed_row(row(m_vars[x_j].m_base2row)));
   720:             TRACE("simplex", display(tout););
   721              SASSERT(is_feasible());

   735          }
   736:         TRACE("simplex", tout << "move " << (to_lower?"to_lower":"to_upper") 
   737                << " v" << x << " delta: " << em.to_string(delta) << "\n";);

   768                  em.abs(delta2);
   769:                 TRACE("simplex", tout << "Delta for v" << s << " " << delta2 << "\n";);
   770                  if (delta2 < delta) {

   807              if ((inc_x && at_upper(x)) || (!inc_x && at_lower(x))) {
   808:                 TRACE("simplex", tout << "v" << x << " pos: " << inc_x 
   809                        << " at upper: " << at_upper(x) 

   828              if (better) {
   829:                 TRACE("simplex", 
   830                        em.display(tout << "gain:", gain); 

   873              bool inc_s =  sign_eq != inc_x_j;
   874:             TRACE("simplex", tout << "x_j: v" << x_j << ", base x_i: v" << s 
   875                    << ", inc_x_i: " << inc_s 

   898                  inc_x_i = inc_s;
   899:                 TRACE("simplex", tout << "x_j v" << x_j << " x_i v" << x_i << " gain: ";
   900                        tout << curr_gain << "\n";);

   912              if (num_repeated > m_blands_rule_threshold) {
   913:                 TRACE("simplex", tout << "using blands rule, " << num_repeated << "\n";);
   914                  // std::cerr << "BLANDS RULE...\n";

  1021              IF_VERBOSE(0, M.display_row(verbose_stream(), r););
  1022:             TRACE("pb", display(tout << "non-well formed row\n"); M.display_row(tout << "row: ", r););
  1023              throw default_exception("non-well formed row");

z3/src/math/subpaving/subpaving_t_def.h:
   245          this->mk_decided_bound(x, mid, true, !m_left_open, right);
   246:         TRACE("subpaving_int_split",
   247                tout << "LEFT:\n"; this->ctx()->display_bounds(tout, left);

   564      n->push(r);
   565:     TRACE("subpaving_mk_bound", tout << "mk_bound: "; display(tout, r); tout << "\ntimestamp: " << r->m_timestamp << "\n";);
   566      if (conflicting_bounds(x, n)) {
   567:         TRACE("subpaving_mk_bound", tout << "conflict\n"; display_bounds(tout, n););
   568          set_conflict(x, n);

   673          if (!is_int(p->x(i)) || !nm().is_int(p->a(i))) {
   674:             TRACE("subpaving_is_int", tout << "polynomial is not integer due to monomial at i: " << i << "\n"; tout.flush();
   675                    display(tout, p->x(i)); tout << " "; nm().display(tout, p->a(i)); tout << "\n";);

   763      }
   764:     TRACE("subpaving_mk_sum", tout << "new variable is integer: " << is_int(p) << "\n";);
   765      var new_var      = mk_var(is_int(p));

   787  void context_t<C>::inc_ref(ineq * a) {
   788:     TRACE("subpaving_ref_count", tout << "inc-ref: " << a << " " << a->m_ref_count << "\n";);
   789      if (a)

   795      if (a) {
   796:         TRACE("subpaving_ref_count",
   797                tout << "dec-ref: " << a << " " << a->m_ref_count << "\n";

   842      }
   843:     TRACE("subpaving_clause", tout << "new clause:\n"; display(tout, c); tout << "\n";);
   844  }

   867  void context_t<C>::add_unit_clause(ineq * a, bool axiom) {
   868:     TRACE("subpaving", a->display(tout, nm(), *m_display_proc); tout << "\n";);
   869      inc_ref(a);

  1173      SASSERT(b != 0 && c != 0);
  1174:     TRACE("may_propagate_bug", display(tout, b); tout << " | "; display(tout, c); tout << "\nresult: " << (b->timestamp() > c->timestamp()) << ", " << b->timestamp() << ", " << c->timestamp() << "\n";);
  1175      return b->timestamp() >= c->timestamp();

  1211          SASSERT(curr_upper == 0 || curr_upper->x() == x);
  1212:         TRACE("subpaving_relevant_bound",
  1213                display(tout, x); tout << " " << (lower ? ">" : "<") << (open ? "" : "=") << " "; nm().display(tout, k); tout << "\n";

  1219              if (curr_upper && (nm().gt(k, curr_upper->value()) || ((open || curr_upper->is_open()) && nm().eq(k, curr_upper->value())))) {
  1220:                 TRACE("subpaving_relevant_bound", tout << "relevant because triggers conflict.\n";);
  1221                  return true;

  1225                  // new lower bound does not improve existing bound
  1226:                 TRACE("subpaving_relevant_bound", tout << "irrelevant because does not improve existing bound.\n";);
  1227                  return false;

  1230                  // new lower bound exceeds the :max-bound threshold
  1231:                 TRACE("subpaving_relevant_bound", tout << "irrelevant because exceeds :max-bound threshold.\n";);
  1232                  return false;

  1254                  nm().add(curr_lower->value(), delta, delta);
  1255:                 TRACE("subpaving_relevant_bound_bug",
  1256                        tout << "k: "; nm().display(tout, k);

  1260                  if (nm().le(k, delta)) {
  1261:                     TRACE("subpaving_relevant_bound", tout << "irrelevant because does not improve existing bound to at least ";
  1262                            nm().display(tout, delta); tout << "\n";);

  1269              if (curr_lower && (nm().gt(curr_lower->value(), k) || ((open || curr_lower->is_open()) && nm().eq(k, curr_lower->value())))) {
  1270:                 TRACE("subpaving_relevant_bound", tout << "relevant because triggers conflict.\n";);
  1271                  return true;

  1275                  // new upper bound does not improve existing bound
  1276:                 TRACE("subpaving_relevant_bound", tout << "irrelevant because does not improve existing bound.\n";);
  1277                  return false;

  1280                  // new upper bound exceeds the -:max-bound threshold
  1281:                 TRACE("subpaving_relevant_bound", tout << "irrelevant because exceeds -:max-bound threshold.\n";);
  1282                  return false;

  1305                  if (nm().ge(k, delta)) {
  1306:                     TRACE("subpaving_relevant_bound", tout << "irrelevant because does not improve existing bound to at least ";
  1307                            nm().display(tout, delta); tout << "\n";);

  1311          }
  1312:         TRACE("subpaving_relevant_bound", tout << "new bound is relevant\n";);
  1313          return true;

  1377  void context_t<C>::propagate_clause(clause * c, node * n) {
  1378:     TRACE("propagate_clause", tout << "propagate using:\n"; display(tout, c); tout << "\n";);
  1379      m_num_visited++;

  1401      ineq * a = (*c)[j];
  1402:     TRACE("propagate_clause", tout << "propagating inequality: "; display(tout, a); tout << "\n";);
  1403      propagate_bound(a->x(), a->value(), a->is_lower(), a->is_open(), n, justification(c));

  1442                  nm().set(a, p->a(i));
  1443:                 TRACE("propagate_polynomial_bug", tout << "a: "; nm().display(tout, a); tout << "\n";);
  1444              }
  1445          }
  1446:         TRACE("propagate_polynomial_bug", tout << "r before mul 1/a: "; im().display(tout, r); tout << "\n";);
  1447          im().div(r, a, r);
  1448:         TRACE("propagate_polynomial_bug", tout << "r after mul 1/a:  "; im().display(tout, r); tout << "\n";);
  1449          // r contains the deduced bounds for y.

  1468  void context_t<C>::propagate_polynomial(var x, node * n) {
  1469:     TRACE("propagate_polynomial", tout << "propagate_polynomial: "; display(tout, x); tout << "\n";);
  1470:     TRACE("propagate_polynomial_detail", display_bounds(tout, n););
  1471      SASSERT(is_polynomial(x));

  1485      }
  1486:     TRACE("propagate_polynomial", tout << "unbounded_var: "; display(tout, unbounded_var); tout << "\n";);
  1487  

  1502  void context_t<C>::propagate_monomial(var x, node * n) {
  1503:     TRACE("propagate_monomial", tout << "propagate_monomial: "; display(tout, x); tout << "\n";);
  1504      SASSERT(is_monomial(x));

  1526      }
  1527:     TRACE("propagate_monomial", tout << "found_zero: " << found_zero << ", found_unbounded: " << found_unbounded << "\n";);
  1528      if (found_zero) {

  1604  void context_t<C>::propagate_monomial_downward(var x, node * n, unsigned j) {
  1605:     TRACE("propagate_monomial", tout << "propagate_monomial_downward: "; display(tout, x); tout << ", j: " << j << "\n";
  1606            display(tout, get_monomial(x)); tout << "\n";);

  1713      var x = b->x();
  1714:     TRACE("subpaving_propagate", tout << "propagate: "; display(tout, b); tout << ", timestamp: " << b->timestamp() << "\n";);
  1715      typename watch_list::const_iterator it  = m_wlist[x].begin();

  1789          bool axiom = GET_TAG(*it) != 0;
  1790:         TRACE("subpaving_init", tout << "asserting: "; display(tout, a); tout << ", axiom: " << axiom << "\n";);
  1791          if (a->x() == null_var)

  1796      }
  1797:     TRACE("subpaving_init", tout << "bounds after init\n"; display_bounds(tout, n););
  1798  }

  1808      SASSERT(m_leaf_tail == m_root);
  1809:     TRACE("subpaving_init", display_constraints(tout););
  1810      assert_units(m_root);

  1812      propagate(m_root);
  1813:     TRACE("subpaving_init", tout << "root bounds after propagation\n"; display_bounds(tout, m_root););
  1814      SASSERT(check_invariant());

  1820          init();
  1821:     TRACE("subpaving_stats", statistics st; collect_statistics(st); tout << "statistics:\n"; st.display_smt2(tout););
  1822:     TRACE("subpaving_main", display_params(tout););
  1823      while (m_leaf_head != nullptr) {

  1830              break;
  1831:         TRACE("subpaving_main", tout << "selected node: #" << n->id() << ", depth: " << n->depth() << "\n";);
  1832          remove_from_leaf_dlist(n);

  1836          }
  1837:         TRACE("subpaving_main", tout << "node #" << n->id() << " after propagation\n";
  1838                display_bounds(tout, n););
  1839          if (n->inconsistent()) {
  1840:             TRACE("subpaving_main", tout << "node #" << n->id() << " is inconsistent.\n";);
  1841              // TODO: conflict resolution

  1844          if (n->depth() >= m_max_depth) {
  1845:             TRACE("subpaving_main", tout << "maximum depth reached, skipping node #" << n->id() << "\n";);
  1846              continue;

  1848          var x = (*m_var_selector)(n);
  1849:         TRACE("subpaving_main", tout << "splitting variable: "; display(tout, x); tout << "\n";);
  1850          if (x != null_var) {

  1855      }
  1856:     TRACE("subpaving_stats", statistics st; collect_statistics(st); tout << "statistics:\n"; st.display_smt2(tout););
  1857  }

z3/src/math/subpaving/tactic/subpaving_tactic.cpp:
  156                  lower = !lower;
  157:             TRACE("subpaving_tactic", tout << x << " " << k << " " << lower << " " << open << "\n";);
  158              return m_ctx->mk_ineq(x, k, lower, open);

z3/src/model/array_factory.cpp:
   63  expr * array_factory::get_some_value(sort * s) {
   64:     TRACE("array_factory", tout << mk_pp(s, m_manager) << "\n";);
   65      value_set * set = nullptr;

   74  bool array_factory::mk_two_diff_values_for(sort * s) {
   75:     TRACE("array_factory", tout << mk_pp(s, m_manager) << "\n";);
   76      DEBUG_CODE({

  103          if (!mk_two_diff_values_for(s)) {
  104:             TRACE("array_factory_bug", tout << "could not create diff values: " << mk_pp(s, m_manager) << "\n";);
  105              return false;

  115      v2 = *it;
  116:     TRACE("array_factory", tout << v1 << " " << v2 << "\n";);
  117      return true;    

  149  
  150:     TRACE("array_factory_bug", tout << "array fresh value: using fresh index, range: " << mk_pp(range, m_manager) << "\n";);
  151      expr_ref v1(m_manager), v2(m_manager), w1(m_manager), w2(m_manager);

  159          // Thus, A[i1] == A[i2] which is a contradiction since v1 != v2 and A[i1] = v1 and A[i2] = v2. 
  160:         TRACE("array_factory_bug", tout << "v1: " << mk_pp(v1, m_manager) << " v2: " << mk_pp(v2, m_manager) << "\n";);
  161          ptr_buffer<expr> args1;

  198      // failed to create a fresh array value
  199:     TRACE("array_factory_bug", tout << "failed to build fresh array value\n";);
  200      return nullptr;

z3/src/model/datatype_factory.cpp:
   41      register_value(r);
   42:     TRACE("datatype", tout << mk_pp(r, m_util.get_manager()) << "\n";);
   43      return r;    

   69      bool result = contains(last);
   70:     TRACE("datatype", tout << mk_pp(e, m_manager) << " in " << mk_pp(last, m_manager) << " " << result << "\n";);
   71      return result;

  129              }
  130:             TRACE("datatype", tout << "almost fresh: " << mk_pp(new_value, m_manager) << "\n";);
  131              return new_value;

  141          return m_model.get_fresh_value(s);
  142:     TRACE("datatype", tout << "generating fresh value for: " << s->get_name() << "\n";);
  143      value_set * set = get_value_set(s);

  149              m_last_fresh_value.insert(s, val);
  150:         TRACE("datatype", tout << "0. result: " << mk_pp(val, m_manager) << "\n";);
  151          return val;

  182          new_value = m_manager.mk_app(constructor, args);
  183:         CTRACE("datatype", found_fresh_arg && set->contains(new_value), tout << "seen: " << new_value << "\n";);
  184          if (found_fresh_arg && set->contains(new_value))

  189                  m_last_fresh_value.insert(s, new_value);
  190:             TRACE("datatype", tout << "1. result: " << mk_pp(new_value, m_manager) << "\n";);
  191              return new_value;

  200              ++num_iterations;
  201:             TRACE("datatype", tout << num_iterations << " " << mk_pp(get_last_fresh_value(s), m_manager) << "\n";);
  202              ptr_vector<func_decl> const & constructors = *m_util.get_datatype_constructors(s);

  206                  unsigned num         = constructor->get_arity();
  207:                 TRACE("datatype", tout << "checking constructor: " << constructor->get_name() << "\n";);
  208                  for (unsigned i = 0; i < num; i++) {
  209                      sort * s_arg        = constructor->get_domain(i);
  210:                     TRACE("datatype", tout << mk_pp(s, m_manager) << " " 
  211                            << mk_pp(s_arg, m_manager) << " are_siblings " 

  224                          if (!maybe_new_arg) {
  225:                             TRACE("datatype", 
  226                                    tout << "no argument found for " << mk_pp(s_arg, m_manager) << "\n";);

  241                      new_value = m_manager.mk_app(constructor, args);
  242:                     TRACE("datatype", tout << "potential new value: " << mk_pp(new_value, m_manager) << "\n";);
  243                      m_last_fresh_value.insert(s, new_value);

  245                          register_value(new_value);
  246:                         TRACE("datatype", tout << "2. result: " << mk_pp(new_value, m_manager) << "\n";);
  247                          return new_value;

z3/src/model/func_interp.cpp:
  144  
  145:     TRACE("func_interp", tout << "set_else: " << expr_ref(e, m()) << "\n";);
  146  

  197      reset_interp_cache();
  198:     CTRACE("func_interp_bug", get_entry(args) != 0,
  199             tout << "Old: " << mk_ismt2_pp(get_entry(args)->m_result, m()) << "\n";

z3/src/model/model_core.cpp:
  55      }
  56:     TRACE("model", tout << "register " << d->get_name() << "\n";
  57            if (v) tout << mk_pp(v, m) << "\n";

  83  func_interp* model_core::update_func_interp(func_decl* d, func_interp* fi) {
  84:     TRACE("model", tout << "register " << d->get_name() << "\n";);
  85  

z3/src/model/model_evaluator.cpp:
  110          bool r = (fi != nullptr) && eval_fi(fi, num, args, result);
  111:         CTRACE("model_evaluator", r, tout << "reduce_app " << f->get_name() << "\n";
  112                 for (unsigned i = 0; i < num; i++) tout << mk_ismt2_pp(args[i], m) << "\n";

  152          auto st = reduce_app_core(f, num, args, result, result_pr);
  153:         CTRACE("model_evaluator", st != BR_FAILED, 
  154                 tout << st << " " << mk_pp(f, m) << "  ";

  199              pp(func_decl* f, expr_ref& r) :f(f), r(r) {}
  200:             ~pp() { TRACE("model_evaluator", tout << mk_pp(f, r.m()) << " " << r << "\n";); }
  201          };

  216                  st = contains_as_array(val) ? BR_REWRITE_FULL : BR_DONE;
  217:                 TRACE("model_evaluator", tout << result << "\n";);
  218                  return st;

  316              result = def;
  317:             TRACE("model_evaluator", tout << result << "\n";);
  318              return true;

  330              m_def_cache.insert(g, result);
  331:             TRACE("model_evaluator", tout << mk_pp(g, m) << " " << result << "\n";);
  332              return true;

  334          
  335:         TRACE("model_evaluator",
  336              tout << "could not get array interpretation " << mk_pp(g, m) << " " << fi << "\n";

  342      void expand_stores(expr_ref& val) {
  343:         TRACE("model_evaluator", tout << val << "\n";);
  344          vector<expr_ref_vector> stores;

  357              }
  358:             TRACE("model_evaluator", tout << val << "\n";);
  359          }

  391  
  392:         CTRACE("model_evaluator", def != nullptr, tout << "get_macro for " << f->get_name() << " (model completion: " << m_model_completion << ") " << mk_pp(def, m) << "\n";);
  393  

  461          }
  462:         TRACE("model_evaluator", tout << "mk_array_eq " << m_array_equalities << " "
  463              << mk_pp(a, m) << " " << mk_pp(b, m) << "\n";);

  481              if (args_are_unique1 && args_are_unique2 && !stores1.empty()) {
  482:                 TRACE("model_evaluator", tout << "args are unique " << conj << "\n";);
  483                  return mk_array_eq_core(stores1, else1, stores2, else2, conj, result);

  497              result = mk_and(conj);
  498:             TRACE("model_evaluator", tout << mk_pp(a, m) << " == " << mk_pp(b, m) << " -> " << conj << "\n";
  499                    for (auto& s : stores1) tout << "store: " << s << "\n"; );

  538          args_table table2(DEFAULT_HASHTABLE_INITIAL_CAPACITY, ah, ae);
  539:         TRACE("model_evaluator",
  540                tout << "arity " << arity << "\n";

  554                  // first insertion takes precedence.
  555:                 TRACE("model_evaluator", tout << "duplicate " << stores2[i] << "\n";);
  556                  continue;

  561              if (table1.find(stores2[i].data(), args)) {
  562:                 TRACE("model_evaluator", tout << "found value " << stores2[i] << "\n";);
  563                  table1.remove(args);

  570              else {
  571:                 TRACE("model_evaluator", tout << "not found value " << stores2[i] << "\n";);
  572                  switch (compare(else1, val)) {

  610          are_unique = true;
  611:         TRACE("model_evaluator", tout << mk_pp(a, m) << "\n";);
  612  

  631          if (!m_ar.is_as_array(a)) {
  632:             TRACE("model_evaluator", tout << "no translation: " << mk_pp(a, m) << "\n";);
  633:             TRACE("model_evaluator", tout << m_model << "\n";);
  634              return false;

  639          if (!g) {
  640:             TRACE("model_evaluator", tout << "no interpretation for " << mk_pp(f, m) << "\n";);
  641              return false;

  644          if (!else_case) {
  645:             TRACE("model_evaluator", tout << "no else case " << mk_pp(a, m) << "\n";);
  646              return false;

  666          if (!ground) {
  667:             TRACE("model_evaluator", tout << "could not extract ground array interpretation: " << mk_pp(a, m) << "\n";);
  668              return false;

  747  void model_evaluator::operator()(expr * t, expr_ref & result) {
  748:     TRACE("model_evaluator", tout << mk_ismt2_pp(t, m()) << "\n";);
  749      m_imp->operator()(t, result);
  750      m_imp->expand_stores(result);
  751:     TRACE("model_evaluator", tout << "eval: " << mk_ismt2_pp(t, m()) << " --> " << result << "\n";);
  752  }

  798          (void)ex;
  799:         TRACE("model_evaluator", tout << ex.msg () << "\n";);
  800          return false;

z3/src/model/model_implicant.cpp:
   65          IF_VERBOSE(3, verbose_stream() << "Not evaluated " << mk_pp(e, m) << " := " << mk_pp(val, m) << "\n";);
   66:         TRACE("pdr", tout << "Variable is not tracked: " << mk_pp(e, m) << " := " << mk_pp(val, m) << "\n";);
   67          set_x(e);

   98      
   99:     TRACE("pdr_verbose", 
  100            tout << "formulas:\n";

  104      expr_ref_vector model = prune_by_cone_of_influence(formulas);
  105:     TRACE("pdr_verbose",
  106            tout << "pruned model:\n";

  120      
  121:     TRACE("pdr", 
  122            tout << "formulas:\n";

  153      reset();
  154:     TRACE("pdr", 
  155            tout << "minimized model:\n";

  290      for (unsigned i = 0; i < tocollect.size(); ++i) {     
  291:         TRACE("pdr_verbose", tout << "collect: " << mk_pp(tocollect[i], m) << "\n";);
  292          for_each_expr(*this, m_visited, tocollect[i]);

  305      m_visited.reset();
  306:     TRACE("pdr", tout << sz << " ==> " << model.size() << "\n";);
  307      return model;

  447          else {
  448:             TRACE("pdr", tout << "not inherited:\n" << mk_pp(e, m) << "\n" << mk_pp(v, m) << "\n";);
  449              set_x(e);

  461      else {
  462:         TRACE("pdr", tout << "not inherited:\n" << mk_pp(e, m) << "\n" << mk_pp(v, m) << "\n";);
  463          set_x(e);

  478      
  479:     TRACE("pdr", tout << mk_pp(a, m) << "\n";);
  480      while (m_array.is_store(a)) {

  504                  if (!is_ground(store[j].get())) {
  505:                     TRACE("pdr", tout << "could not extract array interpretation: " << mk_pp(a, m) << "\n" << mk_pp(store[j].get(), m) << "\n";);
  506                      return false;

  513          if (!else_case) {
  514:             TRACE("pdr", tout << "no else case " << mk_pp(a, m) << "\n";);
  515              return false;

  517          if (!is_ground(else_case)) {
  518:             TRACE("pdr", tout << "non-ground else case " << mk_pp(a, m) << "\n" << mk_pp(else_case, m) << "\n";);
  519              return false;

  524          }
  525:         TRACE("pdr", tout << "else case: " << mk_pp(else_case, m) << "\n";);
  526          return true;
  527      }
  528:     TRACE("pdr", tout << "no translation: " << mk_pp(a, m) << "\n";);
  529      

  536  void model_implicant::eval_array_eq(app* e, expr* arg1, expr* arg2) {
  537:     TRACE("pdr", tout << "array equality: " << mk_pp(e, m) << "\n";);
  538      expr_ref v1 = (*m_model)(arg1);

  547      if (!r->is_infinite() && !r->is_very_big() && !s->is_infinite() && !s->is_very_big()) {
  548:         TRACE("pdr", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  549          set_x(e);

  555          !extract_array_func_interp(v2, store, else2)) {
  556:         TRACE("pdr", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  557          set_x(e);

  562          if (m.is_value(else1) && m.is_value(else2)) {
  563:             TRACE("pdr", tout 
  564                    << "defaults are different: " << mk_pp(e, m) << " " 

  571          else {
  572:             TRACE("pdr", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  573              set_x(e);

  594          if (m.is_value(w1) && m.is_value(w2)) {
  595:             TRACE("pdr", tout << "Equality evaluation: " << mk_pp(e, m) << "\n"; 
  596                    tout << mk_pp(s1, m) << " |-> " << mk_pp(w1, m) << "\n";

  606          else {
  607:             TRACE("pdr", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  608              set_x(e);

  632          else {
  633:             TRACE("pdr", tout << "cannot evaluate: " << mk_pp(vl, m) <<  "\n";);
  634              set_x(e);

  659          else {
  660:             TRACE("pdr", tout << "not value equal:\n" << mk_pp(e1, m) << "\n" << mk_pp(e2, m) << "\n";);
  661              set_x(e);

  851          SASSERT(!is_unknown(form));
  852:         TRACE("pdr_verbose", 
  853                tout << "formula is " << (is_true(form) ? "true" : is_false(form) ? "false" : "unknown") << "\n" <<mk_pp(form, m)<< "\n";);

  860              IF_VERBOSE(0, verbose_stream() << "formula undetermined in model: " << mk_pp(form, m) << "\n";);
  861:             TRACE("pdr", model_smt2_pp(tout, m, *m_model, 0);); 
  862              has_x = true;

z3/src/model/model_implicant.h:
  75      inline void set_number(expr* x, rational const& v) { 
  76:         set_v(x); TRACE("pdr_verbose", tout << mk_pp(x,m) << " " << v << "\n";); m_numbers.insert(x,v); 
  77      }

z3/src/model/model_macro_solver.cpp:
   26      fi->set_else(f_else);
   27:     TRACE("model_finder", tout << f->get_name() << " " << mk_pp(f_else, m) << "\n";);
   28  }

   69              set_else_interp(f, f_else);
   70:             TRACE("model_finder", tout << "satisfying the quantifier using simple macro:\n";
   71              m->display(tout); tout << "\n";);

  309  
  310:     TRACE("model_finder_hint",
  311          tout << "greedy depth: " << depth << ", f: " << f->get_name() << "\n";

  320          m_residue.push_scope();
  321:         TRACE("model_finder", tout << f->get_name() << " " << mk_pp(def, m) << "\n";);
  322          m_fs.insert(f, def);

  375          if (is_cyclic()) return;
  376:         TRACE("model_finder_hint",
  377              tout << "found subset that is satisfied by macros\n";

  383  
  384:     TRACE("model_finder_hint", tout << "candidates from residue:\n";
  385      for (func_decl* f : candidates) {

  446      mk_q_f_defs(qcandidates);
  447:     TRACE("model_finder_hint", tout << "starting hint-solver search using:\n"; display_qcandidates(tout, qcandidates););
  448      for (func_decl* f : m_candidates) {

  471  bool non_auf_macro_solver::add_macro(func_decl* f, expr* f_else) {
  472:     TRACE("model_finder", tout << "trying to add macro for " << f->get_name() << "\n" << mk_pp(f_else, m) << "\n";);
  473      func_decl_set* s = m_dependencies.mk_func_decl_set();

  475      if (!m_dependencies.insert(f, s)) {
  476:         TRACE("model_finder", tout << "failed to add macro\n";);
  477          return false; // cyclic dependency

  512                  func_decl* f = m->get_f();
  513:                 TRACE("model_finder", tout << "considering macro for: " << f->get_name() << "\n";
  514                  m->display(tout); tout << "\n";);

z3/src/model/model_smt2_pp.cpp:
  218          }
  219:         TRACE("model_smt2_pp", for (unsigned i = 0; i < var_names.size(); i++) tout << var_names[i] << "\n";);
  220          f_var_names.reset();

z3/src/model/model.cpp:
   96          (void)ex;
   97:         TRACE("model_evaluator", tout << ex.msg() << "\n";);
   98          return false;

  272              break;
  273:         TRACE("model", tout << "remove\n"; for (func_decl* f : removed) tout << f->get_name() << "\n";);
  274          remove_decls(m_decls, removed);

  438  
  439:     TRACE("model", tout << "cleaning up:\n" << mk_pp(e, m) << "\n";);
  440  

  483                          new_t = fi->get_array_interp(f);
  484:                         TRACE("model", tout << "array interpretation:" << new_t << "\n";);
  485                      }

  511              if (t != new_t.get()) trail.push_back(new_t);
  512:             CTRACE("model", (t != new_t.get()), tout << mk_bounded_pp(t, m) << " " << new_t << "\n";);
  513              todo.pop_back();

  635      }
  636:     TRACE("model", tout << *this << "\n";);
  637  }

z3/src/muz/base/dl_context.cpp:
  346              m_preds.insert(decl);
  347:             TRACE("dl", tout << mk_pp(decl, m) << "\n";);
  348              if (named) {

  356          for (func_decl* p : preds) {
  357:             TRACE("dl", tout << mk_pp(p, m) << "\n";);
  358              m_preds.insert(p);

  571          m_rule_properties.set_generate_proof(generate_proof_trace());
  572:         TRACE("dl", m_rule_set.display(tout););
  573          switch(get_engine()) {

  712          SASSERT(m_closed); //we must finish adding rules before we start transforming them
  713:         TRACE("dl", display_rules(tout););
  714          if (transf(m_rule_set)) {

  717              m_rule_set.ensure_closed();
  718:             TRACE("dl", display_rules(tout););
  719:             TRACE("dl_verbose", display(tout););
  720          }

  756      void context::assert_expr(expr* e) {
  757:         TRACE("dl", tout << mk_ismt2_pp(e, m) << "\n";);
  758          m_background.push_back(e);

  805      void context::configure_engine(expr* q) {
  806:         TRACE("dl", tout << mk_pp(q, m) << " " << m_engine_type << "\n";);
  807          if (m_engine_type != LAST_ENGINE) {

z3/src/muz/base/dl_rule_set.cpp:
   97      void rule_dependencies::populate(rule const* r) {
   98:         TRACE("dl_verbose", tout << r->get_decl()->get_name() << "\n";);
   99          m_visited.reset();

  318      void rule_set::add_rule(rule * r) {
  319:         TRACE("dl_verbose", r->display(m_context, tout << "add:"););
  320          SASSERT(!is_closed());

  330      void rule_set::del_rule(rule * r) {
  331:         TRACE("dl", r->display(m_context, tout << "del:"););
  332          func_decl* d = r->get_decl();

  348      void rule_set::replace_rule(rule * r, rule * other) {
  349:         TRACE("dl", r->display(m_context, tout << "replace:"););
  350          func_decl* d = r->get_decl();

z3/src/muz/base/dl_rule_transformer.cpp:
   73  
   74:         TRACE("dl_rule_transf", 
   75              tout<<"init:\n";

  109              IF_VERBOSE(1, verbose_stream() << new_rules->get_num_rules() << " rules " << sec << "s)\n";);
  110:             TRACE("dl_rule_transf", 
  111                  tout << typeid(p).name()<<":\n";

z3/src/muz/base/dl_rule.cpp:
  190          hoist_compound_predicates(index, m_head, m_body);
  191:         TRACE("dl_rule",
  192                tout << mk_pp(m_head, m) << " :- ";

  262      func_decl* rule_manager::mk_query(expr* query, rule_set& rules) {
  263:         TRACE("dl", tout << mk_pp(query, m) << "\n";);
  264  

  341          }
  342:         TRACE("dl", tout << rule_expr << "\n";);
  343  

  401          fml = m.mk_app(fml->get_decl(), m_args.size(), m_args.data());
  402:         TRACE("dl_rule", tout << mk_pp(fml.get(), m) << "\n";);
  403      }

  638              r = mk(r->get_head(), tail.size(), tail.data(), tail_neg.data(), r->name());
  639:             TRACE("dl", r->display(m_ctx, tout << "reduced rule\n"););
  640          }

  747          if (try_quantifier_elimination) {
  748:             TRACE("dl_rule_unbound_fix_pre_qe",
  749                  tout<<"rule: ";

  762  
  763:         TRACE("dl_rule_unbound_fix",
  764              tout<<"rule: ";

z3/src/muz/base/dl_util.cpp:
  287              expr_ref_vector body(m);
  288:             TRACE("dl", tout << "unreachable: " << unreachable << " " << r.get_decl()->get_name() << "\n");
  289              switch (unreachable) {

  306              }
  307:             TRACE("dl", 
  308                    tout << mk_pp(r.get_head(), m) << " :- \n";

  338  
  339:         TRACE("dl", 
  340                tout << premises[0]->get_id() << " " << mk_pp(premises[0].get(), m) << "\n";

  376  
  377:         TRACE("dl", 
  378                tout << premises[0]->get_id() << " " << mk_pp(premises[0].get(), m) << "\n";

z3/src/muz/base/hnf.cpp:
  165          }
  166:         TRACE("hnf",
  167              tout << mk_pp(n, m) << "\n==>\n" << result << "\n";);

  336          }
  337:         TRACE("hnf", tout << mk_pp(b, m) << "\n";);
  338          if (m.is_or(b)) {

  524      m_imp->operator()(n, p, rs, ps);    
  525:     TRACE("hnf", 
  526            ast_manager& m = rs.get_manager();

z3/src/muz/bmc/dl_bmc_engine.cpp:
   265              SASSERT(m.is_true(eval_q(md, b.m_query_pred, level)));
   266:             TRACE("bmc", model_smt2_pp(tout, m, *md, 0););
   267  

   269              while (true) {
   270:                 TRACE("bmc", tout << "Predicate: " << pred->get_name() << "\n";);
   271                  expr_ref_vector sub(m);

   276                      rule_i = m.mk_app(mk_q_rule(pred, i), mk_q_num(level).get());
   277:                     TRACE("bmc", rls[i]->display(b.m_ctx, tout << "Checking rule " << mk_pp(rule_i, m) << " "););
   278                      if (m.is_true(eval_q(md, rule_i, level))) {

   492              }
   493:             TRACE("bmc", tout << "Predicate: " << pred->get_name() << "\n";);
   494              rule_manager& rm = b.m_ctx.get_rule_manager();

   505                  prop_r = m.mk_app(rule_i, prop->get_num_args(), prop->get_args());
   506:                 TRACE("bmc", rls[i]->display(b.m_ctx, tout << "Checking rule " << mk_pp(rule_i, m) << " ");
   507                        tout << (*md)(prop_r) << "\n";

  1000              if (!new_sorts.empty()) {
  1001:                 TRACE("bmc", dtu.display_datatype(new_sorts[0].get(), tout););
  1002              }

  1198  
  1199:             TRACE("bmc", model_smt2_pp(tout, m, *md, 0););
  1200  

  1202              while (true) {
  1203:                 TRACE("bmc", tout << "Predicate: " << pred->get_name() << "\n";);
  1204                  expr_ref_vector sub(m);

  1209                      expr_ref rule_i = mk_level_rule(pred, i, level);
  1210:                     TRACE("bmc", rls[i]->display(b.m_ctx, tout << "Checking rule " << mk_pp(rule_i, m) << " "););
  1211                      if (m.is_true(md->get_const_interp(to_app(rule_i)->get_decl()))) {

  1515      void bmc::assert_expr(expr* e) {
  1516:         TRACE("bmc", tout << mk_pp(e, m) << "\n";);
  1517          m_solver->assert_expr(e);

z3/src/muz/dataflow/dataflow.h:
  84              for (func_decl* sym : m_rules.get_output_predicates()) {
  85:                 TRACE("dl", tout << sym->get_name() << "\n";);
  86                  const rule_vector& output_rules = m_rules.get_predicate_rules(sym);

z3/src/muz/fp/horn_tactic.cpp:
  212                      msg << "formula is not in Horn fragment: " << mk_pp(g->form(i), m) << "\n";
  213:                     TRACE("horn", tout << msg.str(););
  214                      throw tactic_exception(msg.str());

  289                      mc = mc2.get();
  290:                     TRACE("dl", mc->display(tout << *md << "\n"););
  291                  }

z3/src/muz/rel/check_relation.cpp:
  415      void check_relation_plugin::check_equiv(char const* objective, expr* fml1, expr* fml2) {
  416:         TRACE("doc", tout << mk_pp(fml1, m) << "\n";
  417                tout << mk_pp(fml2, m) << "\n";);

  490          void operator()(relation_base & _r, const relation_base & _src, relation_base * _delta) override {
  491:             TRACE("doc", _r.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););
  492              check_relation& r = get(_r);

z3/src/muz/rel/dl_bound_relation.cpp:
  151          void operator()(relation_base & _r, const relation_base & _src, relation_base * _delta) override {
  152:             TRACE("bound_relation", _r.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););
  153              get(_r).mk_union(get(_src), get(_delta), m_is_widen);

  163          void operator()(relation_base & _r, const relation_base & _src, relation_base * _delta) override {
  164:             TRACE("bound_relation", _r.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););   
  165              get(_r).mk_union_i(get_interval_relation(_src), get(_delta), m_is_widen);
  166:             TRACE("bound_relation", _r.display(tout << "dst':\n"););
  167          }

  345          void operator()(relation_base& t) override {
  346:             TRACE("dl", tout << mk_pp(m_cond, m_cond.get_manager()) << "\n"; t.display(tout););
  347              bound_relation& r = get(t);

  369              }    
  370:             TRACE("dl", t.display(tout << "result\n"););   
  371          }

  403          }
  404:         TRACE("dl", 
  405                tout << "project: ";

z3/src/muz/rel/dl_compiler.cpp:
   191          
   192:         TRACE("dl", tout << "Adding unbound column " << mk_pp(pred, m_context.get_manager()) 
   193                << " " << m_context.get_rel_context()->get_rmanager().to_nice_string(s) << "\n";);

   221          SASSERT(sig.empty());
   222:         TRACE("dl", tout << "Adding unbound column " << mk_pp(pred, m_context.get_manager()) << "\n";);
   223          if (m_empty_tables_registers.find(pred, result))

   273  
   274:         TRACE("dl", tout << mk_pp(head_pred, m_context.get_manager()) << "\n";);
   275  

   339                      SASSERT(acis[i].kind==ACK_UNBOUND_VAR);
   340:                     TRACE("dl", tout << head_pred->get_name() << " index: " << i 
   341                            << " " << m_context.get_rel_context()->get_rmanager().to_nice_string(acis[i].domain) << "\n";);

   458  
   459:         TRACE("dl", r->display(m_context, tout); );
   460  

   627                      relation_sort unbound_sort = m_free_vars[v];
   628:                     TRACE("dl", tout << "unbound: " << v << "\n" << filter_cond << " " << mk_pp(unbound_sort, m) << "\n";);
   629                      make_add_unbound_column(r, 0, head_pred, filtered_res, unbound_sort, filtered_res, dealloc, acc);

   780                      reg_idx new_reg;
   781:                     TRACE("dl", tout << mk_pp(head_pred, m_context.get_manager()) << "\n";);
   782                      bool new_dealloc;

   904                  make_add_unbound_column(r, v, pred, single_res, e->get_sort(), single_res, dealloc, acc);
   905:                 TRACE("dl", tout << "Adding unbound column: " << mk_pp(e, m_context.get_manager()) << "\n";);
   906              }

  1270  
  1271:             TRACE("dl",
  1272                  tout << "Stratum: ";

  1334  
  1335:         TRACE("dl", execution_code.display(execution_context(m_context), tout););
  1336      }

z3/src/muz/rel/dl_instruction.cpp:
   322              log_verbose(ctx);            
   323:             TRACE("dl", tout << "loop entered\n";);
   324              unsigned count = 0;

   327                  if (!m_body->perform(ctx)) {
   328:                     TRACE("dl", tout << "while loop terminated before completion\n";);
   329                      return false;

   331              }
   332:             TRACE("dl", tout << "while loop exited\n";);
   333              return true;

   385  
   386:             TRACE("dl",
   387                  r1.get_signature().output(ctx.get_rel_context().get_manager(), tout);

   393  
   394:             TRACE("dl", 
   395                  ctx.reg(m_res)->get_signature().output(ctx.get_rel_context().get_manager(), tout);

   533              relation_base & r = *ctx.reg(m_reg);
   534:             TRACE("dl_verbose", r.display(tout <<"pre-filter-interpreted:\n"););
   535              if (!find_fn(r, fn)) {

   548              }            
   549:             //TRACE("dl_verbose", r.display(tout <<"post-filter-interpreted:\n"););
   550  

   590              relation_base & reg = *ctx.reg(m_src);
   591:             TRACE("dl_verbose", reg.display(tout <<"pre-filter-interpreted-and-project:\n"););
   592              if (!find_fn(reg, fn)) {

   606              }
   607:             // TRACE("dl_verbose", reg.display(tout << "post-filter-interpreted-and-project:\n"););
   608              return true;

   642          bool perform(execution_context & ctx) override {
   643:             TRACE("dl", tout << "union " << m_src << " into " << m_tgt 
   644                    << " " << ctx.reg(m_src) << " " << ctx.reg(m_tgt) << "\n";);

   701              SASSERT(r_src.get_signature().size() == r_tgt.get_signature().size());
   702:             TRACE("dl_verbose", r_tgt.display(tout <<"pre-union:"););
   703  

   705  
   706:             TRACE("dl_verbose", 
   707                  r_src.display(tout <<"src:");

   843              }
   844:             TRACE("dl", tout<<r1.get_size_estimate_rows()<<" x "<<r2.get_size_estimate_rows()<<" jp->\n";);
   845              ctx.set_reg(m_res, (*fn)(r1, r2));
   846:             TRACE("dl",  tout<<ctx.reg(m_res)->get_size_estimate_rows()<<"\n";);
   847              if (ctx.reg(m_res)->fast_empty()) {

   895              // [Leo]: does not compile on gcc
   896:             // TRACE("dl", tout << "src:"  << m_src << " result: " << m_result << " value:" << m_value << " column:" << m_col << "\n";);
   897          }

  1142  
  1143:             TRACE("dl", instr->display_head_impl(ctx, tout << "% ") << "\n";);
  1144  

z3/src/muz/rel/dl_interval_relation.cpp:
  202  
  203:             TRACE("interval_relation", _r.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););
  204  

  272              r.mk_intersect(m_col, interval(p.dep(), m_value));
  273:             TRACE("interval_relation", tout << m_value << "\n"; r.display(tout););            
  274          }

  294              get(t).filter_interpreted(m_cond);
  295:             TRACE("interval_relation", tout << mk_pp(m_cond, m_cond.get_manager()) << "\n"; t.display(tout););
  296          }

  319      {
  320:         TRACE("interval_relation", tout << s.size() << "\n";);
  321      }    

z3/src/muz/rel/dl_mk_explanations.cpp:
  486          if (&r.get_plugin() != this) {
  487:             TRACE("dl", tout << "not same plugin\n";);
  488              return nullptr;

  491          if (!m.is_eq(cond)) {
  492:             TRACE("dl", tout << "not equality " << mk_pp(cond, m) << "\n";);
  493              return nullptr;

  502          if (!is_var(arg1) || !is_app(arg2)) {
  503:             TRACE("dl", tout << "not variable assignemnt\n";);
  504              return nullptr;

  508          if (!get_context().get_decl_util().is_rule_sort(col_var->get_sort())) {
  509:             TRACE("dl", tout << "not rule sort\n";);
  510              return nullptr;

  846          for (func_decl* orig_decl : predicates) {
  847:             TRACE("dl", tout << mk_pp(orig_decl, m_manager) << "\n";);
  848              func_decl * e_decl = get_e_decl(orig_decl);

  868                  scoped_rel<relation_base> aux_extended_rel = (*product_fun)(orig_rel, *m_e_fact_relation);
  869:                 TRACE("dl", tout << aux_extended_rel << " " << aux_extended_rel->get_plugin().get_name() << "\n";
  870                        tout << e_rel.get_plugin().get_name() << "\n";);
  871                  scoped_ptr<relation_union_fn> union_fun = rmgr.mk_union_fn(e_rel, *aux_extended_rel);
  872:                 TRACE("dl", tout << union_fun << "\n";);
  873                  SASSERT(union_fun);

z3/src/muz/rel/dl_mk_simple_joins.cpp:
   97                  idx_set_union(m_all_nonlocal_vars, non_local_vars_normalized);
   98:                 TRACE("dl", tout << "all-nonlocal: " << m_all_nonlocal_vars << "\n";);
   99              }

  247              m_pinned.push_back(t2n);
  248:             TRACE("dl_verbose", tout << mk_pp(t1, m) << " " << mk_pp(t2, m) << " |-> " << t1n_ref << " " << t2n_ref << "\n";);
  249              

  275              inf.add_rule(*this, t1, t2, r, normalized_vars, non_local_vars);
  276:             TRACE("dl", tout << mk_pp(t1, m) << " " << mk_pp(t2, m) << " ";
  277                    tout << non_local_vars << "\n";

  294              counter.count_rule_vars(r, 1);
  295:             TRACE("dl", tout << "counter: "; for (auto const& kv: counter) tout << kv.m_key << ": " << kv.m_value << " "; tout << "\n";);            
  296              ptr_vector<app> & rule_content = m_rules_content.insert_if_not_there(r, ptr_vector<app>());

  298              
  299:             TRACE("dl", r->display(m_context, tout << "register ");); 
  300              

  323                      set_intersection(non_local_vars, t2_vars);
  324:                     TRACE("dl", tout << "non-local vars: " << non_local_vars << "\n";);
  325                      register_pair(t1, t2, r, non_local_vars);

  360              }
  361:             TRACE("dl", 
  362                    tout << mk_pp(t1, m) << " " << mk_pp(t2, m) << " arity: " << arity << "\n";

  416              app_ref_vector added_tails(added_tails0); //we need a copy since we'll be modifying it
  417:             TRACE("dl", tout << added_tails << "\n";);
  418  

  460                  
  461:                 TRACE("dl", tout << "replace edges " << mk_pp(a_tail, m) << "\n";);
  462  

  495              }
  496:             TRACE("dl", 
  497                    tout << "pair: " << mk_pp(t1, m) << " " << mk_pp(t2, m) << "\n";

  535                      new_transf = m_var_subst(t_new, denormalizer);
  536:                     TRACE("dl", tout  << mk_pp(rt1, m) << " " << mk_pp(rt2, m) << " -> " << new_transf << "\n";);            
  537                      counter.count_vars(rt2, -1);

  545                      // require that tr_vars contains non_local_vars
  546:                     TRACE("dl", tout << "non-local : " << non_local_vars << " tr_vars " << tr_vars << " rt12_vars " << rt2_vars << "\n";);
  547                      if (!non_local_vars.subset_of(tr_vars)) {                        
  548                          var_ref_vector normalizer2 = get_normalizer(rt2, rt1);
  549:                         TRACE("dl", tout << normalizer << "\nnorm\n" << normalizer2 << "\n";);
  550                          denormalizer.reset();

  552                          new_transf = m_var_subst(t_new, denormalizer);
  553:                         TRACE("dl", tout  << mk_pp(rt2, m) << " " << mk_pp(rt1, m) << " -> " << new_transf << "\n";);            
  554                          SASSERT(non_local_vars.subset_of(rm.collect_vars(new_transf)));

  589              m_modified_rules = true;
  590:             TRACE("dl", tout << "replace rule content\n";);
  591              replace_edges(r, removed_tails, added_tails, rule_content);

  665  
  666:             TRACE("report_costs",                  
  667                    display_predicate(m_context, t1, tout);

z3/src/muz/rel/dl_product_relation.cpp:
  452          relation_base * operator()(const relation_base & _r1, const relation_base & _r2) override {
  453:             TRACE("dl", _r1.display(tout); _r2.display(tout););
  454              ptr_vector<relation_base> relations;

  462              result = alloc(product_relation, m_plugin, get_result_signature(), sz, relations.data());
  463:             TRACE("dl",result->display(tout););
  464              return result;

  504              relation_base* result = alloc(product_relation, p, m_sig, relations.size(), relations.data());
  505:             TRACE("dl", _r.display(tout); result->display(tout););
  506              return result;

  558              }
  559:             TRACE("dl_verbose", tout << r1.get_plugin().get_name() << " " << r2.get_plugin().get_name() << " " << (u?"found":"not found") << "\n";); 
  560              m_unions.back().push_back(u);

  605              if (!intersect_fun) {
  606:                 TRACE("dl", tgt.display(tout << "tgt\n"); src.display(tout << "src\n");); 
  607                  warning_msg("intersection does not exist");

  638          void operator()(relation_base& _tgt, const relation_base& _src, relation_base* _delta) override {
  639:             TRACE("dl", _tgt.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););
  640              SASSERT(m_plugin.check_kind(_tgt));

  664                      if (can_do_inner_union(i, j) && can_do_inner_union(j, i)) {
  665:                         TRACE("dl", itgt.display(tout << "tgt:\n"); src[j].display(tout << "src:\n"););
  666                          // union[i][j]

  668                          scoped_rel<relation_base> one_side_delta = fresh_delta ? fresh_delta->clone() : nullptr;
  669:                         TRACE("dl", one_side_union->display(tout << "union 1:\n"); src[j].display(tout););
  670                          do_inner_union(i, j, *one_side_union, src[j], one_side_delta.get());
  671:                         TRACE("dl", one_side_union->display(tout << "union:\n"););
  672                          do_destructive_intersection(side_result, one_side_union);                        
  673:                         TRACE("dl", 
  674                                side_result->display(tout << "inner-union: " << i << " " << j << "\n");

  682                          one_side_delta = fresh_delta ? fresh_delta->clone() : nullptr;
  683:                         TRACE("dl", one_side_union->display(tout << "union 2:\n"); tgt[j].display(tout););
  684                          do_inner_union(i, j, *one_side_union, tgt[j], one_side_delta.get());
  685:                         TRACE("dl", one_side_union->display(tout << "union:\n"););
  686                          do_destructive_intersection(side_result, one_side_union);
  687:                         TRACE("dl", 
  688                                side_result->display(tout << "inner-union: " << i << " " << j << "\n");

  711                      do_intersection(itgt, *side_result);
  712:                     TRACE("dl", side_result->display(tout << "inner-union-end: " << i << "\n"););
  713                  }

  728              }
  729:             TRACE("dl", _tgt.display(tout << "dst':\n"); 
  730                    if (_delta)  _delta->display(tout  << "delta:\n"); ;);

  751          void operator()(relation_base& _tgt, const relation_base& _src, relation_base* _delta) override {
  752:             TRACE("dl_verbose", _tgt.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););
  753              product_relation& tgt = get(_tgt);

  772              (*m_aligned_union_fun)(tgt, src, delta);
  773:             TRACE("dl", _tgt.display(tout << "dst':\n"); 
  774                          if (_delta) _delta->display(tout  << "delta:\n"););

  786          void operator()(relation_base& tgt, const relation_base& _src, relation_base* delta) override {
  787:             TRACE("dl", tgt.display(tout); _src.display(tout); );
  788              product_relation const& src = get(_src);

  801          if (check_kind(src)) {
  802:             TRACE("dl", tgt.display(tout << "different kinds"); src.display(tout););
  803              const product_relation & p_src = get(src);

  839          void operator()(relation_base & _r) override {
  840:             TRACE("dl", _r.display(tout););
  841              product_relation& r = get(_r);

  848              }
  849:             TRACE("dl", _r.display(tout););
  850          }

  916          void operator()(relation_base& _r) override {
  917:             TRACE("dl", _r.display(tout););
  918              product_relation const& r = get(_r);

  924              }
  925:             TRACE("dl", _r.display(tout););
  926          }      

  992  
  993:         TRACE("dl", {
  994                  ast_manager& m = get_ast_manager_from_rel_manager(get_manager());

z3/src/muz/rel/dl_relation_manager.cpp:
   203      void relation_manager::register_relation_plugin_impl(relation_plugin * plugin) {
   204:         TRACE("dl", tout << "register: " << plugin->get_name() << "\n";);
   205          m_relation_plugins.push_back(plugin);

   338          //stuff will be added to it by later operations.
   339:         TRACE("dl", s.output(get_context().get_manager(), tout << "empty product relation"); tout << "\n";);
   340          return product_relation_plugin::get_plugin(*this).mk_empty(s);

   534          relation_base * operator()(const relation_base & r1, const relation_base & r2) override {
   535:             TRACE("dl", tout << r1.get_plugin().get_name() << " " << r2.get_plugin().get_name() << "\n";);
   536              if(r1.get_signature().empty()) {

   741          }
   742:         // TRACE("dl", tout << src.get_plugin().get_name() << " " << tgt.get_plugin().get_name() << " " << (res?"created":"not created") << "\n";); 
   743          return res;

   783          relation_base * operator()(const relation_base & t1) override {
   784:             TRACE("dl", tout << t1.get_plugin().get_name() << "\n";);
   785              scoped_rel<relation_base> aux = t1.clone();

   820              scoped_rel<relation_base> filtered_rel = (*m_join_fun)(tgt, intersected_obj);
   821:             TRACE("dl", 
   822                    tgt.display(tout << "tgt:\n"); 

   830              tgt.reset();
   831:             TRACE("dl", tgt.display(tout << "target reset:\n"); );
   832              (*m_union_fun)(tgt, *filtered_rel);
   833:             TRACE("dl", tgt.display(tout << "intersected target:\n"); );
   834          }

   840              const unsigned * tgt_cols, const unsigned * src_cols) {
   841:         TRACE("dl_verbose", tout << tgt.get_plugin().get_name() << "\n";);
   842          unsigned_vector join_removed_cols;

   868              const relation_base & src, unsigned joined_col_cnt, const unsigned * t_cols, const unsigned * src_cols) {
   869:         TRACE("dl_verbose", tout << t.get_plugin().get_name() << "\n";);
   870          relation_intersection_filter_fn * res = t.get_plugin().mk_filter_by_intersection_fn(t, src, joined_col_cnt, 

   882              const relation_base & src) {
   883:         TRACE("dl_verbose", tout << tgt.get_plugin().get_name() << "\n";);
   884          SASSERT(tgt.get_signature()==src.get_signature());

   894              const unsigned * t_cols, const unsigned * negated_cols) { 
   895:         TRACE("dl", tout << t.get_plugin().get_name() << "\n";);
   896          relation_intersection_filter_fn * res = t.get_plugin().mk_filter_by_negation_fn(t, negated_obj, joined_col_cnt, 

  1555          table_base * operator()(const table_base & t1) override {
  1556:             TRACE("dl", tout << t1.get_plugin().get_name() << "\n";);
  1557              scoped_rel<table_base> aux = t1.clone();

z3/src/muz/rel/dl_sparse_table.cpp:
  303              if (!e) {
  304:                 TRACE("dl_table_relation", tout << "inserting\n";);
  305                  e = m_map.insert_if_not_there3(ofs, offset_vector());

  497      void sparse_table::write_into_reserve(const table_element* f) {
  498:         TRACE("dl_table_relation", tout << "\n";);
  499          m_data.ensure_reserve();

  652  
  653:         TRACE("dl_table_relation", 
  654                tout << "joined_col_cnt: " << joined_col_cnt << "\n";

  695                  table_element val = t1.m_column_layout.get(t1.get_at_offset(t1idx), t1_joined_cols[i]);
  696:                 TRACE("dl_table_relation", tout << "val: " << val << " " << t1idx << " " << t1_joined_cols[i] << "\n";);
  697                  if (t1_key[i] != val) {

  846              }
  847:             TRACE("dl_table_relation", tb1.display(tout); tb2.display(tout); res->display(tout); );
  848              return res;

z3/src/muz/rel/dl_table_relation.cpp:
   94  
   95:             TRACE("dl_table_relation", tout << "# join => "; tres->display(tout););
   96              if(&tres->get_plugin()!=&plugin.m_table_plugin) {

  156  
  157:             TRACE("dl_table_relation", tout << "# transform => "; tres->display(tout););
  158              if(&tres->get_plugin()!=&plugin.m_table_plugin) {

  264              }
  265:             TRACE("dl_table_relation", tout << "# universal union => "; tgt.display(tout););
  266          }

  284  
  285:             TRACE("dl_table_relation", tout << "# union => "; tr_tgt.get_table().display(tout););
  286          }

  317              (*m_tfun)(tr.get_table());
  318:             TRACE("dl_table_relation", tout << "# mutator => "; tr.get_table().display(tout););
  319          }

  387              (*m_tfun)(tr.get_table(), tr_src.get_table());
  388:             TRACE("dl_table_relation", tout << "# negation_filter => "; tr.get_table().display(tout););
  389          }

  439          get_table().add_fact(vals);
  440:         TRACE("dl_table_relation", tout << "# add fact => "; get_table().display(tout););
  441      }

z3/src/muz/rel/dl_vector_relation.h:
  198  
  199:             TRACE("dl_relation",                   
  200                    r1.display(tout << "r1:\n");

  252  
  253:             TRACE("dl_relation",
  254                    ast_manager& m = r.get_plugin().get_ast_manager();

  304  
  305:             TRACE("dl_relation", 
  306                    ast_manager& m = r.get_plugin().get_ast_manager();

  324          void mk_union(vector_relation const& src, vector_relation* delta, bool is_widen) {
  325:             TRACE("dl_relation", display(tout << "dst:\n"); src.display(tout  << "src:\n"););
  326  

  376                  }
  377:                 TRACE("dl_relation", tout << t1 << " u " << t2 << " = " << elems->back() << "\n";);
  378                  change = delta && (change || !((*elems)[i] == (*this)[i]));

  386              }
  387:             TRACE("dl_relation", display(tout << "dst':\n"););
  388          }

z3/src/muz/rel/doc.cpp:
  251  
  252:     TRACE("doc", tout << "num_x: " << num_x << " value: " << value << "\n";);
  253      if (num_x == 0) {

  367              }
  368:             TRACE("doc",
  369                    tout << "pos: ";

  687      if (res != l_false) {        
  688:         TRACE("doc",
  689                tout << mk_pp(fml1, m) << "\n";

z3/src/muz/rel/karr_relation.cpp:
  176                  (void)processed;
  177:                 TRACE("dl", tout << (processed?"+ ":"- ") << mk_pp(e, m) << "\n";
  178                        if (processed) matrix::display_ineq(tout, row, M.b.back(), M.eq.back());

  180              }
  181:             TRACE("dl", display(tout););
  182          }

  261              
  262:             TRACE("dl", 
  263                    for (unsigned i = 0; i < cnt; ++i) {

  288              m_fn = r.m_fn;
  289:             TRACE("dl", r.display(tout); display(tout););
  290          }

  600          }
  601:         TRACE("dl_verbose", m_hb.display(tout););
  602          if (is_sat == l_false) {

  657          }
  658:         TRACE("dl_verbose", m_hb.display(tout););
  659          SASSERT(is_sat == l_true);

  682              karr_relation const& src = get(_src);
  683:             TRACE("dl", r.display(tout << "dst:\n"); src.display(tout  << "src:\n"););
  684  

  691              }            
  692:             TRACE("dl", r.display(tout << "result:\n"););
  693          }

  711              karr_relation & r = get(_r);
  712:             TRACE("dl", r.display(tout << "src:\n"););
  713              r.get_ineqs();

  725              }
  726:             TRACE("dl", r.display(tout << "result:\n"););
  727          }

  761              }
  762:             TRACE("dl", tout << m_value << "\n"; r.display(tout););            
  763          }

  783              get(t).filter_interpreted(m_cond);
  784:             TRACE("dl", tout << mk_pp(m_cond, m_cond.get_manager()) << "\n"; t.display(tout););
  785          }

z3/src/muz/rel/rel_context.cpp:
  142  
  143:         TRACE("dl", m_context.display(tout););
  144  

  151              if (m_context.canceled()) {
  152:                 TRACE("dl", tout << "canceled\n";);
  153                  result = l_undef;

  155              }
  156:             TRACE("dl", m_context.display(tout););
  157              //IF_VERBOSE(3, m_context.display_smt2(0,0,verbose_stream()););

  192              if (m_context.canceled()) {
  193:                 TRACE("dl", tout << "canceled\n";);
  194                  result = l_undef;

  208                  m_context.set_status(TIMEOUT);
  209:                 TRACE("dl", tout << "timeout\n";);
  210                  result = l_undef;

  227          m_context.record_transformed_rules();
  228:         TRACE("dl", display_profile(tout););
  229          return result;

  265                  if (is_approx) {
  266:                     TRACE("dl", tout << "approx\n";);
  267                      res = l_undef;

  280          case l_undef:
  281:             TRACE("dl", tout << "saturation in undef\n";);
  282              break;

  374                      m_context.set_status(APPROX);
  375:                     TRACE("dl", tout << "approx\n";);
  376                      res = l_undef;

  442              if (!rel.empty()) {
  443:                 TRACE("dl", tout << "Resetting: " << mk_ismt2_pp(pred, m) << "\n";);
  444                  rel.reset();

  479  
  480:         TRACE("dl", 
  481                tout << pred->get_name() << ": ";

z3/src/muz/rel/udoc_relation.cpp:
   332              udoc_relation const& r2 = get(_r2);
   333:             TRACE("doc", r1.display(tout << "r1:\n"); r2.display(tout  << "r2:\n"););
   334              udoc_plugin& p = r1.get_plugin();            

   340              r.join(d1, d2, dm, dm1, m_cols1, m_cols2);
   341:             TRACE("doc", result->display(tout << "result:\n"););
   342              IF_VERBOSE(3, result->display(verbose_stream() << "join result:\n"););

   371          relation_base * operator()(const relation_base & tb) override {
   372:             TRACE("doc", tb.display(tout << "src:\n"););
   373              udoc_relation const& t = get(tb);

   384              }
   385:             TRACE("doc", tout << "final size: " << r->get_size_estimate_rows() << '\n';);
   386              SASSERT(ud2.well_formed(dm2));

   429  
   430:             TRACE("doc",
   431                    ast_manager& m = p.get_ast_manager();

   465              udoc_relation const& r = get(_r);
   466:             TRACE("doc", r.display(tout << "r:\n"););
   467              udoc_plugin& p = r.get_plugin();            

   476              }
   477:             TRACE("doc", result->display(tout << "result:\n"););
   478              SASSERT(dst.well_formed(dm));

   496          void operator()(relation_base & _r, const relation_base & _src, relation_base * _delta) override {
   497:             TRACE("doc", _r.display(tout << "dst:\n"); _src.display(tout  << "src:\n"););
   498              udoc_relation& r = get(_r);

   507              SASSERT(!d1 || d1->well_formed(dm));
   508:             TRACE("doc", _r.display(tout << "dst':\n"); );
   509              IF_VERBOSE(3, r.display(verbose_stream() << "union: "););

   581              SASSERT(d.well_formed(dm));
   582:             TRACE("doc", tout << "final size: " << r.get_size_estimate_rows() << '\n';);
   583          }

   840              result.simplify(dm);
   841:             TRACE("doc",
   842                    result.display(dm, tout << "result0:") << "\n";

   844              sub.reset(dm);
   845:             TRACE("doc", result.display(dm, tout << "result:") << "\n";);
   846          }

   854              }
   855:             TRACE("doc", result.display(dm, tout << "result0:") << "\n";);
   856              result.subtract(dm, sub);
   857:             TRACE("doc", 
   858                    sub.display(dm, tout << "sub:") << "\n";

   927  
   928:             TRACE("doc", 
   929                    tout << "original condition: " << mk_pp(condition, m) << "\n";

   947              SASSERT(u.well_formed(dm));
   948:             TRACE("doc", tout << "final size: " << t.get_size_estimate_rows() << '\n';);
   949              IF_VERBOSE(3, t.display(verbose_stream()););

  1034              }
  1035:             TRACE("doc", result->display(tout););
  1036              return result;            

  1174              }
  1175:             TRACE("doc", t.display(tout); tout << "\n"; jp->display(tout); tout << "\n";);
  1176              jp->deallocate();

z3/src/muz/spacer/spacer_arith_generalizers.cpp:
  122                  failed = true;
  123:                 TRACE("spacer.limnum", tout << "Failed to generalize: "
  124                        << lemma->get_cube()

  132          if (!failed && pt.check_inductive(lemma->level(), cube, uses_level, weakness)) {
  133:             TRACE("spacer",
  134                    tout << "Reduced fractions from:\n"

z3/src/muz/spacer/spacer_arith_kernel.cpp:
  66          }
  67:         TRACE("gg", qmat.display(tout););
  68  

  83  
  84:         TRACE("gg", {
  85              tout << "Computed kernel\n";

z3/src/muz/spacer/spacer_cluster_util.cpp:
  202  
  203:     STRACE("spacer_normalize_order'",
  204             tout << "OUT Before:" << mk_pp(out, out.m()) << "\n";);

  208      rw2(out.get(), out);
  209:     STRACE("spacer_normalize_order'",
  210             tout << "OUT After :" << mk_pp(out, out.m()) << "\n";);

z3/src/muz/spacer/spacer_cluster.cpp:
  155                  keep.push_back(lem);
  156:                 TRACE("cluster_stats_verb", tout << "Keeping lemma "
  157                                                   << lem.get_lemma()->get_cube()

  162          if (!found) {
  163:             TRACE("cluster_stats_verb", tout << "Removing subsumed lemma "
  164                                               << lem.get_lemma()->get_cube()

  193  
  194:     TRACE("cluster_stats_verb",
  195            tout << "Trying to add lemma " << lemma->get_cube() << "\n";);

  208      }
  209:     TRACE("cluster_stats", tout << "Added lemma\n" << mk_and(lemma->get_cube()) << "\n"
  210                                  << "to  existing cluster\n" << m_pattern << "\n";);

  248  
  249:     TRACE("cluster_stats_verb",
  250            tout << "Trying to generate a general pattern for " << cube

  269      for (expr *e : patterns) {
  270:         TRACE("cluster_stats_verb",
  271                tout << "Checking pattern " << mk_pp(e, m) << "\n";);

  286              SASSERT(e != nullptr);
  287:             TRACE("cluster_stats",
  288                    tout << "Found a general pattern\n" << mk_pp(e, m) << "\n";);

  294  
  295:     CTRACE("cluster_stats", !all_same,
  296             tout << "Failed to find a general pattern for cluster. Cube is: "

  313      if (clstr && clstr->get_size() <= MAX_CLUSTER_SIZE) {
  314:         TRACE("cluster_stats_verb", {
  315              tout << "Trying to add lemma\n" << lemma->get_cube()

  372  
  373:     TRACE("cluster_stats",
  374            tout << "created new cluster with pattern:\n" << pattern << "\n"

  384          (void)added;
  385:         CTRACE("cluster_stats", added,
  386                 tout << "Added neighbour lemma\n" << mk_and(l->get_cube()) << "\n";);

z3/src/muz/spacer/spacer_conjecture.cpp:
  93  
  94:     CTRACE("global", dirty,
  95             tout << "Filtered " << lit << " from " << vec << "\n got " << out << "\n";);

z3/src/muz/spacer/spacer_context.cpp:
   202      if (!n.is_in_queue()) {
   203:         TRACE("pob_queue",
   204                tout << "pob_queue::push(" << n.post()->get_id() << ")\n";);

   255      
   256:     TRACE("spacer", tout << "Skolemizing: " << vars << "\n";
   257            tout << "from " << mk_pp(fml, m) << "\n";);

   296                   true, pt().get_context().use_ground_pob());
   297:         CTRACE("spacer", !vars.empty(),
   298                 tout << "Failed to eliminate: " << vars << "\n";);

   327                   true, pt().get_context().use_ground_pob());
   328:         CTRACE("spacer", !vars.empty(),
   329                 tout << "Failed to eliminate: " << vars << "\n";);

   431              // keep track of implicitly quantified variables
   432:             CTRACE("spacer", !vars.empty(),
   433                     tout << "Failed to eliminate: " << vars << "\n";);

   662  
   663:         TRACE("spacer",
   664                tout << "new binding: ";

   971      expr* l = lemma->get_expr();
   972:     CTRACE("spacer", !spacer::is_clause(m, l),
   973             tout << "Lemma not a clause: " << mk_pp(l, m) << "\n";);

  1028          for (unsigned j = 0; j < inst.size(); ++j) {
  1029:             TRACE("spacer_detail", tout << "child property: "
  1030                    << mk_pp(inst.get (j), m) << "\n";);

  1059      if (!rf) return;
  1060:     TRACE("spacer", tout << "add_rf: " << head()->get_name() << " "
  1061                           << (rf->is_init() ? "INIT " : "")

  1218          if (!is_quantifier(s) && !mdl.is_true(s)) {
  1219:             TRACE("spacer", tout << "Summary not true in the model: " << mk_pp(s, m) << "\n";);
  1220              return expr_ref(m);

  1243      (*rep)(result);
  1244:     TRACE("spacer", tout << "cover:\n" << mk_pp(result, m) << "\n";);
  1245  

  1270              const lemma_ref_vector &invs = pt.get_bg_invs();
  1271:             CTRACE("spacer", !invs.empty(),
  1272                     tout << "add-bg-invariant: " << mk_pp (pre, m) << "\n";);

  1277                  out.push_back(tmp2);
  1278:                 TRACE("spacer", tout << tmp2 << "\n";);
  1279              }

  1339      //     c = mk_and(core);
  1340:     //     STRACE("spacer_progress", tout << "core: " << mk_epp(c,m) << "\n";);
  1341      // }

  1363  {
  1364:     TRACE("spacer",
  1365            tout << "is-reachable: " << head()->get_name() << " level: "

  1414  
  1415:     CTRACE("spacer", !reach_assumps.empty(),
  1416          tout << "reach assumptions\n" << reach_assumps << "\n";);

  1424  
  1425:     CTRACE("spacer", !reach_assumps.empty(),
  1426          tout << "reach assumptions\n" << reach_assumps << "\n";);

  1431              r = find_rule(**model, is_concrete, reach_pred_used, num_reuse_reach);
  1432:             TRACE("spacer", 
  1433                    tout << "reachable is_sat: " << is_sat << " "
  1434                    << r << " is_concrete " << is_concrete << " rused: " << reach_pred_used << "\n";);
  1435:             CTRACE("spacer", r,
  1436                     ctx.get_datalog_context().get_rule_manager().display_smt2(*r, tout);
  1437                     tout << "\n";);
  1438:             TRACE("spacer_sat", tout << "model is:\n" << **model << "\n";);
  1439          }

  1610      m_solver->assert_expr (m_init, 0);
  1611:     TRACE("spacer",
  1612            tout << "Initial state: " << mk_pp(m_init, m) << "\n";

  1723      }
  1724:     TRACE("spacer_init_rule", tout << mk_pp(trans, m) << "\n";);
  1725  
  1726      // no (universal) quantifiers in recursive rules
  1727:     CTRACE("spacer", ut_size > 0 && !is_ground(trans),
  1728             tout << "Warning: quantifier in recursive rule: " << trans << "\n";);

  1743  
  1744:     // TRACE("spacer",
  1745      //       tout << rule.get_decl()->get_name() << "\n";

  1991  {
  1992:     TRACE("spacer", tout << "add-lemma: " << pp_level(new_lemma->level()) << " "
  1993            << m_pt.head()->get_name() << " "

  2001          }
  2002:         TRACE("spacer", tout << "add-external-lemma: "
  2003                << pp_level(new_lemma->level()) << " "

  2028              if (old_lemma->level() >= new_lemma->level()) {
  2029:                 TRACE("spacer", tout << "Already at a higher level: "
  2030                        << pp_level(old_lemma->level()) << "\n";);

  2399  {
  2400:     TRACE("spacer", tout << "\n";);
  2401      m_pob_queue.reset();

  2417          func_decl* pred = dit->m_key;
  2418:         TRACE("spacer", tout << mk_pp(pred, m) << "\n";);
  2419          SASSERT(!rels.contains(pred));

  2444          for (auto dep : rules.get_dependencies().get_deps(pred)) {
  2445:             TRACE("spacer", tout << mk_pp(pred, m) << " " << mk_pp(dep, m) << "\n";);
  2446              rels.find(dep, pt_user);

  2454          rel->initialize(rels);
  2455:         TRACE("spacer", rel->display(tout); );
  2456      }

  3093      IF_VERBOSE(1, verbose_stream() << "Entering level " << lvl << "\n";);
  3094:     STRACE("spacer_progress", tout << "\n* LEVEL " << lvl << "\n";);
  3095  

  3105      if (m_trace_stream) *m_trace_stream << "Propagating\n\n";
  3106:     STRACE("spacer_progress", tout << "Propagating\n";);
  3107      IF_VERBOSE(1, verbose_stream() << "Propagating: " << std::flush;);

  3123  
  3124:     TRACE("spacer", tout << "expand-pob: " << n.pt().head()->get_name()
  3125                           << (n.is_conjecture() ? " CONJ" : "")

  3132  
  3133:     STRACE("spacer_progress",
  3134             tout << "** expand-pob: " << n.pt().head()->get_name()

  3161  
  3162:     TRACE("spacer", tout << "add-lemma-core: " << pp_level(lvl) << " "
  3163                           << pt.head()->get_name() << " " << mk_pp(fml, m) << "\n";);
  3164  
  3165:     STRACE("spacer_progress",
  3166             tout << "** add-lemma: " << pp_level(lvl) << " "

  3270              for (auto pob : new_pobs) {
  3271:                 TRACE("gg", tout << "pob: is_may_pob " << pob->is_may_pob()
  3272                        << " with post:\n"

  3276                  if (is_requeue(*pob)) {
  3277:                   TRACE("gg",
  3278                          tout << "Adding back blocked pob at level "

  3446          if (used_rfs.size() > 0 && !atleast_one_true) {
  3447:             TRACE("spacer_detail",
  3448                    tout << "model does not satisfy any reachable fact\n";);

  3477          if (used_rfs.size() > 0 && !atleast_one_true) {
  3478:             TRACE("spacer_detail",
  3479                    tout << "model does not satisfy any reachable fact\n";);

  3550        if (/* XXX noop */ n.pt().is_qblocked(n)) {
  3551:           STRACE("spacer_progress",
  3552                  tout << "This pob can be blocked by instantiation\n";);

  3555        if ((n.is_may_pob()) && n.get_gas() == 0) {
  3556:           TRACE("global", tout << "Cant prove may pob. Collapsing "
  3557                                << mk_pp(n.post(), m) << "\n";);

  3565            !n.pt().is_blocked(n, uses_level, &model)) {
  3566:         TRACE("global",
  3567                tout << "Concretizing: " << mk_pp(n.post(), m) << "\n"

  3606              // -- update must summary
  3607:             CTRACE("spacer_sat", r,
  3608                     tout << "Concrete reachable with a rule:\n";

  3644  
  3645:             CTRACE("global", n.is_conjecture(),
  3646                     tout << "Failed to block conjecture "

  3648  
  3649:             CTRACE("global", n.is_subsume(),
  3650                     tout << "Failed to block subsume generalization "

  3677          }
  3678:         TRACE("spacer", tout << "unknown state: " << mk_and(cube) << "\n";);
  3679          throw unknown_exception();

  3689  
  3690:         TRACE("spacer", tout << "cube:\n" << cube << "\n";);
  3691  

  3716              lemma_pob = alloc(class lemma, nref, pob_cube, n.level());
  3717:             TRACE("global", tout << "Disabled local gen on pob (id: "
  3718                                   << n.post()->get_id() << ")\n"

  3727  
  3728:         CTRACE("global", n.is_conjecture() || n.is_subsume(),
  3729                 tout << "Blocked "

  3736  
  3737:         TRACE("spacer",
  3738                tout << "invariant state: "

  3774  
  3775:                 TRACE("global_verbose",
  3776                        tout << "New subsume pob\n" << mk_pp(new_pob->post(), m) << "\n"

  3783  
  3784:                 TRACE("global",
  3785                        tout << "New conjecture pob\n" << mk_pp(new_pob->post(), m) << "\n";);

  3846          }
  3847:         TRACE("spacer", tout << "unknown state: " << mk_and(cube) << "\n";);
  3848          throw unknown_exception();

  4015  
  4016:     TRACE("spacer",
  4017            tout << "Model:\n";

  4240      lbool result = ctx->check_sat(0, nullptr);
  4241:     TRACE("spacer", tout << "Check invariant level: " << lvl << " " << result
  4242            << "\n" << mk_pp(fml, m) << "\n";);

z3/src/muz/spacer/spacer_convex_closure.cpp:
   97      if (!has_kernel) {
   98:         TRACE("cvx_dbg",
   99                tout << "No linear dependencies between pattern vars\n";);

  164  
  165:     TRACE("cvx_dbg", kern.display(tout););
  166      expr_ref eq(m);

  256                                      rational &d) {
  257:     TRACE("cvx_dbg_verb", {
  258          tout << "computing div constraints for ";

  285  
  286:     TRACE("cvx_dbg_verb", tout << "div constraint generated. cf " << m
  287                                 << " and off " << d << "\n";);

  300          kernel2fmls(m_explicit_cc);
  301:         TRACE("cvx_dbg", tout << "Linear equalities true of the matrix "
  302                                << mk_and(m_explicit_cc) << "\n";);

  311          if (m_enable_implicit) {
  312:             TRACE("subsume", tout << "Computing syntactic convex closure\n";);
  313              cc2fmls(m_implicit_cc);

z3/src/muz/spacer/spacer_dl_interface.cpp:
   75          if (!is_subsumed) {
   76:             TRACE("spacer", new_rules.get_rule(i)->display(m_ctx, tout << "Fresh rule "););
   77              m_context->reset();

   98  
   99:     TRACE("spacer",
  100            tout << "query: " << mk_pp(query, m) << "\n";

  186  
  187:     TRACE("spacer",
  188      if (!m.is_true(bg_assertion)) {

z3/src/muz/spacer/spacer_expand_bnd_generalizer.cpp:
  125  
  126:         TRACE("expand_bnd", tout << "Attempting to expand " << lit << " inside "
  127                                   << cube << "\n";);

  132              m_st.atmpts++;
  133:             TRACE("expand_bnd", tout << "Attempting to expand " << lit
  134                                       << " with numeral " << n << "\n";);

  168                                                     expr_ref_vector &candidate) {
  169:     TRACE("expand_bnd_verb",
  170            tout << "Attempting to update lemma with " << candidate << "\n";);

  179          lemma->set_level(uses_level);
  180:         TRACE("expand_bnd", tout << "expand_bnd succeeded with "
  181                                   << mk_and(candidate) << " at level "

z3/src/muz/spacer/spacer_farkas_learner.cpp:
  196      ptr_vector<proof> todo;
  197:     TRACE("spacer_verbose", tout << mk_pp(pr, m) << "\n";);
  198      todo.push_back(pr);

  255                      if (is_pure_expr(Bsymbs, fact, m)) {
  256:                         TRACE("farkas_learner2",
  257                                tout << "Add: " << mk_pp(m.get_fact(arg), m) << "\n";

  325  
  326:             TRACE("farkas_learner2",
  327              for (unsigned i = 0; i < prem_cnt; ++i) {

  377                  combine_constraints(coeffs.size(), lits.data(), coeffs.data(), res);
  378:                 TRACE("farkas_learner2", tout << "Add: " << mk_pp(res, m) << "\n";);
  379                  INSERT(res);

  414              expr* fact = m.get_fact(p);
  415:             TRACE("farkas_learner2",
  416                    tout << mk_ll_pp(p0, m) << "\n";

z3/src/muz/spacer/spacer_generalizers.cpp:
  133      if (dirty) {
  134:         TRACE("spacer",
  135                 tout << "Generalized from:\n" << mk_and(lemma->get_cube())

  166  
  167:     CTRACE("spacer", old_sz > core.size(),
  168             tout << "unsat core reduced lemma from: "
  169             << old_sz << " to " << core.size() << "\n";);
  170:     CTRACE("spacer", old_level < uses_level,
  171             tout << "unsat core moved lemma up from: "

  235  
  236:     CTRACE("core_array_eq", symb.size() > 1 && symb.size() <= 8,
  237            tout << "found " << symb.size() << " array variables in: \n"

  278              if (res == l_false) {
  279:                 TRACE("core_array_eq",
  280                        tout << "strengthened " << mk_pp(lits.get(i), m)

  291  
  292:     TRACE("core_array_eq",
  293             tout << "new possible core " << mk_and(lits) << "\n";);

  299      if (pt.check_inductive(lemma->level(), lits, uses_level1, lemma->weakness())) {
  300:         TRACE("core_array_eq", tout << "Inductive!\n";);
  301          lemma->update_cube(lemma->get_pob(), lits);

  304      else
  305:     {TRACE("core_array_eq", tout << "Not-Inductive!\n";);}
  306  }

  308  void lemma_eq_generalizer::operator() (lemma_ref &lemma) {
  309:     TRACE("core_eq", tout << "Transforming equivalence classes\n";);
  310  

z3/src/muz/spacer/spacer_global_generalizer.cpp:
  285      sub(f.get(), f);
  286:     TRACE("subsume", tout << "skolemized into " << f << "\n";);
  287      m_col_names.reset();

  345      if (!all_same_sz(m, lc.get_lemmas()[0].get_sub(), sz)) {
  346:         TRACE("subsume",
  347                tout << "cannot compute cvx cls of different size variables\n";);

  372  
  373:     CTRACE("subsume_verb", is_syntactic,
  374             tout << "Convex closure introduced new variables. Implicit part of "

  457  
  458:     TRACE("subsume_verb", tout << "weakening " << mk_and(a)
  459                                 << " to over approximate " << b << "\n";);

  492          // could not find an over approximation
  493:         TRACE("subsume",
  494                tout << "mbp did not over-approximate convex closure\n";);

  498  
  499:     TRACE("subsume",
  500            tout << "over approximate produced " << mk_and(a) << "\n";);

  545          // it
  546:         TRACE("global", tout << "stop local generalization on pob " << n_post
  547                               << " id is " << n_post->get_id() << "\n";);

  551          // The literal to be abstracted is not in the pob
  552:         TRACE("global", tout << "Conjecture failed:\n"
  553                               << lit << "\n"

  577      n->disable_local_gen();
  578:     TRACE("global", tout << "set conjecture " << mk_pp(n->get_data()->post(), m)
  579                           << " at level " << n->get_data()->level() << "\n";);

  597          pob->disable_local_gen();
  598:         TRACE("global", tout << "stop local generalization on pob "
  599                               << mk_pp(pob->post(), m) << " id is "

  613  
  614:     TRACE("global", {
  615          tout << "Global generalization of:\n"

  631  
  632:         TRACE("global",
  633                tout << "Found non linear pattern. Marked to concretize \n";);

  646          // Create a conjecture by dropping literal from pob.
  647:         TRACE("global", tout << "Conjecture with pattern\n"
  648                               << mk_pp(pat, m) << "\n"

  699  
  700:         TRACE("global", tout << "Create subsume pob at level " << new_lvl
  701                               << "\n"

  726  
  727:         TRACE("concretize", tout << "pob:\n"
  728                                   << mk_pp(n.post(), m)

  747  
  748:     TRACE("global", tout << "mk_subsume_pob at level " << data->level()
  749                           << " with post state:\n"

z3/src/muz/spacer/spacer_ind_lemma_generalizer.cpp:
  262          if (num_gens > 0) {
  263:             TRACE("indgen",
  264                    tout << "Generalized " << num_gens << " literals\n";);

  271  
  272:             TRACE("indgen", tout << "Original: " << lemma->get_cube() << "\n"
  273                                   << "Generalized: " << m_core << "\n";);

z3/src/muz/spacer/spacer_iuc_solver.cpp:
  312                          bcnt++;
  313:                         TRACE("spacer", tout << "Dumping pf bcnt: " << bcnt << "\n";);
  314                          if (bcnt == 123) {

  364                  cnt++;
  365:                 TRACE("spacer", tout << "Dumping pf cnt: " << cnt << "\n";);
  366                  if (cnt == 123) {

z3/src/muz/spacer/spacer_legacy_frames.cpp:
   85  
   86:     TRACE("spacer",
   87            tout << "propagating " << src_level << " to " << tgt_level;

   97          if (stored_lvl > src_level) {
   98:             TRACE("spacer", tout << "at level: " << stored_lvl << " " << mk_pp(curr, m) << "\n";);
   99              src[i] = src.back();

  103              add_lemma(curr, solver_level);
  104:             TRACE("spacer", tout << "is invariant: " << pp_level(solver_level) << " " << mk_pp(curr, m) << "\n";);
  105              // shadow higher-level src

  110          } else {
  111:             TRACE("spacer", tout << "not propagated: " << mk_pp(curr, m) << "\n";);
  112              ++i;

  115  
  116:     CTRACE("spacer", m_levels[src_level].empty(),
  117             tout << "Fully propagated level "

  146  {
  147:     TRACE("spacer", tout << "propagating to oo from lvl " << level
  148            << " of " << m_pt.m_head->get_name() << "\n";);

z3/src/muz/spacer/spacer_legacy_mbp.cpp:
   57  
   58:     TRACE("spacer",
   59            tout << "After qe_lite:\n";

   88              rw(fml);
   89:             TRACE("spacer",
   90                    tout << "Projected Boolean vars:\n" << mk_pp(fml, m) << "\n";

   94          if (!arith_vars.empty()) {
   95:             TRACE("spacer",
   96                    tout << "Arith vars:\n";

  105              SASSERT(arith_vars.empty());
  106:             TRACE("spacer",
  107                    tout << "Projected arith vars:\n" << mk_pp(fml, m) << "\n";

z3/src/muz/spacer/spacer_legacy_mev.cpp:
   53          IF_VERBOSE(3, verbose_stream() << "Not evaluated " << mk_pp(e, m) << "\n";);
   54:         TRACE("old_spacer", tout << "Variable is not tracked: " << mk_pp(e, m) << "\n";);
   55          set_x(e);

   90  
   91:     TRACE("old_spacer",
   92            tout << "formulas:\n";

  120      reset();
  121:     TRACE("old_spacer",
  122            tout << "minimized model:\n";

  373          else {
  374:             TRACE("old_spacer", tout << "not inherited:\n" << mk_pp(e, m) << "\n" << mk_pp(v, m) << "\n";);
  375              set_x(e);

  383      } else {
  384:         TRACE("old_spacer", tout << "not inherited:\n" << mk_pp(e, m) << "\n" << mk_pp(v, m) << "\n";);
  385          set_x(e);

  402  
  403:     TRACE("old_spacer", tout << mk_pp(a, m) << "\n";);
  404      while (m_array.is_store(a)) {

  428                  if (!is_ground(store[j].get())) {
  429:                     TRACE("old_spacer", tout << "could not extract array interpretation: " << mk_pp(a, m) << "\n" << mk_pp(store[j].get(), m) << "\n";);
  430                      return false;

  437          if (!else_case) {
  438:             TRACE("old_spacer", tout << "no else case " << mk_pp(a, m) << "\n";);
  439              return false;

  441          if (!is_ground(else_case)) {
  442:             TRACE("old_spacer", tout << "non-ground else case " << mk_pp(a, m) << "\n" << mk_pp(else_case, m) << "\n";);
  443              return false;

  448          }
  449:         TRACE("old_spacer", tout << "else case: " << mk_pp(else_case, m) << "\n";);
  450          return true;
  451      }
  452:     TRACE("old_spacer", tout << "no translation: " << mk_pp(a, m) << "\n";);
  453  

  461  {
  462:     TRACE("old_spacer", tout << "array equality: " << mk_pp(e, m) << "\n";);
  463      expr_ref v1(m), v2(m);

  473      if (!r->is_infinite() && !r->is_very_big() && !s->is_infinite() && !s->is_very_big()) {
  474:         TRACE("old_spacer", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  475          set_x(e);

  481              !extract_array_func_interp(v2, store, else2)) {
  482:         TRACE("old_spacer", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  483          set_x(e);

  488          if (m.is_value(else1) && m.is_value(else2)) {
  489:             TRACE("old_spacer", tout
  490                    << "defaults are different: " << mk_pp(e, m) << " "

  495          } else {
  496:             TRACE("old_spacer", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  497              set_x(e);

  518          if (m.is_value(w1) && m.is_value(w2)) {
  519:             TRACE("old_spacer", tout << "Equality evaluation: " << mk_pp(e, m) << "\n";
  520                    tout << mk_pp(s1, m) << " |-> " << mk_pp(w1, m) << "\n";

  528          } else {
  529:             TRACE("old_spacer", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  530              set_x(e);

  562          } else {
  563:             TRACE("old_spacer", tout << "not value equal:\n" << mk_pp(e1, m) << "\n" << mk_pp(e2, m) << "\n";);
  564              set_x(e);

  748          SASSERT(!is_unknown(form));
  749:         TRACE("spacer_verbose",
  750                tout << "formula is " << (is_true(form) ? "true" : is_false(form) ? "false" : "unknown") << "\n" << mk_pp(form, m) << "\n";);

  757              IF_VERBOSE(0, verbose_stream() << "formula undetermined in model: " << mk_pp(form, m) << "\n";);
  758:             TRACE("old_spacer", model_smt2_pp(tout, m, *m_model, 0););
  759              has_x = true;

z3/src/muz/spacer/spacer_legacy_mev.h:
  73          m_numbers.insert(x, v);
  74:         TRACE("spacer_verbose", tout << mk_pp(x, m) << " " << v << "\n";);
  75      }

z3/src/muz/spacer/spacer_manager.cpp:
   99      }
  100:     TRACE("spacer", tout << *md;);
  101      apply(const_cast<model_converter_ref&>(m_mc), md);

z3/src/muz/spacer/spacer_matrix.cpp:
  133              rational::zero()) {
  134:             TRACE("cvx_dbg_verb",
  135                    tout << "Didn't work for " << m_matrix[k][i] << " and "

  167  
  168:                 TRACE("cvx_dbg_verb", {
  169                      tout << "Adding row ";

z3/src/muz/spacer/spacer_mbc.cpp:
  96  
  97:     TRACE("mbc", tout << "Input: " << lits << "\n"
  98            << "Output: \n";

z3/src/muz/spacer/spacer_mev_array.cpp:
   48  
   49:     TRACE("model_evaluator", tout << mk_pp(a, m) << "\n";);
   50      while (m_array.is_store(a)) {

   74                  if (!is_ground(store[j].get())) {
   75:                     TRACE("model_evaluator", tout << "could not extract array interpretation: " << mk_pp(a, m) << "\n" << mk_pp(store[j].get(), m) << "\n";);
   76                      return false;

   83          if (!else_case) {
   84:             TRACE("model_evaluator", tout << "no else case " << mk_pp(a, m) << "\n";);
   85              return false;

   87          if (!is_ground(else_case)) {
   88:             TRACE("model_evaluator", tout << "non-ground else case " << mk_pp(a, m) << "\n" << mk_pp(else_case, m) << "\n";);
   89              return false;

   95          }
   96:         TRACE("model_evaluator", tout << "else case: " << mk_pp(else_case, m) << "\n";);
   97          return true;
   98      }
   99:     TRACE("model_evaluator", tout << "no translation: " << mk_pp(a, m) << "\n";);
  100  

  104  void model_evaluator_array_util::eval_array_eq(model& mdl, app* e, expr* arg1, expr* arg2, expr_ref& res) {
  105:     TRACE("model_evaluator", tout << "array equality: " << mk_pp(e, m) << "\n";);
  106      expr_ref v1(m), v2(m);

  116      if (!r->is_infinite() && !r->is_very_big() && !s->is_infinite() && !s->is_very_big()) {
  117:         TRACE("model_evaluator", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  118          res.reset ();

  124              !extract_array_func_interp(mdl, v2, store, else2)) {
  125:         TRACE("model_evaluator", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  126          res.reset ();

  131          if (m.is_value(else1) && m.is_value(else2)) {
  132:             TRACE("model_evaluator", tout
  133                      << "defaults are different: " << mk_pp(e, m) << " "

  140          else {
  141:             TRACE("model_evaluator", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  142              res.reset ();

  163          if (m.is_value(w1) && m.is_value(w2)) {
  164:             TRACE("model_evaluator", tout << "Equality evaluation: " << mk_pp(e, m) << "\n";
  165                      tout << mk_pp(s1, m) << " |-> " << mk_pp(w1, m) << "\n";

  175          else {
  176:             TRACE("model_evaluator", tout << "equality is unknown: " << mk_pp(e, m) << "\n";);
  177              res.reset ();

z3/src/muz/spacer/spacer_pdr.cpp:
  238          IF_VERBOSE(1,verbose_stream() << "GPDR Entering level "<< lvl << "\n";);
  239:         STRACE("spacer_progress", tout << "\n* LEVEL " << lvl << "\n";);
  240          m_expanded_lvl = infty_level();

  270          if (pt.is_must_reachable(node->pob()->post(), nullptr)) {
  271:             TRACE("spacer",
  272                    tout << "must-reachable: " << pt.head()->get_name() << " level: "

  292              for (auto pob : new_pobs) {
  293:                 TRACE("spacer_pdr",
  294                        tout << "looking at pob at level " << pob->level() << " "

z3/src/muz/spacer/spacer_proof_utils.cpp:
  288              //TODO: fix bug
  289:             TRACE("spacer.fkab", tout << "UNEXPECTED INPUT TO FUNCTION. Bailing out\n";);
  290              return proof_ref(m);

  300              rational const &r = params[i+1].get_rational();
  301:             TRACE("spacer.fkab", tout << "Adding to LCB: " << mk_pp(p, m) << "\n";);
  302              lcb.add_lit(p, r);

  311          //rw(lit0);
  312:         TRACE("spacer.fkab",
  313                tout << "lit0 is: " << lit0 << "\n"

  318          val2 = get_coeff(lcb(), var);
  319:         TRACE("spacer.fkab",
  320                tout << "var: " << var

  323          rational rat1, rat2, coeff0;
  324:         CTRACE("spacer.fkab", !(val1 && val2),
  325                 tout << "Failed to match variables\n";);

  329              coeff0 = coeff0 / lcb.lc();
  330:             TRACE("spacer.fkab", tout << "coeff0: " << coeff0 << "\n";);
  331          }

  334                         << "\n\n\nFAILED TO FIND COEFFICIENT\n\n\n";);
  335:             TRACE("spacer.fkab", tout << "FAILED TO FIND COEFFICIENT\n";);
  336              // failed to find a coefficient

  356          SASSERT(is_arith_lemma(m, pf));
  357:         TRACE("spacer.fkab", tout << mk_pp(pf, m) << "\n";);
  358  

  409  
  410:                     TRACE("spacer.fkab", tout << mk_pp(p, m) << "\n";);
  411                      th_lemma = mk_fk_from_ab(m, hyps,

z3/src/muz/spacer/spacer_prop_solver.cpp:
  125      IF_VERBOSE(21, verbose_stream() << "$ asserted " << mk_pp(form, m) << "\n";);
  126:     TRACE("spacer", tout << "add_formula: " << mk_pp(form, m) << "\n";);
  127  }

  334      if (result == l_false && m_core && m.proofs_enabled() && !m_subset_based_core) {
  335:         TRACE("spacer", tout << "Using IUC core\n";);
  336          m_core->reset();

  388  
  389:     TRACE("psolve_verbose",
  390            tout << "sat: " << mk_pp(mk_and(hard), m) << "\n"

  394            tout << "res: " << res << "\n";);
  395:     CTRACE("psolve", m_core,
  396             tout << "core is: " << mk_pp(mk_and(*m_core), m) << "\n";);

z3/src/muz/spacer/spacer_qe_project.cpp:
  1189                  );
  1190:                 TRACE("qe",
  1191                          if (!fail) {

  1259                      }
  1260:                     TRACE("qe",
  1261                              tout << "projected: " << mk_pp(v, m) << " "

z3/src/muz/spacer/spacer_quant_generalizer.cpp:
  256          if (match_sk_idx(e, zks, idx, sk)) {
  257:             CTRACE("spacer_qgen", idx != sk,
  258                     tout << "Possible cleanup of " << mk_pp(idx, m) << " in "

  280              bind = arith.mk_add(kids_bind.size(), kids_bind.data());
  281:             TRACE("spacer_qgen",
  282                    tout << "replace " << mk_pp(idx, m) << " with " << mk_pp(rep, m) << "\n"

  292          rw(cube);
  293:         TRACE("spacer_qgen",
  294                tout << "Cleaned cube to: " << mk_and(cube) << "\n";);

  509      if (has_nlira(abs_cube)) {
  510:         TRACE("spacer_qgen",
  511                tout << "non-linear expression: " << abs_cube << "\n";);

  514  
  515:     TRACE("spacer_qgen",
  516            tout << "abs_cube is: " << mk_and(abs_cube) << "\n";

  546          unsigned mod = init.get_unsigned() % stride;
  547:         TRACE("spacer_qgen",
  548                tout << "mod=" << mod << " init=" << init << " stride=" << stride << "\n";

  560  
  561:     TRACE("spacer_qgen",
  562            tout << "New CUBE is: " << gnd_cube << "\n";);

  567      if (pt.check_inductive(lemma->level(), gnd_cube, uses_level, lemma->weakness())) {
  568:         TRACE("spacer_qgen",
  569                tout << "Quantifier Generalization Succeeded!\n"

  614  
  615:     CTRACE("spacer_qgen", indices.empty(),
  616             tout << "Found no select indices in: " << pattern << "\n";);

  666  
  667:         TRACE("spacer_qgen",
  668                tout << "Match succeeded!\n";);

  676      stride = instances[1]-instances[0];
  677:     TRACE("spacer_qgen", tout << "Index Stride is: " << stride << "\n";);
  678  

  688  
  689:     TRACE("spacer_qgen",
  690            tout << "initial cube: " << mk_and(lemma->get_cube()) << "\n";);

  702          flatten_and(c, m_cube);
  703:         TRACE("spacer_qgen",
  704                tout << "normalized cube:\n" << mk_and(m_cube) << "\n";);

z3/src/muz/spacer/spacer_sat_answer.cpp:
   66          lbool res = m_solver->check_sat(0, nullptr);
   67:         CTRACE("spacer_sat", res != l_true, tout << "solver at check:\n";
   68                 m_solver->display(tout) << "res: " << res << "\n";);

  135  
  136:     TRACE("spacer_sat",
  137            tout << "Solver in mk_children\n";

  140      lbool res = m_solver->check_sat(0, nullptr);
  141:     CTRACE("spacer_sat", res != l_true,
  142             m_solver->display(tout) << "\n" "Result: " << res << "\n";);

  156      }
  157:     TRACE("spacer_sat", tout << "Children for fact: " << fr.m_fact << " are " << fr.m_kids << "\n";
  158            tout << "gnd_eq for fact are: " << fr.m_gnd_eq << "\n";

  198                                            positions, substs));
  199:     TRACE("spacer_sat", tout << "pf step:\n"
  200            << "premises: " << premises << "\n"

z3/src/muz/spacer/spacer_unsat_core_plugin.cpp:
  100          symbol sym;
  101:         TRACE("spacer.farkas",
  102                tout << "looking at: " << mk_pp(step, m) << "\n";);

  136  
  137:             TRACE("spacer.farkas",
  138                    tout << "Farkas input: "<< "\n";

  212              expr_ref res = compute_linear_combination(coeff_lits);
  213:             TRACE("spacer.farkas", tout << "Farkas core: " << res << "\n";);
  214              m_ctx.add_lemma_to_core(res);

  251  
  252:             TRACE("spacer.farkas",
  253                    tout << "Farkas input: "<< "\n";

z3/src/muz/spacer/spacer_util.cpp:
  152      th_rewriter rw(m);
  153:     TRACE("spacer_mbp", tout << "Before projection:\n"; tout << fml << "\n";
  154            tout << "Vars:\n"

  179  
  180:         TRACE("spacer_mbp", tout << "After qe_lite:\n";
  181                tout << mk_pp(fml, m) << "\n"; tout << "Vars:\n"

  206              SASSERT(!m.is_false(fml));
  207:             TRACE("spacer_mbp", tout << "Projected Booleans:\n"
  208                                       << fml << "\n";);

  211  
  212:         TRACE("spacer_mbp", tout << "Array vars:\n"; tout << array_vars;);
  213  

  227  
  228:         TRACE("spacer_mbp", tout << "extended model:\n"; model_pp(tout, mdl);
  229                tout << "Auxiliary variables of index and value sorts:\n";

  236      if (!arith_vars.empty()) {
  237:         TRACE("spacer_mbp", tout << "Arith vars:\n" << arith_vars;);
  238  

  251  
  252:         TRACE("spacer_mbp", tout << "Projected arith vars:\n"
  253                                   << fml << "\n";

  263          subst_vars(m, arith_vars, mdl, fml);
  264:         TRACE("spacer_mbp",
  265                tout << "After substituting remaining arith vars:\n";

  306  
  307:     TRACE("spacer_expand", tout << "begin expand\n" << conjs << "\n";);
  308  

  349      }
  350:     TRACE("spacer_expand", tout << "end expand\n" << conjs << "\n";);
  351  }

  642  
  643:     CTRACE("inherit_bug", e != out,
  644             tout << "e==out0: " << (e == out0) << " e==out: " << (e == out)

  691  
  692:             TRACE("spacer_normalize", tout << "Normalized:\n"
  693                                             << out << "\n"

  695                                             << mk_and(v) << "\n";);
  696:             TRACE("spacer_normalize", {
  697                  mbp::term_graph egraph(m);

  838  
  839:     TRACE("mbqi_project_verbose", tout << "MBQI: var: " << mk_pp(var, m) << "\n"
  840                                         << "fml: " << fml << "\n";);

  844  
  845:     TRACE("mbqi_project_verbose", tout << "terms:\n" << terms << "\n";);
  846  

  850  
  851:         TRACE("mbqi_project_verbose", tout << "term: " << mk_pp(term, m)
  852                                             << " tval: " << tval

  857          if (tval == val && !occurs(var, term)) {
  858:             TRACE("mbqi_project", tout << "MBQI: replacing " << mk_pp(var, m)
  859                                         << " with " << mk_pp(term, m) << "\n";);

  866  
  867:     TRACE("mbqi_project", tout << "MBQI: failed to eliminate " << mk_pp(var, m)
  868                                 << " from " << fml << "\n";);

z3/src/muz/tab/tab_context.cpp:
  1530  
  1531:             TRACE("dl", tout << is_sat << ":\n" << mk_pp(fml, m) << "\n";);
  1532  

z3/src/muz/transforms/dl_mk_array_blast.cpp:
  221                  var* v2 = it2->m_value;
  222:                 TRACE("dl", tout << mk_pp(a1, m) << " " << mk_pp(a2, m) << "\n";);
  223                  if (get_select(a1) != get_select(a2)) {

  265                  if (!lhs.empty()) {
  266:                     TRACE("dl", tout << "unusable equality " << mk_pp(e, m) << "\n";);
  267                      new_conjs.push_back(e);

  289          m_rewriter(head);
  290:         TRACE("dl", tout << body << " => " << head << "\n";);
  291          change = ackermanize(r, body, head);

  299          rule_set new_rules(m_ctx);
  300:         TRACE("dl", tout << fml2 << "\n";);
  301          rm.mk_rule(fml2, p, new_rules, r.name());

  314              rm.mk_rule_rewrite_proof(r, *new_rule.get());
  315:             TRACE("dl", new_rule->display(m_ctx, tout << "new rule\n"););
  316          }

z3/src/muz/transforms/dl_mk_backwards.cpp:
  73          }
  74:         TRACE("dl", result->display(tout););
  75          return result.detach();

z3/src/muz/transforms/dl_mk_bit_blast.cpp:
   77                  unsigned arity_q = q->get_arity();
   78:                 TRACE("dl",
   79                        model_v2_pp(tout, *model);

  246              m_rewriter(fml2, fml3);
  247:             TRACE("dl", tout << fml << "\n-> " << fml1 << "\n-> " << fml2 << "\n-> " << fml3 << "\n";);
  248              if (fml3 != fml) {

  285                  rm.to_formula(*r, fml);
  286:                 TRACE("dl", tout << fml << "\n";);
  287                  if (blast(r, fml)) {
  288:                     TRACE("dl", tout << "blasted: " << fml << "\n";);
  289                      proof_ref pr(m);

  321              }
  322:             CTRACE("dl", result, result->display(tout););
  323              return result.detach();

z3/src/muz/transforms/dl_mk_coi_filter.cpp:
   94          if (res->get_num_rules() == source.get_num_rules()) {
   95:             TRACE("dl", tout << "No transformation\n";);
   96              res = nullptr;

  113              m_context.add_model_converter(mc0);
  114:             TRACE("dl", m_context.get_model_converter()->display(tout););
  115          }
  116:         CTRACE("dl", res, res->display(tout););
  117          return res.detach();

  152          if (res->get_num_rules() == source.get_num_rules()) {
  153:             TRACE("dl", tout << "No transformation\n";);
  154              res = nullptr;

  176          }
  177:         CTRACE("dl", 0 != res, res->display(tout););
  178          return res.detach();

z3/src/muz/transforms/dl_mk_elim_term_ite.cpp:
  140              new_rules.add_rule(new_rule);
  141:             TRACE("dl", tout << "No term-ite after blast_term_ite\n";);
  142              return true;

  144  
  145:         TRACE("dl", tout << "Rule has term-ite after blasting, starting elimination\n";);
  146          body = ground(body);

  174          fml2 = m.mk_implies(body, ground(r.get_head()));
  175:         CTRACE("dl", has_term_ite(fml2), tout << "Rule has term-ite after elimination. Giving up\n";);
  176          if (has_term_ite(fml2))

  187          rm.mk_rule_rewrite_proof(r, *new_rules.last());
  188:         TRACE("dl", tout << "New rule: " << fml2 << "\n";);
  189          return true;

z3/src/muz/transforms/dl_mk_filter_rules.cpp:
   55          if (!m_context.is_predicate(pred)) {
   56:             TRACE("mk_filter_rules", tout << mk_pp(pred, m) << "\nis not a candidate because it is interpreted.\n";);
   57              return false;

  113              if (is_candidate(tail) && !r->is_neg_tail(i)) {
  114:                 TRACE("mk_filter_rules", tout << "is_candidate: " << mk_pp(tail, m) << "\n";);
  115                  var_idx_set non_local_vars = rm.collect_rule_vars_ex(r, tail);

z3/src/muz/transforms/dl_mk_interp_tail_simplifier.cpp:
  476          }
  477:         TRACE("dl_interp_tail_simplifier_propagation_pre",
  478                  tout << "will propagate rule:\n";

  481          m_rule_subst.get_result(res);
  482:         TRACE("dl_interp_tail_simplifier_propagation",
  483                  tout << "propagated equivalences of:\n";

  541          if (m.is_false(simp_res)) {
  542:             TRACE("dl", r->display(m_context, tout << "rule is infeasible\n"););
  543              return false;

  576  
  577:         CTRACE("dl", (res != r0), r0->display(m_context, tout << "old:\n"); res->display(m_context, tout << "new:\n"););
  578  

  607              res->inherit_predicates(source);
  608:             TRACE("dl",
  609                    source.display(tout);

z3/src/muz/transforms/dl_mk_karr_invariants.cpp:
  204          scoped_ptr<rule_set> src_loop = lc(source);
  205:         TRACE("dl", src_loop->display(tout << "source loop\n"););
  206  

  218          rules->inherit_predicates(source);
  219:         TRACE("dl", rules->display(tout););
  220          m_pinned.reset();

z3/src/muz/transforms/dl_mk_magic_sets.cpp:
  197              rule * r = m_context.get_rule_manager().mk(mag_head, i+1, new_tail.data(), negations.data());
  198:             TRACE("dl", r->display(m_context,tout); );
  199              result.add_rule(r);

z3/src/muz/transforms/dl_mk_magic_symbolic.cpp:
  110          }
  111:         TRACE("dl", result->display(tout););
  112          return result.detach();

z3/src/muz/transforms/dl_mk_quantifier_abstraction.cpp:
   90  
   91:                 TRACE("dl", tout << body << "\n";);
   92                  // 1. replace variables by the compound terms from

  100  
  101:                 TRACE("dl", tout << body << "\n";);
  102                  // 2. replace bound variables by constants.

  121  
  122:                 TRACE("dl", tout << body << "\n";);
  123                  // 3. abstract and quantify those variables that should be bound.

  126  
  127:                 TRACE("dl", tout << body << "\n";);
  128                  // 4. replace remaining constants by variables.

  135                  new_model->register_decl(q, body);
  136:                 TRACE("dl", tout << body << "\n";);
  137              }

  239          }
  240:         TRACE("dl",
  241                tout << mk_pp(new_p, m) << "\n";

  334              rule & r = *source.get_rule(i);
  335:             TRACE("dl", r.display(m_ctx, tout); );
  336              unsigned cnt = vc.get_max_rule_var(r)+1;

  348              rm.mk_rule(fml, pr, *result, r.name());
  349:             TRACE("dl", result->last()->display(m_ctx, tout););
  350          }

z3/src/muz/transforms/dl_mk_quantifier_instantiation.cpp:
   95      void mk_quantifier_instantiation::match(unsigned i, app* pat, unsigned j, term_pairs& todo, quantifier* q, expr_ref_vector& conjs) {
   96:         TRACE("dl", tout << "match" << mk_pp(pat, m) << "\n";);
   97          while (j < todo.size()) {

  162          conjs.push_back(res);
  163:         TRACE("dl", tout << mk_pp(q, m) << "\n==>\n" << mk_pp(res, m) << "\n";);
  164      }

  228          fml = m.mk_implies(fml, r.get_head());
  229:         TRACE("dl", r.display(m_ctx, tout); tout << mk_pp(fml, m) << "\n";);
  230          

z3/src/muz/transforms/dl_mk_rule_inliner.cpp:
   80              m_deltas[1] = var_cnt;
   81:             TRACE("dl",
   82                    output_predicate(m_context, src.get_head(), tout << "unify rules ");

   90          expr_ref res_e(m);
   91:         TRACE("dl", output_predicate(m_context, a, tout); tout << "\n";);
   92          m_subst.apply(2, m_deltas, expr_offset(a, is_tgt ? 0 : 1), res_e);

  126          res->set_accounting_parent_object(m_context, const_cast<rule*>(&tgt));
  127:         TRACE("dl",
  128                tgt.display(m_context,  tout << "tgt (" << tail_index << "): \n");

  195          else {
  196:             TRACE("dl", res->display(m_context, tout << "interpreted tail is unsat\n"););
  197              //the interpreted part is unsatisfiable

  394  
  395:         TRACE("dl", tout<<"rules to be inlined:\n" << (*candidate_inlined_set); );
  396  

  409          }
  410:         TRACE("dl", tout << "inlined rules after mutual inlining:\n" << m_inlined_rules;  );
  411              for (rule * r : m_inlined_rules) 

  427  
  428:             CTRACE("dl", has_quantifier(*r.get()), r->display(m_context, tout););
  429              if (has_quantifier(*r.get())) {

  620          m_unifiers.append(m_positions.find(e));
  621:         TRACE("dl",
  622                tout << "unifier: " << (m_unifiers.empty()?0:m_unifiers.back());

  663              can_remove.set(i, false);
  664:             TRACE("dl", output_predicate(m_context, head, tout << "cannot remove: " << i << " "); tout << "\n";);
  665          }

  702  
  703:         TRACE("dl", rules->display(tout););
  704  

  744  
  745:                 TRACE("dl", r->display(m_context, tout << "processing: " << i << "\n"););
  746  
  747                  if (!valid.get(i)) {
  748:                     TRACE("dl", tout << "invalid: " << i << "\n";);
  749                      break;

  751                  if (!can_expand.get(i)) {
  752:                     TRACE("dl", tout << "cannot expand: " << i << "\n";);
  753                      break;

  759                  if (num_head_unifiers != 1) {
  760:                     TRACE("dl", tout << "no unique unifier " << num_head_unifiers << "\n";);
  761                      break;

  764                  if (!can_remove.get(j) || !valid.get(j) || i == j) {
  765:                     TRACE("dl", tout << PRT(can_remove.get(j)) << " " << PRT(valid.get(j)) << " " << PRT(i != j) << "\n";);
  766                      break;

  771                  // check that the head of r2 only unifies with this single body position.
  772:                 TRACE("dl", output_predicate(m_context, r2->get_head(), tout << "unify head: "); tout << "\n";);
  773                  m_tail_visitor.reset();

  778                  if (!allow_branching && num_tail_unifiers != 1) {
  779:                     TRACE("dl", tout << "too many tails " << num_tail_unifiers << "\n";);
  780                      break;

  784                  if (!try_to_inline_rule(*r.get(), *r2, 0, rl_res)) {
  785:                     TRACE("dl", r->display(m_context, tout << "inlining failed\n"); r2->display(m_context, tout);  );
  786                      break;

  788                  done_something = true;
  789:                 TRACE("dl", r->display(m_context, tout); r2->display(m_context, tout); rl_res->display(m_context, tout); );
  790  

  799                  if (num_tail_unifiers == 1) {
  800:                     TRACE("dl", tout << "setting invalid: " << j << "\n";);
  801                      valid.set(j, false);

  818              res->inherit_predicates(*rules);
  819:             TRACE("dl", res->display(tout););
  820              rules = res.detach();

  845          if (m_context.get_params().xform_inline_eager()) {
  846:             TRACE("dl", source.display(tout << "before eager inlining\n"););
  847              plan_inlining(source);

  858              }
  859:             TRACE("dl", res->display(tout << "after eager inlining\n"););
  860          }

z3/src/muz/transforms/dl_mk_scale.cpp:
   51  				if (!new_fi) {
   52: 					TRACE("dl", tout << new_p->get_name() << " has no value in the current model\n";);
   53  					continue;

   90              md = old_model;
   91:             //TRACE("dl", model_smt2_pp(tout, m, *md, 0); );
   92          }

  160          }
  161:         TRACE("dl", result->display(tout););
  162          if (m_mc) {

z3/src/muz/transforms/dl_mk_slice.cpp:
  123                  m_pinned_exprs.push_back(fml);
  124:                 TRACE("dl", 
  125                        tout << "orig: " << mk_pp(fml, m) << "\n";

  148                      m_todo.pop_back();
  149:                     TRACE("dl", tout << "unhandled proof term\n" << mk_pp(p, m) << "\n";);
  150                  }

  161              if (!m_sliceform2rule.find(fact, r)) {
  162:                 TRACE("dl", tout << "does not have fact\n" << mk_pp(fact, m) << "\n";);
  163                  return false;

  201              expr* fact0   = m.get_fact(p0);
  202:             TRACE("dl", tout << "fact0: " << mk_pp(fact0, m) << "\n";);
  203              rule* orig0;

  214                  expr* fact1   = m.get_fact(p1);
  215:                 TRACE("dl", tout << "fact1: " << mk_pp(fact1, m) << "\n";);
  216                  rule* orig1 = nullptr;

  233                  substs.push_back(m_unifier.get_rule_subst(*r2.get(), false));   
  234:                 TRACE("dl", 
  235                      r1->display(m_ctx, tout << "rule1:");

  243              m_pinned_rules.push_back(r1.get());
  244:             TRACE("dl", 
  245                    tout << "orig: " << mk_pp(slice_concl, m) << "\n";

  251              m_todo.pop_back();
  252:             TRACE("dl", tout << "translated:\n" << mk_pp(p, m) << "\nto\n" << mk_pp(new_p, m) << "\n";);
  253              return true;

  318              }
  319:             TRACE("dl", model_smt2_pp(tout, m, *md, 0); );
  320              model_ref old_model = alloc(model, m);

  330  
  331:                 TRACE("dl", tout << mk_pp(old_p, m) << " " << mk_pp(new_p, m) << "\n";
  332                              for (unsigned j = 0; j < is_sliced.size(); ++j) {

  350                      if (!new_fi) {
  351:                         TRACE("dl", tout << new_p->get_name() << " has no value in the current model\n";);
  352                          dealloc(old_fi);

  355                      if (!new_fi->is_partial()) {
  356:                         TRACE("dl", tout << mk_pp(new_fi->get_else(), m) << "\n";);
  357                          tmp = vs(new_fi->get_else(), subst.size(), subst.data());

  397              md = old_model;
  398:             TRACE("dl", model_smt2_pp(tout, m, *md, 0); );
  399          }

  472              if (is_eq(e, v, r) && is_output(v) && m_var_is_sliceable[v]) {
  473:                 TRACE("dl", tout << "is_eq: " << mk_pp(e, m) << " " << (m_solved_vars[v].get()?"solved":"new") << "\n";);
  474                  add_var(v);
  475                  if (!m_solved_vars[v].get()) { 
  476:                     TRACE("dl", tout << v << " is solved\n";);
  477                      add_free_vars(parameter_vars, r);

  480                  else {
  481:                     TRACE("dl", tout << v << " is used\n";);
  482                      // variables can only be solved once.

  495      bool mk_slice::prune_rule(rule& r) {
  496:         TRACE("dl", r.display(m_ctx, tout << "prune:\n"); );
  497          bool change = false;

  509                      change = true;                    
  510:                     TRACE("dl", tout << "argument " << i << " is not a variable " << p->get_decl()->get_name() << "\n";);
  511                  }

  651              if (is_neg_tail) {
  652:                 TRACE("dl", tout << "negated " << i << " in " << p->get_decl()->get_name() << "\n";);
  653                  bv.unset(i);

  669                  if (!is_output) {
  670:                     TRACE("dl", tout << "input  " << i << " in " << p->get_decl()->get_name() << "\n";);
  671                      bv.unset(i);

  684                  change = true;
  685:                 TRACE("dl", tout << "variable is unslicable " << mk_pp(arg, m) << " for index " << i << " in " << p->get_decl()->get_name() << "\n";);
  686              }

  805  
  806:             TRACE("dl", r.display(m_ctx, tout << "replacing:\n"); new_rule->display(m_ctx, tout << "by:\n"););
  807              if (m_ctx.generate_proof_trace()) {

  851          }
  852:         TRACE("dl", display(tout););        
  853          update_rules(src, *result);
  854:         TRACE("dl", result->display(tout););
  855          if (m_mc) {

z3/src/muz/transforms/dl_mk_subsumption_checker.cpp:
  249          }
  250:         TRACE("dl",
  251              tout << "original set size: "<<orig.get_num_rules()<<"\n"

z3/src/muz/transforms/dl_mk_unbound_compressor.cpp:
   80          m_map.insert(ci, cpred);
   81:         TRACE("dl", tout << "inserting: " << pred->get_name() << " " << arg_index << " for " << cpred->get_name() << "\n";);
   82      }

  105                  (1 == rm.get_counter().get(var_idx))) {
  106:                 TRACE("dl", r->display(m_context, tout << "Compress: "););
  107                  add_task(head_pred, i);

  166              rule* last_rule = m_rules.get(new_size);
  167:             TRACE("dl", tout << "remove\n"; r->display(m_context, tout); 
  168                    tout << "shift\n"; last_rule->display(m_context, tout););

  179              m_head_occurrence_ctr.dec(m_rules.get(rule_index)->get_decl());
  180:             TRACE("dl", tout << "remove\n"; r->display(m_context, tout); 
  181                    tout << "set\n"; new_rule->display(m_context, tout););

  194  
  195:         TRACE("dl", tout << "retrieving: " << ci.first->get_name() << " " << ci.second << "\n";);
  196  

  249          m_rules.push_back(new_rule);
  250:         TRACE("dl", r->display(m_context, tout); new_rule->display(m_context, tout); );
  251          m_context.get_rule_manager().mk_rule_rewrite_proof(*r, *new_rule.get());

  259          rule_ref new_rule = mk_decompression_rule(r, tail_index, arg_index);
  260:         TRACE("dl", tout << "remove\n"; r->display(m_context, tout); tout << "set\n"; new_rule->display(m_context, tout););
  261          m_rules.set(rule_index, new_rule);

z3/src/nlsat/nlsat_evaluator.cpp:
  426              m_am.isolate_roots(polynomial_ref(a->p(), m_pm), undef_var_assignment(m_assignment, a->x()), roots);
  427:             TRACE("nlsat_evaluator",
  428                    m_solver.display(tout << (neg?"!":""), *a); tout << "\n";

  464                  signs.reset();
  465:                 TRACE("nlsat_evaluator", tout << "x: " << x << " max_var(p): " << m_pm.max_var(p) << "\n";);
  466                  // Note: I added undef_var_assignment in the following statement, to allow us to obtain the infeasible interval sets

  478                  ::sign curr_sign = t.sign_at(i, c);
  479:                 TRACE("nlsat_evaluator_bug", tout << "sign of i: " << i << " at cell " << c << "\n"; 
  480                        m_pm.display(tout, a->p(i)); 

  493              table.reset();
  494:             TRACE("nsat_evaluator", m_solver.display(tout, *a) << "\n";);
  495              unsigned num_ps = a->size();

  498                  add(a->p(i), x, table);
  499:                 TRACE("nlsat_evaluator_bug", tout << "table after:\n"; m_pm.display(tout, a->p(i)); tout << "\n"; table.display_raw(tout);); 
  500                  
  501              }
  502:             TRACE("nlsat_evaluator", 
  503                    tout << "sign table for:\n"; 

  519              for (unsigned c = 0; c < num_cells; c++) {
  520:                 TRACE("nlsat_evaluator",
  521                        tout << "cell: " << c << "\n";

  528                  int sign = sign_at(a, table, c);
  529:                 TRACE("nlsat_evaluator", tout << "sign: " << sign << "\n";);
  530                  if (satisfied(sign, k, neg)) {

  572                                  prev_root_id = table.get_root_id(c); 
  573:                                 TRACE("nlsat_evaluator", tout << "updated prev_root_id: " << prev_root_id << " using cell: " << c << "\n";);
  574                              }

  578                                  prev_root_id = table.get_root_id(c-1);
  579:                                 TRACE("nlsat_evaluator", tout << "updated prev_root_id: " << prev_root_id << " using cell: " << (c - 1) << "\n";);
  580                              }

  591              }
  592:             TRACE("nlsat_evaluator", tout << "interval_set: " << result << "\n";);
  593              return result;

  662              }
  663:             TRACE("nlsat_evaluator", tout << "interval_set: " << result << "\n";);
  664              return result;

z3/src/nlsat/nlsat_explain.cpp:
   190                  return;
   191:             TRACE("nlsat_explain", tout << "adding literal: " << lidx << "\n"; m_solver.display(tout, l) << "\n";);
   192              m_already_added_literal.setx(lidx, true, false);

   213              auto s = m_am.eval_sign_at(p, m_assignment);
   214:             TRACE("nlsat_explain", tout << "p: " << p << " var: " << max_var(p) << " sign: " << s << "\n";);
   215              return s;

   222              // TODO: add params, caching
   223:             TRACE("nlsat_factor", tout << "factor\n" << p << "\n";);
   224              fs.reset();

   281              l.neg();
   282:             TRACE("nlsat_explain", tout << "adding (zero assumption) literal:\n"; display(tout, l); tout << "\n";);
   283              add_literal(l);

   314              while (true) {
   315:                 TRACE("nlsat_explain", tout << "elim vanishing x" << x << " k:" << k << " " << p << "\n";);
   316                  if (is_const(p))

   334                  if (m_pm.nonzero_const_coeff(p, x, k)) {
   335:                     TRACE("nlsat_explain", tout << "nonzero const x" << x << "\n";);
   336                      return; // lc is a nonzero constant

   338                  lc = m_pm.coeff(p, x, k, reduct);
   339:                 TRACE("nlsat_explain", tout << "lc: " << lc << " reduct: " << reduct << "\n";);
   340                  if (!is_zero(lc)) {

   584              if (m_factor) {
   585:                 TRACE("nlsat_explain", display(tout << "adding factors of\n", p); tout << "\n";);
   586                  factor(p, m_factors);

   591                      if (!is_const(f)) {
   592:                         TRACE("nlsat_explain", tout << "adding factor:\n"; display(tout, f); tout << "\n";);
   593                          m_todo.insert(f);

   617                  SASSERT(k > 0);
   618:                 TRACE("nlsat_explain", tout << "add_lc, x: "; display_var(tout, x); tout << "\nk: " << k << "\n"; display(tout, p); tout << "\n";);
   619                  if (m_pm.nonzero_const_coeff(p, x, k)) {
   620:                     TRACE("nlsat_explain", tout << "constant coefficient, skipping...\n";);
   621                      continue;

   638              unsigned sz = S.size();
   639:             TRACE("nlsat_explain", tout << "computing psc of\n"; display(tout, p); tout << "\n"; display(tout, q); tout << "\n";
   640                    for (unsigned i = 0; i < sz; ++i) {

   646                  s = S.get(i);
   647:                 TRACE("nlsat_explain", display(tout << "processing psc(" << i << ")\n", s) << "\n";); 
   648                  if (is_zero(s)) {
   649:                     TRACE("nlsat_explain", tout << "skipping psc is the zero polynomial\n";);
   650                      continue;

   652                  if (is_const(s)) {
   653:                     TRACE("nlsat_explain", tout << "done, psc is a constant\n";);
   654                      return;

   656                  if (is_zero(sign(s))) {
   657:                     TRACE("nlsat_explain", tout << "psc vanished, adding zero assumption\n";);
   658                      add_zero_assumption(s);

   660                  }
   661:                 TRACE("nlsat_explain", 
   662                        tout << "adding v-psc of\n";

   726              polynomial_ref pr(p, m_pm);
   727:             TRACE("nlsat_explain", 
   728                    display(tout << "x" << y << " " << k << "[" << i << "](", pr); tout << ")\n";);

   733                  literal l(b, true);
   734:                 TRACE("nlsat_explain", tout << "adding literal\n"; display(tout, l); tout << "\n";);
   735                  add_literal(l);

   845              if (!is_const(p)) {
   846:                 TRACE("nlsat_explain", tout << p << "\n";);
   847                  add_simple_assumption(s == 0 ? atom::EQ : (s < 0 ? atom::LT : atom::GT), p);

   906              anum const & y_val = m_assignment.value(y);
   907:             TRACE("nlsat_explain", tout << "adding literals for "; display_var(tout, y); tout << " -> ";
   908                    m_am.display_decimal(tout, y_val); tout << "\n";);

   925                      int s = m_am.compare(y_val, roots[i]);
   926:                     TRACE("nlsat_explain", 
   927                            m_am.display_decimal(tout << "comparing root: ", roots[i]); tout << "\n";

  1005                  }
  1006:                 TRACE("nlsat_explain", tout << "project loop, processing var "; display_var(tout, x); tout << "\npolynomials\n";
  1007                        display(tout, ps); tout << "\n";);

  1109              }
  1110:             TRACE("nlsat_simplify_core", display(tout << "trying to simplify literal\n", l) << "\nusing equation\n";
  1111                    m_pm.display(tout, info.m_eq, m_solver.display_proc()); tout << "\n";);

  1129                  
  1130:                 TRACE("nlsat_simplify_core", tout << "d: " << d << " factor " << fact << " eq " << eq << " new factor " << new_factor << "\n";);
  1131                  // adjust sign based on sign of lc of eq

  1135                      atom_sign = -atom_sign; // flipped the sign of the current literal
  1136:                     TRACE("nlsat_simplify_core", tout << "odd degree\n";);
  1137                  }
  1138                  if (is_const(new_factor)) {
  1139:                     TRACE("nlsat_simplify_core", tout << "new factor is const\n";);
  1140                      auto s = sign(new_factor); 

  1144                          new_lit = lit_val ? true_literal : false_literal;
  1145:                         TRACE("nlsat_simplify_core", tout << "zero sign: " << info.m_lc_const << "\n";);
  1146                          if (!info.m_lc_const) {

  1156                      else {
  1157:                         TRACE("nlsat_simplify_core", tout << "non-zero sign: " << info.m_lc_const << "\n";);
  1158                          // We have shown the current factor is a constant MODULO the sign of the leading coefficient (of the equation used to rewrite the factor). 

  1196                      new_lit.neg();
  1197:                 TRACE("nlsat_simplify_core", tout << "simplified literal:\n"; display(tout, new_lit) << " " << m_solver.value(new_lit) << "\n";);
  1198                  

  1209                      new_lit = normalize(new_lit, max);
  1210:                     TRACE("nlsat_simplify_core", tout << "simplified literal after normalization:\n"; display(tout, new_lit); tout << " " << m_solver.value(new_lit) << "\n";);
  1211                  }

  1351                      break;
  1352:                 TRACE("nlsat_simplify_core", tout << "using equality for simplifying core\n"; 
  1353                        m_pm.display(tout, eq, m_solver.display_proc()); tout << "\n";);

  1366                  // add equation as an assumption                
  1367:                 TRACE("nlsat_simpilfy_core", display(tout << "adding equality as assumption ", literal(eq->bvar(), true)); tout << "\n";);
  1368                  add_literal(literal(eq->bvar(), true));

  1379              var max_x = max_var(m_ps);
  1380:             TRACE("nlsat_explain", tout << "polynomials in the conflict:\n"; display(tout, m_ps); tout << "\n";);
  1381              elim_vanishing(m_ps);
  1382:             TRACE("nlsat_explain", tout << "elim vanishing\n"; display(tout, m_ps); tout << "\n";);
  1383              project(m_ps, max_x);
  1384:             TRACE("nlsat_explain", tout << "after projection\n"; display(tout, m_ps); tout << "\n";);
  1385          }

  1393                  normalize(m_core2, max);
  1394:                 TRACE("nlsat_explain", display(tout << "core after normalization\n", m_core2) << "\n";);
  1395                  simplify(m_core2, max);
  1396:                 TRACE("nlsat_explain", display(tout << "core after simplify\n", m_core2) << "\n";);
  1397                  main(m_core2.size(), m_core2.data());

  1425              }
  1426:             TRACE("nlsat_minimize", tout << "interval set after adding partial core:\n" << r << "\n";);
  1427              if (todo.size() == 1) {

  1461              while (true) {
  1462:                 TRACE("nlsat_minimize", tout << "core minimization:\n"; display(tout, todo); tout << "\nCORE:\n"; display(tout, core) << "\n";);
  1463                  if (!minimize_core(todo, core))

  1465                  std::reverse(todo.begin(), todo.end());
  1466:                 TRACE("nlsat_minimize", tout << "core minimization:\n"; display(tout, todo); tout << "\nCORE:\n"; display(tout, core) << "\n";);
  1467                  if (!minimize_core(todo, core))

  1469              }
  1470:             TRACE("nlsat_minimize", tout << "core:\n"; display(tout, core););
  1471              r.append(core.size(), core.data());

  1488              SASSERT(num > 0);
  1489:             TRACE("nlsat_explain", 
  1490                    tout << "[explain] set of literals is infeasible in the current interpretation\n"; 

  1497              m_result = nullptr;
  1498:             TRACE("nlsat_explain", display(tout << "[explain] result\n", result) << "\n";);
  1499              CASSERT("nlsat", check_already_added());

  1506              svector<literal> lits;
  1507:             TRACE("nlsat", tout << "project x" << x << "\n"; 
  1508                    m_solver.display(tout, num, ls);

  1527                      m_solver.reorder(renaming.size(), renaming.data());
  1528:                     TRACE("qe", tout << "x: " << x << " max: " << mx_var << " num_vars: " << m_solver.num_vars() << "\n";
  1529                            m_solver.display(tout););

  1551              DEBUG_CODE(
  1552:                 TRACE("nlsat", m_solver.display(tout, result.size(), result.data()) << "\n"; );
  1553                  for (literal l : result) {
  1554:                     CTRACE("nlsat", l_true != m_solver.value(l), m_solver.display(tout, l) << " " << m_solver.value(l) << "\n";);
  1555                      SASSERT(l_true == m_solver.value(l));

  1605              
  1606:             TRACE("nlsat_explain", tout << "Signed projection\n";);
  1607              polynomial_ref p(m_pm);

  1684              }
  1685:             TRACE("nlsat_explain", tout << "glb: " << num_glb << " lub: " << num_lub << "\n" << lub_index << "\n" << glb_index << "\n" << ps << "\n";);
  1686  

  1726                      int s = sign(p);
  1727:                     TRACE("nlsat_explain", tout << "degree: " << d << " " << lc << " sign: " << s << "\n";);
  1728                      SASSERT(s != 0);

  1741          void project_pairs(var x, unsigned idx, polynomial_ref_vector const& ps) {
  1742:             TRACE("nlsat_explain", tout << "project pairs\n";);
  1743              polynomial_ref p(m_pm);

  1774              B = neg(B);
  1775:             TRACE("nlsat_explain", tout << "p: " << p << " A: " << A << " B: " << B << "\n";);
  1776              // x = B/A

  1790                          C = m_pm.coeff(q, x, j);
  1791:                         TRACE("nlsat_explain", tout << "coeff: q" << j << ": " << C << "\n";);
  1792                          if (!is_zero(C)) {

  1797                      }
  1798:                     TRACE("nlsat_explain", tout << "p: " << p << " q: " << q << " r: " << r << "\n";);
  1799                      ensure_sign(r);

z3/src/nlsat/nlsat_interval_set.cpp:
   79              (void)s;
   80:             TRACE("nlsat_interval", tout << "lower: "; am.display_decimal(tout, i.m_lower); tout << ", upper: "; am.display_decimal(tout, i.m_upper);
   81                    tout << "\ns: " << s << "\n";);

   91          sign s = am.compare(curr.m_upper, next.m_lower);
   92:         CTRACE("nlsat", s > 0, display(tout, am, curr); tout << "  "; display(tout, am, next); tout << "\n";);
   93          SASSERT(s <= 0);

  204          if (i1.m_upper_inf || i2.m_lower_inf) {
  205:             TRACE("nlsat_interval", nlsat::display(tout << "i1: ", am, i1); nlsat::display(tout << "i2: ", am, i2););
  206              return sign_pos;

  209          auto s = am.compare(i1.m_upper, i2.m_lower);
  210:         TRACE("nlsat_interval", nlsat::display(tout << "i1: ", am, i1); nlsat::display(tout << " i2: ", am, i2); 
  211                tout << " compare: " << s << "\n";);

  274          if (s_count == 4470) {
  275:             enable_trace("nlsat_interval");
  276:             enable_trace("algebraic");
  277          }
  278  #endif
  279:         TRACE("nlsat_interval", tout << "mk_union\ns1: "; display(tout, s1); tout << "\ns2: "; display(tout, s2); tout << "\n";);
  280          if (s1 == nullptr || s1 == s2)

  295                  while (i2 < sz2) {
  296:                     TRACE("nlsat_interval", tout << "adding remaining intervals from s2: "; nlsat::display(tout, m_am, s2->m_intervals[i2]); tout << "\n";);
  297                      push_back(m_am, result, s2->m_intervals[i2]);

  303                  while (i1 < sz1) {
  304:                     TRACE("nlsat_interval", tout << "adding remaining intervals from s1: "; nlsat::display(tout, m_am, s1->m_intervals[i1]); tout << "\n";);
  305                      push_back(m_am, result, s1->m_intervals[i1]);

  313              int u1_u2_sign = compare_upper_upper(m_am, int1, int2);
  314:             TRACE("nlsat_interval", 
  315                    tout << "i1: " << i1 << ", i2: " << i2 << "\n";

  326                      //
  327:                     TRACE("nlsat_interval", tout << "l1_l2_sign <= 0, u1_u2_sign == 0\n";);
  328                      push_back(m_am, result, int1);

  340                      i2++;
  341:                     TRACE("nlsat_interval", tout << "l1_l2_sign <= 0, u1_u2_sign > 0\n";);
  342                      // i1 may consume other intervals of s2

  351                          //                [     ]
  352:                         TRACE("nlsat_interval", tout << "l1_l2_sign <= 0, u1_u2_sign < 0, u1_l2_sign < 0\n";);
  353                          push_back(m_am, result, int1);

  359                          SASSERT(!int2.m_lower_inf);
  360:                         TRACE("nlsat_interval", tout << "l1_l2_sign <= 0, u1_u2_sign < 0, u1_l2_sign == 0\n";);
  361                          // Cases:

  384                          SASSERT(u1_l2_sign > 0);
  385:                         TRACE("nlsat_interval", tout << "l1_l2_sign <= 0, u1_u2_sign < 0, u1_l2_sign > 0\n";);
  386                          if (l1_l2_sign == 0) {

  410                  if (u1_u2_sign == 0) {
  411:                     TRACE("nlsat_interval", tout << "l2 < l1 <= u1 = u2\n";);
  412                      // Case:

  420                  else if (u1_u2_sign < 0) {
  421:                     TRACE("nlsat_interval", tout << "l2 < l1 <= u2 < u2\n";);
  422                      // Case:

  430                      if (u2_l1_sign < 0) {
  431:                         TRACE("nlsat_interval", tout << "l2 <= u2 < l1 <= u1\n";);
  432                          // Case:

  438                      else if (is_zero(u2_l1_sign)) {
  439:                         TRACE("nlsat_interval", tout << "l1_l2_sign > 0, u1_u2_sign > 0, u2_l1_sign == 0\n";);
  440                          SASSERT(!int1.m_lower_open && !int2.m_upper_open);

  451                      else {
  452:                         TRACE("nlsat_interval", tout << "l2 < l1 < u2 < u1\n";);
  453                          SASSERT(l1_l2_sign > 0);

  553              interval const & int2 = s2->m_intervals[i2];
  554:             TRACE("nlsat_interval", tout << "subset main loop, i1: " << i1 << ", i2: " << i2 << "\n";
  555                    tout << "int1: "; nlsat::display(tout, m_am, int1); tout << "\n";

  557              if (compare_lower_lower(m_am, int1, int2) < 0) {
  558:                 TRACE("nlsat_interval", tout << "done\n";);
  559                  // interval [int1.lower1, int2.lower2] is not in s2

  565                  interval const & int2 = s2->m_intervals[i2];
  566:                 TRACE("nlsat_interval", tout << "inner loop, i2: " << i2 << "\n";
  567                        tout << "int2: "; nlsat::display(tout, m_am, int2); tout << "\n";);

  569                  if (u1_u2_sign == 0) {
  570:                     TRACE("nlsat_interval", tout << "case 1, break\n";);
  571                      // consume both

  578                  else if (u1_u2_sign < 0) {
  579:                     TRACE("nlsat_interval", tout << "case 2, break\n";);
  580                      // consume only int1, int2 may cover other intervals of s1 

  588                      int u2_l1_sign = compare_upper_lower(m_am, int2, int1);
  589:                     TRACE("nlsat_interval", tout << "subset, u2_l1_sign: " << u2_l1_sign << "\n";);
  590                      if (u2_l1_sign < 0) {
  591:                         TRACE("nlsat_interval", tout << "case 3, break\n";);
  592                          // s1:           [ ...

  600                      if (i2 == sz2 - 1) {
  601:                         TRACE("nlsat_interval", tout << "case 4, done\n";);
  602                          // s1:   ... ]

  608                      if (!adjacent(m_am, int2, next2)) {
  609:                         TRACE("nlsat_interval", tout << "not adjacent, done\n";);
  610                          // s1:   ... ]

  614                      }
  615:                     TRACE("nlsat_interval", tout << "continue..\n";);
  616                      // continue with adjacent interval of s2

z3/src/nlsat/nlsat_solver.cpp:
   342                  return;
   343:             TRACE("ref", display(tout << "inc: " << b << " " << a->ref_count() << " ", *a) << "\n";);
   344              a->inc_ref();

   358              a->dec_ref();
   359:             TRACE("ref", display(tout << "dec: " << b << " " << a->ref_count() << " ", *a) << "\n";);
   360              if (a->ref_count() == 0)

   549          void del(ineq_atom * a) {
   550:             CTRACE("nlsat_solver", a->ref_count() > 0, display(tout, *a) << "\n";);
   551              // this triggers in too many benign cases:

   571                  return;
   572:             TRACE("nlsat_verbose", display(tout << "del: b" << a->m_bool_var << " " << a->ref_count() << " ", *a) << "\n";);
   573              if (a->is_ineq_atom())

   602                  uniq_ps.push_back(m_cache.mk_unique(p));
   603:                 TRACE("nlsat_table_bug", tout << "p: " << p << ", uniq: " << uniq_ps.back() << "\n";);
   604              }

   609              ineq_atom * atom = m_ineq_atoms.insert_if_not_there(tmp_atom);
   610:             CTRACE("nlsat_table_bug", tmp_atom != atom, ineq_atom::hash_proc h; 
   611                    tout << "mk_ineq_atom hash: " << h(tmp_atom) << "\n"; display(tout, *tmp_atom, m_display_var) << "\n";);
   612:             CTRACE("nlsat_table_bug", atom->max_var() != max, display(tout << "nonmax: ", *atom, m_display_var) << "\n";);
   613              SASSERT(atom->max_var() == max);

   635                  atom->m_bool_var = b;
   636:                 TRACE("nlsat_verbose", display(tout << "create: b" << atom->m_bool_var << " ", *atom) << "\n";);
   637                  return b;

   675              uniq_p = m_cache.mk_unique(p1); 
   676:             TRACE("nlsat_solver", tout << x << " " << p1 << " " << uniq_p << "\n";);
   677              SASSERT(i > 0);

   810          void check_lemma(unsigned n, literal const* cls, bool is_valid, assumption_set a) {
   811:             TRACE("nlsat", display(tout << "check lemma: ", n, cls) << "\n";
   812                    display(tout););

   880                      IF_VERBOSE(0, checker.display(verbose_stream(), lit) << " := " << checker.value(lit) << "\n");
   881:                     TRACE("nlsat", checker.display(tout, lit) << " := " << checker.value(lit) << "\n";);
   882                  }

   890                          IF_VERBOSE(0, display(verbose_stream() << "violdated clause: ", *c) << "\n");
   891:                         TRACE("nlsat", display(tout << "violdated clause: ", *c) << "\n";);
   892                      }

   901                          IF_VERBOSE(0, display(verbose_stream() << "violdated tautology clause: ", *c) << "\n");
   902:                         TRACE("nlsat", display(tout << "violdated tautology clause: ", *c) << "\n";);
   903                      }                    

   931              ++m_lemma_count;
   932:             TRACE("nlsat_sort", display(tout << "mk_clause:\n", *cls) << "\n";);
   933              std::sort(cls->begin(), cls->end(), lit_lt(*this));
   934:             TRACE("nlsat_sort", display(tout << "#" << m_lemma_count << " after sort:\n", *cls) << "\n";);
   935              if (learned && m_log_lemmas) {

  1136          void assign(literal l, justification j) {
  1137:             TRACE("nlsat", 
  1138                    display(tout << "assigning literal: ", l); 

  1153              updt_eq(b, j);
  1154:             TRACE("nlsat_assign", tout << "b" << b << " -> " << m_bvalues[b]  << "\n";);
  1155          }

  1170              if (val != l_undef) {            
  1171:                 TRACE("nlsat_verbose", display(tout << " assigned value " << val << " for ", l) << "\n";);
  1172                  return val;

  1176              if (a == nullptr) {
  1177:                 TRACE("nlsat_verbose", display(tout << " no atom for ", l) << "\n";);
  1178                  return l_undef;

  1181              if (!m_assignment.is_assigned(max)) {
  1182:                 TRACE("nlsat_verbose", display(tout << " maximal variable not assigned ", l) << "\n";);
  1183                  return l_undef;

  1185              val = to_lbool(m_evaluator.eval(a, l.sign()));
  1186:             TRACE("nlsat_verbose", display(tout << " evaluated value " << val << " for ", l) << "\n";);
  1187:             TRACE("value_bug", tout << "value of: "; display(tout, l); tout << " := " << val << "\n"; 
  1188                    tout << "xk: " << m_xk << ", a->max_var(): " << a->max_var() << "\n";

  1198                  if (const_cast<imp*>(this)->value(l) == l_true) {
  1199:                     TRACE("value_bug:", tout << l << " := true\n";);
  1200                      return true;

  1211                  if (value(cls[i]) != l_false) {
  1212:                     TRACE("is_inconsistent", tout << "literal is not false:\n"; display(tout, cls[i]); tout << "\n";); 
  1213                      return false;

  1268              interval_set_ref new_set(m_ism);
  1269:             TRACE("nlsat_inf_set", tout << "updating infeasible set\n"; m_ism.display(tout, xk_set) << "\n"; m_ism.display(tout, s) << "\n";);
  1270              new_set = m_ism.mk_union(s, xk_set);
  1271:             TRACE("nlsat_inf_set", tout << "new infeasible set:\n"; m_ism.display(tout, new_set) << "\n";);
  1272              SASSERT(!m_ism.is_full(new_set));

  1303                  return; // we only update m_var2eq if the new equality has smaller degree
  1304:             TRACE("nlsat_simplify_core", tout << "Saving equality for "; m_display_var(tout, x) << " (x" << x << ") ";
  1305                    tout << "scope-lvl: " << scope_lvl() << "\n"; display(tout, literal(b, false)) << "\n";

  1318              if (!satisfy_learned && m_lazy >= 2 && cls.is_learned()) {
  1319:                 TRACE("nlsat", tout << "skip learned\n";);
  1320                  return true; // ignore lemmas in super lazy mode

  1334                      return true;  // could happen if clause is a tautology
  1335:                 CTRACE("nlsat", max_var(l) != m_xk || value(l) != l_undef, display(tout); 
  1336                         tout << "xk: " << m_xk << ", max_var(l): " << max_var(l) << ", l: "; display(tout, l) << "\n";

  1344                  curr_set = m_evaluator.infeasible_intervals(a, l.sign(), &cls);
  1345:                 TRACE("nlsat_inf_set", tout << "infeasible set for literal: "; display(tout, l); tout << "\n"; m_ism.display(tout, curr_set); tout << "\n";
  1346                        display(tout, cls) << "\n";); 
  1347                  if (m_ism.is_empty(curr_set)) {
  1348:                     TRACE("nlsat_inf_set", tout << "infeasible set is empty, found literal\n";);
  1349                      R_propagate(l, nullptr);

  1353                  if (m_ism.is_full(curr_set)) {
  1354:                     TRACE("nlsat_inf_set", tout << "infeasible set is R, skip literal\n";);
  1355                      R_propagate(~l, nullptr);

  1358                  if (m_ism.subset(curr_set, xk_set)) {
  1359:                     TRACE("nlsat_inf_set", tout << "infeasible set is a subset of current set, found literal\n";);
  1360                      R_propagate(l, xk_set);

  1365                  if (m_ism.is_full(tmp)) {
  1366:                     TRACE("nlsat_inf_set", tout << "infeasible set + current set = R, skip literal\n";
  1367                            display(tout, cls) << "\n";);

  1376              }
  1377:             TRACE("nlsat_inf_set", tout << "num_undef: " << num_undef << "\n";);
  1378              if (num_undef == 0) 

  1392              else {
  1393:                 TRACE("nlsat_lazy", tout << "skipping clause, satisfy_learned: " << satisfy_learned << ", cls.is_learned(): " << cls.is_learned()
  1394                        << ", lazy: " << m_lazy << "\n";);

  1457              m_ism.peek_in_complement(m_infeasible[m_xk], m_is_int[m_xk], w, m_randomize);
  1458:             TRACE("nlsat", 
  1459                    tout << "infeasible intervals: "; m_ism.display(tout, m_infeasible[m_xk]); tout << "\n";
  1460                    tout << "assigning "; m_display_var(tout, m_xk) << "(x" << m_xk << ") -> " << w << "\n";);
  1461:             TRACE("nlsat_root", tout << "value as root object: "; m_am.display_root(tout, w); tout << "\n";);
  1462              if (!m_am.is_rational(w))

  1470              if (m_bk == null_bool_var && m_xk >= num_vars()) {
  1471:                 TRACE("nlsat", tout << "found model\n"; display_assignment(tout););
  1472                  fix_patch();

  1485          lbool search() {
  1486:             TRACE("nlsat", tout << "starting search...\n"; display(tout); tout << "\nvar order:\n"; display_vars(tout););
  1487:             TRACE("nlsat_proof", tout << "ASSERTED\n"; display(tout););
  1488:             TRACE("nlsat_proof_sk", tout << "ASSERTED\n"; display_abst(tout);); 
  1489:             TRACE("nlsat_mathematica", display_mathematica(tout););
  1490:             TRACE("nlsat", display_smt2(tout););
  1491              m_bk = 0;

  1504                  }
  1505:                 TRACE("nlsat_bug", tout << "xk: x" << m_xk << " bk: b" << m_bk << "\n";);
  1506                  if (is_satisfied()) {

  1509                  while (true) {
  1510:                     TRACE("nlsat_verbose", tout << "processing variable "; 
  1511                            if (m_xk != null_var) {

  1589                      if (cls) {
  1590:                         TRACE("nlsat", display(tout << "conflict " << lo << " " << hi, *cls); tout << "\n";);
  1591                      }

  1597          lbool check() {
  1598:             TRACE("nlsat_smt2", display_smt2(tout););
  1599:             TRACE("nlsat_fd", tout << "is_full_dimensional: " << is_full_dimensional() << "\n";);
  1600              init_search();

  1621              lbool r = search_check();
  1622:             CTRACE("nlsat_model", r == l_true, tout << "model before restore order\n"; display_assignment(tout););
  1623              if (reordered) {

  1625              }
  1626:             CTRACE("nlsat_model", r == l_true, tout << "model\n"; display_assignment(tout););
  1627:             CTRACE("nlsat", r == l_false, display(tout););
  1628              SASSERT(r != l_true || check_satisfied(m_clauses));

  1756              bool_var b  = antecedent.var();
  1757:             TRACE("nlsat_resolve", display(tout << "resolving antecedent: ", antecedent) << "\n";);
  1758              if (assigned_value(antecedent) == l_undef) {

  1763                      SASSERT(is_arith_atom(b) && max_var(b) < m_xk); // must be in a previous stage
  1764:                     TRACE("nlsat_resolve", tout << "literal is unassigned, but it is false in arithmetic interpretation, adding it to lemma\n";); 
  1765                      mark(b);

  1771              unsigned b_lvl = m_levels[b];
  1772:             TRACE("nlsat_resolve", tout << "b_lvl: " << b_lvl << ", is_marked(b): " << is_marked(b) << ", m_num_marks: " << m_num_marks << "\n";);
  1773              if (!is_marked(b)) {

  1775                  if (b_lvl == scope_lvl() /* same level */ && max_var(b) == m_xk /* same stage */) {
  1776:                     TRACE("nlsat_resolve", tout << "literal is in the same level and stage, increasing marks\n";);
  1777                      m_num_marks++;

  1779                  else {
  1780:                     TRACE("nlsat_resolve", tout << "previous level or stage, adding literal to lemma\n";
  1781                            tout << "max_var(b): " << max_var(b) << ", m_xk: " << m_xk << ", lvl: " << b_lvl << ", scope_lvl: " << scope_lvl() << "\n";);

  1787          void resolve_clause(bool_var b, unsigned sz, literal const * c) {
  1788:             TRACE("nlsat_proof", tout << "resolving "; if (b != null_bool_var) display_atom(tout, b) << "\n"; display(tout, sz, c); tout << "\n";);
  1789:             TRACE("nlsat_proof_sk", tout << "resolving "; if (b != null_bool_var) tout << "b" << b; tout << "\n"; display_abst(tout, sz, c); tout << "\n";); 
  1790  

  1797          void resolve_clause(bool_var b, clause const & c) {
  1798:             TRACE("nlsat_resolve", tout << "resolving clause for b: " << b << "\n"; display(tout, c) << "\n";);
  1799              resolve_clause(b, c.size(), c.data());

  1803          void resolve_lazy_justification(bool_var b, lazy_justification const & jst) {
  1804:             TRACE("nlsat_resolve", tout << "resolving lazy_justification for b" << b << "\n";);
  1805              unsigned sz = jst.num_lits();

  1808              // if the current interpretation (really) makes the core in jst infeasible.
  1809:             TRACE("nlsat_mathematica", 
  1810                    tout << "assignment lemma\n";

  1822              // lazy clause is a valid clause
  1823:             TRACE("nlsat_mathematica", display_mathematica_lemma(tout, m_lazy_clause.size(), m_lazy_clause.data()););            
  1824:             TRACE("nlsat_proof_sk", tout << "theory lemma\n"; display_abst(tout, m_lazy_clause.size(), m_lazy_clause.data()); tout << "\n";); 
  1825:             TRACE("nlsat_resolve", 
  1826                    tout << "m_xk: " << m_xk << ", "; m_display_var(tout, m_xk) << "\n";

  1852                  clause const& c = jst.clause(i);
  1853:                 TRACE("nlsat", display(tout << "adding clause assumptions ", c) << "\n";);
  1854                  m_lemma_assumptions = m_asm.mk_join(static_cast<_assumption_set>(c.assumptions()), m_lemma_assumptions);

  1901          void remove_literals_from_lvl(scoped_literal_vector & lemma, unsigned lvl) {
  1902:             TRACE("nlsat_resolve", tout << "removing literals from lvl: " << lvl << " and stage " << m_xk << "\n";);
  1903              unsigned sz = lemma.size();

  1956              if (!found_lvl) {
  1957:                 TRACE("nlsat_resolve", tout << "fail to find new lvl, using previous one\n";);
  1958                  new_lvl = scope_lvl() - 1;

  1977              SASSERT(check_marks());
  1978:             TRACE("nlsat_proof", tout << "STARTING RESOLUTION\n";);
  1979:             TRACE("nlsat_proof_sk", tout << "STARTING RESOLUTION\n";);
  1980              m_conflicts++;
  1981:             TRACE("nlsat", tout << "resolve, conflicting clause:\n"; display(tout, *conflict_clause) << "\n";
  1982                    tout << "xk: "; if (m_xk != null_var) m_display_var(tout, m_xk); else tout << "<null>"; tout << "\n";

  2003                          if (is_marked(b)) {
  2004:                             TRACE("nlsat_resolve", tout << "found marked: b" << b << "\n"; display_atom(tout, b) << "\n";);
  2005                              m_num_marks--;

  2017                                  found_decision = true;
  2018:                                 TRACE("nlsat_resolve", tout << "found decision\n";);
  2019                                  m_lemma.push_back(literal(b, m_bvalues[b] == l_true));

  2047                  unsigned max_lvl = max_scope_lvl(m_lemma.size(), m_lemma.data());
  2048:                 TRACE("nlsat_resolve", tout << "conflict does not depend on current decision, backtracking to level: " << max_lvl << "\n";);
  2049                  SASSERT(max_lvl < scope_lvl());

  2052                  top = m_trail.size();
  2053:                 TRACE("nlsat_resolve", tout << "scope_lvl: " << scope_lvl() << " num marks: " << m_num_marks << "\n";);
  2054                  SASSERT(scope_lvl() == max_lvl);

  2056  
  2057:             TRACE("nlsat_proof", tout << "New lemma\n"; display(tout, m_lemma); tout << "\n=========================\n";);
  2058:             TRACE("nlsat_proof_sk", tout << "New lemma\n"; display_abst(tout, m_lemma); tout << "\n=========================\n";);
  2059  
  2060              if (m_lemma.empty()) {
  2061:                 TRACE("nlsat", tout << "empty clause generated\n";);
  2062                  return false; // problem is unsat, empty clause was generated

  2065              reset_marks(); // remove marks from the literals in m_lemmas.
  2066:             TRACE("nlsat", tout << "new lemma:\n"; display(tout, m_lemma.size(), m_lemma.data()); tout << "\n";
  2067                    tout << "found_decision: " << found_decision << "\n";);

  2092                  var new_max_var = max_var(sz, m_lemma.data());
  2093:                 TRACE("nlsat_resolve", tout << "backtracking to stage: " << new_max_var << ", curr: " << m_xk << "\n";);
  2094                  undo_until_stage(new_max_var);

  2096                  new_cls = mk_clause(sz, m_lemma.data(), true, m_lemma_assumptions.get());
  2097:                 TRACE("nlsat", tout << "new_level: " << scope_lvl() << "\nnew_stage: " << new_max_var << "\n"; 
  2098                        if (new_max_var != null_var) m_display_var(tout, new_max_var) << "\n";);

  2112                      unsigned new_lvl = find_new_level_arith_lemma(m_lemma.size(), m_lemma.data());
  2113:                     TRACE("nlsat", tout << "backtracking to new level: " << new_lvl << ", curr: " << m_scope_lvl << "\n";);
  2114                      undo_until_level(new_lvl);

  2117                  if (lemma_is_clause(*conflict_clause)) {
  2118:                     TRACE("nlsat", tout << "found decision literal in conflict clause\n";);
  2119                      VERIFY(process_clause(*conflict_clause, true));

  2126              if (!process_clause(*new_cls, true)) {
  2127:                 TRACE("nlsat", tout << "new clause triggered another conflict, restarting conflict resolution...\n";
  2128                        display(tout, *new_cls) << "\n";

  2133              }
  2134:             TRACE("nlsat_resolve_done", display_assignment(tout););
  2135              return true;

  2189                  if (!is_satisfied(c)) {
  2190:                     TRACE("nlsat", tout << "not satisfied\n"; display(tout, c); tout << "\n";); 
  2191                      return false;

  2197          bool check_satisfied() const {
  2198:             TRACE("nlsat", tout << "bk: b" << m_bk << ", xk: x" << m_xk << "\n"; if (m_xk != null_var) { m_display_var(tout, m_xk); tout << "\n"; });
  2199              unsigned num = m_atoms.size();

  2334              collector.collect(m_learned);
  2335:             TRACE("nlsat_reorder", collector.display(tout, m_display_var););
  2336              var_vector new_order;

  2340              std::sort(new_order.begin(), new_order.end(), reorder_lt(collector));
  2341:             TRACE("nlsat_reorder", 
  2342                    tout << "new order: "; for (unsigned i = 0; i < num; i++) tout << new_order[i] << " "; tout << "\n";);

  2379              SASSERT(can_reorder());
  2380:             TRACE("nlsat_reorder", tout << "solver before variable reorder\n"; display(tout);
  2381                    display_vars(tout);

  2385              SASSERT(num_vars() == sz);
  2386:             TRACE("nlsat_bool_assignment_bug", tout << "before reset watches\n"; display_bool_assignment(tout););
  2387              reset_watches();

  2425              m_pm.rename(sz, p);
  2426:             TRACE("nlsat_bool_assignment_bug", tout << "before reinit cache\n"; display_bool_assignment(tout););
  2427              reinit_cache();

  2430              reattach_arith_clauses(m_learned);
  2431:             TRACE("nlsat_reorder", tout << "solver after variable reorder\n"; display(tout); display_vars(tout););
  2432          }

  2562                  return;
  2563:             TRACE("nlsat_reorder_clauses", tout << "before:\n"; for (unsigned i = 0; i < sz; i++) { display(tout, *(cs[i])); tout << "\n"; });
  2564              m_cs_degrees.reset();

  2570              std::sort(m_cs_p.begin(), m_cs_p.end(), degree_lt(m_cs_degrees));
  2571:             TRACE("nlsat_reorder_clauses", tout << "permutation: "; ::display(tout, m_cs_p.begin(), m_cs_p.end()); tout << "\n";);
  2572              apply_permutation(sz, cs, m_cs_p.data());
  2573:             TRACE("nlsat_reorder_clauses", tout << "after:\n"; for (unsigned i = 0; i < sz; i++) { display(tout, *(cs[i])); tout << "\n"; });
  2574          }

  2667                          q = -q;
  2668:                         TRACE("nlsat", tout << "p: " << p << "\nq: " << q << "\n x" << v << "\n";);
  2669                          m_patch_var.push_back(v);

  2674                              return false;
  2675:                         TRACE("nlsat", display(tout << "simplified\n"););
  2676                          change = true;

  2693                  val = qv / pv;
  2694:                 TRACE("nlsat", 
  2695                        m_display_var(tout << "patch v" << v << " ", v) << "\n";

  2724                          change |= pr != po;
  2725:                         TRACE("nlsat", tout << pr << "\n";);
  2726                          if (m_pm.is_zero(pr)) {

  2942              }
  2943:             TRACE("nlsat_bool_assignment",
  2944                    for (bool_var b = 0; b < sz; b++) {

  3603          }
  3604:         TRACE("nlsat", display(tout););
  3605      }

  3607      void solver::set_bvalues(svector<lbool> const& vs) {
  3608:         TRACE("nlsat", display(tout););
  3609          for (bool_var b = 0; b < vs.size(); ++b) {

  3626  #endif
  3627:         TRACE("nlsat", display(tout););
  3628      }

z3/src/nlsat/tactic/goal2nlsat.cpp:
  100          m_pm.factor(p, fs, m_fparams);
  101:         TRACE("goal2nlsat_bug", tout << "factors:\n" << fs << "\n";); 
  102          SASSERT(fs.distinct_factors() > 0);

  128          p = m_pm.addmul(d1, m_pm.mk_unit(), p1, d2, m_pm.mk_unit(), p2);
  129:         TRACE("goal2nlsat_bug", tout << mk_pp(f, m) << " p: " << p << "\nk: " << k << "\n";);
  130          if (is_const(p)) {

  196                  case OP_FALSE:
  197:                     TRACE("goal2nlsat", tout << "f: " << mk_pp(f, m) << "\n";);
  198                      throw tactic_exception("apply simplify before applying nlsat");

  254      void operator()(goal const & g) {
  255:         TRACE("goal2nlsat", g.display(tout););
  256          if (has_term_ite(g))

z3/src/nlsat/tactic/nlsat_tactic.cpp:
   64                  if (!is_uninterp_const(x2t.get(x))) {
   65:                     TRACE("unsupported", tout << "unsupported atom:\n" << mk_ismt2_pp(x2t.get(x), m) << "\n";);
   66                      return true;

   76                      continue; // arithmetic atom
   77:                 TRACE("unsupported", tout << "unsupported atom:\n" << mk_ismt2_pp(a, m) << "\n";);
   78                  return true; // unsupported

   86                  if (model.is_false(g.form(i))) {
   87:                     TRACE("nlsat", tout << mk_pp(g.form(i), m) << " -> " << model(g.form(i)) << "\n";);
   88                      IF_VERBOSE(0, verbose_stream() << mk_pp(g.form(i), m) << " -> " << model(g.form(i)) << "\n";);

  144  
  145:             TRACE("nlsat", g->display(tout););
  146              expr2var  a2b(m);

  153              m_solver.set_display_var(m_display_var);
  154:             TRACE("nlsat", m_solver.display(tout););
  155              IF_VERBOSE(10000, m_solver.display(verbose_stream()));

z3/src/opt/maxcore.cpp:
   195      void add_soft(expr* e, rational const& w) {
   196:         TRACE("opt", tout << mk_pp(e, m) << " |-> " << w << "\n";);
   197          expr_ref asum(m), fml(m);

   221          m_trail.push_back(e);
   222:         TRACE("opt", tout << "insert: " << mk_pp(e, m) << " : " << w << "\n";
   223                tout << m_asms << " " << "\n"; );

   237          while (m_lower < m_upper) {
   238:             TRACE("opt_verbose",
   239                    s().display(tout << m_asms << "\n") << "\n";

   246              case l_true:
   247:                 CTRACE("opt", m_model->is_false(m_asms),
   248                         tout << *m_model << "assumptions: ";

   346              s().get_model(mdl);
   347:             TRACE("opt", tout << *mdl;);
   348              if (mdl.get()) {

   409                  IF_VERBOSE(100, verbose_stream() << "(opt.maxres core is empty)\n";);
   410:                 TRACE("opt", tout << "empty core\n";);
   411                  cores.reset();

   431  
   432:         TRACE("opt",
   433                tout << "sat: " << is_sat << " num cores: " << cores.size() << "\n";

   454          }
   455:         TRACE("opt", display_vec(tout << "new correction set: ", cs););
   456      }

   492          expr_ref fml(m), tmp(m);
   493:         TRACE("opt", display_vec(tout << "corr_set: ", corr_set););
   494          remove_soft(corr_set, m_asms);

   560          SASSERT(!core.empty());
   561:         TRACE("opt", display_vec(tout << "minimized core: ", core););
   562          IF_VERBOSE(10, display_vec(verbose_stream() << "core: ", core););

   596              m_correction_set_size = cs.size();
   597:             TRACE("opt", tout << "cs " << m_correction_set_size << " " << core.size() << "\n";);
   598              if (m_correction_set_size >= core.size())

   897          if (cs.empty()) return;
   898:         TRACE("opt", display_vec(tout << "correction set: ", cs););
   899          expr_ref fml(m), asum(m);

   993  
   994:         TRACE("opt_verbose", tout << *mdl;);
   995  

   998          if (upper > m_upper) {
   999:             TRACE("opt", tout << "new upper: " << upper << " vs existing upper: " << m_upper << "\n";);
  1000              return;

  1009  
  1010:         TRACE("opt", tout << "updated upper: " << upper << "\n";);
  1011  

  1035          fml = u.mk_lt(nsoft.size(), weights.data(), nsoft.data(), m_upper);
  1036:         TRACE("opt", tout << "block upper bound " << fml << "\n";);;
  1037          add(fml);

  1040      void remove_soft(exprs const& core, expr_ref_vector& asms) {
  1041:         TRACE("opt", tout << "before remove: " << asms << "\n";);
  1042          unsigned j = 0;

  1046          asms.shrink(j);
  1047:         TRACE("opt", tout << "after remove: " << asms << "\n";);
  1048      }

  1090              add(m_asms);
  1091:             TRACE("opt", tout << "Committing feasible solution\ndefs:" << m_defs << "\nasms:" << m_asms << "\n");
  1092          }

  1103          IF_VERBOSE(0, verbose_stream() << "core status (l_false:) " << is_sat << " core size " << core.size() << "\n");
  1104:         CTRACE("opt", is_sat != l_false,
  1105                 for (expr* c : core) tout << "core: " << mk_pp(c, m) << "\n";

z3/src/opt/maxlex.cpp:
  135              if (mdl) {
  136:                 TRACE("opt", tout << *mdl << "\n";);
  137                  for (auto & soft : m_soft) {

z3/src/opt/maxsmt.cpp:
   80          tmp = pb.mk_ge(weights.size(), weights.data(), fmls.data(), k);
   81:         TRACE("opt", tout << "cost: " << cost << "\n" << tmp << "\n";);
   82          s().assert_expr(tmp);

  102          
  103:         TRACE("opt", 
  104                tout << "lower " << lower << " upper: " << m_upper << " assignments: ";

  186          IF_VERBOSE(1, verbose_stream() << "(maxsmt)\n";);
  187:         TRACE("opt_verbose", s().display(tout << "maxsmt\n") << "\n";);
  188          if (optp.maxlex_enable() && is_maxlex(m_soft)) 

  294      void maxsmt::add(expr* f, rational const& w) {
  295:         TRACE("opt", tout << mk_pp(f, m) << " weight: " << w << "\n";);
  296          SASSERT(m.is_bool(f));

z3/src/opt/opt_context.cpp:
   324  
   325:         TRACE("opt", s.display(tout << "initial search result: " << is_sat << "\n");); 
   326          if (is_sat != l_false) {

   334          if (is_sat != l_true) {
   335:             TRACE("opt", tout << m_hard_constraints << " " << asms << "\n";);            
   336              if (!asms.empty()) {

   342          IF_VERBOSE(1, verbose_stream() << "(optimize:sat)\n");
   343:         TRACE("opt", model_smt2_pp(tout, m, *m_model, 0););
   344          m_optsmt.setup(*m_opt_solver.get());

   390          if (mdl && !m_model_fixed.contains(mdl.get())) {
   391:             TRACE("opt", m_fm->display(tout << "fix-model\n");
   392                    tout << *mdl << "\n";

   419          mdl = m_model;
   420:         CTRACE("opt", mdl, tout << *mdl;);
   421          fix_model(mdl);
   422          if (mdl) mdl->set_model_completion(true);
   423:         CTRACE("opt", mdl, tout << *mdl;);
   424      }

   516              m_model = m_box_models[m_box_index];
   517:             CTRACE("opt", m_model, tout << *m_model << "\n";);
   518              ++m_box_index;           

   548              m_model = m_box_models[0];
   549:             CTRACE("opt", m_model, tout << *m_model << "\n";);
   550          }

   601                  else {
   602:                     TRACE("opt", tout << (*mdl)(obj.m_terms[i]) << "\n";);
   603                  }

   613          }
   614:         TRACE("opt", 
   615                tout << (is_ge?">= ":"<= ") << k << "\n";

   637          update_bound(false);
   638:         TRACE("opt", model_smt2_pp(tout, m, *m_model.get(), 0););
   639      }

   891          goal_ref_buffer result;
   892:         TRACE("opt", g->display(tout););
   893          (*m_simplify)(g, result); 

   896          m_model_converter = r->mc();
   897:         CTRACE("opt", r->mc(), r->mc()->display(tout););
   898          fmls.reset();

   985          if (is_min && get_pb_sum(term, terms, weights, offset)) {
   986:             TRACE("opt", tout << "try to convert minimization\n" << mk_pp(term, m) << "\n";);
   987              // minimize 2*x + 3*y 

  1000              }
  1001:             TRACE("opt", 
  1002                    tout << "Convert minimization " << orig_term << "\n";

  1014          if (is_max && get_pb_sum(term, terms, weights, offset)) {
  1015:             TRACE("opt", tout << "try to convert maximization " << mk_pp(term, m) << "\n";);
  1016              // maximize 2*x + 3*y - z 

  1092      void context::from_fmls(expr_ref_vector const& fmls) {
  1093:         TRACE("opt", tout << fmls << "\n";);
  1094          m_hard_constraints.reset();

  1122                  obj.m_adjust_value.set_negate(neg);
  1123:                 TRACE("opt", tout << "maxsat: " << neg << " " << id << " offset: " << offset << "\n";
  1124                        tout << terms << "\n";);

  1195          if (!m_arith.is_numeral(val, r) && !m_bv.is_numeral(val, r, bvsz)) {
  1196:             TRACE("opt", tout << "model does not evaluate objective to a value but instead " << val << "\n";
  1197                    tout << *mdl << "\n";

  1201          if (r != v) {
  1202:             TRACE("opt", tout << "Out of bounds: " << term << " " << val << " != " << v << "\n";);
  1203              return false;

  1205          else {
  1206:             TRACE("opt", tout << "validated: " << term << " = " << val << "\n";);
  1207          }

  1225          else if (m.is_ite(term) || !is_mul_const(term)) {
  1226:             TRACE("opt", tout << "Purifying " << term << "\n";);
  1227              term = purify(fm, term);

  1298          }
  1299:         TRACE("opt", tout << fmls << "\n";);
  1300      }

  1335                  val = (*m_model)(obj.m_term);
  1336:                 TRACE("opt", tout << obj.m_term << " " << val << "\n";);
  1337                  if (is_numeral(val, r)) {
  1338                      inf_eps val = inf_eps(obj.m_adjust_value(r));
  1339:                     TRACE("opt", tout << "adjusted value: " << val << "\n";);
  1340                      if (is_lower) {

  1350                  val = (*m_model)(obj.m_term);
  1351:                 TRACE("opt", tout << obj.m_term << " " << val << "\n";);
  1352                  if (is_numeral(val, r)) {
  1353                      inf_eps val = inf_eps(obj.m_adjust_value(r));
  1354:                     TRACE("opt", tout << "adjusted value: " << val << "\n";);
  1355                      if (is_lower) {

  1366                      val = (*m_model)(obj.m_terms[j]);
  1367:                     TRACE("opt", tout << mk_pp(obj.m_terms[j], m) << " " << val << "\n";);
  1368                      if (!m.is_true(val)) 

  1374                      ms.update_upper(r);
  1375:                     TRACE("opt", tout << "update upper from " << r << " to " << ms.get_upper() << "\n";);           
  1376                  }

  1378                      ms.update_lower(r);
  1379:                     TRACE("opt", tout << "update lower from " << r << " to " << ms.get_lower() << "\n";);           
  1380                  }

  1726          maxsmt& ms = *m_maxsmts.find(id);
  1727:         TRACE("opt", tout << "Validate: " << id << "\n";);
  1728          for (objective const& obj : m_objectives) {

  1741                  rational value0 = ms.get_lower();
  1742:                 TRACE("opt", tout << "value " << value << " " << value0 << "\n";);
  1743                  // TBD is this correct? SASSERT(value == value0);

  1767                  rational value0 = ms.get_lower();
  1768:                 TRACE("opt", tout << "value " << value << " other " << value0 << "\n";);
  1769                  // TBD SASSERT(value0 == value);

z3/src/opt/opt_cores.cpp:
  319                  IF_VERBOSE(100, verbose_stream() << "(opt.maxres :empty-core)\n";);
  320:                 TRACE("opt", tout << "empty core\n";);
  321                  break;

z3/src/opt/opt_lns.cpp:
  221              case l_false:
  222:                 TRACE("opt", tout << "pruned " << mk_bounded_pp(unprocessed(i), m) << "\n";);
  223                  m_hardened.push_back(m.mk_not(unprocessed(i)));

  235                          ++m_num_improves;                        
  236:                         TRACE("opt", tout << "improved " << mk_bounded_pp(unprocessed(j), m) << "\n";);
  237                          m_hardened.push_back(unprocessed(j));

z3/src/opt/opt_pareto.cpp:
  76          IF_VERBOSE(10, verbose_stream() << "dominates: " << fml << "\n";);
  77:         TRACE("opt", model_smt2_pp(tout << fml << "\n", m, *m_model, 0););
  78          m_solver->assert_expr(fml);        

  89          IF_VERBOSE(10, verbose_stream() << "not dominated by: " << fml << "\n";);
  90:         TRACE("opt", tout << fml << "\n";);
  91          m_solver->assert_expr(fml);        

z3/src/opt/opt_preprocess.cpp:
  194      void preprocess::process_mutex(expr_ref_vector& mutex, obj_map<expr, rational>& new_soft, rational& lower) {
  195:         TRACE("opt", 
  196                for (expr* e : mutex) {

z3/src/opt/opt_sls_solver.h:
  175              }
  176:             TRACE("opt", g->display(tout););
  177              tactic_ref simplify = mk_nnf_tactic(m);

  187              }
  188:             TRACE("opt", m_bvsls->display(tout););
  189          }

  214              expr_ref objective = soft2bv(m_soft, m_weights);
  215:             TRACE("opt", tout << objective << "\n";);
  216              opt_result res(m);

z3/src/opt/opt_solver.cpp:
  165      lbool opt_solver::check_sat_core2(unsigned num_assumptions, expr * const * assumptions) {
  166:         TRACE("opt_verbose", {
  167              tout << "context size: " << m_context.size() << "\n";            

  256          has_shared = true;
  257:         TRACE("opt", tout << (has_shared?"has shared":"non-shared") << " " << val << " " << blocker << "\n";
  258                if (m_last_model) tout << *m_last_model << "\n";);

  300          else if (m_context.get_context().update_model(has_shared)) {
  301:             TRACE("opt", tout << "updated\n";);
  302              m_last_model = nullptr;

  313          m_objective_values[i] = val;
  314:         TRACE("opt", { 
  315                  tout << "objective:     " << mk_pp(m_objective_terms.get(i), m) << "\n";

  362              if (mdl) {
  363:                 TRACE("opt", tout << "get " << i << "\n" << *mdl << "\n";);
  364                  m = mdl;

  367          }        
  368:         TRACE("opt", tout << "get last\n";);
  369          m = m_last_model.get();

  406          smt::theory_var v = get_optimizer().add_objective(term);
  407:         TRACE("opt", tout << v << " " << mk_pp(term, m) << "\n";);
  408          m_objective_vars.push_back(v);

  437          smt::theory_var v = m_objective_vars[var];
  438:         TRACE("opt", tout << "v" << var << " " << val << "\n";);
  439  

z3/src/opt/optsmt.cpp:
  135                  }
  136:                 TRACE("opt", tout << "index: " << delta_index << " delta: " << delta_per_step << " : " << bound << "\n";);
  137                  if (bound == last_bound) {

  195      lbool optsmt::geometric_lex(unsigned obj_index, bool is_maximize) {
  196:         TRACE("opt", tout << "index: " << obj_index << " is-max: " << is_maximize << "\n";);
  197          arith_util arith(m);

  217              is_sat = m_s->check_sat(0, nullptr);
  218:             TRACE("opt", tout << "check " << is_sat << "\n";
  219                    tout << "last bound: " << last_bound << "\n";

  227                  inf_eps obj = m_s->saved_objective_value(obj_index);
  228:                 TRACE("opt", tout << "saved objective: " << obj << "\n";);
  229                  update_lower_lex(obj_index, obj, is_maximize);

  266  
  267:         TRACE("opt", tout << is_sat << " " << num_scopes << "\n";);
  268  

  322                  m_s->assert_expr(fml);
  323:                 TRACE("opt", tout << fml << "\n";);
  324                  is_sat = m_s->check_sat(1,vars);

  361      void optsmt::update_lower_lex(unsigned idx, inf_eps const& v, bool is_maximize) {
  362:         TRACE("opt", tout << v << " lower: " << m_lower[idx] << "\n";);
  363          if (v > m_lower[idx]) {

  373              }
  374:             TRACE("opt", tout << "update best model " << *m_model << "\n";);
  375              m_best_model = m_model;

  381      void optsmt::update_lower(unsigned idx, inf_eps const& v) {
  382:         TRACE("opt", tout << "v" << idx << " >= " << v << "\n";);
  383          m_lower_fmls[idx] = m_s->mk_ge(idx, v);

  387      void optsmt::update_upper(unsigned idx, inf_eps const& v) {
  388:         TRACE("opt", tout << "v" << idx << " <= " << v << "\n";);
  389          m_upper[idx] = v;                    

  405          set_max(m_lower, m_s->get_objective_values(), disj);
  406:         TRACE("opt", model_pp(tout << m_lower << "\n", *m_model););
  407          IF_VERBOSE(2, verbose_stream() << "(optsmt.lower " << m_lower << ")\n";);

  500      lbool optsmt::lex(unsigned obj_index, bool is_maximize) {
  501:         TRACE("opt", tout << "optsmt:lex\n";);
  502          m_context.get_base_model(m_best_model);

  545          mdl = m_best_model.get();
  546:         TRACE("opt", tout << *mdl << "\n";);
  547          labels = m_labels;

  552          inf_eps lo = m_lower[i];
  553:         TRACE("opt", tout << "set lower bound of " << mk_pp(m_objs.get(i), m) << " to: " << lo << "\n";
  554                tout << get_lower(i) << ":" << get_upper(i) << "\n";);    

z3/src/opt/pb_sls.cpp:
  349              m_best_penalty = m_penalty;
  350:             TRACE("opt", display(tout););
  351          }

  501  
  502:             TRACE("opt", tout << "flip: " << l << " num false: " << m_hard_false.num_elems() 
  503                    << " penalty: " << m_penalty << " break count: " << break_count << "\n";);

z3/src/opt/sortmax.cpp:
  78                  is_sat = s().check_sat(0, nullptr);
  79:                 TRACE("opt", tout << is_sat << "\n"; s().display(tout); tout << "\n";);
  80                  if (!m.inc()) {

  89                      }
  90:                     TRACE("opt", model_smt2_pp(tout, m, *m_model.get(), 0););
  91                      m_upper = m_lower + rational(out.size() - first);

  98              }
  99:             TRACE("opt", tout << "min cost: " << m_upper << "\n";);
  100              return is_sat;

z3/src/opt/wmax.cpp:
   52          lbool operator()() override {
   53:             TRACE("opt", tout << "weighted maxsat\n";);
   54              scoped_ensure_theory wth(*this);

   69  
   70:             TRACE("opt",
   71                  s().display(tout) << "\n";

   81                  if (is_sat == l_false) {
   82:                     TRACE("opt", tout << "Unsat\n";);
   83                      break;

  109              }
  110:             TRACE("opt", tout << "min cost: " << m_upper << "\n";);
  111              return is_sat;

z3/src/parsers/smt2/smt2parser.cpp:
   358                      while (m_num_open_paren > 0 || !curr_is_lparen()) {
   359:                         TRACE("sync", tout << "sync(): curr: " << curr() << "\n";
   360                                tout << "m_num_open_paren: " << m_num_open_paren << ", line: " << m_scanner.get_line() << ", pos: "

   662              if (!d->has_var_params() && d->get_num_params() != num) {
   663:                 TRACE("smt2parser", tout << "num: " << num << ", d->get_num_params(): " << d->get_num_params() << "\n";);
   664                  throw parser_exception("invalid number of parameters to sort constructor");

   724              if (!d->has_var_params() && d->get_num_params() != num) {
   725:                 TRACE("smt2parser", tout << "num: " << num << ", d->get_num_params(): " << d->get_num_params() << "\n";);
   726                  throw parser_exception("invalid number of parameters to sort constructor");

   838                      next();
   839:                     TRACE("datatype_parser_bug", tout << ct_name << " " << r_name << "\n";);
   840                      ct_decls.push_back(pm().mk_pconstructor_decl(m_sort_id2param_idx.size(), ct_name, r_name, 0, nullptr));

   930              }                
   931:             TRACE("declare_datatypes", tout << "i: " << i << " new_dt_decls.size(): " << sz << "\n";
   932                    for (unsigned j = 0; j < new_dt_decls.size(); ++j) tout << new_dt_decls[j]->get_name() << "\n";);

  1011          void name_expr(expr * n, symbol const & s) {
  1012:             TRACE("name_expr", tout << "naming: " << s << " ->\n" << mk_pp(n, m()) << "\n";);
  1013              if (!is_ground(n) && has_free_vars(n))

  1085                  fr->m_last_symbol = symbol::null;
  1086:                 TRACE("consume_attributes", tout << "id: " << id << ", expr_stack().size(): " << expr_stack().size() << "\n";);
  1087                  if (id == m_named) {

  1176              SASSERT(is_int || curr_is_float());
  1177:             TRACE("parse_numeral", tout << "curr(): " << curr() << ", curr_numeral(): " << curr_numeral() << ", is_int: " << is_int << "\n";);
  1178              expr_stack().push_back(autil().mk_numeral(curr_numeral(), is_int && !m_ctx.numeral_as_real()));

  1184              expr_stack().push_back(butil().mk_numeral(curr_numeral(), m_scanner.get_bv_size()));
  1185:             TRACE("parse_bv_numeral", tout << "new numeral: " << mk_pp(expr_stack().back(), m()) << "\n";);
  1186              next();

  1192              expr_stack().push_back(sutil().str.mk_string(zs));
  1193:             TRACE("smt2parser", tout << "new string: " << mk_pp(expr_stack().back(), m()) << "\n";);
  1194              next();

  1264              unsigned sort_spos = sort_stack().size();
  1265:             TRACE("parse_sorted_vars", tout << "[before] symbol_stack().size(): " << symbol_stack().size() << "\n";);
  1266              check_lparen_next("invalid list of sorted variables, '(' expected");

  1271                  symbol_stack().push_back(curr_id());
  1272:                 TRACE("parse_sorted_vars", tout << "push_back curr_id(): " << curr_id() << "\n";);
  1273                  next();

  1278              next();
  1279:             TRACE("parse_sorted_vars", tout << "[after] symbol_stack().size(): " << symbol_stack().size() << "\n";);
  1280              symbol const * sym_it  = symbol_stack().data() + sym_spos;

  1287                  expr_stack().push_back(v); // prevent v from being deleted
  1288:                 TRACE("parse_sorted_vars", tout << "registering " << *sym_it << " -> " << mk_pp(v, m()) << ", num: " << num << ", i: " << i << "\n";);
  1289                  m_env.insert(*sym_it, local(v, m_num_bindings));

  1305          void push_bang_frame(expr_frame * curr) {
  1306:             TRACE("consume_attributes", tout << "begin bang, expr_stack.size(): " << expr_stack().size() << "\n";);
  1307              next();

  1401              var_subst sub(m(), false);
  1402:             TRACE("parse_expr", tout << "term\n" << expr_ref(t, m()) << "\npatterns\n" << patterns << "\ncases\n" << cases << "\n";);
  1403              check_patterns(patterns, t->get_sort());

  1424              }
  1425:             TRACE("parse_expr", tout << result << "\n";);
  1426              return result;

  1643          bool is_bv_decimal(char const * s) {
  1644:             TRACE("is_bv_num", tout << "is_bv_decimal: " << s << "\n";);
  1645              SASSERT('0' <= *s && *s <= '9');

  1782              SASSERT(curr_id_is_as() || curr_id_is_underscore());
  1783:             TRACE("parse_qualified_name", tout << "parse_qualified_name() curr_id: " << curr_id() << "\n";);
  1784              unsigned param_spos = m_param_stack.size();

  1786              symbol r = parse_qualified_identifier_core(has_as);
  1787:             TRACE("parse_qualified_name", tout << "parse_qualified_name() r: " << r << "\n";);
  1788              expr * t;

  1850              next();
  1851:             TRACE("push_expr_frame", tout << "push_expr_frame(), curr(): " << m_curr << "\n";);
  1852              if (curr_is_identifier()) {
  1853:                 TRACE("push_expr_frame", tout << "push_expr_frame(), curr_id(): " << curr_id() << "\n";);
  1854                  if (curr_id_is_let()) {

  1926                  sort_stack().pop_back();
  1927:             TRACE("pop_app_frame", tout << "new term: " << mk_pp(t_ref, m()) << "\n";);
  1928              expr_stack().push_back(t_ref.get());

  1948                          throw parser_exception("invalid let expression");
  1949:                     TRACE("let_frame", tout << "declaring: " << *sym_it << " " << mk_pp(*expr_it, m()) << "\n";);
  1950                      m_env.insert(*sym_it, local(*expr_it, m_num_bindings));

  1954                  // the resultant expression is on the top of the stack
  1955:                 TRACE("let_frame", tout << "let result expr: " << mk_pp(expr_stack().back(), m()) << "\n";);
  1956                  expr_ref r(m());

  1999              unsigned num_nopats = nopattern_stack().size() - fr->m_nopat_spos;
  2000:             TRACE("parse_quantifier", tout << "weight: " << fr->m_weight << "\n";);
  2001:             TRACE("skid", tout << "fr->m_skid: " << fr->m_skid << "\n";);
  2002:             TRACE("parse_quantifier", tout << "body:\n" << mk_pp(expr_stack().back(), m()) << "\n";);
  2003              if (fr->m_qid == symbol::null)

  2017                                        );
  2018:             TRACE("mk_quantifier", tout << "id: " << new_q->get_id() << "\n" << mk_ismt2_pp(new_q, m()) << "\n";);
  2019:             TRACE("skid", tout << "new_q->skid: " << new_q->get_skid() << "\n";);
  2020              expr_stack().shrink(fr->m_expr_spos);

  2035              process_last_symbol(fr);
  2036:             TRACE("consume_attributes", tout << "pop_attr_expr_frame, expr_stack.size(): " << expr_stack().size() << "\n";);
  2037              // the resultant expression is already on the top of the stack.

  2097              do {
  2098:                 TRACE("parse_expr", tout << "curr(): " << curr() << ", m_num_expr_frames: " << m_num_expr_frames
  2099                        << ", expr_stack().size(): " << expr_stack().size() << "\n";);

  2106                      pe_state st = parse_expr_state();
  2107:                     TRACE("consume_attributes", tout << "parse_expr_state: " << st << ", expr_stack.size(): " << expr_stack().size() << "\n";);
  2108                      switch (st) {

  2506              c = m().mk_const_decl(id, sort_stack().back());
  2507:             TRACE("declare_const", tout << "declaring " << id << " "; pm().display(tout, sort_stack().back()); tout << "\n";);
  2508              SASSERT(c.get() != 0);

  2553              next();
  2554:             TRACE("after_pop", tout << "expr_stack.size: " << expr_stack().size() << "\n"; m_ctx.dump_assertions(tout););
  2555          }

  2578              if (!f || !m().is_bool(f)) {
  2579:                 TRACE("smt2parser", tout << expr_ref(f, m()) << "\n";);
  2580                  throw cmd_exception("invalid assert command, term is not Boolean");

  3205                      return false;
  3206:                 TRACE("parser_error", tout << "after sync: " << curr() << "\n";);
  3207                  SASSERT(m_num_open_paren == 0);

z3/src/parsers/smt2/smt2scanner.cpp:
  105                  m_id = m_string.begin();
  106:                 TRACE("scanner", tout << "new quoted symbol: " << m_id << "\n";);
  107                  return SYMBOL_TOKEN;

  125                  m_id = m_string.begin();
  126:                 TRACE("scanner", tout << "new symbol: " << m_id << "\n";);
  127                  return SYMBOL_TOKEN;

  172              m_number /= q;
  173:         TRACE("scanner", tout << "new number: " << m_number << "\n";);
  174          return is_float ? FLOAT_TOKEN : INT_TOKEN;

z3/src/parsers/util/scanner.cpp:
  266  scanner::token scanner::read_bv_literal() {
  267:     TRACE("scanner", tout << "read_bv_literal\n";);
  268      if (m_bv_token) {

  289                      m_state = m_bv_size == 0 ? ERROR_TOKEN : BV_TOKEN;
  290:                     TRACE("scanner", tout << m_state << ", bv-size: " << m_bv_size << ", INT_TOKEN: " << INT_TOKEN
  291                            << ", BV_TOKEN: " << BV_TOKEN << "\n";);

z3/src/qe/nlarith_util.cpp:
   126              if (!get_polys(contains_x, num_lits, lits, polys, comps, &branch_conds, nullptr)) {
   127:                 TRACE("nlarith", 
   128                        tout << "could not extract polynomials " << mk_pp(x, m()) << "\n";

   139              if (!m_enable_linear && is_linear(polys)) {
   140:                 TRACE("nlarith", tout << "this is a linear problem " << mk_pp(x,m()) << "\n"; display(tout, polys););
   141                  return false;

   154              inf_branch(polys, comps, branch_conds);
   155:             TRACE("nlarith", 
   156                    for (unsigned i = 0; i < num_lits; ++i) {

   231  
   232:             TRACE("nlarith",
   233                    tout << "Non-linear variables: ";

   524                  subst.push_back(t1);
   525:                 TRACE("nlarith_verbose", 
   526                        display(tout << "inf", polys[j]); 

   529              }
   530:             TRACE("nlarith", tout << "inf-branch\n";);
   531              bc.add_branch(mk_and(es.size(), es.data()), m().mk_true(), subst, mk_inf(bc), z(), z(), z());

   547                  // a_i = 0 /\ b_i != 0 /\ phi[e_i/x]
   548:                 TRACE("nlarith", display(tout << "a_i != 0 & b_i != 0 & hi[e_i / x]", p);tout<<"\n";);
   549                  scoped_ptr<expr_replacer> rp = mk_default_expr_replacer(m(), false);

   567                  // a != 0 & phi[-b/(2a)/x]
   568:                 TRACE("nlarith", display(tout << "a != 0 & phi[-b/2a / x]", p);tout<<"\n";);
   569                  app* a2 = mk_mul(num(2), a);

   596  
   597:             TRACE("nlarith", 
   598                    display(tout, p); tout << "\n";

   646                  bc.add_branch(branch, cond, subst, mk_def(cmp, abc_poly(*this, a, b, c), e1), a, b, c);
   647:                 TRACE("nlarith", tout << mk_pp(branch,m()) << "\n";);
   648  
   649:                 TRACE("nlarith", 
   650                        tout << "0 <= " << mk_pp(d,m()) << "\n";

   661                  bc.add_branch(branch, cond, subst, mk_def(cmp, abc_poly(*this, a, b, c), e2), a, b, c);
   662:                 TRACE("nlarith", tout << mk_pp(branch,m()) << "\n";);
   663              }

   677              }
   678:             TRACE("nlarith_verbose", 
   679                    display(tout, p); 

   702                  if (ps[i].size() > 3) {
   703:                     TRACE("nlarith", tout << "not second-degree: ";
   704                        display(tout, ps[i]); tout <<"\n"; );

   798                  }
   799:                 TRACE("nlarith_verbose", 
   800                        tout << mk_pp(lits[i], m()) << " -> ";

   906              default:
   907:                 TRACE("nlarith", tout << "Cannot decompose " << mk_pp(f, m()) << "\n" << mk_pp(e, m()) << "\n";);
   908                  return false;

   953              }
   954:             TRACE("nlarith_verbose", display(tout, r); display(tout <<" * ", other); display(tout << " = ", result); tout <<"\n";);
   955              r.reset();

  1318              }
  1319:             TRACE("nlarith_verbose", 
  1320                    display(tout, p);

  1455                  if (z() != q1[i].get()) {
  1456:                     TRACE("nlarith", display(tout, q1););
  1457                      return false;

z3/src/qe/nlqsat.cpp:
  269                  lbool res = s.m_solver.check(s.m_asms);
  270:                 TRACE("qe", s.display(tout << res << "\n"); );
  271                  switch (res) {

  292              s.m_asms.append(s.m_assumptions);
  293:             TRACE("qe", tout << "model valid: " << s.m_valid_model << " level: " << lvl << " "; 
  294                    s.display_assumptions(tout);

  324              }
  325:             TRACE("qe", s.display(tout);
  326                    tout << "assumptions\n";

  382              }
  383:             TRACE("qe", s.m_solver.display(tout, result.size(), result.data()); tout << "\n";);
  384              // project quantified real variables.

  389                  ex.project(vars[i], result.size(), result.data(), new_result);
  390:                 TRACE("qe", display_project(tout, vars[i], result, new_result););
  391                  result.swap(new_result);

  437              s.m_solver.vars(l, vs);
  438:             TRACE("qe", s.m_solver.display(tout << vs << " ", l) << "\n";);
  439              for (unsigned v : vs) {

  456              s.m_bvar2level.insert(v, level);            
  457:             TRACE("qe", s.m_solver.display(tout, l); tout << ": " << level << "\n";);
  458          }

  460          void project() {
  461:             TRACE("qe", s.display_assumptions(tout););
  462              if (!s.m_valid_model) {

  487              
  488:             TRACE("qe", tout << "backtrack: " << num_scopes << "\n";);
  489              pop(num_scopes); 

  497              expr_ref fml = s.clause2fml(cl);
  498:             TRACE("qe", tout << level() << ": " << fml << "\n";);
  499              max_level clevel = get_level(cl);

  621                  }
  622:                 TRACE("qe", tout << "not NRA: " << mk_pp(n, s.m) << "\n";);
  623                  throw tactic_exception("not NRA");

  740              SASSERT(result.size() == 1);
  741:             TRACE("qe", result[0]->display(tout););
  742              s.g2s(*result[0]);

  753                          nlsat::bool_var b = s.m_a2b.to_var(v);
  754:                         TRACE("qe", tout << mk_pp(v, m) << " |-> b" << b << "\n";);
  755                          s.m_bound_bvars.back().push_back(b);

  759                          nlsat::var w = s.m_t2x.to_var(v);
  760:                         TRACE("qe", tout << mk_pp(v, m) << " |-> x" << w << "\n";);
  761                          s.m_bound_rvars.back().push_back(w);

  764                      else {
  765:                         TRACE("qe", tout << mk_pp(v, m) << " not found\n";);
  766                      }

  772              nlsat::atom_vector const& atoms = s.m_solver.get_atoms();
  773:             TRACE("qe", s.m_solver.display(tout););
  774              for (unsigned i = 0; i < atoms.size(); ++i) {

  778              }
  779:             TRACE("qe", tout << fml << "\n";);
  780              return true;

  862              reset();
  863:             TRACE("qe", tout << fml << "\n";);
  864              if (!hoist(fml)) {

  867              }
  868:             TRACE("qe", tout << "ex: " << fml << "\n";);
  869              lbool is_sat = check_sat();

z3/src/qe/qe_arith_plugin.cpp:
   184              if (!found) {
   185:                 TRACE("qe_verbose", 
   186                        tout 

   207              }
   208:             TRACE("qe_verbose", 
   209                    tout 

   465              simplify(result);
   466:             TRACE("qe_verbose", tout << "mk_lt " << mk_pp(result, m) << "\n";);
   467          }

   585                      mk_big_or(abs_b - numeral(2), x, tmp4, tmp2);                  
   586:                     TRACE("qe",
   587                            tout << "b | s + z: " << mk_pp(b_divides_sz, m) << "\n";

   599              
   600:             TRACE("qe", 
   601                    {

   716              }
   717:             TRACE("qe_verbose", tout << "Atom: " << mk_pp(result, m) << "\n";);
   718              return true;

   774                          eqs.push_back(tmp1);
   775:                         TRACE("qe", tout << "found:  " << mk_pp(tmp1, m) << "\n";);
   776                      }

   779                          leqs.insert(tmp1);
   780:                         TRACE("qe_verbose", tout << "insert: " << mk_pp(tmp1, m) << "\n";);
   781                      }

   829          void mk_big_or(numeral up, app* x, expr* body, expr_ref& result) {
   830:             TRACE("qe", tout << mk_pp(x, m) << " " << mk_pp(body, m) << "\n";);
   831              if (numeral(1) >= up) {

   849              mk_or(ors.size(), ors.data(), result);
   850:             TRACE("qe", 
   851                    tout 

   976              }
   977:             TRACE("qe", 
   978                    tout << "is singular:\n" 

   986              simplify(result);
   987:             TRACE("qe", 
   988                    tout << "singular solved:\n" 

  1021  
  1022:             TRACE("qe", tout << "is linear: " << mk_pp(p, m) << "\n";);
  1023              SASSERT(values.size() == num_vars + 1);

  1061              
  1062:             TRACE("qe", 
  1063                    tout << "is linear:\n" 

  1077              m_ctx.elim_var(index-1, result, p1);
  1078:             TRACE("qe", tout << "Reduced " << index-1 << " : " << result << "\n";);
  1079              return true;

  1143                  else {
  1144:                     TRACE("qe_verbose", tout << "non-linear " << mk_pp(p, m) << "\n";);
  1145                      return false;

  1202              }
  1203:             TRACE("qe_verbose", 
  1204                    ast_manager& m = m_util.get_manager();

  1585                  add_cache(x, fml, v, result, x_t.get_coeff(), x_t.get_term());
  1586:                 TRACE("qe", 
  1587                          tout << vl << " " << mk_pp(x, m) << " infinite case\n";

  1598                  index -= e_size;
  1599:                 TRACE("qe_verbose", bounds.display(tout); );               
  1600              }

  1632              add_cache(x, fml, v, result, x_t.get_coeff(), x_t.get_term());
  1633:             TRACE("qe", 
  1634                    {

  1660              VERIFY(get_cache(contains_x.x(), fml, vl.get_unsigned(), fml));
  1661:             TRACE("qe", tout << mk_pp(contains_x.x(), m) << " " << vl << "\n" << mk_pp(fml, m) << "\n";);
  1662          } 

  1665              if (!update_bounds(x, fml)) {
  1666:                 TRACE("qe", tout << mk_pp(x.x(), m) << " failed to update bounds\n";);
  1667                  return false;

  1764              // x is of the form: x_t.get_coeff()*x' + x_t.get_term()
  1765:             CTRACE("qe", x_t.get_term(), tout << x_t.get_coeff() << " " << mk_pp(x_t.get_term(), m) << "\n";);
  1766              //

  1790                          // a*coeff*x' + term + a*s <= 0
  1791:                         TRACE("qe", tout << x_t.get_coeff() << "* " << mk_pp(x,m) << " + " 
  1792                                << mk_pp(x_t.get_term(), m) << "\n";);

  1797  
  1798:                     TRACE("qe", tout << a << "* " << mk_pp(x,m) << " + " << mk_pp(term, m) << " <= 0\n";);
  1799                      SASSERT(a.is_int());

  1808                      terms.push_back(term);
  1809:                     TRACE("qe", tout << "a: " << a << " term: " << mk_pp(term, m) << "\n";);
  1810                  }

  1839                      // x := coeff * x + s
  1840:                     TRACE("qe", tout << x_t.get_coeff() << "* " << mk_pp(x,m) << " + " 
  1841                            << mk_pp(x_t.get_term(), m) << "\n";);

  1852                  v -= e_size;
  1853:                 TRACE("qe_verbose", bounds.display(tout); );               
  1854              }

  1874                  // a*coeff*x' + term + a*s <= 0
  1875:                 TRACE("qe", tout << x_t.get_coeff() << "* " << mk_pp(x,m) << " + " 
  1876                        << mk_pp(x_t.get_term(), m) << "\n";);

  1906  
  1907:             TRACE("qe", tout << "TBD (for Real): " << a << " " << mk_pp(def, m) << "\n";);
  1908          }

  1959              subst(x, vl, fml, nullptr);
  1960:             TRACE("qe", tout << mk_pp(fml, m) << "\n";);            
  1961              return true;

  1982              subst(x, vl, fml, nullptr);
  1983:             TRACE("qe", tout << mk_pp(fml, m) << "\n";);
  1984              

  2077              m_ctx.add_constraint(false, z_lt_d);
  2078:             TRACE("qe", tout << mk_pp(z_lt_d, m) << "\n";);
  2079  

  2091              m_ctx.add_constraint(false, new_atom);
  2092:             TRACE("qe", tout << mk_pp(new_atom, m) << "\n";);
  2093              

  2095              mk_div_equivs(bounds, z, result);
  2096:             TRACE("qe", tout << mk_pp(result, m) << "\n";);
  2097              

  2175  
  2176:                 TRACE("qe", tout << mk_pp(mod_eq, m) << "\n";);
  2177              }

  2262              m_util.simplify(result);
  2263:             TRACE("qe", 
  2264                    tout << (is_strict?"strict":"non-strict") << "\n";

  2293          {
  2294:             TRACE("qe", tout << mk_pp(t, m) << "\n";);
  2295              SASSERT(!is_eq_ctx || !is_strict_ctx);

  2309                          m_util.mk_eq(a, x, t, eq);
  2310:                         TRACE("qe", tout << "a:" << a << " x: " << mk_pp(x, m) << "t: " << 
  2311                                mk_pp(t, m) << " eq: " << mk_pp(eq, m) << "\n";);

  2342  
  2343:                 TRACE("qe", 
  2344                        tout << (result_is_strict?"strict result":"non-strict result") << "\n";

  2381  
  2382:                 TRACE("qe_verbose", 
  2383                        app* atm = bounds.atoms(is_strict_ctx, is_lower)[index];    

  2456              m_produce_models(produce_models) {
  2457:             TRACE("qe", tout << "produce models: " << produce_models << "\n";);
  2458              m_util.set_enable_linear(true); // (produce_models);

  2487              m_rewriter(tmp, result);
  2488:             TRACE("qe", tout << vl << " " << mk_pp(result.get(), m) << "\n";);
  2489              m_ctx.add_constraint(true, result);

  2504              
  2505:             TRACE("nlarith", tout << mk_pp(fml, m) << "\n";);
  2506              if (!m_util.create_branches(x.x(), lits.size(), lits.data(), *brs)) {
  2507:                 TRACE("nlarith", tout << "no branches for " << mk_pp(x.x(), m) << "\n";);
  2508                  dealloc(brs);

z3/src/qe/qe_array_plugin.cpp:
   54              for (unsigned i = 0; i < eqs.size(); ++i) {
   55:                 TRACE("qe_verbose", 
   56                        tout << mk_pp(eqs[i].get(), m) << "\n";);

  116              
  117:             TRACE("qe_verbose", 
  118                    tout << mk_pp(lhs, m) << 

  174                  
  175:                 TRACE("qe", 
  176                        tout << "fml: " << mk_pp(fml, m) << "\n";

  246                                 
  247:                 TRACE("qe", 
  248                        tout << "Variable: " << mk_pp(A, m) << "\n";

z3/src/qe/qe_bool_plugin.cpp:
   64              model_eval(x.x(), val_x);
   65:             CTRACE("qe", (!m.is_true(val_x) && !m.is_false(val_x)),
   66                     tout << "Boolean is a don't care: " << mk_pp(x.x(), m) << "\n";);

  133              bool n = m_ctx.neg_atoms().contains(x);
  134:             TRACE("quant_elim", tout << mk_pp(x, m) << " " << mk_pp(fml, m) << "\n";);
  135              if (p && n) {

z3/src/qe/qe_datatype_plugin.cpp:
  141                  m_recognizers.push_back(a);
  142:                 TRACE("qe", tout << "add recognizer:" << mk_pp(a, m) << "\n";);
  143                  return true;

  224          void add_atom(app* a, bool is_pos) {
  225:             TRACE("qe", tout << "add atom:" << mk_pp(a, m) << " " << (is_pos?"pos":"neg") << "\n";);
  226              if (is_pos) {

  338                  fml = get_expr(fml.get());  
  339:                 TRACE("qe", tout << "lift:\n" << mk_pp(fml.get(), m) << "\n";);
  340              }

  392              m_map.insert(a, e, nullptr);
  393:             TRACE("qe", tout << "replace: " << mk_pp(a, m) << " ==> \n" << mk_pp(e, m) << "\n";);
  394              return true;

  468              SASSERT(m_datatype_util.is_datatype(s));
  469:             TRACE("qe", tout << mk_pp(x.x(), m) << " " << vl << "\n";);
  470              if (m_datatype_util.is_recursive(s)) {

  480              SASSERT(m_datatype_util.is_datatype(s));
  481:             TRACE("qe", tout << mk_pp(x.x(), m) << " " << vl << "\n";);
  482              if (m_datatype_util.is_recursive(s)) {

  614              }
  615:             TRACE("qe", tout << "could not get number of branches " << mk_pp(x.x(), m) << "\n";);
  616              return false;

  669  
  670:             TRACE("qe", tout << mk_pp(x, m) << " " << vl << " " << mk_pp(fml, m) << " " << (def != 0) << "\n";);
  671              //

  683                  add_def(fresh_x, def);
  684:                 TRACE("qe", tout << "Add recognizer " << mk_pp(is_c, m) << "\n";);
  685                  return;

  689              if (has_selector(contains_x, fml, c)) {
  690:                 TRACE("qe", tout << "Eliminate selector " << mk_ll_pp(c, m) << "\n";);
  691                  subst_constructor(contains_x, c, fml, def); 

  743              }
  744:             TRACE("qe", tout << "reduced " << mk_pp(fml.get(), m) << "\n";);
  745          }

  753              if (sz != 1 && has_recognizer(x.x(), fml, r, c)) {
  754:                 TRACE("qe", tout << mk_pp(x.x(), m) << " has a recognizer\n";);
  755                  num_branches = rational(1);
  756              }        
  757:             TRACE("qe", tout << mk_pp(x.x(), m) << " branches: " << sz << "\n";);
  758              return true; 

  772              if (has_recognizer(x, fml, r, c)) {
  773:                 TRACE("qe", tout << mk_pp(x, m) << " has a recognizer\n";);
  774                  return;

  791              if (has_recognizer(x.x(), fml, r, c)) {
  792:                 TRACE("qe", tout << mk_pp(x.x(), m) << " has a recognizer\n";);
  793              }

z3/src/qe/qe_dl_plugin.cpp:
  211                  if (!m.is_eq(e, e1, e2)) {
  212:                     TRACE("quant_elim", tout << "Cannot handle: " << mk_pp(e, m) << "\n";);
  213                      return false;

  218                  if (contains_x(e2) || x != e1) {
  219:                     TRACE("quant_elim", tout << "Cannot handle: " << mk_pp(e, m) << "\n";);
  220                      return false;

z3/src/qe/qe_mbi.cpp:
   77          quick_for_each_expr(symbols_in_b, marks, b);
   78:         TRACE("qe", 
   79                tout << mk_pp(a, m) << "\n" << mk_pp(b, m) << "\n";

  136          lbool r = m_solver->check_sat(lits);
  137:         TRACE("qe", tout << r << " " << lits << "\n");
  138          switch (r) {

  223          }
  224:         TRACE("qe", tout << "atoms from model: " << lits << "\n";);
  225          solver_ref dual = m_dual_solver->translate(m, m_dual_solver->get_params());

  227          lbool r = dual->check_sat(lits);
  228:         TRACE("qe", dual->display(tout << "dual result " << r << "\n"););
  229          if (l_false == r) {

  265          order_avars(avars);
  266:         TRACE("qe", tout << "vars: " << avars << " from " << lits << "\n";);
  267          return avars;

  333          (void)ok;
  334:         CTRACE("qe", !ok, tout << "projection failure ignored!!!!\n");
  335          fix_non_shared(*mdl, lits);

  345              m_solver->get_unsat_core(lits);
  346:             TRACE("qe", tout << "unsat core: " << lits << "\n";);
  347              // optionally minimize core using superposition.

  369      void uflia_mbi::project(model_ref& mdl, expr_ref_vector& lits) {
  370:         TRACE("qe", 
  371                tout << "project literals: " << lits << "\n" << *mdl << "\n";

  379          for (auto const& d : defs) uflits.push_back(m.mk_eq(d.var, d.term));
  380:         TRACE("qe", tout << "uflits: " << uflits << "\n";);
  381          project_euf(mdl, uflits);

  385          IF_VERBOSE(10, verbose_stream() << "projection : " << lits << "\n");
  386:         TRACE("qe", 
  387                tout << "projection: " << lits << "\n";

  412          }
  413:         TRACE("qe", 
  414                tout << "alits: " << alits << "\n";

  428          lits.append(tg.dcert(*mdl.get(), lits));
  429:         TRACE("qe", tout << "project: " << lits << "\n";);                
  430      }

  481          lits.append(tg.project(*mdl.get()));
  482:         TRACE("qe", tout << "project: " << lits << "\n";);                
  483      }

  498          std::sort(avars.data(), avars.data() + avars.size(), compare_depth);
  499:         TRACE("qe", tout << "avars:" << avars << "\n";);
  500      }

  505          m_fmls.push_back(clause);
  506:         TRACE("qe", tout << "block " << lits << "\n";);
  507          m_solver->assert_expr(clause);

  535                  }
  536:                 TRACE("mbi", tout << "new lits " << lits << "\n";);
  537                  break; // continue

  546                  expr_ref lemma(mk_not(mk_and(lits)));
  547:                 TRACE("mbi", tout << lemma << "\n";);
  548                  blocks[turn].push_back(lemma);

  602          rewrite(b);
  603:         TRACE("interpolator", tout << a << " " << b << "\n");        
  604          solver_ref sA = sf(m, p, false /* no proofs */, true, true, symbol::null);

z3/src/qe/qe_mbp.cpp:
  140              if (!m.is_true(val)) {
  141:                 TRACE("qe", tout << mk_pp(fml, m) << " -> " << val << "\n";);
  142                  fmls[j++] = val;

  186  
  187:         TRACE("mbqi_project_verbose", tout << "MBQI: var: " << mk_pp(var, m) << "\n" << "fml: " << fml << "\n";);
  188          expr_ref_vector terms(m);

  191  
  192:         TRACE("mbqi_project_verbose", tout << "terms:\n" << terms;);
  193  

  196  
  197:             TRACE("mbqi_project_verbose", tout << "term: " << mk_pp(term, m) << " tval: " << tval << " val: " << val << "\n";);
  198  

  201              if (tval == val && !occurs(var, term)) {
  202:                 TRACE("mbqi_project",
  203                      tout << "MBQI: replacing " << mk_pp(var, m) << " with " << mk_pp(term, m) << "\n";);

  210  
  211:         TRACE("mbqi_project",
  212              tout << "MBQI: failed to eliminate " << mk_pp(var, m) << " from " << fml << "\n";);

  332          SASSERT(validate_model(model, fmls));
  333:         TRACE("qe", tout << vars << " " << fmls << "\n";);
  334      }

  339          m_rw(fml);
  340:         TRACE("qe", tout << "After qe_lite:\n" << fml << "\n" << "Vars: " << vars << "\n";);
  341          SASSERT(!m.is_false(fml));

  351      void spacer(app_ref_vector& vars, model& mdl, expr_ref& fml) {
  352:         TRACE("qe", tout << "Before projection:\n" << fml << "\n" << "Vars: " << vars << "\n";);
  353  

  378  
  379:             TRACE("qe", tout << "Array vars: " << array_vars << "\n";);
  380  

  389  
  390:             TRACE("qe",
  391                  tout << "extended model:\n" << mdl;

  396          if (!other_vars.empty()) {
  397:             TRACE("qe", tout << "Other vars: " << other_vars << "\n" << mdl;);
  398  

  405  
  406:             TRACE("qe",
  407                  tout << "Projected other vars:\n" << fml << "\n";

  419              subst_vars(eval, other_vars, fml);
  420:             TRACE("qe", tout << "After substituting remaining other vars:\n" << fml << "\n";);
  421              // an extra round of simplification because subst_vars is not simplifying

z3/src/qe/qe.cpp:
   150              
   151:             TRACE("qe",
   152                    tout << "closed\n" << mk_ismt2_pp(fml_closed, m) << "\n";

   184                          contains_index.push_back(i);
   185:                         TRACE("qe_verbose", tout << "var " << v << " in " << i << "\n";);
   186                      }                

   196                      partition.back().push_back(v);
   197:                     TRACE("qe_verbose", tout << "majority " << v << "\n";);
   198                      continue;

   244                  unsigned r = non_shared_vars[uf.find(idx)];
   245:                 TRACE("qe_verbose", tout << "x: " << x << " r: " << r << "\n";);
   246                  bool found = false;

   259              
   260:             TRACE("qe_verbose", 
   261                    for (unsigned i = 0; i < partition.size(); ++i) {

   329                      eqs.push_back(tmp1);
   330:                     TRACE("qe", tout << "found:  " << mk_ismt2_pp(tmp1, m) << "\n";);
   331                  }

   334                      leqs.insert(tmp1);
   335:                     TRACE("qe_verbose", tout << "insert: " << mk_ismt2_pp(tmp1, m) << "\n";);
   336                  }

   468              }
   469:             TRACE("nnf", 
   470                    tout << mk_ismt2_pp(e, m) << " " << p << "\n";

   518                  m_rewriter.mk_or(tmp1, tmp2, tmp);  
   519:                 TRACE("nnf", 
   520                        tout << mk_ismt2_pp(a, m) << "\n";

   574          bool get_nnf(expr_ref& fml, bool p0) {
   575:             TRACE("nnf", tout << mk_ismt2_pp(fml.get(), m) << "\n";);
   576              bool p = p0;

   857              m_collect_atoms(fml, pos, neg);
   858:             TRACE("qe",
   859                    ast_manager& m = fml.get_manager(); 

   918          // 
   919: #define CHECK_COND(_cond_) if (!(_cond_)) { TRACE("qe", tout << "violated: " << #_cond_ << "\n";); return false; }
   920          bool invariant() const {

   981                      st->m_vars.empty() && !st->has_var()) {
   982:                     TRACE("qe", st->display(tout << "appending leaf\n");); 
   983                      result.push_back(st->fml());

  1011          void reset() {
  1012:             TRACE("qe",tout << "resetting\n";);
  1013              for (auto* ch : m_children) dealloc(ch);

  1039          app*        free_var(unsigned i) const { return m_vars[i]; }
  1040:         void        reset_free_vars() { TRACE("qe", tout << m_vars << "\n";); m_vars.reset(); }
  1041  

  1109              SASSERT(invariant());
  1110:             TRACE("qe", display_node(tout); st->display_node(tout););
  1111              return st;

  1123              SASSERT(invariant());
  1124:             TRACE("qe", display_node(tout); st->display_node(tout););
  1125              return st;

  1247          }
  1248:         TRACE("qe_verbose", tout << "Not relevant: " << mk_ismt2_pp(e, m_s.get_manager()) << "\n";);
  1249          return false;

  1287          ast_manager& m = get_manager();
  1288:         TRACE("qe_verbose", tout << mk_ismt2_pp(e, m) << "\n";);
  1289          for (unsigned i = 0; i < m_plugins.size(); ++i) {

  1294          }
  1295:         TRACE("qe_verbose", tout << "No plugin for " << mk_ismt2_pp(e, m) << "\n";);
  1296          result = p?e:mk_not(m, e);

  1427              m_root.init(f);                       
  1428:             TRACE("qe", 
  1429                    for (unsigned i = 0; i < num_vars; ++i) tout << mk_ismt2_pp(vars[i], m) << "\n";

  1477              
  1478:             TRACE("qe", 
  1479                    tout << "result:" << mk_ismt2_pp(fml, m) << "\n";

  1509              while (true) {
  1510:                 TRACE("qe", model_v2_pp(tout, *model););
  1511                  while (can_propagate_assignment(*model_eval)) {

  1549              expr_ref fml(_fml, m);
  1550:             TRACE("qe", tout << mk_pp(x,m) << " " << mk_pp(def, m) << "\n";);
  1551              m_current->set_var(x, rational(1));

  1572              }
  1573:             TRACE("qe", tout << "Add branch var: " << mk_ismt2_pp(x, m) << " " << mk_ismt2_pp(bv, m) << "\n";);
  1574              m_var2branch.insert(x, bv);

  1592              fml = m.mk_or(m_literals);
  1593:             TRACE("qe", tout << fml << "\n";);
  1594              m_solver.assert_expr(fml);

  1684                  if (!eval(model_eval, b, branch) || branch >= nb) {
  1685:                     TRACE("qe", tout << "evaluation failed: setting branch to 0\n";);
  1686                      branch = rational::zero();

  1768                      }
  1769:                     TRACE("qe", tout << mk_pp(x,m) << " " << mk_pp(val, m) << "\n";);
  1770                      m_current->add_def(x, val);

  1795              }
  1796:             TRACE("qe_verbose", tout << "simp: " << mk_ismt2_pp(result.get(), m) << "\n";);
  1797              m_nnf(result, pos, neg);
  1798:             TRACE("qe", tout << "nnf: " << mk_ismt2_pp(result.get(), m) << "\n";);
  1799          }

  1887          void block_assignment() {                                
  1888:             TRACE("qe_verbose", m_solver.display(tout););             
  1889              add_constraint(true);

  1903              m_current->set_var(x, k);
  1904:             TRACE("qe", tout << mk_pp(x, m) << " := " << k << "\n";);
  1905              if (m_bv.is_bv(x)) {                

  1944              }        
  1945:             TRACE("qe", tout << fml << " free: " << m_current->free_vars() << "\n";);
  1946              m_current->add_child(fml)->reset_free_vars();

  1978                  }
  1979:                 TRACE("qe", tout << "setting variable " << mk_pp(x, m) << " free\n";);
  1980                  m_free_vars.push_back(x);

  1993                  expr_ref fml(m_current->fml(), m);
  1994:                 TRACE("qe", tout << fml << "\n";);
  1995                  conj_enum conjs(m, fml);

  2131              flet<unsigned> fl6(m_fparams.m_relevancy_lvl, 0);
  2132:             TRACE("qe", 
  2133                    for (unsigned i = 0; i < num_vars; ++i) {

  2147              push_context(th.detach());
  2148:             TRACE("qe", 
  2149                    for (unsigned i = 0; i < num_vars; ++i) {

  2220      void expr_quant_elim::operator()(expr* assumption, expr* fml, expr_ref& result) {
  2221:         TRACE("qe", 
  2222                if (assumption) tout << "elim assumption\n" << mk_ismt2_pp(assumption, m) << "\n";

  2231          abstract_expr(bound.size(), bound.data(), result);
  2232:         TRACE("qe", tout << "elim result\n" << mk_ismt2_pp(result, m) << "\n";);
  2233      }

  2379          expr_ref fml(_fml, m);
  2380:         TRACE("qe", tout << mk_pp(fml, m) << "\n";);
  2381          init_qe();  

  2511                  }                
  2512:                 TRACE("qe", 
  2513                        tout << (solved?"solved":"not solved") << "\n";

  2546          void elim_var(unsigned idx, expr* fml, expr* def) override {
  2547:             TRACE("qe", tout << idx << ": " << mk_pp(m_vars->get(idx), m) << " " << mk_pp(fml, m) << " " << m_contains.size() << "\n";);
  2548              *m_fml = fml;

  2557          void add_var(app* x) override {
  2558:             TRACE("qe", tout << "add var: " << mk_pp(x, m) << "\n";);
  2559              m_vars->push_back(x);

  2582              m_vars = &vars;
  2583:             TRACE("qe", tout << "Vars: " << vars << "\n";);
  2584              for (auto* v  : vars) {

  2618              app_ref_vector vars(m);
  2619:             TRACE("qe", tout << "simplifying" << mk_pp(new_body, m) << "\n";);
  2620              result = new_body;
  2621              extract_vars(old_q, result, vars);
  2622:             TRACE("qe", tout << "variables extracted" << mk_pp(result, m) << "\n";);
  2623  

  2634              result = expr_abstract(vars, result);
  2635:             TRACE("qe", tout << "abstracted" << mk_pp(result, m) << "\n";);
  2636              ptr_vector<sort> sorts;

z3/src/qe/qsat.cpp:
   163          eval.set_model_completion(true);
   164:         TRACE("qe_assumptions", model_v2_pp(tout, *mdl););
   165  

   201          }
   202:         TRACE("qe_assumptions", tout << "level: " << level << "\n";
   203                model_v2_pp(tout, *mdl);

   248              if (m_lit2pred.find(a, p)) {
   249:                 TRACE("qe", tout << mk_pp(a, m) << " " << mk_pp(p, m) << "\n";);
   250                  level.merge(m_elevel.find(p));

   254              if (is_uninterp_const(a) && m.is_bool(a)) {
   255:                 TRACE("qe", tout << mk_pp(a, m) << "\n";);
   256                  l = m_elevel.find(a);

   278              if (!is_boolop && m.is_bool(a)) {
   279:                 TRACE("qe", tout << mk_pp(a, m) << "\n";);
   280                  r = fresh_bool("p");

   357          max_level lvl2;
   358:         TRACE("qe", tout << mk_pp(a, m) << " " << lvl << "\n";);
   359          if (m_asm2pred.find(a, b)) 

   385              add_asm(p, a);
   386:             TRACE("qe", tout << mk_pp(a, m) << " |-> " << p << "\n";);
   387          }

   516                  (m.is_false(val_a) && m.is_true(val_b))) {
   517:                 TRACE("qe", 
   518                        tout << model << "\n";

   570              m_solver->get_unsat_core(core);
   571:             TRACE("qe_core", m_solver->display(tout << "core: " << core << "\n") << "\n";);
   572          }

   626                      validate_assumptions(*m_model.get(), asms);
   627:                 TRACE("qe", tout << asms << "\n";);
   628                  solver& s = get_kernel(m_level).s();

   632                      s.get_model(m_model);
   633:                     CTRACE("qe", !m_model, tout << "no model\n");
   634                      if (!m_model)

   638                      SASSERT(validate_model(asms));
   639:                     TRACE("qe", s.display(tout); display(tout << "\n", *m_model.get()); display(tout, asms); );
   640                      if (m_level == 0) 

   672                  case l_undef:
   673:                     TRACE("qe", tout << "check-sat is undef\n");
   674                      return res;

   768              initialize_levels();
   769:             TRACE("qe", tout << fml << "\n";);
   770          }

   800              if (m_model.get() && !m_pred_abs.validate_defs(*m_model.get())) {
   801:                 TRACE("qe", 
   802                        tout << msg << "\n";

   826              expr_ref_vector core1(m), core2(m), dels(m);
   827:             TRACE("qe", tout << core.size() << "\n";);
   828              mus mus(get_kernel(level).s());

   840              }
   841:             TRACE("qe", tout << core1.size() << " " << core2.size() << "\n";);
   842              if (core1.size() > 8) {

   845                  }
   846:                 TRACE("qe", tout << core1.size() << " -> " << core2.size() << "\n";);
   847                  core.reset();

   910              get_core(core, m_level);
   911:             TRACE("qe", display(tout); display(tout << "core\n", core););
   912              SASSERT(m_level >= 2);

   920              m_mbp(force_elim(), m_avars, mdl, core);
   921:             TRACE("qe", tout << "aux vars: " << m_avars << "\n";);
   922              for (app* v : m_avars) m_pred_abs.ensure_expr_level(v, m_level-1);

   935                  // fishy - this can happen.
   936:                 TRACE("qe", tout << "max-level: " << level.max() << " level: " << m_level << "\n");
   937                  return false;

   947              pop(num_scopes); 
   948:             TRACE("qe", tout << "backtrack: " << num_scopes << " new level: " << m_level << "\nproject:\n" << core << "\n|->\n" << fml << "\n";);
   949              if (m_level == 0 && m_mode != qsat_sat) {

  1027                      extract_vars(q, tmp, vars);
  1028:                     TRACE("qe", tout << vars << " " << mk_pp(q, m) << " " << tmp << "\n";);
  1029                      tmp = elim_rec(tmp);

  1033                      
  1034:                     TRACE("qe", tout << "elim-rec " << tmp << "\n";);
  1035                      tmp = elim(vars, tmp);

  1044                      trail.push_back(tmp);
  1045:                     TRACE("qe", tout << tmp << "\n";);
  1046                      visited.insert(e, tmp);

  1063              expr_ref fml(_fml, m);
  1064:             TRACE("qe", tout << vars << ": " << fml << "\n";);
  1065              expr_ref_vector defs(m);

  1081              m_fa.assert_expr(m.mk_not(fml));
  1082:             TRACE("qe", tout << "ex: " << fml << "\n";);
  1083              lbool is_sat = check_sat();

  1104                  if (!mdl.is_true(c)) {
  1105:                     TRACE("qe", tout << "component of core is not true: " << mk_pp(c, m) << "\n";
  1106                            tout << mdl << "\n";);

  1117  #if 0
  1118:             TRACE("qe", tout << "Validate core\n";);
  1119              solver& s = get_kernel(m_level).s();

  1133              lbool is_sat = solver.check();
  1134:             CTRACE("qe", is_sat != l_false, 
  1135                     tout << fmls << "\nare not unsat\n";);

  1141  #if 0
  1142:             TRACE("qe", tout << "Validate model\n";);
  1143              solver& s = get_kernel(m_level).s();

  1155                  if (!m_model->is_true(fmls[i]) && m.inc()) {
  1156:                     TRACE("qe", tout << "Formula does not evaluate to true in model: " << mk_pp(fmls[i], m) << "\n";);
  1157                      return false;

  1172  #if 0
  1173:             TRACE("qe", tout << "Validate projection\n";);
  1174              if (!validate_model(mdl, core.size(), core.c_ptr())) return false;

  1179              if (!vars.empty()) {
  1180:                 TRACE("qe", tout << "Not validating partial projection\n";);
  1181                  return true;

  1183              if (!validate_model(mdl, proj.size(), proj.c_ptr())) {
  1184:                 TRACE("qe", tout << "Projection is false in model\n";);
  1185                  return false;

  1192                  if (cont(proj)) {
  1193:                     TRACE("qe", tout << "Projection contains free variable: " << mk_pp(m_avars.get(i), m) << "\n";);
  1194                      return false;

  1212              if (!check_fmls(fmls)) {
  1213:                 TRACE("qe", tout << "implication check failed, could be due to turning != into >\n";);
  1214              }

  1268              
  1269:             TRACE("qe", tout << fml << "\n";);
  1270  

  1293              m_fa.assert_expr(m.mk_not(fml));
  1294:             TRACE("qe", tout << "ex: " << fml << "\n";);
  1295              lbool is_sat = check_sat();

  1399              SASSERT(m_objective);
  1400:             TRACE("qe", tout << "maximize: " << core << "\n";);
  1401              m_was_sat |= !core.empty();

z3/src/qe/lite/qe_lite.cpp:
   160                          if (fr.second == 0) {
   161:                             CTRACE("der_bug", vidx >= definitions.size(), tout << "vidx: " << vidx << "\n";);
   162                              // Remark: The size of definitions may be smaller than the number of variables occurring in the quantified formula.

   264              ts.push_back(rhs);
   265:             TRACE("qe_lite", tout << mk_pp(eq, m) << "\n";);
   266              return true;

   287              expr* lhs = nullptr, *rhs = nullptr;
   288:             TRACE("qe_lite", tout << mk_pp(e, m) << "\n";);
   289  

   303                      ts.push_back(rhs);
   304:                     TRACE("qe_lite", tout << res << "\n";);
   305                      return true;

   321          void get_elimination_order() {
   322:             TRACE("top_sort",
   323                    tout << "DEFINITIONS: " << std::endl;

   329  
   330:             TRACE("qe_lite",
   331                    tout << "Elimination m_order:" << std::endl;

   346                  unsigned inx = sz - idx - 1;
   347:                 TRACE("qe_lite", tout << idx << " |-> " << r << "\n";);
   348:                 CTRACE("top_sort", m_subst_map.get(inx) != nullptr,
   349                         tout << "inx is " << inx << "\n"

   401              expr_ref new_e = m_subst(t, m_subst_map.size(), m_subst_map.data());
   402:             TRACE("qe_lite", tout << new_e << "\n";);
   403  

   451              else {
   452:                 TRACE("der_bug", tout << "Did not find any diseq\n" << mk_pp(q, m) << "\n";);
   453                  r = q;

   548          void flatten_definitions(expr_ref_vector& conjs) {
   549:             TRACE("qe_lite",
   550                    expr_ref tmp(m);

   584              }
   585:             TRACE("qe_lite",
   586                    expr_ref tmp(m);

   633                      if (m.is_not(conjs[i].get(), ne) && m.is_eq(ne, l, r)) {
   634:                         TRACE("qe_lite", tout << mk_pp(conjs[i].get(), m) << " " << is_variable(l) << " " << is_variable(r) << "\n";);
   635                          if (is_variable(l) && ::is_var(l) && is_unconstrained(::to_var(l), r, i, conjs)) {

   710          void operator()(quantifier * q, expr_ref & r, proof_ref & pr) {
   711:             TRACE("qe_lite", tout << mk_pp(q, m) << "\n";);
   712              pr = nullptr;

   808                  expr_ref tmp(m);
   809:                 TRACE("qe_lite",
   810                        tout << mk_pp(e1, m) << " = " << mk_pp(e2, m) << "\n";);

  1099              }
  1100:             TRACE("qe_lite", tout << mk_pp(t, m) << " " << (result?"true":"false") << "\n";);
  1101  

  1171              for (unsigned i = 0; i < num_vars; i++) {
  1172:                 TRACE("qe_lite", tout << "xs[" << i << "]: " << xs[i] << "\n";);
  1173                  cnstr->m_xs[i] = xs[i];

  1363                  if (subsumes(c, *c2)) {
  1364:                     TRACE("qe_lite", display(tout, c); tout << "\nsubsumed:\n"; display(tout, *c2); tout << "\n";);
  1365                      c2->m_dead = true;

  1439                  if (is_occ(f)) {
  1440:                     TRACE("qe_lite", tout << "OCC: " << mk_ismt2_pp(f, m) << "\n";);
  1441                      continue;
  1442                  }
  1443:                 TRACE("qe_lite", tout << "not OCC:\n" << mk_ismt2_pp(f, m) << "\n";);
  1444                  quick_for_each_expr(proc, visited, f);

  1571              SASSERT(m_var2pos.size()   == m_is_int.size());
  1572:             TRACE("qe_lite", tout << mk_pp(t,m) << " |-> " << x << " forbidden: " << forbidden << "\n";);
  1573              return x;

  1593              SASSERT(m_var2expr.get(x) == t);
  1594:             TRACE("qe_lite", tout << mk_ismt2_pp(t, m) << " --> " << x << "\n";);
  1595              return x;

  1613          void add_constraint(expr * f, expr_dependency * dep) {
  1614:             TRACE("qe_lite", tout << mk_pp(f, m) << "\n";);
  1615              SASSERT(!m.is_or(f) || m_fm_occ);

  1693  
  1694:             TRACE("qe_lite", tout << "before mk_constraint: "; for (unsigned i = 0; i < xs.size(); i++) tout << " " << xs[i]; tout << "\n";);
  1695  

  1704  
  1705:             TRACE("qe_lite", tout << "add_constraint: "; display(tout, *new_c); tout << "\n";);
  1706              VERIFY(register_constraint(new_c));

  1717                  m_inconsistent = true;
  1718:                 TRACE("qe_lite", tout << "is false "; display(tout, *c); tout << "\n";);
  1719                  return false;

  1740              else {
  1741:                 TRACE("qe_lite", tout << "all variables are forbidden "; display(tout, *c); tout << "\n";);
  1742                  m_new_fmls.push_back(to_expr(*c));

  1794              std::stable_sort(x_cost_vector.begin(), x_cost_vector.end(), x_cost_lt(m_is_int));
  1795:             TRACE("qe_lite",
  1796                    for (auto const& kv : x_cost_vector) {

  1970                  // literal is true
  1971:                 TRACE("qe_lite", tout << "resolution " << x << " consequent literal is always true: \n";
  1972                        display(tout, l);

  2014              if (tautology) {
  2015:                 TRACE("qe_lite", tout << "resolution " << x << " tautology: \n";
  2016                        display(tout, l);

  2024              if (new_lits.empty() && new_xs.empty() && (new_c.is_neg() || (new_strict && new_c.is_zero()))) {
  2025:                 TRACE("qe_lite", tout << "resolution " << x << " inconsistent: \n";
  2026                        display(tout, l);

  2042  
  2043:             TRACE("qe_lite", tout << "resolution " << x << "\n";
  2044                    display(tout, l);

  2065                  mark_constraints_dead(x);
  2066:                 TRACE("qe_lite", tout << "variable was eliminated (trivial case)\n";);
  2067                  return true;

  2083  
  2084:             TRACE("qe_lite", tout << "eliminating " << mk_ismt2_pp(m_var2expr.get(x), m) << "\nlowers:\n";
  2085                    display_constraints(tout, l); tout << "uppers:\n"; display_constraints(tout, u););

  2093                      if (m_inconsistent || num_new_cnstrs > limit) {
  2094:                         TRACE("qe_lite", tout << "too many new constraints: " << num_new_cnstrs << "\n";);
  2095                          del_constraints(new_constraints.size(), new_constraints.data());

  2118              }
  2119:             TRACE("qe_lite", tout << "variables was eliminated old: " << num_old_cnstrs << " new_constraints: " << sz << "\n";);
  2120              return true;

  2128                          expr * new_f = to_expr(*c);
  2129:                         TRACE("qe_lite", tout << "asserting...\n" << mk_ismt2_pp(new_f, m) << "\nnew_dep: " << c->m_dep << "\n";);
  2130                          m_new_fmls.push_back(new_f);

  2160              else {
  2161:                 TRACE("qe_lite", display(tout););
  2162  

  2369          }
  2370:         TRACE("qe_lite", tout << fmls << "\n";);
  2371          is_variable_test is_var(index_set, index_of_bound);

  2378          if (m_use_array_der) m_array_der(fmls);
  2379:         TRACE("qe_lite", for (unsigned i = 0; i < fmls.size(); ++i) tout << mk_pp(fmls[i].get(), m) << "\n";);
  2380      }

  2449              else {
  2450:                 TRACE("qe", tout << mk_pp(a, m) << " != " << mk_pp(b, m) << "\n";);
  2451              }

  2502              if (f != new_f) {
  2503:                 TRACE("qe", tout << mk_pp(f, m) << "\n" << new_f << "\n" << new_pr << "\n";);
  2504                  g->update(i, new_f, new_pr, g->dep(i));

z3/src/qe/mbp/mbp_arith.cpp:
   69              eval(lit, val);
   70:             CTRACE("qe", !m.is_true(val), tout << mk_pp(lit, m) << " := " << val << "\n";);
   71              if (m.is_false(val))

   77  
   78:             TRACE("opt", tout << mk_pp(lit, m) << " " << a.is_lt(lit) << " " << a.is_gt(lit) << "\n";);
   79              bool is_not = m.is_not(lit, lit);

  120                      val = eval(arg);
  121:                     TRACE("qe", tout << mk_pp(arg, m) << " " << val << "\n";);
  122                      if (!a.is_numeral(val, r)) return false;

  143                      expr_ref val = eval(arg1);
  144:                     TRACE("qe", tout << mk_pp(arg1, m) << " " << val << "\n";);
  145                      if (!a.is_numeral(val, r)) return false;

  173                  }
  174:                 TRACE("qe", tout << "Skipping " << mk_pp(lit, m) << "\n";);
  175                  return false;

  183                  }
  184:                 TRACE("qe", tout << "Skipping " << mk_pp(lit, m) << "\n";);
  185                  return false;

  187              else {
  188:                 TRACE("qe", tout << "Skipping " << mk_pp(lit, m) << "\n";);
  189                  return false;

  235                  val = eval(t1);
  236:                 TRACE("qe", tout << mk_pp(t1, m) << " := " << val << "\n";);
  237                  if (m.is_true(val)) {

  327              model_evaluator eval(model);
  328:             TRACE("qe", tout << model;);
  329              eval.set_model_completion(true);

  336              unsigned j = 0;
  337:             TRACE("qe", tout << "vars: " << vars << "\n";
  338              for (expr* f : fmls) tout << mk_pp(f, m) << " := " << model(f) << "\n";);

  341                  if (!linearize(mbo, eval, fml, fmls, tids)) {
  342:                     TRACE("qe", tout << "could not linearize: " << mk_pp(fml, m) << "\n";);
  343                      fmls[j++] = fml;

  349              fmls.shrink(j);
  350:             TRACE("qe", tout << "formulas\n" << fmls << "\n";
  351              for (auto const& [e, id] : tids)

  373                      }
  374:                     TRACE("qe", tout << mk_pp(v, m) << " " << val << "\n";);
  375                      tids.insert(v, mbo.add_var(r, a.is_int(v)));

  418  
  419:             TRACE("qe", tout << "remaining vars: " << vars << "\n";
  420              for (unsigned v : real_vars) tout << "v" << v << " " << mk_pp(index2expr[v], m) << "\n";

  434              rows2fmls(def_vars, rows, index2expr, fmls);
  435:             TRACE("qe", mbo.display(tout << "mbo result\n");
  436              for (auto const& d : defs) tout << "def: " << d << "\n";

  443  
  444:             TRACE("qe",
  445                  for (auto const& [v, t] : result)

  617                  else {
  618:                     TRACE("qe", tout << "omitting model update for non-uninterpreted constant " << mk_pp(e, m) << "\n";);
  619                  }

  648                      valid = false;
  649:                     TRACE("qe", tout << mk_pp(fml, m) << " := " << val << "\n";);
  650                  }

  664                      if (!a.is_numeral(val, r)) {
  665:                         TRACE("qe", tout << eval.get_model() << "\n";);
  666                          IF_VERBOSE(1, verbose_stream() << "mbp failed on " << mk_pp(v, m) << " := " << val << "\n");

  671                  }
  672:                 CTRACE("qe", kv.m_value.is_zero(), tout << mk_pp(v, m) << " has coefficeint 0\n";);
  673                  if (!kv.m_value.is_zero()) {

z3/src/qe/mbp/mbp_arrays.cpp:
   542              if (store != m_v) {
   543:                 TRACE("qe", tout << "not a store " << mk_pp(eq, m) << " " << lhs_has_v << " " << rhs_has_v << " " << mk_pp(m_v, m) << "\n";);
   544                  return UINT_MAX;

  1024                  if (!m_ari_u.is_real(srt) && !m_ari_u.is_int(srt) && !m_bv_u.is_bv_sort(srt)) {
  1025:                     TRACE("qe", tout << "non-numeric index sort for Ackerman" << mk_pp(srt, m) << "\n";);
  1026                      is_numeric = false;

  1376  
  1377:             TRACE("qe",
  1378                    tout << "indices\n";

  1390  
  1391:             TRACE("qe", tout << lits << "\n";);
  1392  

  1402  
  1403:             TRACE("qe", tout << "done: " << lits << "\n";);
  1404  

z3/src/qe/mbp/mbp_datatypes.cpp:
   45              SASSERT(is_app(val));
   46:             TRACE("qe", tout << mk_pp(var, m) << " := " << val << "\n";);
   47              m_val = to_app(val);

   63              catch (const cant_project &) {
   64:                 TRACE("qe", tout << "can't project:" << mk_pp(var, m) << "\n";);
   65                  return false;

   84              val = m.mk_app(f, args.size(), args.data());
   85:             TRACE("qe", tout << mk_pp(m_var->x(), m) << " |-> " << val << "\n";);
   86              reduce(val, lits);

  112              sub.insert(m_var->x(), val);
  113:             TRACE("qe", tout << mk_pp(m_var->x(), m) << " = " << mk_pp(val, m) << "\n";
  114                    tout << lits << "\n";);

  213                  }
  214:                 CTRACE("qe", reduced, tout << vars << "\n" << lits << "\n";);
  215              }

  276                  }
  277:                 TRACE("qe", tout << "contains: " << mk_pp(f, m) << " " << has_var.is_marked(f) << "\n";);
  278                  visited.mark(f);
  279              }
  280:             TRACE("qe", tout << "contains: " << mk_pp(e, m) << " " << has_var.is_marked(e) << "\n";);
  281              return has_var.is_marked(e);

z3/src/qe/mbp/mbp_plugin.cpp:
   65              val = model(e1);
   66:             TRACE("qe", tout << mk_pp(e1, m) << " |-> " << val << "\n";);
   67              if (val2expr.find(val, e2)) {

  195          eval.set_expand_array_equalities(true);
  196:         TRACE("qe", tout << fmls << "\n";);
  197:         DEBUG_CODE(for (expr* fml : fmls) { CTRACE("qe", m.is_false(eval(fml)), tout << mk_pp(fml, m) << " is false\n" << model;); SASSERT(!m.is_false(eval(fml))); });
  198  

  207          }
  208:         TRACE("qe", tout << fmls << "\n";);
  209      }

  211      void project_plugin::extract_bools(model_evaluator& eval, expr_ref_vector& fmls, unsigned idx, expr* fml, bool is_true) {
  212:         TRACE("qe", tout << "extract bools: " << mk_pp(fml, m) << "\n";);
  213          if (!is_app(fml))

z3/src/qe/mbp/mbp_solve_plugin.cpp:
  102                      t = mk_term(is_int, a_val, sign, done);
  103:                     TRACE("qe", tout << mk_pp(e, m) << " := " << t << "\n";);
  104                      return true;

z3/src/qe/mbp/mbp_term_graph.cpp:
   221          const app *a = ::to_app(e);
   222:         TRACE("qe_verbose", tout << a->get_family_id() << " " << m_solved.contains(a->get_decl()) << " " << m_decls.contains(a->get_decl()) << "\n";);
   223          return

   592          expr* mk_pure(term const& t) {
   593:             TRACE("qe", t.display(tout););
   594              expr* e = nullptr;

   611                  }
   612:                 TRACE("qe_verbose", tout << *ch << " -> " << mk_pp(e, m) << "\n";);
   613              }

   692              }
   693:             TRACE("qe", tout << "literals: " << res << "\n";);
   694          }

   704                      else 
   705:                         TRACE("qe", tout << "skipping " << mk_pp(lit, m) << "\n";);
   706                  }

   714                      else 
   715:                         TRACE("qe", tout << "skipping " << mk_pp(lit, m) << "\n";);
   716                  }

   719                  else 
   720:                     TRACE("qe", tout << "skipping " << mk_pp(lit, m) << "\n";);
   721              }
   722              remove_duplicates(res);
   723:             TRACE("qe", tout << "literals: " << res << "\n";);            
   724          }

   797                          }
   798:                         TRACE("qe", tout << "function: " << d->get_name() << "\n";);
   799                          res.push_back(m.mk_distinct(args.size(), args.data()));

   807              args_are_distinct(res);
   808:             TRACE("qe", tout << res << "\n";);
   809          }

   861              }
   862:             TRACE("qe", tout << "literals: " << res << "\n";);
   863          }

   927              }
   928:             TRACE("qe", tout << "after distinct: " << res << "\n";);
   929          }

  1088                  add_term2app(*t, pure);
  1089:                 TRACE("qe_verbose", tout << "purified " << *t << " " << mk_pp(pure, m) << "\n";);
  1090                  expr* rep = nullptr;                // ensure that the root has a representative

  1112              m_tg.reset_marks();
  1113:             TRACE("qe", display(tout << "after purify\n"););
  1114          }

  1179          }
  1180:         TRACE("qe", 
  1181                for (auto & es : equivs) {

  1200      expr_ref_vector term_graph::dcert(model& mdl, expr_ref_vector const& lits) {
  1201:         TRACE("qe", tout << "dcert " << lits << "\n";);
  1202          struct pair_t {

  1297          }
  1298:         TRACE("qe", tout << result << "\n";);
  1299          return result;

z3/src/sat/sat_aig_cuts.cpp:
   35          unsigned_vector node_ids = filter_valid_nodes();
   36:         TRACE("cut_simplifier", display(tout););
   37          augment(node_ids);
   38:         TRACE("cut_simplifier", display(tout););
   39          ++m_num_cut_calls;

  330              m_literals.shrink(m_literals.size() - n.size());
  331:             TRACE("cut_simplifier", tout << "duplicate\n";);
  332          }

  336      void aig_cuts::add_node(bool_var v, uint64_t lut, unsigned sz, bool_var const* args) {
  337:         TRACE("cut_simplifier", tout << v << " == " << cut::table2string(sz, lut) << " " << bool_var_vector(sz, args) << "\n";);
  338          reserve(v);

  348      void aig_cuts::add_node(literal head, bool_op op, unsigned sz, literal const* args) {
  349:         TRACE("cut_simplifier", tout << head << " == " << op << " " << literal_vector(sz, args) << "\n";);
  350          unsigned v = head.var();

  409          m_roots.reset();
  410:         TRACE("cut_simplifier", display(tout););
  411      }

  713                  m_clause.push_back(parity ? r : ~r);
  714:                 TRACE("cut_simplifier", tout << "validate: " << m_clause << "\n";);
  715                  on_clause(m_clause);

  728                  m_clause.push_back(0 == (n.lut() & (1ull << i)) ? ~r : r);
  729:                 TRACE("cut_simplifier", tout << n.lut() << " " <<  m_clause << "\n";);
  730                  on_clause(m_clause);

z3/src/sat/sat_anf_simplifier.cpp:
   48          clauses2anf(solver);
   49:         TRACE("anf_simplifier", solver.display(tout); s.display(tout););
   50          solver.simplify();
   51:         TRACE("anf_simplifier", solver.display(tout););
   52          anf2clauses(solver);

   86                  ++m_stats.m_num_units;
   87:                 TRACE("anf_simplifier", tout << "unit " << p << " : " << lit << "\n";);
   88              }

   96                  ++m_stats.m_num_eqs;
   97:                 TRACE("anf_simplifier", tout << "equivalence " << p << " : " << x << " == " << y << "\n";);
   98              }

  249  
  250:         TRACE("anf_simplifier", 
  251                tout << "kept:\n";

  391          ps.add(p);
  392:         TRACE("anf_simplifier", tout << "bin: " << b.first << " " << b.second << " : " << p << "\n";);
  393      }

  401          ps.add(p);
  402:         TRACE("anf_simplifier", tout << "clause: " << c << " : " << p << "\n";);
  403      }

  409          ps.add(p);
  410:         TRACE("anf_simplifier", tout << "xor: " << x << " : " << p << "\n";);
  411      }

  418          ps.add(p);
  419:         TRACE("anf_simplifier", tout << "aig: " << head << " == " << ands << " poly : " << p << "\n";);
  420      }

  426          ps.add(p);
  427:         TRACE("anf_simplifier", tout << "ite: " << head << " == " << c << "?" << th << ":" << el << " poly : " << p << "\n";);
  428      }

z3/src/sat/sat_asymm_branch.cpp:
  170          CASSERT("asymm_branch", s.check_invariant());
  171:         TRACE("asymm_branch_detail", s.display(tout););
  172          report rpt(*this);

  345          SASSERT(!s.inconsistent());
  346:         TRACE("asymm_branch_detail", tout << "assigning: " << l << "\n";);
  347          s.assign_scoped(l);

  405          case 1:
  406:             TRACE("asymm_branch", tout << "produced unit clause: " << c[0] << "\n";);
  407              s.assign_unit(c[0]);

  435      bool asymm_branch::process(clause & c) {
  436:         TRACE("asymm_branch_detail", tout << "processing: " << c << "\n";);
  437          SASSERT(s.scope_lvl() == 0);

z3/src/sat/sat_bcd.cpp:
   46              IF_VERBOSE(1, verbose_stream() << "Decomposed set " << f.m_L.size() << " rest: " << f.m_R.size() << "\n";);
   47:             TRACE("sat",
   48                    tout << "Decomposed set " << f.m_L.size() << "\n";

   92          }
   93:         TRACE("sat", for (clause* cls : m_clauses) if (cls) tout << *cls << "\n";);
   94      }

  130          m_R.append(tmpR);
  131:         TRACE("bcd", tout << lit << " " << "pos: " << tmpL.size() << " " << "neg: " << tmpR.size() << "\n";);
  132      }

  241      literal bcd::find_blocked(use_list& ul, clause const& cls) {
  242:         TRACE("bcd", tout << cls << "\n";);
  243  

  249              if (is_blocked(ul, lit)) {
  250:                 TRACE("bcd", tout << "is blocked " << lit << " : " << cls << "\n";);
  251                  result = lit;

  344          IF_VERBOSE(0, verbose_stream() << "num merge: " << num_merge << "\n");
  345:         TRACE("sat", uf.display(tout););
  346      }

z3/src/sat/sat_binspr.cpp:
  150          }
  151:         TRACE("sat", s->display(tout););
  152          algorithm2();

  169              }
  170:             TRACE("sat", tout << "added " << (s->init_trail_size() - m_solver.init_trail_size()) << " units\n";);
  171          }

  195              literal p = to_literal(l_idx);
  196:             TRACE("sat", tout << "p " << p << " " << s->value(p) << "\n";);
  197              if (is_used(p) && s->value(p) == l_undef) {

  205                      s->propagate(false);
  206:                     TRACE("sat", s->display(tout << "unit\n"););
  207                      IF_VERBOSE(0, verbose_stream() << "unit " << (~p) << "\n");

  211                      literal u = ~s->m_trail[i];
  212:                     TRACE("sat", tout << "p " << p << " u " << u << "\n";);
  213                      for (clause* cp : m_use_list[u.index()]) {

  246                                  s->propagate(false);
  247:                                 TRACE("sat", s->display(tout););
  248                              }

  271          }
  272:         TRACE("sat", tout << p << " " << q << " " << u << " " << v << " " << g_is_sat() << "\n";);
  273          return g_is_sat();

  304              if (!inconsistent) {            
  305:                 TRACE("sat", tout << "not implied: " << p << " " << lit << "\n";);
  306                  m_state = 0;

  344          IF_VERBOSE(2, verbose_stream() << "SPR: " << learned << " " << ~lit1 << " " << ~lit2 << "\n");
  345:         TRACE("sat", tout << "SPR: " << learned << " " << ~lit1 << " " << ~lit2 << "\n";);
  346          s->mk_clause(~lit1, ~lit2, learned ? sat::status::redundant() : sat::status::asserted());

  425          m_state &= mask;
  426:         TRACE("sat", 
  427                {

z3/src/sat/sat_clause_use_list.h:
  34          clause_use_list() {
  35:             STRACE("clause_use_list_bug", tout << "[cul_created] " << this << "\n";);
  36              m_size = 0; 

  54          void insert(clause & c) { 
  55:             STRACE("clause_use_list_bug", tout << "[cul_insert] " << this << " " << &c << "\n";);
  56              SASSERT(!m_clauses.contains(&c)); 

  63          void erase_not_removed(clause & c) { 
  64:             STRACE("clause_use_list_bug", tout << "[cul_erase_not_removed] " << this << " " << &c << "\n";);
  65              SASSERT(m_clauses.contains(&c)); 

  72          void erase(clause & c) { 
  73:             STRACE("clause_use_list_bug", tout << "[cul_erase] " << this << " " << &c << "\n";);
  74              SASSERT(m_clauses.contains(&c)); 

z3/src/sat/sat_clause.cpp:
  180          clause * cls = new (mem) clause(m_id_gen.mk(), num_lits, lits, learned);
  181:         TRACE("sat_clause", tout << "alloc: " << cls->id() << " " << *cls << " " << (learned?"l":"a") << "\n";);
  182          SASSERT(!learned || cls->is_learned());

  198      void clause_allocator::del_clause(clause * cls) {
  199:         TRACE("sat_clause", tout << "delete: " << cls->id() << " " << *cls << "\n";);
  200          m_id_gen.recycle(cls->id());

z3/src/sat/sat_cleaner.cpp:
   47              }
   48:             TRACE("cleanup_bug", tout << "processing wlist of " << to_literal(l_idx) << "\n";);
   49              watch_list & wlist = *it;

   55                  case watched::BINARY:
   56:                     TRACE("cleanup_bug", 
   57                            tout << ~to_literal(l_idx) << " " << it2->get_literal() << "\n";

   64                      }
   65:                     TRACE("cleanup_bug", tout << "keeping: " << ~to_literal(l_idx) << " " << it2->get_literal() << "\n";);
   66                      break;

   88              clause & c = *(*it);
   89:             TRACE("sat_cleaner_bug", tout << "cleaning: " << c << "\n";
   90                    for (unsigned i = 0; i < c.size(); i++) tout << c[i] << ": " << s.value(c[i]) << "\n";);
   91:             CTRACE("sat_cleaner_frozen", c.frozen(), tout << c << "\n";);
   92              unsigned sz = c.size();

  110          end_loop:
  111:             CTRACE("sat_cleaner_frozen", c.frozen(),
  112                     tout << "sat: " << (i < sz) << ", new_size: " << j << "\n";

  119                  unsigned new_sz = j;
  120:                 CTRACE("sat_cleaner_bug", new_sz < 2, tout << "new_sz: " << new_sz << "\n";
  121                         if (c.size() > 0) tout << "unit: " << c[0] << "\n";

  133                      SASSERT(s.value(c[0]) == l_undef && s.value(c[1]) == l_undef);
  134:                     TRACE("cleanup_bug", tout << "clause became binary: " << c[0] << " " << c[1] << "\n";);
  135                      s.mk_bin_clause(c[0], c[1], c.is_learned());

  200          s.propagate(false); // make sure that everything was propagated.
  201:         TRACE("sat_cleaner_bug", s.display(tout); s.display_watches(tout););
  202          if (s.m_inconsistent)

z3/src/sat/sat_cut_simplifier.cpp:
  161          report _report(*this);
  162:         TRACE("cut_simplifier", s.display(tout););
  163          unsigned n = 0, i = 0;

  222              literal head = ~xors[index];
  223:             TRACE("cut_simplifier", tout << xors << "\n";);
  224              unsigned sz = xors.size() - 1;

  344          IF_VERBOSE(10, verbose_stream() << u << " " << v << " " << c << "\n";);
  345:         TRACE("cut_simplifier", tout << u << " == " << v << "\n";);                            
  346          certify_equivalence(u, v, c);                    

z3/src/sat/sat_drat.cpp:
  182      void drat::append(literal l, status st) {
  183:         TRACE("sat_drat", pp(tout, st) << " " << l << "\n";);
  184  

  200      void drat::append(literal l1, literal l2, status st) {
  201:         TRACE("sat_drat", pp(tout, st) << " " << l1 << " " << l2 << "\n";);
  202          declare(l1);

  232      void drat::append(clause& c, status st) {
  233:         TRACE("sat_drat", pp(tout, st) << " " << c << "\n";);
  234          for (literal lit : c) declare(lit);

  373                  }
  374:                 CTRACE("sat_drat", num_true == 0 && num_undef == 1, display(tout););
  375                  SASSERT(num_true != 0 || num_undef != 1);

  427          //display(std::cout);
  428:         TRACE("sat_drat",
  429                tout << literal_vector(n, c) << "\n";

  547          lbool old_value = value(l);
  548:         //        TRACE("sat_drat", tout << "assign " << l << " := " << new_value << " from " << old_value << "\n";);
  549          switch (old_value) {

  580  
  581:             //TRACE("sat_drat", tout << "Propagate " << l << " " << c << " watch: " << wc.m_l1 << " " << wc.m_l2 << "\n";);
  582              if (wc.m_l1 == ~l) {

z3/src/sat/sat_elim_eqs.cpp:
   72                          if (r1.index() < r2.index()) {
   73:                             TRACE("elim_eqs", tout << l1 << " " << l2 << " " << r1 << " " << r2 << "\n";);
   74                              m_new_bin.push_back(bin(r1, r2, it->is_learned()));

  103              clause & c     = *(*it);
  104:             TRACE("sats", tout << "processing: " << c << "\n";);
  105              unsigned sz    = c.size();

  137              for (literal l : c) VERIFY(l == norm(roots, l));
  138:             TRACE("sats", tout << "after normalization/sorting: " << c << "\n"; tout.flush(););
  139              DEBUG_CODE({
  140                      for (literal l : c) {
  141:                         CTRACE("sat", l != norm(roots, l), tout << l << " " << norm(roots, l) << "\n"; tout.flush(););
  142                          SASSERT(l == norm(roots, l));

  167              }
  168:             TRACE("elim_eqs", tout << "after removing duplicates: " << c << " j: " << j << "\n";);
  169  

  235              bool set_root = m_solver.set_root(l, r);
  236:             TRACE("elim_eqs", tout << l << " " << r << "\n";);
  237              if (m_solver.is_assumption(v) || (m_solver.is_external(v) && (m_solver.is_incremental() || !set_root))) {

  247                  model_converter::entry & e = mc.mk(model_converter::ELIM_VAR, v);
  248:                 TRACE("save_elim", tout << "marking as deleted: " << v << " l: " << l << " r: " << r << "\n";);
  249                  m_solver.set_eliminated(v, true);

  258          for (literal l : c) {
  259:             CTRACE("elim_eqs_bug", m_solver.was_eliminated(l.var()), tout << "lit: " << l << " " << norm(roots, l) << "\n";
  260                     tout << c << "\n";);

  280      void elim_eqs::operator()(literal_vector const & roots, bool_var_vector const & to_elim) {
  281:         TRACE("elim_eqs", tout << "before bin cleanup\n"; m_solver.display(tout););
  282          cleanup_bin_watches(roots);
  283:         TRACE("elim_eqs", tout << "after bin cleanup\n"; m_solver.display(tout););
  284          cleanup_clauses(roots, m_solver.m_clauses);

  290          SASSERT(check_clauses(roots));
  291:         TRACE("elim_eqs", tout << "after full cleanup\n"; m_solver.display(tout););
  292      }

  294      void elim_eqs::operator()(union_find<>& uf) {
  295:         TRACE("elim_eqs", tout << "before union-find bin\n";);
  296          literal_vector roots(m_solver.num_vars(), null_literal);

  303                  to_elim.push_back(i);
  304:                 TRACE("elim_eqs", tout << "remove " << roots[i] << "\n";);
  305              }

z3/src/sat/sat_elim_vars.cpp:
  123          dd::bdd b =  m.mk_exists(m_var2index[v], b0);       
  124:         TRACE("elim_vars",
  125                tout << "eliminate " << v << "\n";

z3/src/sat/sat_gc.cpp:
   38          if (!should_gc()) return;
   39:         TRACE("sat", tout << m_conflicts_since_gc << " " << m_gc_threshold << "\n";);
   40          unsigned gc = m_stats.m_gc_clause;

  159      void solver::gc_half(char const * st_name) {
  160:         TRACE("sat", tout << "gc\n";);
  161          unsigned sz     = m_learned.size();

  194      void solver::gc_dyn_psm() {
  195:         TRACE("sat", tout << "gc\n";);
  196          // To do gc at scope_lvl() > 0, I will need to use the reinitialization stack, or live with the fact

  215              m_min_d_tk = d_tk;
  216:         TRACE("sat_frozen", tout << "m_min_d_tk: " << m_min_d_tk << "\n";);
  217          unsigned frozen    = 0;

  244                          // move to frozen;
  245:                         TRACE("sat_frozen", tout << "freezing size: " << c.size() << " psm: " << psm(c) << " " << c << "\n";);
  246                          detach_clause(c);

  286      bool solver::activate_frozen_clause(clause & c) {
  287:         TRACE("sat_gc", tout << "reactivating:\n" << c << "\n";);
  288          SASSERT(at_base_lvl());

  306          }
  307:         TRACE("sat", tout << "after cleanup:\n" << mk_lits_pp(j, c.begin()) << "\n";);
  308          unsigned new_sz = j;

z3/src/sat/sat_integrity_checker.cpp:
   48              VERIFY(c[i].var() <= s.num_vars());
   49:             CTRACE("sat_bug", s.was_eliminated(c[i].var()),
   50                     tout << "l: " << c[i].var() << "\n";

   73                      for (unsigned i = 2; i < c.size(); i++) {
   74:                         CTRACE("sat_bug", s.value(c[i]) != l_false,
   75                                 tout << c << " status: " << s.status(c) << "\n";

  146                  VERIFY(!s.was_eliminated(w.get_literal().var()));
  147:                 CTRACE("sat_watched_bug", !s.get_wlist(~(w.get_literal())).contains(watched(l, w.is_learned())),
  148                         tout << "l: " << l << " l2: " << w.get_literal() << "\n"; 

  171              literal l = ~to_literal(l_idx++);            
  172:             CTRACE("sat_bug", 
  173                     s.was_eliminated(l.var()) && !wlist.empty(),

  198              if (ids.contains(cp->id())) {
  199:                 TRACE("sat", tout << "Repeated clause: " << cp->id() << "\n";);
  200                  return false;

z3/src/sat/sat_local_search.cpp:
  263          IF_VERBOSE(11, display(verbose_stream() << "verify ", c););
  264:         TRACE("sat", display(verbose_stream() << "verify ", c););
  265          if (c.m_k < value) {

  508  
  509:         TRACE("sat", tout << m_units << "\n";);
  510          // remove unit clauses

  515  
  516:         TRACE("sat", display(tout););
  517  

  733          
  734:         TRACE("sat", 
  735                tout << "seed:\t" << m_config.random_seed() << '\n';

z3/src/sat/sat_lookahead.cpp:
    84      void lookahead::add_binary(literal l1, literal l2) {
    85:         TRACE("sat", tout << "binary: " << l1 << " " << l2 << "\n";);
    86          SASSERT(l1 != l2);

    97      void lookahead::del_binary(unsigned idx) {
    98:         // TRACE("sat", display(tout << "Delete " << to_literal(idx) << "\n"););
    99          literal_vector & lits = m_binary[idx];

   159                      // u \/ v, ~v \/ w, u \/ ~w => u is unit
   160:                     TRACE("sat", tout << "tc1: " << u << "\n";);
   161                      propagated(u);

   185          if (is_stamped(~v)) {         
   186:             TRACE("sat", tout << "try_add_binary: " << u << "\n";);       
   187              propagated(u);        // u \/ ~v, u \/ v => u is a unit literal

   192              if (is_stamped(~u)) {
   193:                 TRACE("sat", tout << "try_add_binary: " << v << "\n";);
   194                  propagated(v);    // v \/ ~u, u \/ v => v is a unit literal

   260          }
   261:         TRACE("sat", display_candidates(tout););
   262          SASSERT(!m_candidates.empty());

   267          SASSERT(!m_candidates.empty() && m_candidates.size() <= max_num_cand);
   268:         TRACE("sat", display_candidates(tout););
   269          return true;

   344          } 
   345:         TRACE("sat", display_candidates(tout << "sum: " << sum << "\n"););
   346          if (skip_candidates > 0) {

   397                  if (!is_true(lit1)) {
   398:                     TRACE("sat", tout << l << " " << lit1 << "\n";);
   399                      return false;

   405                  if (!is_true(lit2)) {
   406:                     TRACE("sat", tout << l << " " << lit2 << "\n";);
   407                      return false;

   653          }
   654:         TRACE("sat", display_scc(tout););
   655      }

   671          m_settled = null_literal;
   672:         TRACE("sat", display_dfs(tout););
   673      }

   714      void lookahead::get_scc(literal v) {
   715:         TRACE("scc", tout << v << "\n";);
   716          set_parent(v, null_literal);

   766              if (t == ~v) {
   767:                 TRACE("sat", display_scc(tout << "found contradiction during scc search\n"););
   768                  set_conflict();

   852          literal w, uu;
   853:         TRACE("sat", 
   854                for (literal u = m_settled; u != null_literal; u = get_link(u)) {

   858          for (literal u = m_settled; u != null_literal; u = uu) {
   859:             TRACE("sat", tout << "process: " << u << "\n";);
   860              uu = get_link(u);

   871                  literal v = ~get_next(~u, j);
   872:                 TRACE("sat", tout << "child " << v << " link: " << get_link(v) << "\n";);
   873                  literal pv = get_parent(v);

   890                  set_child(w, u);
   891:                 TRACE("sat", tout << "child(" << w << ") = " << u << " link(" << u << ") = " << v << "\n";);
   892              }
   893          }
   894:         TRACE("sat", 
   895                    display_forest(tout << "forest: ", get_child(null_literal));

   960          SASSERT(2*m_lookahead.size() == offset);
   961:         TRACE("sat", for (unsigned i = 0; i < m_lookahead.size(); ++i) 
   962                           tout << m_lookahead[i].m_lit << " : " << m_lookahead[i].m_offset << "\n";);

  1041          m_init_freevars = m_freevars.size();
  1042:         TRACE("sat", m_s.display(tout); display(tout););
  1043      }

  1096              set_undef(l);
  1097:             TRACE("sat", tout << "inserting free var v" << l.var() << "\n";);
  1098              m_freevars.insert(l.var());

  1164                  //update_prefix(m_wstack[i]);
  1165:                 TRACE("sat", tout << "windfall: " << nlit << " " << l2 << "\n";); 
  1166                  // if we use try_add_binary, then this may produce new assignments

  1235                  if (is_false(l2)) {
  1236:                     TRACE("sat", tout << l1 << " " << l2 << " " << "\n";);
  1237                      set_conflict();

  1271                  // this could create a conflict from propagation, but we complete the transaction.
  1272:                 TRACE("sat", display(tout););
  1273                  literal l1 = b.m_u;

  1707  
  1708:         TRACE("sat",
  1709                for (literal lit : clauses) {

  1723          literal_vector const& lits = m_binary[l.index()];
  1724:         TRACE("sat", tout << l << " => " << lits << "\n";);
  1725          for (literal lit : lits) {

  1734              literal l = m_trail[i];
  1735:             TRACE("sat", tout << "propagate " << l << " @ " << m_level << "\n";);
  1736              propagate_binary(l);

  1743          //VERIFY(!missed_propagation());
  1744:         TRACE("sat_verbose", display(tout << scope_lvl() << " " << (inconsistent()?"unsat":"sat") << "\n"););
  1745      }

  1748      void lookahead::compute_lookahead_reward() {
  1749:         TRACE("sat", display_lookahead(tout); );
  1750          m_delta_decrease = pow(m_config.m_delta_rho, 1.0 / (double)m_lookahead.size());

  1777                  else {
  1778:                     TRACE("sat", tout << "lookahead: " << lit << " @ " << m_lookahead[i].m_offset << "\n";);
  1779                      reset_lookahead_reward(lit);

  1790                  if (unsat) {
  1791:                     TRACE("sat", tout << "backtracking and setting " << ~lit << "\n";);
  1792                      lookahead_backtrack();

  1823          lookahead_backtrack();
  1824:         TRACE("sat", display_lookahead(tout); );
  1825      }

  1840              if (mixd > h || (mixd == h && m_s.m_rand(count) == 0)) {
  1841:                 CTRACE("sat", l != null_literal, tout << lit << " mix diff: " << mixd << "\n";);
  1842                  if (mixd > h) count = 1;

  1846          }
  1847:         TRACE("sat", tout << "selected: " << l << "\n";);
  1848          return l;

  1939                  if (unsat) {
  1940:                     TRACE("sat", tout << "unit: " << ~lit << "\n";);
  1941                      ++m_stats.m_double_lookahead_propagations;

  2009          if (is_undef(l)) {
  2010:             TRACE("sat", tout << "assign: " << l << " @ " << m_level << " " << m_trail_lim.size() << " " << m_search_mode << "\n";);
  2011              set_true(l);

  2015                  m_stats.m_propagations++;
  2016:                 TRACE("sat", tout << "removing free var v" << l.var() << "\n";);
  2017                  if (l.var() > m_freevars.max_var()) IF_VERBOSE(0, verbose_stream() << "bigger than max-var: " << l << " " << " " << m_freevars.max_var() << "\n";);

  2023          else if (is_false(l)) {
  2024:             TRACE("sat", tout << "conflict: " << l << " @ " << m_level << " " << m_search_mode << "\n";);
  2025              SASSERT(!is_true(l));

  2034              literal l = m_trail[i];
  2035:             TRACE("sat", tout << "propagate " << l << " @ " << m_level << "\n";);
  2036              propagate_binary(l);

  2060          while (true) {
  2061:             TRACE("sat", display(tout););
  2062              inc_istamp();

  2071              }
  2072:             TRACE("sat", tout << "choose: " << l << " " << trail << "\n";);
  2073              ++m_stats.m_decisions;

  2167          while (true) {
  2168:             TRACE("sat", display(tout););
  2169              checkpoint();

  2171              if (inconsistent()) {
  2172:                 TRACE("sat", tout << "inconsistent: " << m_cube_state.m_cube << "\n";);
  2173                  m_cube_state.m_freevars_threshold = m_freevars.size();     

  2206              if (inconsistent()) {
  2207:                 TRACE("sat", tout << "inconsistent: " << m_cube_state.m_cube << "\n";);
  2208                  m_cube_state.m_freevars_threshold = prev_nfreevars;

  2222              }
  2223:             TRACE("sat", tout << "choose: " << lit << " cube: " << m_cube_state.m_cube << "\n";);
  2224              SASSERT(vars.empty() || vars.contains(lit.var()));

z3/src/sat/sat_lookahead.h:
  440          void set_height(literal v, unsigned h) { m_dfs[v.index()].m_height = h; }
  441:         void set_parent(literal v, literal p) { TRACE("scc", tout << v << " <- " << p << "\n";); m_dfs[v.index()].m_parent = p; }
  442          void set_vcomp(literal v, literal u) { m_dfs[v.index()].m_vcomp = u; }

  534          unsigned double_look(literal l, unsigned& base);
  535:         void set_conflict() { TRACE("sat", tout << "conflict\n";); m_inconsistent = true; }
  536          bool inconsistent() const { return m_inconsistent; }

z3/src/sat/sat_lut_finder.cpp:
  117          uint64_t lut = convert_combination(m_vars, v);
  118:         TRACE("aig_simplifier",
  119                for (clause* cp : m_clauses_to_remove) {

z3/src/sat/sat_model_converter.cpp:
  125                      if (l == null_literal) {
  126:                         CTRACE("sat", !sat, 
  127                                 tout << "exposed: " << m_exposed_lim << "\n";

  168                      if (!sat) {
  169:                         TRACE("sat_model_bug", tout << "failed eliminated: " << mk_lits_pp(static_cast<unsigned>(it - itbegin), itbegin) << "\n";);
  170                          ok = false;

  231          add_elim_stack(e);
  232:         TRACE("sat_mc_bug", tout << "adding: " << c << "\n";);
  233      }

  242          add_elim_stack(e);
  243:         TRACE("sat_mc_bug", tout << "adding (binary): " << l1 << " " << l2 << "\n";);
  244      }

  254          add_elim_stack(e);
  255:         // TRACE("sat_mc_bug", tout << "adding (wrapper): "; for (literal l : c) tout << l << " "; tout << "\n";);
  256      }

  264          add_elim_stack(e);
  265:         TRACE("sat_mc_bug", tout << "adding: " << c << "\n";);
  266      }

  282                      for (literal l : it2->m_clauses) {
  283:                         CTRACE("sat_model_converter", l.var() == it->var(), tout << "var: " << it->var() << "\n"; display(tout););
  284                          SASSERT(l.var() != it->var());

z3/src/sat/sat_mus.cpp:
   39          s.m_core.append(m_mus);
   40:         TRACE("sat", tout << "new core: " << s.m_core << "\n";);
   41      }

   60          bool minimize_partial = s.m_config.m_core_minimize_partial;
   61:         TRACE("sat", tout << "old core: " << s.get_core() << "\n";);
   62          literal_vector& core = get_core();

   70                         verbose_stream() << ")\n";);
   71:             TRACE("sat", 
   72                    tout << "core: " << core << "\n";

   92                  is_sat = s.check(mus.size(), mus.data());
   93:                 TRACE("sat", tout << "mus: " << mus << "\n";);
   94              }

  119                  else {
  120:                     TRACE("sat", tout << "core: " << new_core << " mus: " << mus << "\n";);
  121                      core.reset();

z3/src/sat/sat_probing.cpp:
   84              s.push();
   85:             TRACE("sat", tout << "probing " << l << "\n";);
   86              s.assign_scoped(l);

   90              if (s.inconsistent()) {
   91:                 TRACE("sat", tout << "probe failed: " << ~l << "\n";);
   92                  // ~l must be true

  123      void probing::process_core(bool_var v) {
  124:         TRACE("probing", tout << "processing: " << v << " counter: " << -m_counter << "\n";);
  125          SASSERT(s.m_qhead == s.m_trail.size());

  130          s.assign_scoped(l);
  131:         TRACE("sat", tout << "probing " << l << "\n";);
  132          unsigned old_tr_sz = s.m_trail.size();

  135              // ~l must be true
  136:             TRACE("sat", tout << "probe failed: " << ~l << "\n";
  137                    s.display(tout););

z3/src/sat/sat_scc.cpp:
  138                      // found new SCC
  139:                     CTRACE("scc_cycle", s.back() != l_idx, {
  140                              tout << "cycle: ";

  155                          // variable was already assigned... just consume stack
  156:                         TRACE("scc_detail", tout << "consuming stack...\n";);
  157                          unsigned l2_idx;

  166                          // check if the SCC has an external variable, and check for conflicts
  167:                         TRACE("scc_detail", tout << "assigning roots...\n";);
  168                          literal  r = null_literal;

  188  
  189:                         TRACE("scc_detail", tout << "r: " << r << "\n";);
  190  

  230          report rpt(*this);
  231:         TRACE("scc", m_solver.display(tout););
  232:         TRACE("scc_details", m_solver.display_watches(tout););
  233          literal_vector roots;

  236              return 0;
  237:         TRACE("scc", for (unsigned i = 0; i < roots.size(); i++) { tout << i << " -> " << roots[i] << "\n"; }
  238                tout << "to_elim: "; for (unsigned v : to_elim) tout << v << " "; tout << "\n";);

  241          eliminator(roots, to_elim);
  242:         TRACE("scc_detail", m_solver.display(tout););
  243          CASSERT("scc_bug", m_solver.check_invariant());

  246              reduce_tr();
  247:         TRACE("scc_detail", m_solver.display(tout););
  248          return to_elim.size();

z3/src/sat/sat_simplifier.cpp:
   141              c.set_removed(true);
   142:             TRACE("sat_simplifier", tout << "del_clause: " << c << "\n";);
   143              m_need_cleanup = true;

   186          init_visited();
   187:         TRACE("after_cleanup", s.display(tout););
   188          CASSERT("sat_solver", s.check_invariant());

   200          CASSERT("sat_solver", s.check_invariant());
   201:         TRACE("sat_simplifier", s.display(tout););
   202  
   203          s.m_cleaner(true);
   204:         TRACE("after_cleanup", s.display(tout););
   205          CASSERT("sat_solver", s.check_invariant());

   249          if (m_need_cleanup || vars_eliminated) {
   250:             TRACE("after_simplifier", tout << "cleanning watches...\n";);
   251              cleanup_watches();

   258          CASSERT("sat_solver", s.check_invariant());
   259:         TRACE("sat_simplifier", s.display(tout); tout << "model_converter:\n"; s.m_mc.display(tout););
   260  

   310      void simplifier::cleanup_clauses(clause_vector & cs, bool learned, bool vars_eliminated) {
   311:         TRACE("sat", tout << "cleanup_clauses\n";);
   312          clause_vector::iterator it  = cs.begin();

   437              clause & c2 = it.curr();
   438:             CTRACE("sat_simplifier", c2.was_removed(), tout << "clause has been removed:\n" << c2 << "\n";);
   439              SASSERT(!c2.was_removed());

   479                  }
   480:                 TRACE("subsumption", tout << c1 << " subsumed " << c2 << "\n";);
   481                  remove_clause(c2, false);

   485                  // subsumption resolution
   486:                 TRACE("subsumption_resolution", tout << c1 << " sub-ref(" << *l_it << ") " << c2 << "\n";);
   487                  elim_lit(c2, *l_it);
   488                  m_num_sub_res++;
   489:                 TRACE("subsumption_resolution", tout << "result: " << c2 << "\n";);
   490              }

   579                  s.set_learned(c1, false);
   580:             TRACE("subsumption", tout << c1 << " subsumed " << c2 << "\n";);
   581              remove_clause(c2, false);

   681      void simplifier::elim_lit(clause & c, literal l) {
   682:         TRACE("elim_lit", tout << "processing: " << l << " @ " << c << "\n";);
   683          m_need_cleanup = true;

   703              // clause was satisfied
   704:             TRACE("elim_lit", tout << "clause was satisfied\n";);
   705              remove_clause(c, true);

   710          case 0:
   711:             TRACE("elim_lit", tout << "clause is empty\n";);
   712              s.set_conflict();

   714          case 1:
   715:             TRACE("elim_lit", tout << "clause became unit: " << c[0] << "\n";);
   716              c.restore(sz0);

   720          case 2:
   721:             TRACE("elim_lit", tout << "clause became binary: " << c[0] << " " << c[1] << "\n";);
   722              c.restore(sz0);

   727          default:
   728:             TRACE("elim_lit", tout << "result: " << c << "\n";);
   729              m_sub_todo.insert(c);

   751                              SASSERT(wlist[j] == w);
   752:                             TRACE("set_not_learned_bug",
   753                                    tout << "marking as not learned: " << l2 << " " << wlist[j].is_learned() << "\n";);

   815                  if (it->get_literal() == last_lit) {
   816:                     TRACE("subsumption", tout << "eliminating: " << ~to_literal(l_idx)
   817                            << " " << it->get_literal() << "\n";);

   859          subsume_with_binaries();
   860:         TRACE("subsumption_bug", s.display(tout););
   861          while (true) {
   862:             TRACE("subsumption", tout << "sub_todo size: " << m_sub_todo.size() << "\n";);
   863  

   878  
   879:             TRACE("subsumption_bug", s.display(tout););
   880  

   892              m_sub_counter--;
   893:             TRACE("subsumption", tout << "next: " << c << "\n";);
   894              if (s.m_trail.size() > m_last_sub_trail_sz) {

   910                  case 2:
   911:                     TRACE("subsumption", tout << "clause became binary: " << c << "\n";);
   912                      s.mk_bin_clause(c[0], c[1], c.is_learned());

   920              }
   921:             TRACE("subsumption", tout << "using: " << c << "\n";);
   922              back_subsumption1(c);

  1593          void block_covered_clause(clause& c, literal l, model_converter::kind k) {
  1594:             TRACE("blocked_clause", tout << "new blocked clause: " << c << "\n";);
  1595              SASSERT(!s.is_external(l));

  1608              literal l2 = w.get_literal();
  1609:             TRACE("blocked_clause", tout << "new blocked clause: " << l2 << " " << l1 << "\n";);
  1610              s.set_learned(l1, l2);

  1725      void simplifier::elim_blocked_clauses() {
  1726:         TRACE("blocked_clause_bug", tout << "trail: " << s.m_trail.size() << "\n"; s.display_watches(tout); s.display(tout););
  1727          blocked_cls_report rpt(*this);

  1749          unsigned cost = 2 * num_pos * num_neg + num_pos * num_bin_neg + num_neg * num_bin_pos;
  1750:         CTRACE("sat_simplifier", cost == 0, tout << v << " num_pos: " << num_pos << " num_neg: " << num_neg << " num_bin_pos: " << num_bin_pos
  1751                 << " num_bin_neg: " << num_bin_neg << " cost: " << cost << "\n";);

  1774          std::stable_sort(tmp.begin(), tmp.end(), bool_var_and_cost_lt());
  1775:         TRACE("sat_simplifier",
  1776                for (auto& p : tmp) tout << "(" << p.first << ", " << p.second << ") ";

  1812      bool simplifier::resolve(clause_wrapper const & c1, clause_wrapper const & c2, literal l, literal_vector & r) {
  1813:         CTRACE("resolve_bug", !c1.contains(l) || !c2.contains(~l), tout << c1 << "\n" << c2 << "\nl: " << l << "\n";);
  1814          if (m_visited.size() <= 2*s.num_vars())

  1882                      if (it2->is_binary_clause() && it2->get_literal() == l) {
  1883:                         TRACE("bin_clause_bug", tout << "removing: " << l << " " << it2->get_literal() << "\n";);
  1884                          m_sub_bin_todo.erase(bin_clause(l2, l, it2->is_learned()));

  1893          }
  1894:         TRACE("bin_clause_bug", tout << "collapsing watch_list of: " << l << "\n";);
  1895          wlist.finalize();

  1912                  m_sub_todo.erase(c);
  1913:                 TRACE("sat_simplifier", tout << "del_clause (elim_var): " << c << "\n";);
  1914                  m_need_cleanup = true;

  1931  
  1932:         TRACE("sat_simplifier", tout << v << " num_pos: " << num_pos << " neg_pos: " << num_neg << "\n";);
  1933  

  1948  
  1949:         TRACE("sat_simplifier", tout << v << " num_pos: " << num_pos << " neg_pos: " << num_neg << " before_lits: " << before_lits << "\n";);
  1950  

  1964  
  1965:         TRACE("sat_simplifier", tout << "collecting number of after_clauses\n";);
  1966          unsigned before_clauses = num_pos + num_neg;

  1971                  if (resolve(c1, c2, pos_l, m_new_cls)) {
  1972:                     TRACE("sat_simplifier", tout << c1 << "\n" << c2 << "\n-->\n";
  1973                            for (literal l : m_new_cls) tout << l << " "; tout << "\n";);

  1975                      if (after_clauses > before_clauses) {
  1976:                         TRACE("sat_simplifier", tout << "too many after clauses: " << after_clauses << "\n";);
  1977                          return false;

  1981          }
  1982:         TRACE("sat_simplifier", tout << "eliminate " << v << ", before: " << before_clauses << " after: " << after_clauses << "\n";
  1983                tout << "pos\n";

  2009                      continue;                
  2010:                 TRACE("sat_simplifier", tout << c1 << "\n" << c2 << "\n-->\n" << m_new_cls << "\n";);
  2011                  if (cleanup_clause(m_new_cls)) {

z3/src/sat/sat_solver.cpp:
    93          SASSERT(m_config.m_num_threads > 1 || check_invariant());
    94:         CTRACE("sat", !m_clauses.empty(), tout << "Delete clauses\n";);
    95          del_clauses(m_clauses);
    96:         CTRACE("sat", !m_learned.empty(), tout << "Delete learned\n";);
    97          del_clauses(m_learned);

   347                  for (unsigned i = 0; i < num_lits; i++) {
   348:                     CTRACE("sat", was_eliminated(lits[i]), tout << lits[i] << " was eliminated\n";);
   349                      SASSERT(!was_eliminated(lits[i]));

   413          bool redundant = st.is_redundant();
   414:         TRACE("sat", tout << "mk_clause: "  << mk_lits_pp(num_lits, lits) << (redundant?" learned":" aux") << "\n";);
   415          bool logged = false;

   418              bool keep = m_trim || simplify_clause(num_lits, lits);
   419:             TRACE("sat_mk_clause", tout << "mk_clause (after simp), keep: " << keep << "\n" << mk_lits_pp(num_lits, lits) << "\n";);
   420              if (!keep) {

   473          if (w0 && !m_trim) {
   474:             TRACE("sat", tout << "found binary " << l1 << " " << l2 << "\n";);
   475              if (w0->is_learned() && !redundant) {

   533          SASSERT(!at_base_lvl());
   534:         TRACE("sat_reinit", tout << "adding to reinit stack: " << c << "\n";);
   535          m_clauses_to_reinit.push_back(clause_wrapper(c));

   539      void solver::push_reinit_stack(literal l1, literal l2) {
   540:         TRACE("sat_reinit", tout << "adding to reinit stack: " << l1 << " " << l2 << "\n";);
   541          m_clauses_to_reinit.push_back(clause_wrapper(l1, l2));

   803              literal l    = cls[i];
   804:             CTRACE("sat", value(l) != l_false, tout << l << ":=" << value(l););
   805              SASSERT(value(l) == l_false);

   878          m_not_l    = not_l;
   879:         TRACE("sat", display(display_justification(tout << "conflict " << not_l << " ", c) << "\n"));
   880      }

   884          SASSERT(!m_trail.contains(l) && !m_trail.contains(~l));
   885:         TRACE("sat_assign_core", tout << l << " " << j << "\n";);
   886          if (j.level() == 0) {

  1014          unsigned curr_level = lvl(l);
  1015:         TRACE("sat_propagate", tout << "propagating: " << l << "@" << curr_level << " " << m_justification[l.var()] << "\n"; );
  1016  

  1051                  if (value(it->get_blocked_literal()) == l_true) {
  1052:                     TRACE("propagate_clause_bug", tout << "blocked literal " << it->get_blocked_literal() << "\n";
  1053                      tout << get_clause(it) << "\n";);

  1059                  clause& c = get_clause(cls_off);
  1060:                 TRACE("propagate_clause_bug", tout << "processing... " << c << "\nwas_removed: " << c.was_removed() << "\n";);
  1061                  if (c[0] == not_l)
  1062                      std::swap(c[0], c[1]);
  1063:                 CTRACE("propagate_bug", c[1] != not_l, tout << "l: " << l << " " << c << "\n";);
  1064  

  1263              if (m_config.m_force_cleanup) do_cleanup(true);
  1264:             TRACE("sat", display(tout););
  1265  

  1278                  IF_VERBOSE(SAT_VB_LVL, verbose_stream() << "(sat \"abort: max-conflicts = 0\")\n";);
  1279:                 TRACE("sat", display(tout); m_mc.display(tout););
  1280                  return l_undef;

  1584              next = m_rand() % num_vars();
  1585:             TRACE("random_split", tout << "next: " << next << " value(next): " << value(next) << "\n";);
  1586              if (value(next) == l_undef && !was_eliminated(next))

  1667          
  1668:         TRACE("sat_decide", tout << scope_lvl() << ": next-case-split: " << next_lit << "\n";);
  1669          assign_scoped(next_lit);

  1758  
  1759:         TRACE("sat",
  1760                tout << literal_vector(num_lits, lits) << "\n";

  1807          reset_assumptions();
  1808:         TRACE("sat", tout << "reassert: " << m_min_core << "\n";);
  1809          for (literal lit : m_min_core) {

  1819          if (tracking_assumptions() && at_base_lvl() && !inconsistent()) {
  1820:             TRACE("sat", tout << "assumptions: " << m_assumptions << " user scopes: " << m_user_scope_literals << "\n";);
  1821              if (!propagate(false)) return;

  1834                  propagate(false);
  1835:             TRACE("sat",
  1836                    tout << "consistent: " << !inconsistent() << "\n";

  1914              m_ext->init_search();
  1915:         TRACE("sat", display(tout););
  1916      }

  1930  
  1931:         TRACE("sat", tout << "simplify\n";);
  1932  

  2066          }
  2067:         TRACE("sat_mc_bug", m_mc.display(tout););
  2068  

  2098  
  2099:         TRACE("sat", for (bool_var v = 0; v < num; v++) tout << v << ": " << m_model[v] << "\n";);
  2100  

  2116                  IF_VERBOSE(1, verbose_stream() << "failed clause " << c.id() << ": " << c << "\n";);
  2117:                 TRACE("sat", tout << "failed: " << c << "\n";
  2118                        tout << "assumptions: " << m_assumptions << "\n";

  2141                          IF_VERBOSE(1, verbose_stream() << "elim l1: " << was_eliminated(l.var()) << " elim l2: " << was_eliminated(l2) << "\n");
  2142:                         TRACE("sat", m_mc.display(tout << "failed binary: " << l << " " << l2 << "\n"););
  2143                          ok = false;

  2152                  IF_VERBOSE(1, verbose_stream() << "assumption: " << l << " does not model check " << value_at(l, m) << "\n";);
  2153:                 TRACE("sat",
  2154                        tout << l << " does not model check\n";

  2171              ok = false;
  2172:             TRACE("sat", tout << "model: " << m << "\n"; m_mc.display(tout););
  2173              IF_VERBOSE(0, verbose_stream() << "model check failed\n");

  2263          }
  2264:         TRACE("sat", tout << "restart " << restart_level(to_base) << "\n";);
  2265          IF_VERBOSE(30, display_status(verbose_stream()););
  2266:         TRACE("sat", tout << "restart " << restart_level(to_base) << "\n";);
  2267          pop_reinit(restart_level(to_base));

  2361                                      !m_user_scope_literals.empty())) {
  2362:             TRACE("sat", tout << "unsat core\n";);
  2363              resolve_conflict_for_unsat_core();

  2370                  drat_log_clause(0, nullptr, sat::status::redundant());
  2371:             TRACE("sat", tout << "conflict level is 0\n";);
  2372              return l_false;

  2379          if (allow_backtracking() && unique_max && !m_force_conflict_analysis) {
  2380:             TRACE("sat", tout << "unique max " << js << " " << m_not_l << "\n";);
  2381              pop_reinit(m_scope_lvl - m_conflict_lvl + 1);

  2409  
  2410:         TRACE("sat_conflict_detail", 
  2411                tout << "resolve: " << m_not_l << " " 

  2419          if (m_not_l != null_literal) {
  2420:             TRACE("sat_conflict_detail", tout << "not_l: " << m_not_l << "\n";);
  2421              process_antecedent(m_not_l, num_marks);

  2425          do {
  2426:             TRACE("sat_conflict_detail", tout << "processing consequent: " << consequent << " @" << (consequent==null_literal?m_conflict_lvl:lvl(consequent)) << "\n";
  2427                    tout << "num_marks: " << num_marks << "\n";

  2455                  fill_ext_antecedents(consequent, js, false);
  2456:                 TRACE("sat", tout << "ext antecedents: " << m_ext_antecedents << "\n";);
  2457                  for (literal l : m_ext_antecedents) 

  2484                  }
  2485:                 CTRACE("sat", idx == 0, 
  2486                         for (literal lit : m_trail)

  2488                                 tout << "missed " << lit << "@" << lvl(lit) << "\n";);
  2489:                 CTRACE("sat", idx == 0, display(tout););
  2490                  if (idx == 0)

  2500  
  2501:             TRACE("sat", display_justification(tout << consequent << " ", js) << "\n";);            
  2502          }

  2511      void solver::learn_lemma_and_backjump() {
  2512:         TRACE("sat_lemma", tout << "new lemma size: " << m_lemma.size() << "\n" << m_lemma << "\n";);
  2513          

  2524                  dyn_sub_res();
  2525:             TRACE("sat_lemma", tout << "new lemma (after minimization) size: " << m_lemma.size() << "\n" << m_lemma << "\n";);
  2526          }

  2542                  if (lvl(m_lemma[i]) == backjump_lvl) {
  2543:                     TRACE("sat", tout << "swap " << m_lemma[0] << "@" << lvl(m_lemma[0]) << m_lemma[1] << "@" << backjump_lvl << "\n";);
  2544                      std::swap(m_lemma[i], m_lemma[0]);

  2561          else {
  2562:             TRACE("sat", tout << "backtrack " << (m_scope_lvl - backtrack_lvl + 1) << " scopes\n";);
  2563              ++m_stats.m_backtracks;

  2573          m_lemma.reset();
  2574:         TRACE("sat_conflict_detail", tout << "consistent " << (!m_inconsistent) << " scopes: " << scope_lvl() << " backtrack: " << backtrack_lvl << " backjump: " << backjump_lvl << "\n";);
  2575          decay_activity();

  2591          SASSERT(var < num_vars());
  2592:         TRACE("sat", tout << antecedent << " " << (is_marked(var)?"+":"-") << "\n";);
  2593          if (!is_marked(var)) {

  2602      void solver::process_consequent_for_unsat_core(literal consequent, justification const& js) {
  2603:         TRACE("sat", tout << "processing consequent: ";
  2604                if (consequent == null_literal) tout << "null\n";

  2645      void solver::resolve_conflict_for_unsat_core() {
  2646:         TRACE("sat_verbose", display(tout);
  2647                unsigned level = 0;

  2678              justification js = m_justification[m_not_l.var()];
  2679:             TRACE("sat", tout << "not_l: " << m_not_l << "\n";
  2680                    display_justification(tout, js) << "\n";);

  2789          SASSERT(var < num_vars());
  2790:         TRACE("sat_verbose", tout << "process " << var << "@" << var_lvl << " marked " << is_marked(var) << " conflict " << m_conflict_lvl << "\n";);
  2791          if (!is_marked(var) && var_lvl > 0) {

  2837              bool_var v = m_trail[i].var();
  2838:             TRACE("forget_phase", tout << "forgetting phase of v" << v << "\n";);
  2839              m_phase[v] = m_rand() % 2 == 0;

  3138              }
  3139:             TRACE("sat_conflict", 
  3140                    display_justification(tout << var << " ",js) << "\n";);

  3404          SASSERT(!inconsistent());
  3405:         TRACE("sat_verbose", tout << "q:" << m_qhead << " trail: " << m_trail.size() << "\n";);
  3406          SASSERT(m_qhead == m_trail.size());

  3476          }
  3477:         TRACE("sat",
  3478              tout << "clauses to reinit: " << (m_clauses_to_reinit.size() - old_sz) << "\n";

  3562          if (!m_replay_assign.empty()) IF_VERBOSE(20, verbose_stream() << "replay assign: " << m_replay_assign.size() << "\n");
  3563:         CTRACE("sat", !m_replay_assign.empty(), tout << "replay-assign: " << m_replay_assign << "\n";);
  3564          for (unsigned i = m_replay_assign.size(); i-- > 0; ) {

  3618              m_ext->user_push();
  3619:         TRACE("sat", tout << "user_push: " << lit << "\n";);
  3620      }

  3631          gc_vars(max_var);
  3632:         TRACE("sat", display(tout););
  3633  

  3765                      continue;
  3766:                 TRACE("cleanup_bug", tout << "collected: " << l << " " << l2 << "\n";);
  3767                  r.push_back(bin_clause(l, l2));

  4024              if (is_empty(c) || is_unit(c)) {
  4025:                 TRACE("sat_missed_prop", tout << "missed_propagation: " << c << "\n";
  4026                        for (literal l : c) tout << l << ": " << value(l) << "\n";);

  4258          index_set s;
  4259:         TRACE("sat", tout << m_core << "\n";);
  4260          for (unsigned i = 0; i < m_core.size(); ++i) {
  4261:             TRACE("sat", tout << m_core[i] << ": "; display_index_set(tout, m_antecedents.find(m_core[i].var())) << "\n";);
  4262              s |= m_antecedents.find(m_core[i].var());

  4267          }
  4268:         TRACE("sat", tout << m_core << "\n";);
  4269      }

  4288          }
  4289:         TRACE("sat", tout << asms << "\n";);
  4290          m_antecedents.reset();

  4342      lbool solver::get_consequences(literal_vector const& asms, literal_vector const& lits, vector<literal_vector>& conseq) {
  4343:         TRACE("sat", tout << asms << "\n";);
  4344          m_antecedents.reset();

  4395                      if (!resolve_conflict()) {
  4396:                         TRACE("sat", display(tout << "inconsistent\n"););
  4397                          m_inconsistent = false;

  4422              if (is_sat == l_false) {
  4423:                 TRACE("sat", tout << "unsat\n";);
  4424                  m_inconsistent = false;

  4482          for (literal lit: unfixed_lits) {
  4483:             TRACE("sat", tout << "extract: " << lit << " " << value(lit) << " " << lvl(lit) << "\n";);
  4484  

  4504          justification js = m_justification[lit.var()];
  4505:         TRACE("sat", tout << lit << " " << js << "\n";);
  4506          bool all_found = true;

  4541          }
  4542:         TRACE("sat", display_index_set(tout << lit << ": " , s) << "\n";);
  4543          return all_found;

z3/src/sat/sat_solver.h:
  391          void assign(literal l, justification j) {
  392:             TRACE("sat_assign", tout << l << " previous value: " << value(l) << " j: " << j << "\n";);
  393              switch (value(l)) {

  414                  m_model_is_current = false;
  415:                 TRACE("sat", tout << "canceled\n";);
  416                  m_reason_unknown = "sat.canceled";

z3/src/sat/sat_xor_finder.cpp:
   59          s.init_visited();
   60:         TRACE("sat_xor", tout << c << "\n";);
   61          bool parity = false;

  119          if (parity == (lits.size() % 2 == 0)) lits[0].neg();
  120:         TRACE("sat_xor", tout << parity << ": " << lits << "\n";);
  121          m_on_xor(lits);

  139          }
  140:         TRACE("sat_xor", tout << l1 << " " << l2 << "\n";);
  141          return update_combinations(c, parity, mask);

  156          }
  157:         TRACE("sat_xor", tout << c2 << "\n";);
  158          // insert missing

  194          for (unsigned i = 0; i < (1ul << sz); ++i) {     
  195:             TRACE("sat_xor", tout << i << ": " << parity << " " << m_parity[sz][i] << " " << get_combination(i) << "\n";);
  196              if (parity == m_parity[sz][i] && !get_combination(i)) {

z3/src/sat/sat_solver/inc_sat_solver.cpp:
   200  
   201:         TRACE("sat", tout << _assumptions << "\n";);
   202          m_dep2asm.reset();

   351      void assert_expr_core(expr * t) override {
   352:         TRACE("goal2sat", tout << mk_pp(t, m) << "\n";);
   353          m_is_cnf &= is_clause(t);

   468          init_preprocess();
   469:         TRACE("sat", tout << assumptions << "\n" << vars << "\n";);
   470          sat::literal_vector asms;

   493          for (unsigned i = 0; i < lconseq.size(); ++i) {
   494:             TRACE("sat", tout << lconseq[i] << "\n";);
   495              bool_var2conseq.insert(lconseq[i][0].var(), i);

   587              m_cached_mc = concat(m_cached_mc.get(), m_sat_mc.get());
   588:             TRACE("sat", m_cached_mc->display(tout););
   589              return m_cached_mc;

   607          g.get_formulas(m_internalized_fmls);
   608:         TRACE("sat", m_solver.display(tout); tout << m_internalized_fmls << "\n";);
   609          m_internalized_converted = true;

   710              strm << "(sat.giveup interpreted functions sent to SAT solver " << funs <<")";
   711:             TRACE("sat", tout << strm.str() << "\n";);
   712              IF_VERBOSE(1, verbose_stream() << strm.str() << "\n";);

   742          SASSERT(!g->proofs_enabled());
   743:         TRACE("sat", m_solver.display(tout); g->display(tout););
   744  

   756              set_reason_unknown(ex.msg());
   757:             TRACE("sat", tout << "exception: " << ex.msg() << "\n";);
   758              m_preprocess = nullptr;

   774          m_mcs.set(m_mcs.size()-1, concat(m_mcs.back(), g->mc()));
   775:         TRACE("sat", g->display_with_dependencies(tout););
   776  

   851              }
   852:             CTRACE("sat", internalized, tout << "var: " << bvars << "\n";);
   853          }

   856          }
   857:         CTRACE("sat", !internalized, tout << "unhandled variable " << mk_pp(v, m) << "\n";);
   858          return internalized;

   877              else {
   878:                 TRACE("sat", tout << "variable is not bound " << mk_pp(v, m) << "\n";);
   879                  return false;

   991          }
   992:         CTRACE("sat", m_dep2asm.size() != m_asms.size(), 
   993                 tout << m_dep2asm.size() << " vs " << m_asms.size() << "\n";

  1010          sat::literal_vector const& core = m_solver.get_core();
  1011:         TRACE("sat",
  1012                for (auto const& kv : m_dep2asm) {

  1048      void get_model_core(model_ref & mdl) override {
  1049:         TRACE("sat", tout << "retrieve model " << (m_solver.model_is_current()?"present":"absent") << "\n";);
  1050          if (!m_solver.model_is_current()) {

  1057          }
  1058:         TRACE("sat", m_solver.display_model(tout););
  1059:         CTRACE("sat", m_sat_mc, m_sat_mc->display(tout););
  1060          sat::model ll_m = m_solver.get_model();

  1084  
  1085:         TRACE("sat", m_solver.display(tout););
  1086          if (m_sat_mc) {

  1090          if (m_mcs.back()) {      
  1091:             TRACE("sat", m_mcs.back()->display(tout););
  1092              (*m_mcs.back())(mdl);
  1093          }
  1094:         TRACE("sat", model_smt2_pp(tout, m, *mdl, 0););        
  1095  

  1109                  return;
  1110:             CTRACE("sat", !m.is_true(tmp),
  1111                     tout << "Evaluation failed: " << mk_pp(f, m) << " to " << tmp << "\n";

z3/src/sat/smt/arith_axioms.cpp:
   81          }
   82:         TRACE("arith", tout << expr_ref(p, m) << " " << expr_ref(q, m) << "\n";);
   83          // if q is zero, then idiv and mod are uninterpreted functions.

  363          expr* e2 = var2expr(v2);
  364:         TRACE("arith", tout << "new eq: v" << v1 << " v" << v2 << "\n";);
  365          if (e1->get_id() > e2->get_id())

  446          SASSERT(!is_infeasible());
  447:         TRACE("arith", tout << term << "\n" << lp().constraints(););
  448      }

  485                  if (!a.is_bounded(n)) {
  486:                     TRACE("arith", tout << "unbounded " << expr_ref(n, m) << "\n";);
  487                      continue;

  492  
  493:                 TRACE("arith", tout << get_value(v) << " != " << r1 << " div " << r2 << "\n";);
  494                  rational div_r = div(r1.x, r2);

  518  
  519:                 TRACE("arith", tout << r1 << " div " << r2 << "\n";);
  520                  continue;

z3/src/sat/smt/arith_internalize.cpp:
   91          ctx.push(value_trail<expr*>(m_not_handled));
   92:         TRACE("arith", tout << "unsupported " << mk_pp(n, m) << "\n";);
   93          m_not_handled = n;

   97          if (a.is_underspecified(n)) {
   98:             TRACE("arith", tout << "Unhandled: " << mk_pp(n, m) << "\n";);
   99              ctx.push(push_back_vector(m_underspecified));

  134          add_def_constraint_and_equality(var, lp::LE, rational(c));
  135:         TRACE("arith", tout << "add " << cnst << ", var = " << var << "\n";);
  136          return var;

  309      bool solver::internalize_atom(expr* atom) {
  310:         TRACE("arith", tout << mk_pp(atom, m) << "\n";);
  311          expr* n1, *n2;

  366          else {
  367:             TRACE("arith", tout << "Could not internalize " << mk_pp(atom, m) << "\n";);
  368              found_unsupported(atom);

  382          m_bool_var2bound.insert(bv, b);
  383:         TRACE("arith_verbose", tout << "Internalized " << lit << ": " << mk_pp(atom, m) << " " << *b << "\n";);
  384          m_new_bounds.push_back(b);

  395      theory_var solver::internalize_def(expr* term, scoped_internalize_state& st) {
  396:         TRACE("arith", tout << expr_ref(term, m) << "\n";);
  397          if (ctx.get_enode(term))

  420          SASSERT(!m.is_bool(t));
  421:         TRACE("arith", tout << mk_pp(t, m) << " " << force << " " << reflect(t) << "\n";);
  422          if (!force && !reflect(t))

  472              }
  473:             TRACE("arith", tout << "v" << v << " := " << mk_pp(t, m) << "\n" << vars << "\n";);
  474              m_solver->register_existing_terms();

  482          theory_var v = mk_evar(term);
  483:         TRACE("arith", tout << mk_bounded_pp(term, m) << " v" << v << "\n";);
  484  

  515                      SASSERT(lp::tv::is_term(vi));
  516:                     TRACE("arith_verbose",
  517                          tout << "v" << v << " := " << mk_pp(term, m)

  568      enode* solver::mk_enode(expr* e) {
  569:         TRACE("arith", tout << expr_ref(e, m) << "\n";);
  570          enode* n = ctx.get_enode(e);

  590          theory_var v = mk_var(e);
  591:         TRACE("arith_verbose", tout << "v" << v << " " << mk_pp(n, m) << "\n";);
  592          SASSERT(m_bounds.size() <= static_cast<unsigned>(v) || m_bounds[v].empty());

z3/src/sat/smt/arith_solver.cpp:
    89              api_bound* b = nullptr;
    90:             CTRACE("arith", !m_bool_var2bound.contains(lit.var()), tout << "not found " << lit << "\n";);
    91              if (m_bool_var2bound.find(lit.var(), b)) 

   103          case l_false:
   104:             TRACE("arith", tout << "propagation conflict\n";);
   105              get_infeasibility_explanation_and_set_conflict();

   148          bool find_glb = (same_polarity == (k == lp_api::lower_t));
   149:         TRACE("arith", tout << lit1 << " v" << v << " val " << val << " find_glb: " << find_glb << " is_true: " << is_true << " k: " << k << " is_lower: " << (k == lp_api::lower_t) << "\n";);
   150          if (find_glb) {

   195          m_core.push_back(lit1);
   196:         TRACE("arith", tout << lit2 << " <- " << m_core << "\n";);
   197          arith_proof_hint* ph = nullptr;

   237  
   238:         TRACE("arith", tout << "lp bound v" << v << " " << be.kind() << " " << be.m_bound << "\n";);
   239  

   248                  continue;
   249:             TRACE("arith", tout << "lp bound " << lit << " bound: " << *b << " first: " << first << "\n";);
   250  

   257              }
   258:             CTRACE("arith", m_unassigned_bounds[v] == 0, tout << "missed bound\n";);
   259              updt_unassigned_bounds(v, -1);
   260:             TRACE("arith", for (auto lit : m_core) tout << lit << ": " << s().value(lit) << "\n";);
   261              DEBUG_CODE(for (auto lit : m_core) { VERIFY(s().value(lit) == l_true); });

   271          if ((k == lp::LE || k == lp::LT) && b.get_bound_kind() == lp_api::upper_t && value <= b.get_value()) {
   272:             TRACE("arith", tout << "v <= value <= b.get_value() => v <= b.get_value() \n";);
   273              return b.get_lit();  

   275          if ((k == lp::GE || k == lp::GT) && b.get_bound_kind() == lp_api::lower_t && b.get_value() <= value) {
   276:             TRACE("arith", tout << "b.get_value() <= value <= v => b.get_value() <= v \n";);
   277              return b.get_lit();

   279          if (k == lp::LE && b.get_bound_kind() == lp_api::lower_t && value < b.get_value()) {
   280:             TRACE("arith", tout << "v <= value < b.get_value() => v < b.get_value()\n";);
   281              return ~b.get_lit();

   283          if (k == lp::LT && b.get_bound_kind() == lp_api::lower_t && value <= b.get_value()) {
   284:             TRACE("arith", tout << "v < value <= b.get_value() => v < b.get_value()\n";);
   285              return ~b.get_lit();

   287          if (k == lp::GE && b.get_bound_kind() == lp_api::upper_t && b.get_value() < value) {
   288:             TRACE("arith", tout << "b.get_value() < value <= v => b.get_value() < v\n";);
   289              return ~b.get_lit();

   291          if (k == lp::GT && b.get_bound_kind() == lp_api::upper_t && b.get_value() <= value) {
   292:             TRACE("arith", tout << "b.get_value() <= value < v => b.get_value() < v\n";);
   293              return ~b.get_lit();

   383      void solver::assert_bound(bool is_true, api_bound& b) {
   384:         TRACE("arith", tout << b << "\n";);
   385          lp::constraint_index ci = b.get_constraint(is_true);

   423              if (b.first == UINT_MAX || (is_lower ? b.second < v : b.second > v)) {
   424:                 TRACE("arith", tout << "tighter bound " << tv.to_string() << "\n";);
   425                  m_history.push_back(vec[ti]);

   445      void solver::flush_bound_axioms() {
   446:         CTRACE("arith", !m_new_bounds.empty(), tout << "flush bound axioms\n";);
   447  

   460              }
   461:             CTRACE("arith_verbose", !atoms.empty(),
   462                  for (unsigned i = 0; i < atoms.size(); ++i) {

   588  
   589:             TRACE("arith", ctx.display_validation_failure(tout << *b << "\n", mdl, n));
   590              IF_VERBOSE(0, ctx.display_validation_failure(verbose_stream() << *b << "\n", mdl, n));

   610              rational r = get_value(v);
   611:             TRACE("arith", tout << mk_pp(o, m) << " v" << v << " := " << r << "\n";);
   612              SASSERT("integer variables should have integer values: " && (ctx.get_config().m_arith_ignore_int || !a.is_int(o) || r.is_int() || m.limit().is_canceled()));

   653      void solver::push_core() {
   654:         TRACE("arith_verbose", tout << "push\n";);
   655          m_scopes.push_back(scope());

   666      void solver::pop_core(unsigned num_scopes) {
   667:         TRACE("arith", tout << "pop " << num_scopes << "\n";);
   668          unsigned old_size = m_scopes.size() - num_scopes;

   676              m_nla->pop(num_scopes);
   677:         TRACE("arith_verbose", tout << "num scopes: " << num_scopes << " new scope level: " << m_scopes.size() << "\n";);
   678          th_euf_solver::pop_core(num_scopes);

   697          theory_var v2 = lp().local_to_external(vi2);
   698:         TRACE("arith", tout << "fixed: " << mk_pp(var2expr(v1), m) << " " << mk_pp(var2expr(v2), m) << "\n";);
   699          // we expect lp() to ensure that none of these returns happen.

   738              rational val;
   739:             TRACE("arith", tout << lp().get_variable_name(vi) << " " << v << "\n";);
   740              if (v != euf::null_theory_var && a.is_numeral(var2expr(v), val) && bound == val) {

   768      void solver::updt_unassigned_bounds(theory_var v, int inc) {
   769:         TRACE("arith_verbose", tout << "v" << v << " " << m_unassigned_bounds[v] << " += " << inc << "\n";);
   770          ctx.push(vector_value_trail<unsigned, false>(m_unassigned_bounds, v));

   795          if (m.inc() && m_solver.get() && get_num_vars() > 0) {
   796:             TRACE("arith", display(tout << "update variable values\n"););
   797              ctx.push(value_trail<bool>(m_model_is_initialized));

   847              return;
   848:         TRACE("arith", tout << s().scope_lvl() << "\n"; tout.flush(););
   849          m_tmp_var_set.clear();

   877      bool solver::assume_eqs() {
   878:         TRACE("arith", display(tout););
   879          random_update();

   893              theory_var other = m_model_eqs.insert_if_not_there(v);
   894:             TRACE("arith", tout << "insert: v" << v << " := " << get_value(v) << " found: v" << other << "\n";);
   895              if (!is_equal(other, v))

   916              m_assume_eq_head++;
   917:             CTRACE("arith",
   918                  is_eq(v1, v2) && n1->get_root() != n2->get_root(),

   963              case l_undef:
   964:                 TRACE("arith", tout << "check feasible is undef\n";);
   965                  return sat::check_result::CR_CONTINUE;

   974  
   975:         TRACE("arith", ctx.display(tout););
   976  

   985          case l_undef:
   986:             TRACE("arith", tout << "check-lia giveup\n";);
   987              if (ctx.get_config().m_arith_ignore_int) 

   999          case l_undef:
  1000:             TRACE("arith", tout << "check-nra giveup\n";);
  1001              st = sat::check_result::CR_GIVEUP;

  1015          if (m_not_handled != nullptr) {
  1016:             TRACE("arith", tout << "unhandled operator " << mk_pp(m_not_handled, m) << "\n";);
  1017              return sat::check_result::CR_GIVEUP;

  1027              m_todo_terms.push_back(std::make_pair(t, rational::one()));
  1028:             TRACE("nl_value", tout << "v" << v << " " << t.to_string() << "\n";);
  1029:             TRACE("nl_value", tout << "v" << v << " := w" << t.to_string() << "\n";
  1030              lp().print_term(lp().get_term(t), tout) << "\n";);

  1037                  lp::lar_term const& term = lp().get_term(t);
  1038:                 TRACE("nl_value", lp().print_term(term, tout) << "\n";);
  1039                  scoped_anum r1(m_nla->am());

  1063      lbool solver::make_feasible() {
  1064:         TRACE("pcs", tout << lp().constraints(););
  1065          auto status = lp().find_feasible_solution();
  1066:         TRACE("arith_verbose", display(tout););
  1067          switch (status) {

  1076          default:
  1077:             TRACE("arith", tout << "status treated as inconclusive: " << status << "\n";);
  1078              return l_undef;

  1101      lbool solver::check_lia() {
  1102:         TRACE("arith", );
  1103          if (!m.inc())

  1118          case lp::lia_move::branch: {
  1119:             TRACE("arith", tout << "branch\n";);
  1120              app_ref b(m);

  1136          case lp::lia_move::cut: {
  1137:             TRACE("arith", tout << "cut\n";);
  1138              ++m_stats.m_gomory_cuts;

  1152          case lp::lia_move::conflict:
  1153:             TRACE("arith", tout << "conflict\n";);
  1154              // ex contains unsat core

  1157          case lp::lia_move::undef:
  1158:             TRACE("arith", tout << "lia undef\n";);
  1159              lia_check = l_undef;

  1202              set_evidence(ev.ci());
  1203:         TRACE("arith",
  1204              tout << "Lemma - " << (is_conflict ? "conflict" : "propagation") << "\n";

  1299                  if (lower_bound) {
  1300:                     TRACE("arith", tout << "lower: " << offset << " / " << g << " = " << offset / g << " >= " << ceil(offset / g) << "\n";);
  1301                      offset = ceil(offset / g);

  1303                  else {
  1304:                     TRACE("arith", tout << "upper: " << offset << " / " << g << " = " << offset / g << " <= " << floor(offset / g) << "\n";);
  1305                      offset = floor(offset / g);

  1314  
  1315:         // CTRACE("arith", is_int,
  1316          //        lp().print_term(term, tout << "term: ") << "\n";

  1325  
  1326:         TRACE("arith", tout << t << ": " << atom << "\n";
  1327          lp().print_term(term, tout << "bound atom: ") << (lower_bound ? " >= " : " <= ") << k << "\n";);

  1336      void solver::term2coeffs(lp::lar_term const& term, u_map<rational>& coeffs, rational const& coeff) {
  1337:         TRACE("arith", lp().print_term(term, tout) << "\n";);
  1338          for (lp::lar_term::ival ti : term) {

  1349                  SASSERT(w >= 0);
  1350:                 TRACE("arith", tout << (tv.id()) << ": " << w << "\n";);
  1351              }

  1412              }
  1413:             TRACE("arith", tout << "is_lower: " << is_lower << " pos " << pos << "\n";);
  1414              // TBD utility: lp::lar_term term = mk_term(ineq.m_poly);

  1427          if (!m.inc()) {
  1428:             TRACE("arith", tout << "canceled\n";);
  1429              return l_undef;
  1430          }
  1431:         CTRACE("arith", !m_nla, tout << "no nla\n";);
  1432          if (!m_nla) 

z3/src/sat/smt/array_axioms.cpp:
   36          m_axiom_trail.push_back(r); 
   37:         TRACE("array", display(tout, r) << " " << m_axioms.contains(idx) << "\n";);
   38          if (m_axioms.contains(idx))

   81              
   82:         TRACE("array", tout << "default-axiom: " << mk_bounded_pp(child, m, 2) << "\n";);
   83          if (a.is_const(child))

  103  
  104:         TRACE("array", display(tout << "select-axiom: " << (should_delay ? "delay " : ""), r) << "\n";);
  105  

  133      bool solver::assert_store_axiom(app* e) {
  134:         TRACE("array", tout << "store-axiom: " << mk_bounded_pp(e, m) << "\n";);
  135          ++m_stats.m_num_store_axiom;

  184          euf::enode* s2 = e_internalize(sel2);
  185:         TRACE("array", 
  186                tout << "select-store " << ctx.bpp(s1) << " " << ctx.bpp(s1->get_root()) << "\n";

  230          ++m_stats.m_num_select_store_axiom;
  231:         TRACE("array", tout << "select-stored " << new_prop << "\n";);
  232          return new_prop;

  272          literal lit2 = eq_internalize(sel1, sel2);
  273:         TRACE("array", tout << "extensionality-axiom: " << mk_bounded_pp(e1, m) << " == " << mk_bounded_pp(e2, m) << "\n" << lit1 << " " << ~lit2 << "\n";);
  274          return add_clause(lit1, ~lit2);

  463          rewrite(beta);
  464:         TRACE("array", tout << alpha << " == " << beta << "\n";);
  465          return ctx.propagate(e_internalize(alpha), e_internalize(beta), array_axiom());

  471      bool solver::assert_congruent_axiom(expr* e1, expr* e2) {
  472:         TRACE("array", tout << "congruence-axiom: " << mk_bounded_pp(e1, m) << " " << mk_bounded_pp(e2, m) << "\n";);
  473          ++m_stats.m_num_congruence_axiom;

  636                  continue;
  637:             CTRACE("array", !ctx.is_relevant(n), tout << "not relevant: " << ctx.bpp(n) << "\n");
  638              if (!ctx.is_relevant(n))

  643              // arrays used as indices in other arrays have to be treated as shared issue #3532, #3529
  644:             CTRACE("array", !ctx.is_shared(r) && !is_shared_arg(r), tout << "not shared: " << ctx.bpp(r) << "\n");
  645              if (ctx.is_shared(r) || is_shared_arg(r)) 

  649          }
  650:         TRACE("array", tout << "collecting shared vars...\n"; for (auto v : roots) tout << ctx.bpp(var2enode(v)) << "\n";);
  651          for (auto* n : to_unmark)

z3/src/sat/smt/array_internalize.cpp:
  25          if (!visit_rec(m, e, sign, root)) {
  26:             TRACE("array", tout << mk_pp(e, m) << "\n";);
  27              return sat::null_literal;

z3/src/sat/smt/array_model.cpp:
  131                  if (!values.get(p->get_arg(i)->get_root_id())) {
  132:                     TRACE("array", tout << ctx.bpp(p->get_arg(i)) << "\n");
  133                  }

  140          
  141:         TRACE("array", tout << "array-as-function " << ctx.bpp(n) << " := " << mk_pp(f, m) << "\n" << "default " << mk_pp(fi->get_else(), m) << "\n";);
  142          parameter p(f);

  284                  mg_merge(v, get_representative(w));                                
  285:                 TRACE("array", tout << "merge: " << ctx.bpp(n) << " " << v << " " << w << "\n";);
  286              }

  296          v = mg_find(v);
  297:         CTRACE("array", !m_defaults[v], tout << "set default: " << v << " " << ctx.bpp(n) << "\n";);
  298          if (!m_defaults[v]) 

  345  
  346:             CTRACE("array", m_defaults[v], 
  347                     tout << ctx.bpp(m_defaults[v]->get_root()) << "\n";

z3/src/sat/smt/array_solver.cpp:
  154          euf::enode* n2 = var2enode(v2);
  155:         TRACE("array", tout << "merge: " << ctx.bpp(n1) << " == " << ctx.bpp(n2) << "\n";);
  156          SASSERT(n1->get_root() == n2->get_root());

  183          euf::enode* child = var2enode(v_child);
  184:         TRACE("array", tout << "v" << v_child << " - " << ctx.bpp(select) << " " << ctx.bpp(child) << " prop: " << should_prop_upward(get_var_data(v_child)) << "\n";);
  185:         TRACE("array", tout << "can beta reduce " << can_beta_reduce(child) << "\n";);
  186          if (can_beta_reduce(child)) 

z3/src/sat/smt/bv_delay_internalize.cpp:
  134  
  135:         TRACE("bv", tout << mk_bounded_pp(e, m) << " evaluates to " << r1 << " arguments: " << args << "\n";);
  136          // check x*0 = 0

  209              inv = invert(s, n);
  210:             TRACE("bv", tout << "enforce " << inv << "\n";);
  211              add_unit(eq_internalize(inv, n));

  282              add_unit(eq_internalize(mul1, n->get_arg(1)));
  283:             TRACE("bv", tout << mul1 << "\n";);
  284              return false;

  289              add_unit(eq_internalize(mul1, n->get_arg(0)));
  290:             TRACE("bv", tout << mul1 << "\n";);
  291              return false;

z3/src/sat/smt/bv_internalize.cpp:
   92          ctx.attach_th_var(n, this, r);        
   93:         TRACE("bv", tout << "mk-var: v" << r << " " << n->get_expr_id() << " " << mk_bounded_pp(n->get_expr(), m) << "\n";);
   94          return r;

  241      void solver::mk_bits(theory_var v) {
  242:         TRACE("bv", tout << "v" << v << "@" << s().scope_lvl() << "\n";);
  243          expr* e = var2expr(v);

  249              sat::literal lit = ctx.internalize(b2b, false, false);
  250:             TRACE("bv", tout << "add-bit: " << lit << " " << literal2expr(lit) << "\n";);
  251              if (m_bits[v].back() == sat::null_literal)

  294          zero_one_bits& bits = m_zero_one_bits[v];
  295:         TRACE("bv", tout << "register v" << v << " " << l << " " << mk_true() << "\n";);
  296          bits.push_back(zero_one_bit(v, idx, is_true));

  304          m_bits[v].push_back(l);
  305:         TRACE("bv", tout << "add-bit: v" << v << "[" << idx << "] " << l << " " << literal2expr(l) << "@" << s().scope_lvl() << "\n";);
  306          SASSERT(m_num_scopes == 0);

  347                  sat::literal lit = ctx.internalize(bit, false, false);
  348:                 TRACE("bv", tout << "set " << m_bits[v][i] << " == " << lit << "\n";);
  349                  add_clause(~lit, m_bits[v][i]);

  590          init_bits(e, bits);
  591:         TRACE("bv_verbose", tout << arg_bits << " " << bits << " " << new_bits << "\n";);
  592      }

  676              m_bits[v_arg][idx] = lit;
  677:             TRACE("bv", tout << "add-bit: " << lit << " " << literal2expr(lit) << "\n";);
  678              atom* a = new (get_region()) atom(lit.var());

  761          unsigned sz = m_bits[v1].size();
  762:         TRACE("bv", tout << "ackerman-eq: " << s().scope_lvl() << " " << oe << "\n";);
  763          literal_vector eqs;

  772          }
  773:         TRACE("bv", for (auto l : eqs) tout << mk_bounded_pp(literal2expr(l), m) << " "; tout << "\n";);
  774          euf::th_proof_hint* ph = ctx.mk_smt_clause(name(), eqs.size(), eqs.data());

z3/src/sat/smt/bv_solver.cpp:
   90              SASSERT(get_bv_size(v1) == get_bv_size(v2));
   91:             TRACE("bv", tout << "detected equality: v" << v1 << " = v" << v2 << "\n" << pp(v1) << pp(v2););
   92              m_stats.m_num_bit2eq++;

  138                  wpos = idx;
  139:                 TRACE("bv", tout << "moved wpos of v" << v << " to " << wpos << "\n";);
  140                  return;

  142          }
  143:         TRACE("bv", tout << "v" << v << " is a fixed variable.\n";);
  144          fixed_var_eh(v);

  167          SASSERT(m_bits[v1][idx] == ~m_bits[v2][idx]);
  168:         TRACE("bv", tout << "found new diseq axiom\n" << pp(v1) << pp(v2););
  169          m_stats.m_num_diseq_static++;

  206          force_push();
  207:         TRACE("bv", tout << "new eq " << mk_bounded_pp(var2expr(eq.v1()), m) << " == " << mk_bounded_pp(var2expr(eq.v2()), m) << "\n";);
  208          if (is_bv(eq.v1())) {

  249          
  250:         TRACE("bv", tout << "diff: " << v1 << " != " << v2 << " @" << s().scope_lvl() << "\n";);
  251          unsigned sz = m_bits[v1].size();

  310          auto& c = bv_justification::from_index(idx);
  311:         TRACE("bv", display_constraint(tout, idx) << "\n";);
  312          switch (c.m_kind) {

  508          atom* a = get_bv2a(l.var());
  509:         TRACE("bv", tout << "asserted: " << l << "\n";);
  510          if (a) {

  574          lbool   val = s().value(bit1);
  575:         TRACE("bv", tout << "propagating v" << v1 << " #" << var2enode(v1)->get_expr_id() << "[" << idx << "] = " << val << "\n";);
  576          if (val == l_undef)

  585              SASSERT(m_bits[v1][idx] != ~m_bits[v2][idx]);
  586:             TRACE("bv", tout << "propagating #" << var2enode(v2)->get_expr_id() << "[" << idx << "] = " << s().value(bit2) << "\n";);
  587  

  636      void solver::push_core() {
  637:         TRACE("bv", tout << "push: " << get_num_vars() << "@" << m_prop_queue_lim.size() << "\n";);
  638          th_euf_solver::push_core();

  651          m_zero_one_bits.shrink(old_sz);
  652:         TRACE("bv", tout << "num vars " << old_sz << "@" << m_prop_queue_lim.size() << "\n";);
  653      }

  709          }    
  710:         TRACE("bv", tout << "infer new equations for bit-vectors that are now equal\n";);
  711      }

  861  
  862:         TRACE("bv", tout << "merging: v" << v1 << " #" << var2enode(v1)->get_expr_id() << " v" << v2 << " #" << var2enode(v2)->get_expr_id() << "\n";);
  863  
  864          if (!merge_zero_one_bits(r1, r2)) {
  865:             TRACE("bv", tout << "conflict detected\n";);
  866              return; // conflict was detected

  874              literal bit2 = m_bits[v2][idx];
  875:             CTRACE("bv", bit1 == ~bit2, tout << pp(v1) << pp(v2) << "idx: " << idx << "\n";);
  876              if (bit1 == ~bit2) {

  882              lbool val2 = s().value(bit2);
  883:             TRACE("bv", tout << "merge v" << v1 << " " << bit1 << ":= " << val1 << " " << bit2 << ":= " << val2 << "\n";);
  884              if (val1 == val2)
  885                  continue;
  886:             CTRACE("bv", (val1 != l_undef && val2 != l_undef), tout << "inconsistent "; tout << pp(v1) << pp(v2) << "idx: " << idx << "\n";);
  887              if (val1 == l_false)

  902          auto jst = sat::justification::mk_ext_justification(s().scope_lvl(), constraint->to_index());
  903:         TRACE("bv", tout << jst << " " << constraint << "\n");
  904          return jst;

z3/src/sat/smt/dt_solver.cpp:
  121      void solver::assert_is_constructor_axiom(enode* n, func_decl* c, literal antecedent) {
  122:         TRACE("dt", tout << mk_pp(c, m) << " " << ctx.bpp(n) << "\n";);
  123          m_stats.m_assert_cnstr++;

  161          SASSERT(c->get_root() == r->get_arg(0)->get_root());
  162:         TRACE("dt", tout << ctx.bpp(c) << "\n" << ctx.bpp(r) << "\n";);
  163          literal l = ctx.enode2literal(r);

  256          
  257:         TRACE("dt", tout << ctx.bpp(n) << " non_rec_c: " << non_rec_c->get_name() << " #rec: " << d->m_recognizers.size() << "\n";);
  258  

  334      void solver::apply_sort_cnstr(enode* n, sort* s) {
  335:         TRACE("dt", tout << "apply_sort_cnstr: #" << ctx.bpp(n) << "\n";);
  336          force_push();

  350              return;
  351:         TRACE("dt", tout << "assigning recognizer: #" << n->get_expr_id() << " " << ctx.bpp(n) << "\n";);
  352          SASSERT(n->num_args() == 1);

  371      void solver::add_recognizer(theory_var v, enode* recognizer) {
  372:         TRACE("dt", tout << "add recognizer " << v << " " << mk_pp(recognizer->get_expr(), m) << "\n";);
  373          v = m_find.find(v);

  386          lbool val = ctx.value(recognizer);
  387:         TRACE("dt", tout << "adding recognizer to v" << v << " rec: #" << recognizer->get_expr_id() << " val: " << val << "\n";);
  388  

  425  
  426:         CTRACE("dt", d->m_recognizers.empty(), ctx.display(tout););
  427          SASSERT(!d->m_recognizers.empty());

  451          }
  452:         TRACE("dt", tout << "propagate " << num_unassigned << " eqs: " << eqs.size() << "\n";);
  453          if (num_unassigned == 0) {

  490          auto* con2 = d2->m_constructor;
  491:         TRACE("dt", tout << "merging v" << v1 << " v" << v2 << "\n" << ctx.bpp(var2enode(v1)) << " == " << ctx.bpp(var2enode(v2)) << " " << ctx.bpp(con1) << " " << ctx.bpp(con2) << "\n";);
  492          if (con1 && con2 && con1->get_decl() != con2->get_decl())

  600      void solver::occurs_check_explain(enode* app, enode* root) {
  601:         TRACE("dt", tout << "occurs_check_explain " << ctx.bpp(app) << " <-> " << ctx.bpp(root) << "\n";);
  602  

  618  
  619:         TRACE("dt",
  620              tout << "occurs_check\n"; for (enode_pair const& p : m_used_eqs) tout << ctx.bpp(p.first) << " - " << ctx.bpp(p.second) << " ";);

  687      bool solver::occurs_check(enode* n) {
  688:         TRACE("dt_verbose", tout << "occurs check: " << ctx.bpp(n) << "\n";);
  689          m_stats.m_occurs_check++;

  702  
  703:             TRACE("dt_verbose", tout << "occurs check loop: " << ctx.bpp(app) << (op == ENTER ? " enter" : " exit") << "\n";);
  704  

  718              ctx.set_conflict(euf::th_explain::conflict(*this, m_used_eqs, ctx.mk_smt_hint(name(), m_used_eqs)));
  719:             TRACE("dt", tout << "occurs check conflict: " << ctx.bpp(n) << "\n";);
  720          }

  785          euf::enode* con = m_var_data[m_find.find(v)]->m_constructor;
  786:         CTRACE("dt", !con, display(tout) << ctx.bpp(n) << "\n";);
  787          if (con->num_args() == 0)

z3/src/sat/smt/euf_ackerman.cpp:
  126              return;
  127:         TRACE("ack", tout << "conflict eh: " << mk_pp(a, m) << " == " << mk_pp(b, m) << "\n";);
  128          insert(a, b);

  138              return;
  139:         TRACE("ack", tout << mk_pp(a, m) << " " << mk_pp(b, m) << " " << mk_pp(c, m) << "\n";);
  140          insert(a, b, c);

  146              return;
  147:         TRACE("ack", tout << "used cc: " << mk_pp(a, m) << " == " << mk_pp(b, m) << "\n";);
  148          SASSERT(a->get_decl() == b->get_decl());

  193          app* b = to_app(_b);
  194:         TRACE("ack", tout << mk_pp(a, m) << " " << mk_pp(b, m) << "\n";);
  195          sat::literal_vector lits;

  218          expr_ref eq3(ctx.mk_eq(a, b), m);
  219:         TRACE("ack", tout << mk_pp(a, m) << " " << mk_pp(b, m) << " " << mk_pp(c, m) << "\n";);
  220          lits[0] = ~ctx.mk_literal(eq1);

z3/src/sat/smt/euf_internalize.cpp:
   65              }
   66:             TRACE("euf", tout << "non-bool\n";);
   67              return sat::null_literal;

   77          if (!visit_rec(m, e, sign, root)) {
   78:             TRACE("euf", tout << "visit-rec\n";);          
   79              return sat::null_literal;

  176  
  177:         TRACE("euf", tout << "attach b" << v << " " << mk_bounded_pp(e, m) << "\n";);
  178          m_bool_var2expr.reserve(v + 1, nullptr);

  194              n = mk_enode(e, 0, nullptr);
  195:         CTRACE("euf", n->bool_var() != sat::null_bool_var && n->bool_var() != v, display(tout << bpp(n) << " " << n->bool_var() << " vs " << v << "\n"));
  196          SASSERT(n->bool_var() == sat::null_bool_var || n->bool_var() == v);

z3/src/sat/smt/euf_invariant.cpp:
  54                  (n->get_arg(0)->get_root() == n->get_arg(1)->get_root())) {
  55:                 enable_trace("euf");
  56:                 TRACE("euf", display(tout << n->get_expr_id() << ": " << mk_pp(n->get_expr(), m) << "\n" 
  57                                       << "#" << n->get_arg(0)->get_expr_id() << " == #" << n->get_arg(1)->get_expr_id() << " r: " << n->get_arg(0)->get_root_id() << "\n");

z3/src/sat/smt/euf_model.cpp:
   49              (void)s;
   50:             TRACE("model", tout << s.bpp(r) << " := " << value << "\n";);
   51              values.set(id, value);

   70      void solver::update_model(model_ref& mdl) {
   71:         TRACE("model", tout << "create model\n";);
   72          if (m_qmodel) {

   88              mb->finalize_model(*mdl);
   89:         TRACE("model", tout << "created model " << *mdl << "\n";);
   90          validate_model(*mdl);

  129          
  130:         TRACE("model",
  131                for (auto * t : deps.deps()) {

  143          for (enode* n : deps.top_sorted()) {
  144:             TRACE("model", tout << bpp(n->get_root()) << "\n");
  145              unsigned id = n->get_root_id();

  220              expr* v = m_values.get(n->get_root_id());
  221:             CTRACE("euf", !v, tout << "no value for " << mk_pp(e, m) << "\n";);
  222              if (!v)

  237                      args.push_back(val);                
  238:                     CTRACE("euf", !val, tout << "no value for " << bpp(earg) << "\n" << bpp(n) << "\n"; display(tout););
  239                      SASSERT(val);

  243                      fi->insert_new_entry(args.data(), v);
  244:                 TRACE("euf", tout << bpp(n) << " " << f->get_name() << "\n";
  245                        for (expr* arg : args) tout << mk_pp(arg, m) << " ";

  271                  m_values2root.insert(m_values.get(n->get_expr_id()), n);
  272:         TRACE("model", 
  273                for (auto const& kv : m_values2root) 

  329          ev.set_model_completion(true);
  330:         TRACE("model",
  331              for (enode* n : m_egraph.nodes()) {

  355                  continue;
  356:             CTRACE("euf", first, display_validation_failure(tout, mdl, n););
  357              IF_VERBOSE(0, display_validation_failure(verbose_stream(), mdl, n););

z3/src/sat/smt/euf_proof.cpp:
   54      void solver::log_antecedents(literal l, literal_vector const& r, th_proof_hint* hint) {
   55:         TRACE("euf", log_antecedents(tout, l, r););
   56          if (!use_drat())

  300      void solver::on_clause(unsigned n, literal const* lits, sat::status st) {
  301:         TRACE("euf", tout << "on-clause " << n << "\n");
  302          on_lemma(n, lits, st);

z3/src/sat/smt/euf_relevancy.cpp:
   75          flush();
   76:         TRACE("relevancy", tout << "root " << sat::literal_vector(n, lits) << "\n");
   77          sat::literal true_lit = sat::null_literal;

  104          flush();
  105:         TRACE("relevancy", tout << "def " << sat::literal_vector(n, lits) << "\n");
  106          for (unsigned i = 0; i < n; ++i) {

  165      void relevancy::asserted(sat::literal lit) {
  166:         TRACE("relevancy", tout << "asserted " << lit << " relevant " << is_relevant(lit) << "\n");
  167          if (!m_enabled)

  212      void relevancy::merge(euf::enode* root, euf::enode* other) {
  213:         TRACE("relevancy", tout << "merge #" << ctx.bpp(root) << " " << is_relevant(root) << " #" << ctx.bpp(other) << " " << is_relevant(other) << "\n");
  214          if (is_relevant(root))

  225              return;
  226:         TRACE("relevancy", tout << "mark #" << ctx.bpp(n) << "\n");
  227          m_trail.push_back(std::make_pair(update::add_queue, 0));

  231      void relevancy::mark_relevant(sat::literal lit) {
  232:         TRACE("relevancy", tout << "mark " << lit << " " << is_relevant(lit) << " " << ctx.s().value(lit) << " lim: " << m_lim.size() << "\n");
  233          if (!m_enabled)

  252          SASSERT(m_num_scopes == 0);
  253:         TRACE("relevancy", tout << "propagate " << lit << " lim: " << m_lim.size() << "\n");
  254          SASSERT(ctx.s().value(lit) == l_true);

  278          next:
  279:             TRACE("relevancy", tout << "propagate " << lit << " " << true_lit << " " << m_roots[idx] << "\n");
  280              ;

  288              m_todo.pop_back();
  289:             TRACE("relevancy", tout << "propagate #" << ctx.bpp(n) << " lim: " << m_lim.size() << "\n");
  290              if (n->is_relevant())

z3/src/sat/smt/euf_solver.cpp:
  170      void solver::init_search() {        
  171:         TRACE("before_search", s().display(tout););
  172          m_reason_unknown.clear();

  259          r.shrink(j);
  260:         CTRACE("euf", probing, tout << "explain " << l << " <- " << r << "\n");
  261          DEBUG_CODE(for (auto lit : r) SASSERT(s().value(lit) == l_true););

  341          expr* e = m_bool_var2expr.get(l.var(), nullptr);
  342:         TRACE("euf", tout << "asserted: " << l << "@" << s().scope_lvl() << " := " << mk_bounded_pp(e, m) << "\n";);
  343          if (!e) 

  440  
  441:             CTRACE("euf", s().value(lit) != l_true, tout << lit << " " << s().value(lit) << "@" << lvl << " " << is_eq << " " << mk_bounded_pp(a, m) << " = " << mk_bounded_pp(b, m) << "\n";);
  442              if (s().value(lit) == l_false && m_ackerman) 

  509          ++m_stats.m_final_checks;
  510:         TRACE("euf", s().display(tout););
  511          bool give_up = false;

  520              case sat::check_result::CR_CONTINUE: cont = true; break;
  521:             case sat::check_result::CR_GIVEUP: m_reason_unknown = "incomplete theory " + e->name().str(); TRACE("euf", tout << "give up " << e->name() << "\n"); give_up = true; break;
  522              default: break;

  550              return sat::check_result::CR_CONTINUE;
  551:         TRACE("after_search", s().display(tout););
  552          if (give_up)

  602          SASSERT(m_egraph.num_scopes() == m_scopes.size());
  603:         TRACE("euf_verbose", display(tout << "pop to: " << m_scopes.size() << "\n"););
  604      }

  647      
  648:         TRACE("euf", for (auto const& kv : replay.m) tout << "b" << kv.m_value << "\n";);
  649          for (auto const& [e, generation, v] : m_reinit) {
  650              scoped_generation _sg(*this, generation);
  651:             TRACE("euf", tout << "replay: b" << v << " #" << e->get_id() << " " << mk_bounded_pp(e, m) << " " << si.is_bool_op(e) << "\n";);
  652              sat::literal lit;

  678                      relevancy_reinit(e);
  679:         TRACE("euf", display(tout << "replay done\n"););
  680      }

  687      void solver::relevancy_reinit(expr* e) {
  688:         TRACE("euf", tout << "internalize again " << mk_pp(e, m) << "\n";);
  689          if (to_app(e)->get_family_id() != m.get_basic_family_id()) {

  895          (void)ok;
  896:         TRACE("euf", tout << ok << " " << l << " -> " << r << "\n";);
  897          // roots cannot be eliminated as long as the egraph contains the expressions.

z3/src/sat/smt/fpa_solver.cpp:
   49          expr* ccnv;
   50:         TRACE("t_fpa", tout << "converting " << mk_ismt2_pp(e, m) << "\n";);
   51  

   53              res = ccnv;
   54:             TRACE("t_fpa_detail", tout << "cached:" << "\n";
   55                    tout << mk_ismt2_pp(e, m) << "\n" << " -> " << "\n" << mk_ismt2_pp(res, m) << "\n";);

   59  
   60:             TRACE("t_fpa_detail", tout << "converted; caching:" << "\n";
   61                    tout << mk_ismt2_pp(e, m) << "\n" << " -> " << "\n" << mk_ismt2_pp(res, m) << "\n";);

   94          ctx.attach_th_var(n, this, v);
   95:         TRACE("t_fpa", tout << "new theory var: " << mk_ismt2_pp(n->get_expr(), m) << " := " << v << "\n";);
   96      }

  134          attach_new_th_var(n);
  135:         TRACE("fp", tout << "post: " << mk_bounded_pp(e, m) << "\n";);
  136          m_nodes.push_back(std::tuple(n, sign, root));

  141      void solver::apply_sort_cnstr(enode* n, sort* s) {
  142:         TRACE("t_fpa", tout << "apply sort cnstr for: " << mk_ismt2_pp(n->get_expr(), m) << "\n";);
  143          SASSERT(s->get_family_id() == get_id());

  212      void solver::activate(expr* n) {
  213:         TRACE("t_fpa", tout << "relevant_eh for: " << mk_ismt2_pp(n, m) << "\n";);
  214  

  266  
  267:         TRACE("t_fpa", tout << "new eq: " << x << " = " << y << "\n";
  268                tout << mk_ismt2_pp(xe, m) << "\n" << " = " << "\n" << mk_ismt2_pp(ye, m) << "\n";);

  272  
  273:         TRACE("t_fpa_detail", tout << "xc = " << mk_ismt2_pp(xc, m) << "\n" <<
  274              "yc = " << mk_ismt2_pp(yc, m) << "\n";);

  302  
  303:         TRACE("t_fpa", tout << "assign_eh for: " << l << "\n" << mk_ismt2_pp(e, m) << "\n";);
  304  

  356          values.set(n->get_root_id(), value);
  357:         TRACE("t_fpa", tout << ctx.bpp(n) << " := " << value << "\n";);
  358      }

z3/src/sat/smt/pb_card.cpp:
  126          }
  127:         TRACE("ba", display(tout << "init watch: ", s, true););
  128          SASSERT(root == sat::null_literal || s.value(root) == l_true);

z3/src/sat/smt/pb_internalize.cpp:
  122              add_pb_ge(v, wlits, k.get_unsigned());
  123:             TRACE("ba", tout << "root: " << root << " lit: " << lit << "\n";);
  124              return lit;

  149              add_pb_ge(v, wlits, k.get_unsigned());
  150:             TRACE("goal2sat", tout << "root: " << root << " lit: " << lit << "\n";);
  151              return lit;

  205              if (sign) lit.neg();
  206:             TRACE("ba", tout << "root: " << root << " lit: " << lit << "\n";);
  207              return lit;

z3/src/sat/smt/pb_pb.cpp:
  180  
  181:             TRACE("ba", display(tout << "init watch: ", s, true););
  182  

  247          unsigned sum = 0;
  248:         TRACE("ba", display(tout << "validate: " << alit << "\n", s, true););
  249          for (wliteral wl : *this) {

z3/src/sat/smt/pb_solver.cpp:
    36          m_stats.m_num_conflicts++;
    37:         TRACE("pb", display(tout, c, true); );
    38          if (!validate_conflict(c)) {

    58              m_num_propagations_since_pop++;
    59:             //TRACE("pb", tout << "#prop: " << m_stats.m_num_propagations << " - " << c.lit() << " => " << lit << "\n";);
    60              SASSERT(validate_unit_propagation(c, lit));

    71          if (p.lit() != sat::null_literal && value(p.lit()) == l_false) {
    72:             TRACE("pb", tout << "pb: flip sign " << p << "\n";);
    73              IF_VERBOSE(2, verbose_stream() << "sign is flipped " << p << "\n";);

   282          BADLOG(display(verbose_stream() << "assign: " << alit << " watch: " << p.num_watch() << " size: " << p.size(), p, true));
   283:         TRACE("pb", display(tout << "assign: " << alit << "\n", p, true););
   284          SASSERT(!inconsistent());

   350              SASSERT(bound <= slack);
   351:             TRACE("pb", tout << "conflict " << alit << "\n";);
   352              set_conflict(p, alit);

   374              BADLOG(verbose_stream() << "slack " << slack << " " << bound << " " << m_a_max << "\n";);
   375:             TRACE("pb", tout << p << "\n"; for(auto j : m_pb_undef) tout << j << " "; tout << "\n";);
   376              for (unsigned index1 : m_pb_undef) {

   391  
   392:         TRACE("pb", display(tout << "assign: " << alit << "\n", p, true););
   393  

   499          m_coeffs.reserve(v + 1, 0);
   500:         TRACE("ba_verbose", tout << l << " " << offset << "\n";);
   501  

   549          unsigned c = static_cast<unsigned>(c1);
   550:         // TRACE("pb", tout << l << " " << c << "\n";);
   551          m_overflow |= c != c1;

   640          sat::justification js = s().m_conflict;
   641:         TRACE("pb", tout << consequent << " " << js << "\n";);
   642          bool unique_max;

   668  
   669:             DEBUG_CODE(TRACE("sat_verbose", display(tout, m_A);););
   670:             TRACE("pb", tout << "process consequent: " << consequent << " : "; s().display_justification(tout, js) << "\n";);
   671              SASSERT(offset > 0);

   736                      get_antecedents(consequent, p, m_lemma);
   737:                     TRACE("pb", display(tout, p, true); tout << m_lemma << "\n";);
   738                      if (_debug_conflict) {

   761                  m_A = m_C;
   762:                 TRACE("pb", display(tout << "conflict: ", m_A);););
   763  

   788              --idx;
   789:             TRACE("sat_verbose", tout << "Unmark: v" << v << "\n";);
   790              --m_num_marks;

   882          ineq.divide(c);
   883:         TRACE("pb", display(tout << "var: " << v << " " << c << ": ", ineq, true););
   884      }

   900          SASSERT(validate_lemma());
   901:         TRACE("pb", active2pb(m_B); display(tout, m_B, true););
   902      }

   930      void solver::resolve_with(ineq const& ineq) {
   931:         TRACE("pb", display(tout, ineq, true););
   932          inc_bound(ineq.m_k);        
   933:         TRACE("pb", tout << "bound: " << m_bound << "\n";);
   934  

   937              inc_coeff(l, static_cast<unsigned>(ineq.coeff(i)));
   938:             TRACE("pb", tout << "bound: " << m_bound << " lit: " << l << " coeff: " << ineq.coeff(i) << "\n";);
   939          }

   990          }
   991:         TRACE("pb", tout << consequent << " " << js << "\n";);
   992          unsigned idx = s().m_trail.size() - 1;

   994          do {
   995:             TRACE("pb", s().display_justification(tout << "process consequent: " << consequent << " : ", js) << "\n";
   996                    if (consequent != sat::null_literal) { active2pb(m_A); display(tout, m_A, true); }

  1056                          SASSERT(k > c);
  1057:                         TRACE("pb", tout << "visited: " << l << "\n";);
  1058                          k -= c;

  1105                  if (idx == 0) {
  1106:                     TRACE("pb", tout << "there is no consequent\n";);
  1107                      goto bail_out;

  1118          while (m_num_marks > 0 && !m_overflow);
  1119:         TRACE("pb", active2pb(m_A); display(tout, m_A, true););
  1120  

  1130      bail_out:
  1131:         TRACE("pb", tout << "bail " << m_overflow << "\n";);
  1132          if (m_overflow) {

  1186          if (slack >= 0) {
  1187:             TRACE("pb", tout << "slack is non-negative\n";);
  1188              IF_VERBOSE(20, verbose_stream() << "(sat.card slack: " << slack << " skipped: " << num_skipped << ")\n";);

  1191          if (m_overflow) {
  1192:             TRACE("pb", tout << "overflow\n";);
  1193              return false;

  1198              }
  1199:             TRACE("pb", tout << "no asserting literal\n";);
  1200              return false;

  1202  
  1203:         TRACE("pb", tout << m_lemma << "\n";);
  1204  

  1211          for (unsigned i = 1; i < m_lemma.size(); ++i) {
  1212:             CTRACE("pb", s().is_marked(m_lemma[i].var()), tout << "marked: " << m_lemma[i] << "\n";);
  1213              s().mark(m_lemma[i].var());

  1557      void solver::get_antecedents(literal l, pbc const& p, literal_vector& r) {
  1558:         TRACE("pb", display(tout << l << " level: " << s().scope_lvl() << " ", p, true););
  1559          SASSERT(p.lit() == sat::null_literal || value(p.lit()) == l_true);

  1609              }
  1610:             CTRACE("pb", coeff == 0, display(tout << l << " coeff: " << coeff << "\n", p, true);); 
  1611              

  1660              }
  1661:             CTRACE("pb",!found, s().display(tout << l << ":" << c << "\n"););
  1662              SASSERT(found););

  1700      void solver::remove_constraint(constraint& c, char const* reason) {
  1701:         TRACE("pb", display(tout << "remove ", c, true) << " " << reason << "\n";);
  1702          IF_VERBOSE(21, display(verbose_stream() << "remove " << reason << " ", c, true););

  1875      void solver::gc_half(char const* st_name) {
  1876:         TRACE("pb", tout << "gc\n";);
  1877          unsigned sz     = m_learned.size();

  1922          unsigned bound = c.k();
  1923:         TRACE("pb", tout << "assign: " << c.lit() << ": " << ~alit << "@" << lvl(~alit) << " " << c << "\n";);
  1924  

  1960          if (bound != index && value(c[bound]) == l_false) {
  1961:             TRACE("pb", tout << "conflict " << c[bound] << " " << alit << "\n";);
  1962              if (c.lit() != sat::null_literal && value(c.lit()) == l_undef) {

  1974  
  1975:         // TRACE("pb", tout << "no swap " << index << " " << alit << "\n";);
  1976          // there are no literals to swap with,

  2009      void solver::pop(unsigned n) {        
  2010:         TRACE("sat_verbose", tout << "pop:" << n << "\n";);
  2011          unsigned new_lim = m_constraint_to_reinit_lim.size() - n;

  2340          if (!all_units) {            
  2341:             TRACE("pb", tout << "replacing by pb: " << c << "\n";);
  2342              m_wlits.reset();

  2903                  if (slit.empty()) {
  2904:                     TRACE("pb", tout << "subsume cardinality\n" << c1 << "\n" << c2 << "\n";);
  2905                      remove_constraint(c2, "subsumed");

  2909                  else {
  2910:                     TRACE("pb", tout << "self subsume cardinality\n";);
  2911                      IF_VERBOSE(11, 

  2941                  else {
  2942:                     TRACE("pb", tout << "remove\n" << c1 << "\n" << c2 << "\n";);
  2943                      removed_clauses.push_back(&c2);

  3273          }
  3274:         CTRACE("pb", val >= 0, active2pb(m_A); display(tout, m_A, true););
  3275          return val < 0;

  3286          }
  3287:         CTRACE("pb", k > 0, display(tout, ineq, true););
  3288          return k <= 0;

  3345          constraint* c = add_pb_ge(sat::null_literal, m_wlits, m_bound, true);                
  3346:         TRACE("pb", if (c) display(tout, *c, true););
  3347          ++m_stats.m_num_lemmas;

  3569          lbool is_sat = s0.check();
  3570:         TRACE("pb", s0.display(tout << "trying sat encoding"););
  3571          if (is_sat == l_false) return true;

  3680              if (value(l) != l_false) {
  3681:                 TRACE("pb", tout << "literal " << l << " is not false\n";);
  3682                  return false;

  3684              if (!p.contains(l)) {
  3685:                 TRACE("pb", tout << "lemma contains literal " << l << " not in inequality\n";);
  3686                  return false;

  3695          }
  3696:         CTRACE("pb", value >= p.m_k, tout << "slack: " << value << " bound " << p.m_k << "\n";
  3697                 display(tout, p);

z3/src/sat/smt/q_ematch.cpp:
  155              m_qs.add_unit(m_qs.mk_literal(d));
  156:         CTRACE("q", r != q, tout << mk_pp(q, m) << " -->\n" << r << "\n" << m_new_defs << "\n";);
  157          return quantifier_ref(to_quantifier(r), m);

  189      void ematch::on_merge(euf::enode* root, euf::enode* other) {
  190:         TRACE("q", tout << "on-merge " << ctx.bpp(root) << " " << ctx.bpp(other) << "\n";);
  191          SASSERT(root->get_root() == other->get_root());

  329              return;
  330:         TRACE("q", b->display(ctx, tout << "on-binding " << mk_pp(q, m) << "\n") << "\n";);
  331  

  573      void ematch::add(quantifier* _q) {
  574:         TRACE("q", tout << "add " << mk_pp(_q, m) << "\n");
  575          clause* c = clausify(_q);

  597              bool unary = (mp->get_num_args() == 1);
  598:             TRACE("q", tout << "adding:\n" << expr_ref(mp, m) << "\n");
  599              if (!unary && j >= num_eager_multi_patterns) {
  600:                 TRACE("q", tout << "delaying (too many multipatterns):\n" << mk_ismt2_pp(mp, m) << "\n";);
  601                  if (!m_lazy_mam)

  673      bool ematch::operator()() {
  674:         TRACE("q", m_mam->display(tout););
  675          if (propagate(false))

  690                  IF_VERBOSE(0, verbose_stream() << "missed propagation " << i << "\n");
  691:                 TRACE("q", display(tout << "missed propagation\n"));
  692                  break;

  694          
  695:         TRACE("q", tout << "no more propagation\n";);
  696          return false;

z3/src/sat/smt/q_eval.cpp:
   49              lbool cmp = compare(n, binding, l.lhs, l.rhs, evidence);
   50:             TRACE("q", tout << l.lhs << " ~~ " << l.rhs << " is " << cmp << "\n";);
   51              switch (cmp) {

   95          if (tn != tr) evidence.push_back(euf::enode_pair(tn, tr)), tn = tr;
   96:         TRACE("q", tout << mk_pp(s, m) << " ~~ " << mk_pp(t, m) << "\n";
   97                tout << ctx.bpp(sn) << " " << ctx.bpp(tn) << "\n";);

  241  
  242:                     TRACE("q", tout << "evidence " << ctx.bpp(a) << " " << ctx.bpp(b) << "\n");
  243                      evidence.push_back(euf::enode_pair(a, b));

z3/src/sat/smt/q_mam.cpp:
   955                  SASSERT(!is_quantifier(p));
   956:                 TRACE("mam", tout << "lin: " << reg << " " << get_check_mark(reg) << " " << is_var(p) << "\n";);
   957                  if (is_var(p)) {

  1302                  if (curr_compatibility > max_compatibility) {
  1303:                     TRACE("mam", tout << "better child " << best_child << " -> " << curr_child << "\n";);
  1304                      best_child         = curr_child;

  1511                  m_incompatible.reset();
  1512:                 TRACE("mam_compiler_detail", tout << "processing head: " << *head << "\n";);
  1513                  instruction * curr = head->m_next;

  1515                  while (curr != nullptr && curr->m_opcode != CHOOSE && curr->m_opcode != NOOP) {
  1516:                     TRACE("mam_compiler_detail", tout << "processing instr: " << *curr << "\n";);
  1517                      switch (curr->m_opcode) {

  1520                          if (is_compatible(bnd)) {
  1521:                             TRACE("mam_compiler_detail", tout << "compatible\n";);
  1522                              unsigned ireg     = bnd->m_ireg;

  1535                          else {
  1536:                             TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1537                              m_incompatible.push_back(curr);

  1543                          if (is_compatible(chk)) {
  1544:                             TRACE("mam_compiler_detail", tout << "compatible\n";);
  1545                              unsigned reg = chk->m_reg;

  1551                          else if (m_use_filters && is_semi_compatible(chk)) {
  1552:                             TRACE("mam_compiler_detail", tout << "semi compatible\n";);
  1553                              unsigned reg = chk->m_reg;

  1579                          else {
  1580:                             TRACE("mam_compiler_detail", tout << "incompatible " << chk->m_reg << "\n";);
  1581                              m_incompatible.push_back(curr);

  1586                          if (is_compatible(static_cast<compare*>(curr))) {
  1587:                             TRACE("mam_compiler_detail", tout << "compatible\n";);
  1588                              unsigned reg1   = static_cast<compare*>(curr)->m_reg1;

  1602                          else {
  1603:                             TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1604                              m_incompatible.push_back(curr);

  1623                              unsigned reg = flt->m_reg;
  1624:                             TRACE("mam_compiler_detail", tout << "compatible " << reg << "\n";);
  1625:                             CTRACE("mam_compiler_bug", !m_todo.contains(reg), {
  1626                                      for (unsigned t : m_todo) { tout << t << " "; }

  1641                              unsigned reg = flt->m_reg;
  1642:                             TRACE("mam_compiler_detail", tout << "semi compatible " << reg << "\n";);
  1643:                             CTRACE("mam_compiler_bug", !m_todo.contains(reg), {
  1644                                      for (unsigned t : m_todo) { tout << t << " "; }

  1652                              unsigned  h  = get_pat_lbl_hash(reg);
  1653:                             TRACE("mam_lbl_bug",
  1654                                    tout << "curr_set: " << flt->m_lbl_set << "\n";

  1671                          else {
  1672:                             TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1673                              m_incompatible.push_back(curr);

  1677                      default:
  1678:                         TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1679                          m_incompatible.push_back(curr);

  1685  
  1686:                 TRACE("mam_compiler", tout << *head << " " << head << "\n";
  1687                        tout << "m_compatible.size(): " << m_compatible.size() << "\n";

  1695                      choose * best_child = find_best_child(first_child);
  1696:                     TRACE("mam", tout << "best child " << best_child << "\n";);
  1697                      if (best_child == nullptr) {

  1780              r->m_num_choices  = m_num_choices;
  1781:             TRACE("mam_compiler", tout << "new tree for:\n" << mk_pp(mp, m) << "\n" << *r;);
  1782              return r;

  1798              m_is_tmp_tree = is_tmp_tree;
  1799:             TRACE("mam_compiler", tout << "updating tree with:\n" << mk_pp(mp, m) << "\n";);
  1800:             TRACE("mam_bug", tout << "before insertion\n" << *tree << "\n";);
  1801              if (!is_tmp_tree)

  1805              insert(tree->m_root, first_idx);
  1806:             TRACE("mam_bug",
  1807                    tout << "m_num_choices: " << m_num_choices << "\n";);

  1812              }
  1813:             TRACE("mam_bug",
  1814                    tout << "m_num_choices: " << m_num_choices << "\n";

  2006          void init(code_tree * t) {
  2007:             TRACE("mam_bug", tout << "preparing to match tree:\n" << *t << "\n";);
  2008              m_registers.reserve(t->get_num_regs(), nullptr);

  2017                  return;
  2018:             TRACE("trigger_bug", tout << "execute for code tree:\n"; t->display(tout););
  2019              init(t);

  2024                  while ((app = t->next_candidate()) && !ctx.resource_limits_exceeded()) {
  2025:                     TRACE("trigger_bug", tout << "candidate\n" << ctx.bpp(app) << "\n";);
  2026                      if (!app->is_marked3() && app->is_cgr()) {

  2033                  while ((app = t->next_candidate()) && !ctx.resource_limits_exceeded()) {
  2034:                     TRACE("trigger_bug", tout << "candidate\n" << ctx.bpp(app) << "\n";);
  2035                      if (app->is_cgr()) 

  2182          if (best_v == nullptr) {
  2183:             TRACE("mam_bug", tout << "m_top: " << m_top << ", m_backtrack_stack.size(): " << m_backtrack_stack.size() << "\n";
  2184                    tout << *c << "\n";);

  2262      bool interpreter::execute_core(code_tree * t, enode * n) {
  2263:         TRACE("trigger_bug", tout << "interpreter::execute_core\n"; t->display(tout); tout << "\nenode\n" << mk_ismt2_pp(n->get_expr(), m) << "\n";);
  2264          unsigned since_last_check = 0;

  2276          // It doesn't make sense to process an irrelevant enode.
  2277:         TRACE("mam_execute_core", tout << "EXEC " << t->get_root_lbl()->get_name() << "\n";);
  2278          if (!ctx.is_relevant(n))

  2293  
  2294:         TRACE("mam_int", display_pc_info(tout););
  2295  #ifdef _PROFILE_MAM

  2432                       goto backtrack;                                                                                    \
  2433:                  TRACE("mam_int", tout << "bind candidate: " << mk_pp(m_app->get_expr(), m) << "\n";);     \
  2434                   m_backtrack_stack[m_top].m_instr              = m_pc;                                                  \

  2631              m_pattern_instances.push_back(m_app);
  2632:             TRACE("mam_int", tout << "continue candidate:\n" << mk_ll_pp(m_app->get_expr(), m););
  2633              for (unsigned i = 0; i < m_num_args; i++)

  2650      backtrack:
  2651:         TRACE("mam_int", tout << "backtracking.\n";);
  2652          if (m_top == 0) {
  2653:             TRACE("mam_int", tout << "no more alternatives.\n";);
  2654  #ifdef _PROFILE_MAM

  2662  
  2663:         TRACE("mam_int", tout << "backtrack top: " << bp.m_instr << " " << *(bp.m_instr) << "\n";);
  2664  #ifdef _PROFILE_MAM

  2689              m_pc = static_cast<const choose*>(bp.m_instr)->m_alt;
  2690:             TRACE("mam_int", tout << "alt: " << m_pc << "\n";);
  2691              SASSERT(m_pc != 0);

  2702                         bp.m_curr = m_app;                                                                                       \
  2703:                        TRACE("mam_int", tout << "bind next candidate:\n" << mk_ll_pp(m_app->get_expr(), m););      \
  2704                         m_oreg    = m_b->m_oreg

  2782                      update_max_generation(m_app, nullptr); // null indicates a top-level match
  2783:                     TRACE("mam_int", tout << "continue next candidate:\n" << mk_ll_pp(m_app->get_expr(), m););
  2784                      m_num_args = c->m_num_args;

  2891              });
  2892:             TRACE("trigger_bug", tout << "after add_pattern, first_idx: " << first_idx << "\n"; m_trees[lbl_id]->display(tout););
  2893          }

  3100                  return;
  3101:             TRACE("q", tout << "candidate " << ctx.bpp(app) << "\n";);
  3102              if (!t->has_candidates()) {

  3133              m_is_clbl.reserve(lbl_id+1, false);
  3134:             TRACE("trigger_bug", tout << "update_clbls: " << lbl->get_name() << " is already clbl: " << m_is_clbl[lbl_id] << "\n";);
  3135:             TRACE("mam_bug", tout << "update_clbls: " << lbl->get_name() << " is already clbl: " << m_is_clbl[lbl_id] << "\n";);
  3136              if (m_is_clbl[lbl_id])

  3143                      update_lbls(app, h);
  3144:                     TRACE("mam_bug", tout << "updating labels of: #" << app->get_expr_id() << "\n";
  3145                            tout << "new_elem: " << h << "\n";

  3159                      r_plbls.insert(elem);
  3160:                     TRACE("trigger_bug", tout << "updating plabels of:\n" << mk_ismt2_pp(c->get_root()->get_expr(), m) << "\n";
  3161                            tout << "new_elem: " << static_cast<unsigned>(elem) << "\n";
  3162                            tout << "plbls:    " << c->get_root()->get_plbls() << "\n";);
  3163:                     TRACE("mam_bug", tout << "updating plabels of: #" << c->get_root()->get_expr_id() << "\n";
  3164                            tout << "new_elem: " << static_cast<unsigned>(elem) << "\n";

  3173              m_is_plbl.reserve(lbl_id+1, false);
  3174:             TRACE("trigger_bug", tout << "update_plbls: " << lbl->get_name() << " is already plbl: " << m_is_plbl[lbl_id] << ", lbl_id: " << lbl_id << "\n";
  3175                    tout << "mam: " << this << "\n";);
  3176:             TRACE("mam_bug", tout << "update_plbls: " << lbl->get_name() << " is already plbl: " << m_is_plbl[lbl_id] << "\n";);
  3177              if (m_is_plbl[lbl_id])

  3289              }
  3290:             TRACE("mam_path_tree_updt",
  3291                    tout << "updated path tree:\n";

  3327              }
  3328:             TRACE("mam_path_tree_updt",
  3329                    tout << "updated path tree:\n";

  3393                          m_egraph.set_lbl_hash(n);
  3394:                     TRACE("mam_bug",
  3395                            tout << "updating pc labels " << plbl->get_name() << " " <<

  3403                  func_decl * clbl = to_app(child)->get_decl();
  3404:                 TRACE("mam_bug", tout << "updating pc labels " << plbl->get_name() << " " << clbl->get_name() << "\n";);
  3405                  update_plbls(plbl);

  3415          void update_filters(quantifier * qa, app * mp) {
  3416:             TRACE("mam_bug", tout << "updating filters using:\n" << mk_pp(mp, m) << "\n";);
  3417              unsigned num_vars = qa->get_num_decls();

  3467          void collect_parents(enode * r, path_tree * t) {
  3468:             TRACE("mam", tout << ctx.bpp(r) << " " << t << "\n";);
  3469              if (t == nullptr)

  3488  #endif
  3489:                 TRACE("mam_path_tree",
  3490                        tout << "processing:\n";

  3533  
  3534:                     TRACE("mam_path_tree", tout << "processing: #" << curr_child->get_expr_id() << "\n";);
  3535                      for (enode* curr_parent : euf::enode_parents(curr_child)) {

  3548                          enode * curr_parent_cg     = curr_parent->get_cg();
  3549:                         TRACE("mam_path_tree", tout << "processing parent:\n" << mk_pp(curr_parent->get_expr(), m) << "\n";);
  3550:                         TRACE("mam_path_tree", tout << "parent is marked: " << curr_parent->is_marked1() << "\n";);
  3551                          if (filter.may_contain(m_lbl_hasher(lbl)) &&

  3579                                          if (curr_tree->m_code) {
  3580:                                             TRACE("mam_path_tree", tout << "found candidate " << expr_ref(curr_parent->get_expr(), m) << "\n";);
  3581                                              add_candidate(curr_tree->m_code, curr_parent);

  3628              approx_set & plbls2 = r2->get_plbls();
  3629:             TRACE("incremental_matcher", tout << "pp: plbls1: " << plbls1 << ", plbls2: " << plbls2 << "\n";);
  3630:             TRACE("mam_info", tout << "pp: " << plbls1.size() * plbls2.size() << "\n";);
  3631              if (!plbls1.empty() && !plbls2.empty()) {

  3689  
  3690:             TRACE("mam_new_pat", tout << "matching new patterns:\n";);
  3691              m_tmp_trees_to_delete.reset();

  3748              SASSERT(m.is_pattern(mp));
  3749:             TRACE("trigger_bug", tout << "adding pattern\n" << mk_ismt2_pp(qa, m) << "\n" << mk_ismt2_pp(mp, m) << "\n";);
  3750:             TRACE("mam_bug", tout << "adding pattern\n" << mk_pp(qa, m) << "\n" << mk_pp(mp, m) << "\n";);
  3751              // Z3 checks if a pattern is ground or not before solving.

  3793          void propagate() override {
  3794:             TRACE("trigger_bug", tout << "match\n"; display(tout););
  3795              propagate_to_match();

  3814          bool check_missing_instances() override {
  3815:             TRACE("missing_instance", tout << "checking for missing instances...\n";);
  3816              flet<bool> l(m_check_missing_instances, true);

  3821          void on_match(quantifier * qa, app * pat, unsigned num_bindings, enode * const * bindings, unsigned max_generation) override {
  3822:             TRACE("trigger_bug", tout << "found match " << mk_pp(qa, m) << "\n";);
  3823              unsigned min_gen = 0, max_gen = 0;

  3831          void add_node(enode * n, bool lazy) override {
  3832:             TRACE("trigger_bug", tout << "relevant_eh:\n" << mk_ismt2_pp(n->get_expr(), m) << "\n";
  3833                    tout << "mam: " << this << "\n";);
  3834:             TRACE("mam", tout << "relevant_eh: #" << n->get_expr_id() << "\n";);
  3835              if (n->has_lbl_hash())

  3840                  unsigned h      = m_lbl_hasher(lbl);
  3841:                 TRACE("trigger_bug", tout << "lbl: " << lbl->get_name() << " is_clbl(lbl): " << is_clbl(lbl)
  3842                        << ", is_plbl(lbl): " << is_plbl(lbl) << ", h: " << h << "\n";

  3847                      update_children_plbls(n, h);
  3848:                 TRACE("mam_bug", tout << "adding relevant candidate:\n" << mk_ll_pp(n->get_expr(), m) << "\n";);
  3849                  if (!lazy)

  3861  
  3862:             TRACE("mam", tout << "on_merge: #" << other->get_expr_id() << " #" << root->get_expr_id() << "\n";);
  3863:             TRACE("mam_inc_bug_detail", m_egraph.display(tout););
  3864:             TRACE("mam_inc_bug",
  3865                    tout << "before:\n#" << other->get_expr_id() << " #" << root->get_expr_id() << "\n";

  3883              root_plbls |= other_plbls;
  3884:             TRACE("mam_inc_bug",
  3885                    tout << "after:\n";

z3/src/sat/smt/q_mbi.cpp:
  197          auto proj = solver_project(mdl, qb, eqs, false);
  198:         CTRACE("q", !proj, tout << "could not project " << qb.mbody << " " << eqs << "\n" << mdl);
  199          if (!proj)

  231          ctx.rewrite(proj);
  232:         TRACE("q", tout << "project: " << proj << "\n";);
  233          IF_VERBOSE(11, verbose_stream() << "mbi:\n" << mk_pp(q, m) << "\n" << proj << "\n");

  277              mbody = mk_not(m, mbody);
  278:         TRACE("q", tout << "specialize " << mbody << "\n";);
  279          return result;

  316          m_defs.reset();
  317:         TRACE("q",
  318                tout << "Project\n";

  334              if (p && !fmls_extracted) {
  335:                 TRACE("q", tout << "domain eqs\n" << qb.domain_eqs << "\n";);
  336                                  

  340                      if (!m_model->is_true(e)) {
  341:                         TRACE("q", tout << "not true: " << mk_pp(e, m) << " := " << (*m_model)(e) << "\n");
  342                          return expr_ref(nullptr, m);

  354              else if (!(*p)(*m_model, vars, fmls)) {
  355:                 TRACE("q", tout << "theory projection failed\n");
  356                  return expr_ref(m);

  362              term = replace_model_value(val);
  363:             TRACE("euf", tout << "replaced model value " << term << "\nfrom\n" << val << "\n");
  364              rep.insert(v, term);

  369          rep(fmls);
  370:         TRACE("q", tout << "generated formulas\n" << fmls << "\ngenerated eqs:\n" << eqs << "\n";
  371                      for (auto const& [v,t] : m_defs) tout << v << " := " << t << "\n");

z3/src/sat/smt/q_model_fixer.cpp:
   72  
   73:         TRACE("q", tout << "start: " << mdl << "\n";);
   74          m_dependencies.reset();

   98  	}
   99:         TRACE("q", tout << "end: " << mdl << "\n";);
  100      }

  254          auto& v2r = ctx.values2root();
  255:         TRACE("q",
  256                tout << "invert-app " << mk_pp(t, m) << " =\n" << mk_pp(value, m) << "\n";

  275      void model_fixer::invert_arg(app* t, unsigned i, expr* value, expr_ref_vector& lits) {
  276:         TRACE("q", tout << "invert-arg " << mk_pp(t, m) << " " << i << " " << mk_pp(value, m) << "\n";);
  277          auto const* md = get_projection_data(t->get_decl(), i);

  328      expr_ref model_fixer::restrict_arg(app* t, unsigned i) {
  329:         TRACE("q", tout << "restrict-arg " << mk_pp(t, m) << " " << i << "\n";);
  330          auto const* md = get_projection_data(t->get_decl(), i);

z3/src/sat/smt/q_queue.cpp:
   43      void queue::setup() {
   44:         TRACE("q", tout << "qi_cost: " << m_params.m_qi_cost << "\n";);
   45          if (!m_parser.parse_string(m_params.m_qi_cost.c_str(), m_cost_function)) {

  107          m_vals[CS_FACTOR]          = static_cast<float>(stat->get_case_split_factor());
  108:         TRACE("q_detail", for (unsigned i = 0; i < m_vals.size(); i++) { tout << m_vals[i] << " "; } tout << "\n";);
  109      }

  198                  // do not delay instances that produce a conflict.
  199:                 TRACE("q", tout << "promoting instance that produces a conflict\n" << mk_pp(f.q(), m) << "\n";);
  200                  instantiate(curr);

  202              else {
  203:                 TRACE("q", tout << "delaying quantifier instantiation... " << f << "\n" << mk_pp(f.q(), m) << "\ncost: " << curr.m_cost << "\n";);
  204                  m_delayed_entries.push_back(curr);

  229              for (entry & e : m_delayed_entries) {
  230:                 TRACE("q", tout << e.m_qb << ", cost: " << e.m_cost << ", instantiated: " << e.m_instantiated << "\n";);
  231                  if (!e.m_instantiated && e.m_cost <= m_params.m_qi_lazy_threshold && (!init || e.m_cost < cost_limit)) {

z3/src/sat/smt/q_solver.cpp:
  360      void solver::log_instantiation(unsigned n, sat::literal const* lits, justification* j) {
  361:         TRACE("q", for (unsigned i = 0; i < n; ++i) tout << literal2expr(lits[i]) << "\n";);
  362          if (get_config().m_instantiations2console) {

z3/src/sat/smt/recfun_solver.cpp:
   22  
   23: #define TRACEFN(x) TRACE("recfun", tout << x << '\n';)
   24  

  238          if (!visit_rec(m, e, sign, root)) {
  239:             TRACE("array", tout << mk_pp(e, m) << "\n";);
  240              return sat::null_literal;

z3/src/sat/smt/sat_th.h:
  187          void force_push() {
  188:             CTRACE("euf_verbose", m_num_scopes > 0, tout << "push-core " << m_num_scopes << "\n";);
  189              for (; m_num_scopes > 0; --m_num_scopes) push_core();

z3/src/sat/smt/user_solver.cpp:
  254          if (!visit_rec(m, e, sign, root)) {
  255:             TRACE("array", tout << mk_pp(e, m) << "\n";);
  256              return sat::null_literal;

z3/src/sat/smt/xor_solver.d:
   33          unsigned sz = x.size();
   34:         TRACE("ba", tout << "assign: "  << ~alit << "@" << lvl(~alit) << " " << x << "\n"; display(tout, x, true); );
   35  

   49                  x.watch_literal(*this, ~lit);
   50:                 TRACE("ba", tout << "swap in: " << lit << " " << x << "\n";);
   51                  return l_undef;

  190          SASSERT(js.get_kind() == justification::EXT_JUSTIFICATION);
  191:         TRACE("ba", tout << l << ": " << js << "\n"; 
  192                for (unsigned i = 0; i <= index; ++i) tout << s().m_trail[i] << " "; tout << "\n";

  198          while (true) {
  199:             TRACE("ba", tout << "process: " << l << " " << js << "\n";);
  200              if (js.get_kind() == justification::EXT_JUSTIFICATION) {
  201                  constraint& c = index2constraint(js.get_ext_justification_idx());
  202:                 TRACE("ba", tout << c << "\n";);
  203                  if (!c.is_xr()) {

  215                          if (lvl(lit) == level) {
  216:                             TRACE("ba", tout << "mark: " << lit << "\n";);
  217                              ++num_marks;

  261          m_parity_trail.reset();
  262:         TRACE("ba", tout << r << "\n";);
  263      }

  292          if (x.lit() != null_literal) r.push_back(x.lit());
  293:         // TRACE("ba", display(tout << l << " ", x, true););
  294          SASSERT(x.lit() == null_literal || value(x.lit()) == l_true);

z3/src/sat/tactic/goal2sat.cpp:
  156      void mk_clause(unsigned n, sat::literal * lits, euf::th_proof_hint* ph) {
  157:         TRACE("goal2sat", tout << "mk_clause: "; for (unsigned i = 0; i < n; i++) tout << lits[i] << " "; tout << "\n";);
  158          if (relevancy_enabled())

  177      void mk_root_clause(unsigned n, sat::literal * lits, euf::th_proof_hint* ph = nullptr) {
  178:         TRACE("goal2sat", tout << "mk_root_clause: "; for (unsigned i = 0; i < n; i++) tout << lits[i] << " "; tout << "\n";);
  179          if (relevancy_enabled())

  323                      m_solver.set_external(v);
  324:                 TRACE("sat", tout << "new_var: " << v << ": " << mk_bounded_pp(t, m, 2) << " " << is_uninterp_const(t) << "\n";);
  325              }

  395              }                
  396:             TRACE("goal2sat_not_handled", tout << mk_ismt2_pp(t, m) << "\n";);
  397              std::ostringstream strm;

  407      void convert_or(app * t, bool root, bool sign) {
  408:         TRACE("goal2sat", tout << "convert_or:\n" << mk_bounded_pp(t, m, 2) << " root " << root << " stack " << m_result_stack.size() << "\n";);        
  409          unsigned num = t->get_num_args();

  458      void convert_and(app * t, bool root, bool sign) {
  459:         TRACE("goal2sat", tout << "convert_and:\n" << mk_bounded_pp(t, m, 2) << " root: " << root  << " result stack: " << m_result_stack.size() << "\n";);
  460  

  684          SASSERT(m_euf);
  685:         TRACE("goal2sat", tout << "convert-euf " << mk_bounded_pp(e, m, 2) << " root " << root << "\n";);
  686          euf::solver* euf = ensure_euf();

  782      void process(expr* n, bool is_root) {
  783:         TRACE("goal2sat", tout << "process-begin " << mk_bounded_pp(n, m, 2) 
  784              << " root: " << is_root 

  802              bool sign  = _fr.m_sign;
  803:             TRACE("goal2sat_bug", tout << "result stack\n";
  804              tout << "ref-count: " << t->get_ref_count() << "\n";

  821                      goto loop;
  822:                 TRACE("goal2sat_bug", tout << "visit " << mk_bounded_pp(arg, m, 2) << " result stack: " << m_result_stack.size() << "\n";);
  823              }
  824:             TRACE("goal2sat_bug", tout << "converting\n";
  825                    tout << mk_bounded_pp(t, m, 2) << " root: " << root << " sign: " << sign << "\n";

  830          }
  831:         TRACE("goal2sat", tout 
  832              << "done process: " << mk_bounded_pp(n, m, 3) 

  842          SASSERT(n->get_ref_count() > 0);
  843:         TRACE("goal2sat", tout << "internalize " << mk_bounded_pp(n, m, 2) << "\n";);
  844          process(n, false);

  846          sat::literal result = m_result_stack.back();
  847:         TRACE("goal2sat", tout << "done internalize " << result << " " << mk_bounded_pp(n, m, 2) << "\n";);
  848          m_result_stack.pop_back();

  888          VERIFY(m_result_stack.empty());
  889:         TRACE("goal2sat", tout << "assert: " << mk_bounded_pp(n, m, 3) << "\n";);
  890          process(n, true);
  891:         CTRACE("goal2sat", !m_result_stack.empty(), tout << m_result_stack << "\n";);
  892          SASSERT(m_result_stack.empty());

  979              }
  980:             TRACE("goal2sat", tout << mk_bounded_pp(f, m, 2) << "\n";);
  981              process(f);

z3/src/sat/tactic/sat_tactic.cpp:
   47              bool produce_core = g->unsat_core_enabled();
   48:             TRACE("before_sat_solver", g->display(tout););
   49              g->elim_redundancies();

   53              m_goal2sat(*g, m_params, *m_solver, map, dep2asm);
   54:             TRACE("sat", tout << "interpreted_atoms: " << m_goal2sat.has_interpreted_funs() << "\n";
   55                    func_decl_ref_vector funs(m);

   70              IF_VERBOSE(TACTIC_VERBOSITY_LVL, m_solver->display_status(verbose_stream()););
   71:             TRACE("sat_dimacs", m_solver->display_dimacs(tout););
   72              dep2assumptions(dep2asm, assumptions);
   73              lbool r = m_solver->check(assumptions.size(), assumptions.data());
   74:             TRACE("sat", tout << "result of checking: " << r << " "; 
   75                    if (r == l_undef) tout << m_solver->get_reason_unknown(); tout << "\n";

   97                      sat::model const & ll_m = m_solver->get_model();
   98:                     TRACE("sat_tactic", for (unsigned i = 0; i < ll_m.size(); i++) tout << i << ":" << ll_m[i] << " "; tout << "\n";);
   99                      for (auto const& kv : map) {

  106                              continue;
  107:                         TRACE("sat_tactic", tout << "extracting value of " << mk_ismt2_pp(n, m) << "\nvar: " << v << "\n";);
  108                          switch (sat::value_at(v, ll_m)) {

  126                      m_goal2sat.update_model(md);
  127:                     TRACE("sat_tactic", model_v2_pp(tout, *md););
  128                      g->add(model2model_converter(md.get()));

  230              proc.m_solver->collect_statistics(m_stats);
  231:             TRACE("sat", tout << ex.msg() << "\n";);            
  232              throw;
  233          }
  234:         TRACE("sat_stats", m_stats.display_smt2(tout););
  235      }

z3/src/sat/tactic/sat2goal.cpp:
  142      // apply externalized model converter
  143:     CTRACE("sat_mc", m_gmc, m_gmc->display(tout << "before sat_mc\n"); model_v2_pp(tout, *md););
  144      if (m_gmc) (*m_gmc)(md);
  145:     CTRACE("sat_mc", m_gmc, m_gmc->display(tout << "after sat_mc\n"); model_v2_pp(tout, *md););
  146  }

  163      }
  164:     TRACE("sat_mc", tout << "insert " << v << "\n";);
  165  }

z3/src/shell/datalog_frontend.cpp:
  166  
  167:     TRACE("dl_compiler", ctx.display(tout););
  168  

  195  
  196:             TRACE("dl_compiler", rules_code.display(ex_ctx, tout););
  197  

  234  
  235:         TRACE("dl_compiler", ctx.display(tout);
  236                rules_code.display(ex_ctx, tout););

z3/src/smt/arith_eq_adapter.cpp:
   46              m_already_processed.erase(m_n1, m_n2);
   47:             TRACE("arith_eq_adapter_profile", tout << "del #" << m_n1->get_owner_id() << " #" << m_n2->get_owner_id() << "\n";);
   48          }

   85          ast_manager & m = get_manager();
   86:         TRACE("arith_eq_adapter_mk_axioms", tout << "#" << n1->get_owner_id() << " #" << n2->get_owner_id() << "\n";
   87                tout << mk_ismt2_pp(n1->get_expr(), m) << "\n" << mk_ismt2_pp(n2->get_expr(), m) << "\n";);

  107          
  108:         CTRACE("arith_eq_adapter_relevancy", !(ctx.is_relevant(n1) && ctx.is_relevant(n2)),
  109                 tout << "is_relevant(n1): #" << n1->get_owner_id() << " " << ctx.is_relevant(n1) << "\n";

  121          
  122:         TRACE("arith_eq_adapter_profile", tout << "mk #" << n1->get_owner_id() << " #" << n2->get_owner_id() << " " <<
  123                m_already_processed.size() << " " << ctx.get_scope_level() << "\n";);

  126          
  127:         TRACE("arith_eq_adapter_profile_detail", 
  128                tout << "mk_detail " << mk_bounded_pp(n1->get_expr(), m, 5) << " " << 

  134          
  135:         TRACE("arith_eq_adapter_bug", tout << mk_bounded_pp(t1_eq_t2, m) << "\n" 
  136                << mk_bounded_pp(t1, m) << "\n"

  178          }
  179:         TRACE("arith_eq_adapter_perf",
  180                tout << mk_ismt2_pp(t1_eq_t2, m) << "\n" << mk_ismt2_pp(le, m) << "\n" << mk_ismt2_pp(ge, m) << "\n";);

  183          m_already_processed.insert(n1, n2, data(t1_eq_t2, le, ge));
  184:         TRACE("arith_eq_adapter_profile", tout << "insert #" << n1->get_owner_id() << " #" << n2->get_owner_id() << "\n";);
  185          ctx.internalize(t1_eq_t2, true); 
  186          literal t1_eq_t2_lit(ctx.get_bool_var(t1_eq_t2)); 
  187:         TRACE("interface_eq", 
  188                tout << "core should try true phase first for the equality: " << t1_eq_t2_lit << "\n";

  190                tout << "try_true_first: " << ctx.try_true_first(t1_eq_t2_lit.var()) << "\n";);
  191:         TRACE("arith_eq_adapter_bug",
  192                tout << "le: " << mk_ismt2_pp(le, m) << "\nge: " << mk_ismt2_pp(ge, m) << "\n";);

  212          ctx.mk_th_axiom(tid, t1_eq_t2_lit, ~le_lit, ~ge_lit, m_proof_hint.size(), m_proof_hint.data());
  213:         TRACE("arith_eq_adapter", tout << "internalizing: "
  214                << " " << mk_pp(le, m) << ": " << le_lit 

  218          if (m_owner.get_fparams().m_arith_add_binary_bounds) {
  219:             TRACE("arith_eq_adapter", tout << "adding binary bounds...\n";);
  220              ctx.mk_th_axiom(tid, le_lit, ge_lit, m_proof_hint.size(), m_proof_hint.data());

  230          }
  231:         TRACE("arith_eq_adapter_detail", ctx.display(tout););
  232      }

  234      void arith_eq_adapter::new_eq_eh(theory_var v1, theory_var v2) {
  235:         TRACE("arith_eq_adapter", tout << "v" << v1 << " = v" << v2 << " #" << get_enode(v1)->get_owner_id() << " = #" << get_enode(v2)->get_owner_id() << "\n";);
  236:         TRACE("arith_eq_adapter_bug", tout << mk_bounded_pp(get_enode(v1)->get_expr(), get_manager()) << "\n" << mk_bounded_pp(get_enode(v2)->get_expr(), get_manager()) << "\n";);
  237          mk_axioms(get_enode(v1), get_enode(v2));

  240      void arith_eq_adapter::new_diseq_eh(theory_var v1, theory_var v2) {
  241:         TRACE("arith_eq_adapter", tout << "v" << v1 << " != v" << v2 << " #" << get_enode(v1)->get_owner_id() << " != #" << get_enode(v2)->get_owner_id() << "\n";);
  242          mk_axioms(get_enode(v1), get_enode(v2));

  249      void arith_eq_adapter::reset_eh() {
  250:         TRACE("arith_eq_adapter", tout << "reset\n";);
  251          m_already_processed .reset();

  257          context & ctx = get_context();
  258:         TRACE("arith_eq_adapter", tout << "restart\n";);
  259          enode_pair_vector tmp(m_restart_pairs);

  263                  break;
  264:             TRACE("arith_eq_adapter", tout << "creating arith_eq_adapter axioms at the base level #" << p.first->get_owner_id() << " #" <<
  265                    p.second->get_owner_id() << "\n";);

z3/src/smt/arith_eq_solver.cpp:
  163  {
  164:     TRACE("arith_eq_solver", print_row(tout << "solving: ", values); );
  165      //

  200      if (!gcd_test(values)) {
  201:         TRACE("arith_eq_solver", print_row(tout << "not sat\n", values););
  202          return false;

  234  
  235:     TRACE("arith_eq_solver",
  236            tout << "solved at index " << index << ": ";

  250      SASSERT(1 <= index && index < s.size());
  251:     TRACE("arith_eq_solver",
  252            tout << "substitute " << index << ":\n";

  320  
  321:     TRACE("arith_eq_solver",
  322            tout << "result: ";

  345  
  346:     TRACE("arith_eq_solver", print_rows(tout << "solving:\n", rows););
  347  

  355              unsat_row = r;
  356:             TRACE("arith_eq_solver", print_row(tout << "input is unsat: ", unsat_row); );
  357              return false;

  364              unsat_row = r;
  365:             TRACE("arith_eq_solver", print_row(tout << "unsat: ", unsat_row); );
  366              return false;

  393  
  394:     TRACE("arith_eq_solver",
  395            tout << ((done.size()<=1)?"solved ":"incomplete check ") << done.size() << "\n";

  435  
  436:             TRACE("arith_eq_solver",
  437                    tout << "unsat:\n";

  476                      gcd_normalize(unsat_row);
  477:                     TRACE("arith_eq_solver",
  478                            tout << "gcd: ";

  484                  if (gcd_test(unsat_row)) {
  485:                     TRACE("arith_eq_solver", tout << "missed pure explanation\n";);
  486                      return true;

  543              unsat_row = r;
  544:             TRACE("arith_eq_solver", print_row(tout << "input is unsat: ", unsat_row); );
  545              return false;

  615                          unsat_row = r;
  616:                         TRACE("arith_eq_solver", print_row(tout << "unsat: ", unsat_row); );
  617                          return false;

  623  
  624:     TRACE("arith_eq_solver",
  625            tout << ((live.size()<=1)?"solved ":"incomplete check ") << live.size() << "\n";

z3/src/smt/diff_logic.h:
   314              --it;
   315:             TRACE("dl_bug", tout << "undo assignment: " << it->get_var() << " " << it->get_old_value() << "\n";);
   316              m_assignment[it->get_var()] = it->get_old_value();

   370  
   371:         TRACE("arith", display(tout << id << " " << gamma << "\n");
   372                display_edge(tout, last_e);

   413                      case DL_PROCESSED:
   414:                         TRACE("arith", display_edge(tout << "processed twice: ", e););
   415                          // if two edges with the same source/target occur in the graph.

   471      void init_var(dl_var v) {
   472:         TRACE("dl_bug", tout << "init_var " << v << "\n";);
   473          if (static_cast<unsigned>(v) < m_out_edges.size() && (!m_out_edges[v].empty() || !m_in_edges[v].empty())) {

   489          SASSERT(static_cast<unsigned>(v) < m_heap.get_bounds());
   490:         TRACE("dl_bug", tout << "init_var " << v << ", m_assignment[v]: " << m_assignment[v] << "\n";);
   491          SASSERT(m_assignment[v].is_zero());

   503          m_activity.push_back(0);
   504:         TRACE("dl_bug", tout << "creating edge:\n"; display_edge(tout, m_edges.back()););
   505          m_out_edges[source].push_back(new_id);

   605                      if (delta.is_nonneg() && (gamma + delta).is_neg()) {
   606:                         TRACE("diff_logic_traverse", tout << "Reducing path by ";
   607                                display_edge(tout, e2);

   621                      else {
   622:                         TRACE("diff_logic_traverse", display_edge(tout << "skipping: ", e2););
   623                      }

   633          
   634:         TRACE("diff_logic_traverse", {   
   635                  tout << "Num conflicts: " << num_conflicts << "\n";

   887              const edge & e = m_edges.back();
   888:             TRACE("dl_bug", tout << "deleting edge:\n"; display_edge(tout, e););
   889              dl_var source  = e.get_source();

   958      void acc_assignment(dl_var v, const numeral & inc) {
   959:         TRACE("dl_bug", tout << "update v: " << v << " += " << inc << " m_assignment[v] " << m_assignment[v] << "\n";);
   960          m_assignment_stack.push_back(assignment_trail(v, m_assignment[v]));

  1110                  if (!discovered.contains(next) && !explored.contains(next)) {
  1111:                     TRACE("diff_logic", tout << "thread[" << prev << "] --> " << next << std::endl;);
  1112                      threads[prev] = next;

  1151                  if (!visited.contains(next)) {
  1152:                     TRACE("diff_logic", tout << "parents[" << next << "] --> " << current << std::endl;);
  1153                      parents[next] = current;

  1207          }
  1208:         TRACE("eq_scc",
  1209                for (dl_var v = 0; v < n; v++) {

  1312              if (e.get_target() != e1.get_source()) {
  1313:                 TRACE("check_explanation", display_edge(tout, e); display_edge(tout, e1); );
  1314                  return false;

  1318          if (w.is_nonneg()) {
  1319:             TRACE("check_explanation", tout << "weight: " << w << "\n";);
  1320              return false;

  1332                  nodes[i] != m_edges[edges[i]].get_source()) {
  1333:                 TRACE("diff_logic_traverse", tout << "checking index " << i << " ";
  1334                        tout << "potential: " << potentials[i] << " ";

  1398              dl_var v = curr.m_var;
  1399:             TRACE("dl_bfs", tout << "processing: " << v << "\n";);
  1400              edge_id_vector & edges = m_out_edges[v];

  1407                  set_gamma(e, gamma);
  1408:                 TRACE("dl_bfs", display_edge(tout << "processing edge: ", e) << " gamma: " << gamma << "\n";);
  1409                  if (is_connected(gamma, zero_edge, e, timestamp)) {
  1410                      dl_var curr_target = e.get_target();
  1411:                     TRACE("dl_bfs", tout << "curr_target: " << curr_target << ", mark: " << bfs_mark[curr_target] << "\n";);
  1412                      if (curr_target == target) {
  1413:                         TRACE("dl_bfs", tout << "found path\n";);
  1414:                         TRACE("dl_eq_bug", tout << "path: " << source << " --> " << target << "\n";
  1415                                display_edge(tout, e);

  1427                                });
  1428:                         TRACE("dl_eq_bug", display_edge(tout, e););
  1429                          f(e.get_explanation());

  1437                                  edge & e = m_edges[curr.m_edge_id];
  1438:                                 TRACE("dl_eq_bug", display_edge(tout, e););
  1439                                  f(e.get_explanation());

  1557          unsigned num_relevant = 1;
  1558:         TRACE("diff_logic", display(tout); );
  1559                  

  1575              }
  1576:             TRACE("diff_logic", tout << "source: " << source << "\n";);
  1577    

  1588                  }
  1589:                 TRACE("diff_logic", display_edge(tout, e););
  1590                  target = is_fw?e.get_target():e.get_source();

  1625                  case DL_PROP_PROCESSED_RELEVANT: 
  1626:                     TRACE("diff_logic", tout << delta << " ?> " << state.m_delta[target] << "\n";);
  1627                      SASSERT(delta >= state.m_delta[target]);

  1630                  case DL_PROP_PROCESSED_IRRELEVANT: 
  1631:                     TRACE("diff_logic", tout << delta << " ?> " << state.m_delta[target] << "\n";);
  1632                      SASSERT(delta >= state.m_delta[target]);

  1657  
  1658:         TRACE("diff_logic", {
  1659                  tout << (is_fw?"is_fw":"is_bw") << ": ";

  1679          vector<edge_id_vector> const& edges = m_out_edges;
  1680:         TRACE("diff_logic", tout << "$" << a << " a:" << m_assignment[a] << " $" << b << " b: " << m_assignment[b] 
  1681                << " e0: " << e0.get_weight() << " n0: " << n0 << "\n";

  1697                  if (tgt.contains(d) && n2 <= e1.get_weight()) {
  1698:                     TRACE("diff_logic", 
  1699                            tout << "$" << c << " delta_c: " << src.m_delta[c] << " c: " << m_assignment[c] << "\n";

  1718          if (!subsumed.empty()) {
  1719:             TRACE("diff_logic", 
  1720                    display(tout);

  1845  
  1846:         TRACE("diff_logic", 
  1847                display_edge(tout << "bridge:   ", e1); 

  1854              m_mark[v] = DL_PROCESSED;
  1855:             TRACE("diff_logic", tout << v << "\n";);
  1856  

  1868                  m_parent[w] = e_id;
  1869:                 TRACE("diff_logic", tout << w << " : " << gamma << " " << e2.get_weight() << "\n";);
  1870                  if (w == dst2 && gamma <= e2.get_weight()) {

z3/src/smt/dyn_ack.cpp:
   96              app_ref lemma(m.mk_or(lits), m);
   97:             TRACE("dyn_ack", tout << lemma << "\n";);
   98:             TRACE("dyn_ack", tout << false_pr << "\n";);
   99              return m.mk_lemma(false_pr, lemma);

  213          if (m_app_pair2num_occs.find(n1, n2, num_occs)) {
  214:             TRACE("dyn_ack", tout << "used_cg_eh:\n" << mk_pp(n1, m) << "\n" << mk_pp(n2, m) << "\nnum_occs: " << num_occs << "\n";);
  215              num_occs++;

  229          if (num_occs == m_params.m_dack_threshold) {
  230:             TRACE("dyn_ack", tout << "found candidate:\n" << mk_pp(n1, m) << "\n" << mk_pp(n2, m) << "\nnum_occs: " << num_occs << "\n";);
  231              m_to_instantiate.push_back(p);

  240              std::swap(n1,n2);
  241:         TRACE("dyn_ack", 
  242                tout << mk_pp(n1, m) << " = " << mk_pp(n2, m) << " = " << mk_pp(r, m) << "\n";);

  248          if (m_triple.m_app2num_occs.find(n1, n2, r, num_occs)) {
  249:             TRACE("dyn_ack", tout << mk_pp(n1, m) << "\n" << mk_pp(n2, m) << "\n"
  250                    << mk_pp(r, m) << "\n" << "\nnum_occs: " << num_occs << "\n";);

  266          if (num_occs == m_params.m_dack_threshold) {
  267:             TRACE("dyn_ack", tout << "found candidate:\n" << mk_pp(n1, m) << "\n" << mk_pp(n2, m) 
  268                    << "\n" << mk_pp(r, m) 

  295      void dyn_ack_manager::gc() {
  296:         TRACE("dyn_ack", tout << "dyn_ack GC\n";);
  297          unsigned num_deleted = 0;

  305              if (m_instantiated.contains(p)) {
  306:                 TRACE("dyn_ack", tout << "1) erasing:\n" << mk_pp(p.first, m) << "\n" << mk_pp(p.second, m) << "\n";);
  307                  m.dec_ref(p.first);

  321                  num_deleted++;
  322:                 TRACE("dyn_ack", tout << "2) erasing:\n" << mk_pp(p.first, m) << "\n" << mk_pp(p.second, m) << "\n";);
  323                  m_app_pair2num_occs.erase(p.first, p.second);

  401          literal l = m_context.get_literal(eq);
  402:         TRACE("dyn_ack", tout << "eq:\n" << mk_pp(eq, m) << "\nliteral: "; 
  403                m_context.display_literal(tout, l); tout << "\n";);

  412          m_context.m_stats.m_num_dyn_ack++;
  413:         TRACE("dyn_ack_inst", tout << "dyn_ack: " << n1->get_id() << " " << n2->get_id() << "\n";);
  414:         TRACE("dyn_ack", tout << "expanding Ackermann's rule for:\n" << mk_pp(n1, m) << "\n" << mk_pp(n2, m) << "\n";);
  415          unsigned num_args = n1->get_num_args();

  438          }
  439:         TRACE("dyn_ack_clause", tout << "new clause:\n"; m_context.display_clause_detail(tout, cls); tout << "\n";);
  440          m_clause2app_pair.insert(cls, p);

  464          ctx.m_stats.m_num_dyn_ack++;
  465:         TRACE("dyn_ack_inst", tout << "dyn_ack: " << n1->get_id() << " " << n2->get_id() << " " << r->get_id() << "\n";);
  466:         TRACE("dyn_ack", tout << "expanding Ackermann's rule for:\n" << mk_pp(n1, m) << "\n" 
  467                << mk_pp(n2, m) << "\n"

  494          }
  495:         TRACE("dyn_ack_clause", ctx.display_clause_detail(tout << "new clause:\n", cls); tout << "\n";);
  496          m_triple.m_clause2apps.insert(cls, tr);

  520      void dyn_ack_manager::gc_triples() {
  521:         TRACE("dyn_ack", tout << "dyn_ack GC\n";);
  522          unsigned num_deleted = 0;

  530              if (m_triple.m_instantiated.contains(p)) {
  531:                 TRACE("dyn_ack", tout << "1) erasing:\n" << mk_pp(p.first, m) << "\n" << mk_pp(p.second, m) << "\n";);
  532                  m.dec_ref(p.first);

  547                  num_deleted++;
  548:                 TRACE("dyn_ack", tout << "2) erasing:\n" << mk_pp(p.first, m) << "\n" << mk_pp(p.second, m) << "\n";);
  549                  m_triple.m_app2num_occs.erase(p.first, p.second, p.third);

z3/src/smt/expr_context_simplifier.cpp:
  169  void expr_context_simplifier::insert_context(expr* e, bool polarity) {
  170:     TRACE("expr_context_simplifier", tout << mk_pp(e, m_manager) << "\n";);
  171      if (m_manager.is_not(e)) {

  183      reduce_rec(arg, tmp);
  184:     TRACE("expr_context_simplifier", tout << mk_pp(arg, m_manager) << " -> " << mk_pp(tmp.get(), m_manager) << "\n";);    
  185      if (is_true(tmp.get()) && is_and) {

  433  
  434:         TRACE("expr_context_simplifier", 
  435                tout << mk_pp(e, m_manager) 

  709  
  710:         TRACE("expr_context_simplifier", 
  711                tout << mk_pp(e, m_manager) 

z3/src/smt/fingerprints.cpp:
   71          if (m_set.contains(d)) {
   72:             TRACE("fingerprint_bug", tout << "failed: " << *d;);
   73              return nullptr;
   74          }
   75:         TRACE("fingerprint_bug", tout << "inserting @" << m_scopes.size() << " " << *d;);
   76          fingerprint * f = new (m_region) fingerprint(m_region, data, data_hash, def, num_args, d->m_args);

  114          m_scopes.shrink(new_lvl);
  115:         TRACE("fingerprint_bug", tout << "pop @" << m_scopes.size() << "\n";);
  116      }

  140              if (i == num_args) {
  141:                 TRACE("missing_instance_detail", tout << "found instance data: " << data << "=" << *f;);
  142                  return true;

z3/src/smt/mam.cpp:
   915                  SASSERT(!is_quantifier(p));
   916:                 TRACE("mam", tout << "lin: " << reg << " " << get_check_mark(reg) << " " << is_var(p) << "\n";);
   917                  if (is_var(p)) {

  1275                  if (curr_compatibility > max_compatibility) {
  1276:                     TRACE("mam", tout << "better child " << best_child << " -> " << curr_child << "\n";);
  1277                      best_child         = curr_child;

  1484                  m_incompatible.reset();
  1485:                 TRACE("mam_compiler_detail", tout << "processing head: " << *head << "\n";);
  1486                  instruction * curr = head->m_next;

  1488                  while (curr != nullptr && curr->m_opcode != CHOOSE && curr->m_opcode != NOOP) {
  1489:                     TRACE("mam_compiler_detail", tout << "processing instr: " << *curr << "\n";);
  1490                      switch (curr->m_opcode) {

  1493                          if (is_compatible(bnd)) {
  1494:                             TRACE("mam_compiler_detail", tout << "compatible\n";);
  1495                              unsigned ireg     = bnd->m_ireg;

  1508                          else {
  1509:                             TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1510                              m_incompatible.push_back(curr);

  1516                          if (is_compatible(chk)) {
  1517:                             TRACE("mam_compiler_detail", tout << "compatible\n";);
  1518                              unsigned reg = chk->m_reg;

  1524                          else if (m_use_filters && is_semi_compatible(chk)) {
  1525:                             TRACE("mam_compiler_detail", tout << "semi compatible\n";);
  1526                              unsigned reg = chk->m_reg;

  1552                          else {
  1553:                             TRACE("mam_compiler_detail", tout << "incompatible " << chk->m_reg << "\n";);
  1554                              m_incompatible.push_back(curr);

  1559                          if (is_compatible(static_cast<compare*>(curr))) {
  1560:                             TRACE("mam_compiler_detail", tout << "compatible\n";);
  1561                              unsigned reg1   = static_cast<compare*>(curr)->m_reg1;

  1575                          else {
  1576:                             TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1577                              m_incompatible.push_back(curr);

  1596                              unsigned reg = flt->m_reg;
  1597:                             TRACE("mam_compiler_detail", tout << "compatible " << reg << "\n";);
  1598:                             CTRACE("mam_compiler_bug", !m_todo.contains(reg), {
  1599                                      for (unsigned t : m_todo) { tout << t << " "; }

  1614                              unsigned reg = flt->m_reg;
  1615:                             TRACE("mam_compiler_detail", tout << "semi compatible " << reg << "\n";);
  1616:                             CTRACE("mam_compiler_bug", !m_todo.contains(reg), {
  1617                                      for (unsigned t : m_todo) { tout << t << " "; }

  1625                              unsigned  h  = get_pat_lbl_hash(reg);
  1626:                             TRACE("mam_lbl_bug",
  1627                                    tout << "curr_set: " << flt->m_lbl_set << "\n";

  1644                          else {
  1645:                             TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1646                              m_incompatible.push_back(curr);

  1650                      default:
  1651:                         TRACE("mam_compiler_detail", tout << "incompatible\n";);
  1652                          m_incompatible.push_back(curr);

  1658  
  1659:                 TRACE("mam_compiler", tout << *head << " " << head << "\n";
  1660                        tout << "m_compatible.size(): " << m_compatible.size() << "\n";

  1670                      choose * best_child = find_best_child(first_child);
  1671:                     TRACE("mam", tout << "best child " << best_child << "\n";);
  1672                      if (best_child == nullptr) {

  1755              r->m_num_choices  = m_num_choices;
  1756:             TRACE("mam_compiler", tout << "new tree for:\n" << mk_pp(mp, m) << "\n" << *r;);
  1757              return r;

  1773              m_is_tmp_tree = is_tmp_tree;
  1774:             TRACE("mam_compiler", tout << "updating tree with:\n" << mk_pp(mp, m) << "\n";);
  1775:             TRACE("mam_bug", tout << "before insertion\n" << *tree << "\n";);
  1776              if (!is_tmp_tree)

  1780              insert(tree->m_root, first_idx);
  1781:             TRACE("mam_bug",
  1782                    tout << "m_num_choices: " << m_num_choices << "\n";);

  1787              }
  1788:             TRACE("mam_bug",
  1789                    tout << "m_num_choices: " << m_num_choices << "\n";

  2001          void init(code_tree * t) {
  2002:             TRACE("mam_bug", tout << "preparing to match tree:\n" << *t << "\n";);
  2003              m_registers.reserve(t->get_num_regs(), nullptr);

  2009          bool execute(code_tree * t) {
  2010:             TRACE("trigger_bug", tout << "execute for code tree:\n"; t->display(tout););
  2011              init(t);

  2014                  for (enode* app : t->get_candidates()) {
  2015:                     TRACE("trigger_bug", tout << "candidate\n" << mk_ismt2_pp(app->get_expr(), m) << "\n";);
  2016                      if (!app->is_marked() && app->is_cgr()) {

  2028                  for (enode* app : t->get_candidates()) {
  2029:                     TRACE("trigger_bug", tout << "candidate\n" << mk_ismt2_pp(app->get_expr(), m) << "\n";);
  2030                      if (app->is_cgr()) {
  2031:                         TRACE("trigger_bug", tout << "is_cgr\n";);
  2032                          // scoped_suspend_rlimit susp(m.limit(), false);

  2193          if (best_v == nullptr) {
  2194:             TRACE("mam_bug", tout << "m_top: " << m_top << ", m_backtrack_stack.size(): " << m_backtrack_stack.size() << "\n";
  2195                    tout << *c << "\n";);

  2278      bool interpreter::execute_core(code_tree * t, enode * n) {
  2279:         TRACE("trigger_bug", tout << "interpreter::execute_core\n"; t->display(tout); tout << "\nenode\n" << mk_ismt2_pp(n->get_expr(), m) << "\n";);
  2280          unsigned since_last_check = 0;

  2292          // It doesn't make sense to process an irrelevant enode.
  2293:         TRACE("mam_execute_core", tout << "EXEC " << t->get_root_lbl()->get_name() << "\n";);
  2294          SASSERT(m_context.is_relevant(n));

  2314              goto backtrack;
  2315:         TRACE("mam_int", display_pc_info(tout););
  2316          

  2467                       goto backtrack;                                                                                    \
  2468:                  TRACE("mam_int", tout << "bind candidate: " << mk_pp(m_app->get_expr(), m) << "\n";);     \
  2469                   m_backtrack_stack[m_top].m_instr              = m_pc;                                                  \

  2617              if (m_use_filters && static_cast<const get_cgr *>(m_pc)->m_lbl_set.empty_intersection(m_args[IDX]->get_root()->get_plbls())) { \
  2618:                 TRACE("trigger_bug", tout << "m_args[IDX]->get_root():\n" << mk_ismt2_pp(m_args[IDX]->get_root()->get_expr(), m) << "\n"; \
  2619                        tout << "cgr  set: "; static_cast<const get_cgr *>(m_pc)->m_lbl_set.display(tout); tout << "\n"; \

  2681              m_pattern_instances.push_back(m_app);
  2682:             TRACE("mam_int", tout << "continue candidate:\n" << mk_ll_pp(m_app->get_expr(), m););
  2683              for (unsigned i = 0; i < m_num_args; i++)

  2690      backtrack:
  2691:         TRACE("mam_int", tout << "backtracking.\n";);
  2692          if (m_top == 0) {
  2693:             TRACE("mam_int", tout << "no more alternatives.\n";);
  2694  #ifdef _PROFILE_MAM

  2704  
  2705:         TRACE("mam_int", tout << "backtrack top: " << bp.m_instr << " " << *(bp.m_instr) << "\n";);
  2706  #ifdef _PROFILE_MAM

  2731              m_pc = static_cast<const choose*>(bp.m_instr)->m_alt;
  2732:             TRACE("mam_int", tout << "alt: " << m_pc << "\n";);
  2733              SASSERT(m_pc != 0);

  2744                         bp.m_curr = m_app;                                                                                       \
  2745:                        TRACE("mam_int", tout << "bind next candidate:\n" << mk_ll_pp(m_app->get_expr(), m););      \
  2746                         m_oreg    = m_b->m_oreg

  2824                      update_max_generation(m_app, nullptr); // null indicates a top-level match
  2825:                     TRACE("mam_int", tout << "continue next candidate:\n" << mk_ll_pp(m_app->get_expr(), m););
  2826                      m_num_args = c->m_num_args;

  2931                         m_trail_stack.push(push_back_trail<app*, false>(m_trees[lbl_id]->get_patterns())););
  2932:             TRACE("trigger_bug", tout << "after add_pattern, first_idx: " << first_idx << "\n"; m_trees[lbl_id]->display(tout););
  2933          }

  3157              if (t != nullptr) {
  3158:                 TRACE("mam_candidate", tout << "adding candidate:\n" << mk_ll_pp(app->get_expr(), m););
  3159                  if (!t->has_candidates())

  3189              m_is_clbl.reserve(lbl_id+1, false);
  3190:             TRACE("trigger_bug", tout << "update_clbls: " << lbl->get_name() << " is already clbl: " << m_is_clbl[lbl_id] << "\n";);
  3191:             TRACE("mam_bug", tout << "update_clbls: " << lbl->get_name() << " is already clbl: " << m_is_clbl[lbl_id] << "\n";);
  3192              if (m_is_clbl[lbl_id])

  3199                      update_lbls(app, h);
  3200:                     TRACE("mam_bug", tout << "updating labels of: #" << app->get_owner_id() << "\n";
  3201                            tout << "new_elem: " << h << "\n";

  3215                      r_plbls.insert(elem);
  3216:                     TRACE("trigger_bug", tout << "updating plabels of:\n" << mk_ismt2_pp(c->get_root()->get_expr(), m) << "\n";
  3217                            tout << "new_elem: " << static_cast<unsigned>(elem) << "\n";
  3218                            tout << "plbls:    " << c->get_root()->get_plbls() << "\n";);
  3219:                     TRACE("mam_bug", tout << "updating plabels of: #" << c->get_root()->get_owner_id() << "\n";
  3220                            tout << "new_elem: " << static_cast<unsigned>(elem) << "\n";

  3229              m_is_plbl.reserve(lbl_id+1, false);
  3230:             TRACE("trigger_bug", tout << "update_plbls: " << lbl->get_name() << " is already plbl: " << m_is_plbl[lbl_id] << ", lbl_id: " << lbl_id << "\n";
  3231                    tout << "mam: " << this << "\n";);
  3232:             TRACE("mam_bug", tout << "update_plbls: " << lbl->get_name() << " is already plbl: " << m_is_plbl[lbl_id] << "\n";);
  3233              if (m_is_plbl[lbl_id])

  3345              }
  3346:             TRACE("mam_path_tree_updt",
  3347                    tout << "updated path tree:\n";

  3383              }
  3384:             TRACE("mam_path_tree_updt",
  3385                    tout << "updated path tree:\n";

  3447                          n->set_lbl_hash(m_context);
  3448:                     TRACE("mam_bug",
  3449                            tout << "updating pc labels " << plbl->get_name() << " " <<

  3457                  func_decl * clbl = to_app(child)->get_decl();
  3458:                 TRACE("mam_bug", tout << "updating pc labels " << plbl->get_name() << " " << clbl->get_name() << "\n";);
  3459                  update_plbls(plbl);

  3469          void update_filters(quantifier * qa, app * mp) {
  3470:             TRACE("mam_bug", tout << "updating filters using:\n" << mk_pp(mp, m) << "\n";);
  3471              unsigned num_vars = qa->get_num_decls();

  3541  #endif
  3542:                 TRACE("mam_path_tree",
  3543                        tout << "processing:\n";

  3586  
  3587:                     TRACE("mam_path_tree", tout << "processing: #" << curr_child->get_owner_id() << "\n";);
  3588                      enode_vector::const_iterator it2  = curr_child->begin_parents();

  3604                          enode * curr_parent_cg     = curr_parent->get_cg();
  3605:                         TRACE("mam_path_tree", tout << "processing parent:\n" << mk_pp(curr_parent->get_expr(), m) << "\n";);
  3606:                         TRACE("mam_path_tree", tout << "parent is marked: " << curr_parent->is_marked() << "\n";);
  3607                          if (filter.may_contain(m_lbl_hasher(lbl)) &&

  3633                                          if (curr_tree->m_code) {
  3634:                                             TRACE("mam_path_tree", tout << "found candidate " << expr_ref(curr_parent->get_expr(), m) << "\n";);
  3635                                              add_candidate(curr_tree->m_code, curr_parent);

  3682              approx_set & plbls2 = r2->get_plbls();
  3683:             TRACE("incremental_matcher", tout << "pp: plbls1: " << plbls1 << ", plbls2: " << plbls2 << "\n";);
  3684:             TRACE("mam_info", tout << "pp: " << plbls1.size() * plbls2.size() << "\n";);
  3685              if (!plbls1.empty() && !plbls2.empty()) {

  3737          void match_new_patterns() {
  3738:             TRACE("mam_new_pat", tout << "matching new patterns:\n";);
  3739              m_tmp_trees_to_delete.reset();

  3782                  app * pat = to_app(mp->get_arg(i));
  3783:                 TRACE("mam_pat", tout << mk_ismt2_pp(qa, m) << "\npat:\n" << mk_ismt2_pp(pat, m) << "\n";);
  3784                  SASSERT(!pat->is_ground());

  3829              SASSERT(m.is_pattern(mp));
  3830:             TRACE("trigger_bug", tout << "adding pattern\n" << mk_ismt2_pp(qa, m) << "\n" << mk_ismt2_pp(mp, m) << "\n";);
  3831:             TRACE("mam_bug", tout << "adding pattern\n" << mk_pp(qa, m) << "\n" << mk_pp(mp, m) << "\n";);
  3832              // Z3 checks if a pattern is ground or not before solving.

  3888          void match() override {
  3889:             TRACE("trigger_bug", tout << "match\n"; display(tout););
  3890              for (code_tree* t : m_to_match) {

  3921          bool check_missing_instances() override {
  3922:             TRACE("missing_instance", tout << "checking for missing instances...\n";);
  3923              flet<bool> l(m_check_missing_instances, true);

  3929          void on_match(quantifier * qa, app * pat, unsigned num_bindings, enode * const * bindings, unsigned max_generation, vector<std::tuple<enode *, enode *>> & used_enodes) override {
  3930:             TRACE("trigger_bug", tout << "found match " << mk_pp(qa, m) << "\n";);
  3931  #ifdef Z3DEBUG

  3933                  if (!m_context.slow_contains_instance(qa, num_bindings, bindings)) {
  3934:                     TRACE("missing_instance",
  3935                            tout << "qa:\n" << mk_ll_pp(qa, m) << "\npat:\n" << mk_ll_pp(pat, m);

  3958          void relevant_eh(enode * n, bool lazy) override {
  3959:             TRACE("trigger_bug", tout << "relevant_eh:\n" << mk_ismt2_pp(n->get_expr(), m) << "\n";
  3960                    tout << "mam: " << this << "\n";);
  3961:             TRACE("mam", tout << "relevant_eh: #" << n->get_owner_id() << "\n";);
  3962              if (n->has_lbl_hash())

  3967                  unsigned h      = m_lbl_hasher(lbl);
  3968:                 TRACE("trigger_bug", tout << "lbl: " << lbl->get_name() << " is_clbl(lbl): " << is_clbl(lbl)
  3969                        << ", is_plbl(lbl): " << is_plbl(lbl) << ", h: " << h << "\n";

  3974                      update_children_plbls(n, h);
  3975:                 TRACE("mam_bug", tout << "adding relevant candidate:\n" << mk_ll_pp(n->get_expr(), m) << "\n";);
  3976                  if (!lazy)

  3988  
  3989:             TRACE("mam", tout << "add_eq_eh: #" << r1->get_owner_id() << " #" << r2->get_owner_id() << "\n";);
  3990:             TRACE("mam_inc_bug_detail", m_context.display(tout););
  3991:             TRACE("mam_inc_bug",
  3992                    tout << "before:\n#" << r1->get_owner_id() << " #" << r2->get_owner_id() << "\n";

  4010              r2_plbls |= r1_plbls;
  4011:             TRACE("mam_inc_bug",
  4012                    tout << "after:\n";

z3/src/smt/old_interval.cpp:
  321  
  322:     TRACE("interval_bug", tout << "operator*= " << *this << " " << other << "\n";);
  323  

  327              // a <= x <= b <= 0, c <= y <= d <= 0 --> x*y <= a*c  (we can use the fact that x or y is always negative (i.e., b is neg or d is neg))
  328:             TRACE("interval_bug", tout << "(N, N)\n";);
  329              ext_numeral new_lower = b * d;

  341              // a <= x <= b <= 0,  c <= y, c < 0 --> x*y <= a*c (uses the fact that b is not positive)
  342:             TRACE("interval_bug", tout << "(N, M)\n";);
  343              ext_numeral new_lower = a * d; SASSERT(new_lower.is_neg());

  354              // x <= b <= 0,  0 <= c <= y --> x*y <= b*c
  355:             TRACE("interval_bug", tout << "(N, P)\n";);
  356              SASSERT(other.is_P());

  371              // a < 0, a <= x,  c <= y <= d <= 0 --> x*y <= a*c (uses the fact that d is not positive)
  372:             TRACE("interval_bug", tout << "(M, N)\n";);
  373              ext_numeral new_lower = b * c; SASSERT(new_lower.is_neg());

  382          else if (other.is_M()) {
  383:             TRACE("interval_bug", tout << "(M, M)\n";);
  384              SASSERT(!a.is_zero() && !b.is_zero() && !c.is_zero() && !d.is_zero());

  414              // b > 0, x <= b, 0 <= c <= y <= d --> x*y <= b*d (uses the fact that c is not negative)
  415:             TRACE("interval_bug", tout << "(M, P)\n";);
  416              SASSERT(other.is_P());

  431              // 0 <= a <= x,  y <= d <= 0  --> a*d <= x*y
  432:             TRACE("interval_bug", tout << "(P, N)\n";);
  433              ext_numeral new_lower = b * c;

  445              // 0 <= a <= x <= b,  y <= d --> x*y <= b*d (uses the fact that a is not negative)
  446:             TRACE("interval_bug", tout << "(P, M)\n";);
  447              ext_numeral new_lower = b * c; SASSERT(new_lower.is_neg());

  458              // x <= b, y <= d --> x*y <= b*d (uses the fact that x is pos (a is not negative) or y is pos (c is not negative))
  459:             TRACE("interval_bug", tout << "(P, P)\n";);
  460              SASSERT(other.is_P());

  470      }
  471:     TRACE("interval_bug", tout << "operator*= result: " << *this << "\n";);
  472:     CTRACE("interval", !(!(contains_zero1 || contains_zero2) || contains_zero()),
  473             tout << "contains_zero1: " << contains_zero1 << ", contains_zero2: " << contains_zero2 << ", contains_zero(): " << contains_zero() << "\n";);

  486  bool interval::contains_zero() const {
  487:     TRACE("interval_zero_bug", tout << "contains_zero info: " << *this << "\n";
  488            tout << "m_lower.is_neg(): " << m_lower.is_neg() << "\n";

  570          // 0/other = 0 if other != 0
  571:         TRACE("interval", other.display_with_dependencies(tout););
  572          if (other.m_lower.is_pos() || (other.m_lower.is_zero() && other.m_lower_open)) {

  627              // we need both bounds to justify upper bound
  628:             TRACE("interval", tout << "before: " << m_lower << " " << m_upper << " " << n << "\n";);
  629              m_lower.expt(n);
  630              m_upper.expt(n);
  631:             TRACE("interval", tout << "after: " << m_lower << " " << m_upper << "\n";);
  632              if (m_lower > m_upper || (m_lower == m_upper && !m_lower_open && m_upper_open)) {

z3/src/smt/qi_queue.cpp:
   49      void qi_queue::setup() {
   50:         TRACE("qi_cost", tout << "qi_cost: " << m_params.m_qi_cost << "\n";);
   51          if (!m_parser.parse_string(m_params.m_qi_cost.c_str(), m_cost_function)) {

  118          m_vals[CS_FACTOR]          = static_cast<float>(stat->get_case_split_factor());
  119:         TRACE("qi_queue_detail", for (unsigned i = 0; i < m_vals.size(); i++) { tout << m_vals[i] << " "; } tout << "\n";);
  120          return stat;

  139          float cost             = get_cost(q, pat, generation, min_top_generation, max_top_generation);
  140:         TRACE("qi_queue_detail",
  141                tout << "new instance of " << q->get_qid() << ", weight " << q->get_weight()

  146                tout << "\n";);
  147:         TRACE("new_entries_bug", tout << "[qi:insert]\n";);
  148          m_new_entries.push_back(entry(f, cost, generation));

  164                  // do not delay instances that produce a conflict.
  165:                 TRACE("qi_unsat", tout << "promoting instance that produces a conflict\n" << mk_pp(qa, m) << "\n";);
  166                  instantiate(curr);

  168              else {
  169:                 TRACE("qi_queue", tout << "delaying quantifier instantiation... " << f << "\n" << mk_pp(qa, m) << "\ncost: " << curr.m_cost << "\n";);
  170                  m_delayed_entries.push_back(curr);

  181          m_new_entries.reset();
  182:         TRACE("new_entries_bug", tout << "[qi:instantiate]\n";);
  183      }

  207                  
  208:         TRACE("qi_queue_profile", tout << q->get_qid() << ", gen: " << generation << " " << *f << " cost: " << ent.m_cost << "\n";);
  209  

  212          if (m_checker.is_sat(q->get_expr(), num_bindings, bindings)) {
  213:             TRACE("checker", tout << "instance already satisfied\n";);
  214              // we log the "dummy" instantiations separately from "instance"
  215:             STRACE("dummy", tout << "### " << static_cast<void*>(f) <<", " << q->get_qid() << "\n";);
  216:             STRACE("dummy", tout << "Instance already satisfied (dummy)\n";);
  217              // a dummy instantiation is still an instantiation.

  222  
  223:         STRACE("instance", tout << "### " << static_cast<void*>(f) <<", " << q->get_qid()  << "\n";);
  224  

  230  
  231:         TRACE("qi_queue", tout << "new instance:\n" << mk_pp(instance, m) << "\n";);
  232          expr_ref  s_instance(m);

  235  
  236:         TRACE("qi_queue_bug", tout << "new instance after simplification:\n" << s_instance << "\n";);
  237          if (m.is_true(s_instance)) {
  238:             STRACE("instance", tout <<  "Instance reduced to true\n";);
  239              stat -> inc_num_instances_simplify_true();

  257     
  258:         TRACE("qi_queue", tout << "simplified instance:\n" << s_instance << "\n";);
  259          stat->inc_num_instances();

  320          }
  321:         TRACE("qi_queue", tout << mk_pp(lemma, m) << "\n#" << lemma->get_id() << ":=\n" << mk_ll_pp(lemma, m););
  322          m_stats.m_num_instances++;

  344                  if (true_child && has_unassigned) {
  345:                     TRACE("qi_queue_profile_detail", tout << "missed:\n" << mk_ll_pp(s_instance, m) << "\n#" << true_child->get_id() << "\n";);
  346                      num_useless++;
  347                      if (num_useless % 10 == 0) {
  348:                         TRACE("qi_queue_profile", tout << "num useless: " << num_useless << "\n";);
  349                      }

  359      void qi_queue::push_scope() {
  360:         TRACE("new_entries_bug", tout << "[qi:push-scope]\n";);
  361          m_scopes.push_back(scope());

  380          m_scopes.shrink(new_lvl);
  381:         TRACE("new_entries_bug", tout << "[qi:pop-scope]\n";);
  382      }

  396      bool qi_queue::final_check_eh() {
  397:         TRACE("qi_queue", display_delayed_instances_stats(tout); tout << "lazy threshold: " << m_params.m_qi_lazy_threshold
  398                << ", scope_level: " << m_context.get_scope_level() << "\n";);

  404                  entry & e       = m_delayed_entries[i];
  405:                 TRACE("qi_queue", tout << e.m_qb << ", cost: " << e.m_cost << ", instantiated: " << e.m_instantiated << "\n";);
  406                  if (!e.m_instantiated && e.m_cost <= m_params.m_qi_lazy_threshold && (!init || e.m_cost < min_cost)) {

  410              }
  411:             TRACE("qi_queue_min_cost", tout << "min_cost: " << min_cost << ", scope_level: " << m_context.get_scope_level() << "\n";);
  412              bool result = true;

  414                  entry & e       = m_delayed_entries[i];
  415:                 TRACE("qi_queue", tout << e.m_qb << ", cost: " << e.m_cost << " min-cost: " << min_cost << ", instantiated: " << e.m_instantiated << "\n";);
  416                  if (!e.m_instantiated && e.m_cost <= min_cost) {
  417:                     TRACE("qi_queue",
  418                            tout << "lazy quantifier instantiation...\n" << mk_pp(static_cast<quantifier*>(e.m_qb->get_data()), m) << "\ncost: " << e.m_cost << "\n";);

  430              entry & e       = m_delayed_entries[i];
  431:             TRACE("qi_queue", tout << e.m_qb << ", cost: " << e.m_cost << ", instantiated: " << e.m_instantiated << "\n";);
  432              if (!e.m_instantiated && e.m_cost <= m_params.m_qi_lazy_threshold)  {
  433:                 TRACE("qi_queue",
  434                        tout << "lazy quantifier instantiation...\n" << mk_pp(static_cast<quantifier*>(e.m_qb->get_data()), m) << "\ncost: " << e.m_cost << "\n";);

z3/src/smt/seq_eq_solver.cpp:
    37          }
    38:         TRACE("seq_verbose", display_equations(tout););
    39      }

    53      dependency* deps = m_dm.mk_join(dep2, e.dep());
    54:     TRACE("seq_verbose", 
    55            tout << e.ls << " = " << e.rs << " ==> ";

    59      if (!ctx.inconsistent() && simplify_eq(ls, rs, deps)) {
    60:         TRACE("seq", tout << "simplified\n";);
    61          return true;

    76  
    77:     TRACE("seq_verbose", tout << ls << " = " << rs << "\n";);
    78      if (!ctx.inconsistent() && solve_nth_eq(ls, rs, deps)) {

    85          // The propagation step from arithmetic state (e.g. length offset) to length constraints
    86:         TRACE("seq", tout << "inserting equality\n";);
    87          m_eqs.set(idx, depeq(m_eq_id++, ls, rs, deps));        

   147      if (root1 == root2) {
   148:         TRACE("seq", tout << "(" << mk_pp(l_fst, m) << ", " << mk_pp(r_fst,m) << ")\n";);
   149          offset = 0;

   153      if (m_offset_eq.find(root1, root2, offset)) {
   154:         TRACE("seq", tout << "(" << mk_pp(l_fst, m) << ", " << mk_pp(r_fst,m) << " " << offset << ")\n";);
   155          return true;

   193          
   194:     TRACE("seq", tout << "split based on length\n";);
   195:     TRACE("seq", display_equation(tout, e););
   196      sort* srt = ls[0]->get_sort();

   244      if (branch_ternary_variable()) {
   245:         TRACE("seq", tout << "branch_ternary_variable\n";);
   246          return true;

   248      if (branch_quat_variable()) {
   249:         TRACE("seq", tout << "branch_quat_variable\n";);
   250          return true;

   255          if (turn && branch_variable_mb()) {
   256:             TRACE("seq", tout << "branch_variable_mb\n";);
   257              return true;

   259          if (!turn && branch_variable_eq()) {
   260:             TRACE("seq", tout << "branch_variable_eq\n";);
   261              return true;

   290          if (l1 == l2 && split_lengths(e.dep(), e.ls, e.rs, len1, len2)) {
   291:             TRACE("seq", tout << "split lengths\n";);
   292              change = true;

   362      if (!is_var(Y) && !m_util.str.is_unit(Y)) {
   363:         TRACE("seq", tout << "TBD: non variable or unit split: " << Y << "\n";);
   364          return false;

   366      if (X == Y) {
   367:         TRACE("seq", tout << "Cycle: " << X << "\n";);
   368          return false;

   410          expr_ref Y2 = m_sk.mk_right(X, b, Y);
   411:         TRACE("seq", tout << Y1 << "\n" << Y2 << "\n" << ls << "\n" << rs << "\n";);
   412          expr_ref bY1 = mk_concat(b, Y1);

   423          if (branch_binary_variable(e)) {
   424:             TRACE("seq", display_equation(tout, e););
   425              return true;

   479          expr_ref Y2 = m_sk.mk_right(x, y);
   480:         TRACE("seq", tout << Y1 << "\n" << Y2 << "\n";);
   481          ys.push_back(Y1);

   505      }
   506:     CTRACE("seq", result, tout << "branch unit variable\n";);
   507      return result;

   706          if (ctx.get_assignment(lit) == l_undef) {
   707:             TRACE("seq", tout << mk_pp(x1, m) << " = " << mk_pp(y1, m) << "?\n";);
   708              ctx.mark_as_relevant(lit);

   711          else if (ctx.get_assignment(lit) == l_true) {
   712:             TRACE("seq", tout << mk_pp(x1, m) << " = " << mk_pp(y1, m) << "\n";);
   713              propagate_eq(dep, lit, x1, y1, true);

   716          }
   717:         TRACE("seq", tout << mk_pp(x1, m) << " != " << mk_pp(y1, m) << "\n";);
   718          lits.push_back(~lit);

   724      if (ctx.get_assignment(lit1) == l_undef) {
   725:         TRACE("seq", tout << mk_pp(x1, m) << " <= " << mk_pp(y1, m) << "?\n";);
   726          ctx.mark_as_relevant(lit1);

   729      if (ctx.get_assignment(lit1) == l_true) {
   730:         TRACE("seq", tout << mk_pp(x1, m) << " <= " << mk_pp(y1, m) << "\n";);
   731          if (ctx.get_assignment(lit2) == l_undef) {

   736      else {
   737:         TRACE("seq", tout << mk_pp(x1, m) << " >\n" << mk_pp(y1, m) << "\n";);
   738          if (ctx.get_assignment(lit3) == l_undef) {

   802          if (branch_variable_eq(e)) {
   803:             TRACE("seq", tout << "branch variable\n";);
   804              return true;

   812      unsigned s = find_branch_start(2*id);
   813:     TRACE("seq", tout << s << " " << id << ": " << e.ls << " = " << e.rs << "\n";);
   814      bool found = find_branch_candidate(s, e.dep(), e.ls, e.rs);

   846  
   847:     TRACE("seq", tout << mk_pp(l, m) << ": " << ctx.get_scope_level() << " - start:" << start << "\n";);
   848  

   852          if (assume_equality(l, v0)) {
   853:             TRACE("seq", tout << mk_pp(l, m) << " " << v0 << "\n";);
   854              return true;

   868          if (assume_equality(l, v0)) {
   869:             TRACE("seq", tout << mk_pp(l, m) << " " << v0 << "\n";);
   870              ++start;

   895          set_conflict(dep, lits);
   896:         TRACE("seq", 
   897                tout << "start: " << start << "\n";

   948      if (n1->get_root() == n2->get_root()) {
   949:         TRACE("seq", tout << mk_pp(l, m) << " = " << mk_pp(r, m) << " roots eq\n";);
   950          return false;

   952      if (ctx.is_diseq(n1, n2)) {
   953:         TRACE("seq", tout << mk_pp(l, m) << " = " << mk_pp(r, m) << " is_diseq\n";);
   954          return false;

   958      if (!ctx.assume_eq(n1, n2)) {
   959:         TRACE("seq", tout << mk_pp(l, m) << " = " << mk_pp(r, m) << " can't assume\n";);
   960          return false;

   962      lbool res = ctx.get_assignment(mk_eq(l, r, false));
   963:     TRACE("seq", tout << mk_pp(l, m) << " = " << mk_pp(r, m) << " literal assigned " << res << "\n";);
   964      return res != l_false;

   977      }
   978:     TRACE("seq", tout << "Unsolved " << mk_pp(e, m);
   979            if (!lower_bound2(e, lo)) lo = -rational::one();

  1099          if (reduce_length_eq(e.ls, e.rs, e.dep())) {
  1100:             TRACE("seq", tout << "reduce length eq\n";);
  1101              return true;

  1161          rs1.push_back(m_sk.mk_post(s, idx1));
  1162:         TRACE("seq", tout << ls1 << "\n"; tout << rs1 << "\n";);
  1163          m_eqs.push_back(depeq(m_eq_id++, ls1, rs1, deps));

  1231      if (l_fst && get_root(len_l_fst) == root2) {
  1232:         TRACE("seq", tout << "(" << mk_pp(l_fst, m) << ", " << mk_pp(r_fst, m) << ")\n";);
  1233          return false;

  1254          if (m_offset_eq.contains(root1, root2)) {
  1255:             TRACE("seq", tout << "(" << mk_pp(l_fst, m) << ", " << mk_pp(r_fst,m) << ")\n";);
  1256              return false;

z3/src/smt/seq_ne_solver.cpp:
   38  bool theory_seq::solve_ne(unsigned idx) {
   39:     TRACE("seq", display_disequation(tout << "solve: ", m_nqs[idx]););
   40      unsigned num_undef_lits = 0;

   52          case l_false:
   53:             TRACE("seq", display_disequation(tout << "has false literal\n", n);
   54                    ctx.display_literal_verbose(tout, lit);

  103                  dep = dep1;
  104:                 TRACE("seq", tout << "conflict explained\n";);
  105              }

  109      else {
  110:         TRACE("seq", tout << "propagate: " << undef_lit << "\n";);
  111          propagate_lit(n.dep(), lits.size(), lits.data(), ~undef_lit);

  169  
  170:         TRACE("seq", display_disequation(tout << "reduced\n", n);
  171                tout << p.first << " -> " << ls << "\n";

  180          if (!change) {
  181:             TRACE("seq", tout << "no change " << p.first << " " << p.second << "\n";);
  182              if (updated) {

  196          }
  197:         TRACE("seq",
  198                tout << "num eqs: " << eqs.size() << "\n";

  231      if (updated) {
  232:         TRACE("seq", display_disequation(tout, n););
  233          m_nqs.set(idx, ne(n.l(), n.r(), new_eqs, new_lits, new_deps));
  234:         TRACE("seq", display_disequation(tout << "updated:\n", m_nqs[idx]););
  235      }

  277      case l_false:
  278:         TRACE("seq", 
  279                display_disequation(tout, n);

  306      case l_false:
  307:         TRACE("seq", ctx.display_literal_smt2(tout << "heads are different: ", eq_head) << "\n";);
  308          return l_true;

z3/src/smt/seq_offset_eq.cpp:
  57          ctx.e_internalized(y)) {
  58:         TRACE("seq", tout << "eqc: " << mk_pp(e, m) << "\n";);    
  59          enode* r1 = th.get_root(x);

  73                  m_has_offset_equality.insert(r2);
  74:                 TRACE("seq", tout << "a length pair: " << mk_pp(e1, m) << ", " << mk_pp(e2, m) << "\n";);
  75                  return;

  86          if (a.is_numeral(n->get_expr(), val) && val.is_int32() && INT_MIN < val.get_int32()) {
  87:             TRACE("seq", tout << "offset: " << mk_pp(n->get_expr(), m) << "\n";);
  88              enode *next = n->get_next();

z3/src/smt/seq_regex.cpp:
   97  
   98:         TRACE("seq_regex", tout << "propagate in RE: " << lit.sign() << " " << mk_pp(e, m) << std::endl;);
   99:         STRACE("seq_regex_brief", tout << "PIR(" << mk_pp(s, m) << ","
  100                                         << state_str(r) << ") ";);

  116          if (coallesce_in_re(lit)) {
  117:             TRACE("seq_regex", tout
  118                  << "simplified conjunctions to an intersection" << std::endl;);
  119:             STRACE("seq_regex_brief", tout << "coallesce_in_re ";);
  120              return;

  123          if (is_string_equality(lit)) {
  124:             TRACE("seq_regex", tout
  125                  << "simplified regex using string equality" << std::endl;);
  126:             STRACE("seq_regex_brief", tout << "string_eq ";);
  127              return;

  141                  _r_temp_owner = r;
  142:                 TRACE("seq_regex", tout
  143                      << "get_overapprox_regex(" << mk_pp(s, m)
  144                      << ") = " << mk_pp(s_approx, m) << std::endl;);
  145:                 STRACE("seq_regex_brief", tout
  146                      << "overapprox=" << state_str(r) << " ";);

  153  
  154:         TRACE("seq", tout << "propagate " << acc << "\n";);
  155  

  213          if (re().is_empty(r) || info.min_length == UINT_MAX) {
  214:             STRACE("seq_regex_brief", tout << "(empty) ";);
  215              th.add_axiom(~lit);

  221              if (m_state_graph.is_dead(get_state_id(r))) {
  222:                 STRACE("seq_regex_brief", tout << "(dead) ";);
  223                  th.add_axiom(~lit);

  260  
  261:         TRACE("seq_regex", tout << "propagate accept: "
  262                                  << mk_pp(e, m) << std::endl;);
  263:         STRACE("seq_regex_brief", tout << std::endl
  264                                         << "PA(" << mk_pp(s, m) << "@" << idx

  270          if (block_unfolding(lit, idx)) {
  271:             STRACE("seq_regex_brief", tout << "(blocked) ";);
  272              return;

  274  
  275:         STRACE("seq_regex_brief", tout << "(unfold) ";);
  276  

  289              if (m.is_false(is_nullable)) {
  290:                 STRACE("seq_regex", tout
  291                      << "Warning: min_length returned 0 for non-nullable regex"
  292                      << std::endl;);
  293:                 STRACE("seq_regex_brief", tout
  294                      << " (Warning: min_length returned 0 for"

  301                  // is_nullable did not simplify
  302:                 STRACE("seq_regex", tout
  303                      << "Warning: is_nullable did not simplify to true or false"
  304                      << std::endl;);
  305:                 STRACE("seq_regex_brief", tout
  306                      << " (Warning: is_nullable did not simplify)";);

  321          deriv = mk_derivative_wrapper(s_i, r);
  322:         STRACE("seq_regex", tout
  323              << "mk_derivative_wrapper: " << re().to_str(deriv) << std::endl;);

  417      expr_ref seq_regex::is_nullable_wrapper(expr* r) {
  418:         STRACE("seq_regex", tout << "nullable: " << mk_pp(r, m) << std::endl;);
  419  

  423  
  424:         STRACE("seq_regex", tout << "nullable result: " << mk_pp(result, m) << std::endl;);
  425:         STRACE("seq_regex_brief", tout << "n(" << state_str(r) << ")="
  426                                         << mk_pp(result, m) << " ";);

  435      expr_ref seq_regex::mk_derivative_wrapper(expr* ele, expr* r) {
  436:         STRACE("seq_regex", tout << "derivative(" << mk_pp(ele, m) << "): " << mk_pp(r, m) << std::endl;);
  437  

  443  
  444:         STRACE("seq_regex", tout << "derivative result: " << mk_pp(der, m) << std::endl;);
  445:         STRACE("seq_regex_brief", tout << "d(" << state_str(r) << ")="
  446                                         << state_str(der) << " ";);

  453      void seq_regex::propagate_eq(expr* r1, expr* r2) {
  454:         TRACE("seq_regex", tout << "propagate EQ: " << mk_pp(r1, m) << ", " << mk_pp(r2, m) << std::endl;);
  455:         STRACE("seq_regex_brief", tout << "PEQ ";);
  456  

  475      void seq_regex::propagate_ne(expr* r1, expr* r2) {
  476:         TRACE("seq_regex", tout << "propagate NEQ: " << mk_pp(r1, m) << ", " << mk_pp(r2, m) << std::endl;);
  477:         STRACE("seq_regex_brief", tout << "PNEQ ";);
  478          sort* seq_sort = nullptr;

  511  
  512:         TRACE("seq_regex", tout << "propagate nonempty: " << mk_pp(e, m) << std::endl;);
  513:         STRACE("seq_regex_brief", tout
  514              << std::endl << "PNE(" << expr_id_str(e) << "," << state_str(r)

  579                  // First visit: add children
  580:                 STRACE("seq_regex_verbose", tout << "1";);
  581                  if (m.is_ite(e, econd, e1, e2) ||

  590                  // Second visit: set value
  591:                 STRACE("seq_regex_verbose", tout << "2";);
  592                  to_visit.pop_back();

  621  
  622:                     STRACE("seq_regex_verbose", tout
  623                          << "mk_deriv_accept: added accept leaf: "

  627              else {
  628:                 STRACE("seq_regex_verbose", tout << "3";);
  629                  // Remaining visits: skip

  736  
  737:         TRACE("seq_regex", tout << "propagate empty: " << mk_pp(e, m) << std::endl;);
  738:         STRACE("seq_regex_brief", tout
  739              << std::endl << "PE(" << expr_id_str(e) << "," << state_str(r)

  789              m_expr_to_state.insert(e, new_id);
  790:             STRACE("seq_regex_brief", tout << "new(" << expr_id_str(e)
  791                                             << ")=" << state_str(e) << " ";);
  792:             STRACE("seq_regex", tout
  793                  << "New state ID: " << new_id

  822          if (m_state_graph.get_size() >= m_max_state_graph_size) {
  823:             STRACE("seq_regex", tout << "Warning: ignored state graph update -- max size of seen states reached!" << std::endl;);
  824:             STRACE("seq_regex_brief", tout << "(MAX SIZE REACHED) ";);
  825              return false;
  826          }
  827:         STRACE("seq_regex", tout << "Updating state graph for regex "
  828                                   << mk_pp(r, m) << ") ";);
  829          
  830:         STRACE("state_graph",
  831              if (!m_state_graph.is_seen(r_id))

  834          m_state_graph.add_state(r_id);
  835:         STRACE("seq_regex", tout << "Updating state graph for regex "
  836                                   << mk_pp(r, m) << ") " << std::endl;);
  837:         STRACE("seq_regex_brief", tout << std::endl << "USG("
  838                                         << state_str(r) << ") ";);

  845              expr_ref_vector derivatives(m);
  846:             STRACE("seq_regex_verbose", tout
  847                  << "getting all derivs: " << r_id << " " << std::endl;);

  850                  unsigned dr_id = get_state_id(dr);
  851:                 STRACE("seq_regex_verbose", tout
  852                      << std::endl << "  traversing deriv: " << dr_id << " ";);              
  853:                 STRACE("state_graph",
  854                      if (!m_state_graph.is_seen(dr_id))

  863  
  864:         STRACE("seq_regex", m_state_graph.display(tout););
  865:         STRACE("seq_regex_brief", tout << std::endl;);
  866:         STRACE("seq_regex_brief", m_state_graph.display(tout););
  867          return true;

z3/src/smt/smt_arith_value.cpp:
   55          while (n != next);
   56:         CTRACE("arith_value", !found, tout << "value not found for " << mk_pp(e, m_ctx->get_manager()) << "\n";);
   57          return found;

   75          while (n != next);
   76:         CTRACE("arith_value", !found, tout << "value not found for " << mk_pp(e, m_ctx->get_manager()) << "\n";);
   77          return found;

   87          if (m_thr) return m_thr->get_upper(n, up, is_strict);
   88:         TRACE("arith_value", tout << "value not found for " << mk_pp(e, m_ctx->get_manager()) << "\n";);
   89          return false;

   99          if (m_thr) return m_thr->get_lower(n, up, is_strict);
  100:         TRACE("arith_value", tout << "value not found for " << mk_pp(e, m_ctx->get_manager()) << "\n";);
  101          return false;

  111          if (m_thr && m_thr->get_value(n, val)) return true;
  112:         TRACE("arith_value", tout << "value not found for " << mk_pp(e, m_ctx->get_manager()) << "\n";);
  113          return false;

  128          while (next != n);
  129:         TRACE("arith_value", tout << "value not found for " << mk_pp(e, m_ctx->get_manager()) << "\n";);
  130          return false;

z3/src/smt/smt_case_split_queue.cpp:
   124                  next = m_context.get_random_value() % m_context.get_num_b_internalized(); 
   125:                 TRACE("random_split", tout << "next: " << next << " get_assignment(next): " << m_context.get_assignment(next) << "\n";);
   126                  if (m_context.get_assignment(next) == l_undef)

   403              s.m_head2_old    = m_head2;
   404:             TRACE("case_split", tout << "head: " << m_head << "\n";);
   405          }

   416              SASSERT(m_head <= m_queue.size());
   417:             TRACE("case_split", display(tout); tout << "head: " << m_head << "\n";);
   418          }

   443                          }
   444:                         TRACE("case_split", tout << "found AND/OR candidate: #" << curr->get_id() << " #" << undef_child->get_id() << "\n";);
   445                          literal l = m_context.get_literal(undef_child);

   447                          phase = l.sign() ? l_false : l_true;
   448:                         TRACE("case_split", display(tout););
   449                          return;

   453                      SASSERT(intern && m_context.get_bool_var(curr) == next);
   454:                     TRACE("case_split", tout << "found candidate: #" << curr->get_id() << "\n";);
   455                      phase = l_undef;
   456:                     TRACE("case_split", display(tout););
   457                      return;

   599              s.m_head_old     = m_head;
   600:             TRACE("case_split", tout << "head: " << m_head << "\n";);
   601          }

   610              SASSERT(m_head <= m_queue.size());
   611:             TRACE("case_split", display(tout); tout << "head: " << m_head << "\n";);
   612          }

   634                      if (!has_child_assigned_to(m_context, to_app(curr), val, undef_child, m_params.m_rel_case_split_order)) {
   635:                         TRACE("case_split", tout << "found AND/OR candidate: #" << curr->get_id() << " #" << undef_child->get_id() << "\n";);
   636                          literal l = m_context.get_literal(undef_child);

   638                          phase = l.sign() ? l_false : l_true;
   639:                         TRACE("case_split", display(tout););
   640                          return;

   644                      SASSERT(intern && m_context.get_bool_var(curr) == next);
   645:                     TRACE("case_split", tout << "found candidate: #" << curr->get_id() << "\n";);
   646                      phase = l_undef;
   647:                     TRACE("case_split", display(tout););
   648                      return;

   656                  next = m_context.get_random_value() % m_context.get_num_b_internalized(); 
   657:                 TRACE("random_split", tout << "next: " << next << " get_assignment(next): " << m_context.get_assignment(next) << "\n";);
   658                  if (m_context.get_assignment(next) == l_undef)

   846              s.m_goal         = m_current_goal;
   847:             TRACE("case_split", tout << "head: " << m_head << "\n";);
   848          }

   859              for (unsigned i = s.m_queue2_trail; i < m_queue2.size(); i++) {
   860:                 //TRACE("case_split", tout << "ld[" << i << "] = " << m_queue2[i].m_last_decided << " cont " << 
   861                  SASSERT((m_queue2[i].m_last_decided == -1) == m_priority_queue2.contains(i));

   879              SASSERT(m_head <= m_queue.size());
   880:             TRACE("case_split", display(tout); tout << "head: " << m_head << "\n";);        
   881          }

   902                      }
   903:                     TRACE("case_split", tout << "found AND/OR candidate: #" << curr->get_id() << " #" << undef_child->get_id() << "\n";);
   904                      literal l = m_context.get_literal(undef_child);

   906                      phase = l.sign() ? l_false : l_true;
   907:                     TRACE("case_split", display(tout););
   908                      return;

   912                  SASSERT(intern && m_context.get_bool_var(curr) == next);
   913:                 TRACE("case_split", tout << "found candidate: #" << curr->get_id() << "\n";);
   914                  phase = l_undef;
   915:                 TRACE("case_split", display(tout););
   916                  return;

   934                  unsigned idx = static_cast<unsigned>(m_priority_queue2.erase_min());
   935:                 TRACE("case_split", tout << "q " << m_queue2.size() << " idx " << idx << "\n"; );
   936                  SASSERT(idx < m_queue2.size());

   991  
   992:                 TRACE("case_split", tout << "Found goal\n" << mk_pp(e, m_manager) << "\n"; );
   993  

  1191                  next = m_context.get_random_value() % m_context.get_num_b_internalized(); 
  1192:                 TRACE("random_split", tout << "next: " << next << " get_assignment(next): " << m_context.get_assignment(next) << "\n";);
  1193                  if (m_context.get_assignment(next) == l_undef)

  1211          void add_theory_aware_branching_info(bool_var v, double priority, lbool phase) override {
  1212:             TRACE("theory_aware_branching", tout << "Add theory-aware branching information for l#" << v << ": priority=" << priority << std::endl;);
  1213              m_theory_vars.insert(v);

z3/src/smt/smt_cg_table.cpp:
  219              n_prime = UNTAG(binary_table*, t)->insert_if_not_there(n);
  220:             TRACE("cg_table", tout << "insert: " << n->get_owner_id() << " " << cg_binary_hash()(n) << " inserted: " << (n == n_prime) << " " << n_prime->get_owner_id() << "\n";
  221                    display_binary(tout, t); tout << "contains_ptr: " << contains_ptr(n) << "\n";); 

  240          case BINARY:
  241:             TRACE("cg_table", tout << "erase: " << n->get_owner_id() << " " << cg_binary_hash()(n) << " contains: " << contains_ptr(n) << "\n";);
  242              UNTAG(binary_table*, t)->erase(n);

z3/src/smt/smt_clause_proof.cpp:
   67          proof_ref pr(justification2proof(st, j), m);
   68:         CTRACE("mk_clause", pr.get(), tout << mk_bounded_pp(pr, m, 4) << "\n";);
   69          update(c, st, pr);        

   76          proof_ref pr(justification2proof(st, j), m);
   77:         CTRACE("mk_clause", pr.get(), tout << mk_bounded_pp(pr, m, 4) << "\n";);
   78          m_lits.reset();

  125      void clause_proof::update(status st, expr_ref_vector& v, proof* p) {
  126:         TRACE("clause_proof", tout << m_trail.size() << " " << st << " " << v << "\n";);
  127          if (ctx.get_fparams().m_clause_proof)

  142      proof_ref clause_proof::get_proof(bool inconsistent) {
  143:         TRACE("context", tout << "get-proof " << ctx.get_fparams().m_clause_proof << "\n";);
  144          if (!ctx.get_fparams().m_clause_proof) 

z3/src/smt/smt_conflict_resolution.cpp:
   107          SASSERT(m_antecedents);
   108:         TRACE("conflict_",
   109                ast_manager& m = get_manager();

   130          case eq_justification::CONGRUENCE: {
   131:             CTRACE("dyn_ack_target", !lhs->is_eq(), tout << "dyn_ack_target2: " << lhs->get_owner_id() << " " << rhs->get_owner_id() << "\n";);
   132              m_dyn_ack_manager.used_cg_eh(lhs->get_expr(), rhs->get_expr());

   318          SASSERT(var < m_ctx.get_num_bool_vars());
   319:         TRACE("conflict_", tout << "processing antecedent (level " << lvl << "):";
   320                m_ctx.display_literal(tout, antecedent);

   355          (void)consequent;
   356:         TRACE("conflict_smt2", 
   357                for (literal& l : antecedents) {

   388      bool conflict_resolution::initialize_resolve(b_justification conflict, literal not_l, b_justification & js, literal & consequent) {
   389:         TRACE("conflict_detail", m_ctx.display(tout););
   390          m_lemma.reset();

   399  
   400:         TRACE("conflict_bug",
   401                tout << "conflict_lvl: " << m_conflict_lvl << " scope_lvl: " << m_ctx.get_scope_level() << " base_lvl: " << m_ctx.get_base_level()

   414          if (m_conflict_lvl <= m_ctx.get_search_level()) {
   415:             TRACE("conflict", tout << "problem is unsat\n";);
   416:             TRACE("conflict", m_ctx.display(tout););
   417              if (m.proofs_enabled())

   423  
   424:         TRACE("conflict", tout << "conflict_lvl: " << m_conflict_lvl << "\n";);
   425  

   444  
   445:         TRACE("conflict", m_ctx.display_literals(tout << "before minimization:\n", m_lemma) << "\n" << m_lemma << "\n";);
   446  
   447:         TRACE("conflict_verbose",m_ctx.display_literals_verbose(tout << "before minimization:\n", m_lemma) << "\n";);
   448  

   451  
   452:         TRACE("conflict", m_ctx.display_literals(tout << "after minimization:\n", m_lemma) << "\n";);
   453:         TRACE("conflict_verbose", m_ctx.display_literals_verbose(tout << "after minimization:\n", m_lemma) << "\n";);
   454:         TRACE("conflict_bug", m_ctx.display_literals_verbose(tout, m_lemma) << "\n";);
   455  

   474  
   475:         TRACE("conflict",
   476                tout << "new scope level:     " << m_new_scope_lvl << "\n";

   493  
   494:         TRACE("conflict", m_ctx.display_literal_verbose(tout, not_l); m_ctx.display(tout << " ", conflict););
   495  

   501          if (not_l != null_literal) {
   502:             TRACE("conflict", tout << "not_l: "; m_ctx.display_literal_verbose(tout, not_l) << "\n";);
   503              process_antecedent(not_l, num_marks);

   513  
   514:             TRACE("conflict", tout << "processing consequent id: " << idx << " lit: " << consequent << " "; m_ctx.display_literal(tout, consequent); 
   515                    m_ctx.display_literal_verbose(tout << " ", consequent) << "\n";

   521                  clause * cls = js.get_clause();
   522:                 TRACE("conflict_smt2", m_ctx.display_clause_smt2(tout, *cls););
   523                  if (cls->is_lemma())

   549              case b_justification::BIN_CLAUSE:
   550:                 TRACE("conflict_smt2", m_ctx.display_literals_smt2(tout, consequent, ~js.get_literal()) << "\n";);
   551                  SASSERT(consequent.var() != js.get_literal().var());

   566                      break;
   567:                 CTRACE("conflict", m_ctx.get_assign_level(l) != m_conflict_lvl && m_ctx.get_assign_level(l) != m_ctx.get_base_level(),
   568                         tout << "assign_level(l): " << m_ctx.get_assign_level(l) << ", conflict_lvl: ";

   588  
   589:         TRACE("conflict", tout << "FUIP: "; m_ctx.display_literal(tout, consequent)<< "\n";);
   590  

   593  
   594:         TRACE("conflict_smt2", m_ctx.display_literals_smt2(tout << "lemma:", m_lemma) << "\n";);
   595  

   764          m_ctx.m_stats.m_num_minimized_lits += sz - j;
   765:         TRACE("conflict", tout << "lemma: " << m_lemma << "\n";);
   766      }

   774          if (m_eq2proof.find(n1, n2, pr)) {
   775:             TRACE("proof_gen_bug", tout << "eq2_pr_cached: #" << n1->get_owner_id() << " #" << n2->get_owner_id() << "\n";);
   776              return pr;

   805          if (!is_eq || (f1 != n2_owner && f2 != n2_owner)) {
   806:             CTRACE("norm_eq_proof_bug", !m_ctx.is_true(n2) && !m_ctx.is_false(n2),
   807                     tout << "n1: #" << n1->get_owner_id() << ", n2: #" << n2->get_owner_id() << "\n";

   823          }
   824:         TRACE("norm_eq_proof",
   825                tout << mk_bounded_pp(pr, m, 4) << "\n";

   851          case eq_justification::EQUATION:
   852:             TRACE("proof_gen_bug", tout << js.get_literal() << "\n"; m_ctx.display_literal_info(tout, js.get_literal()););
   853              return norm_eq_proof(n1, n2, get_proof(js.get_literal()));

   890                  else {
   891:                     TRACE("comm_proof_bug", tout << "e1: #" << e1->get_id() << " e2: #" << e2->get_id() << "\n" << mk_bounded_pp(e1, m, 10) <<
   892                            "\n" << mk_bounded_pp(e2, m, 10) << "\n";);

   930          if (m_lit2proof.find(l, pr)) {
   931:             TRACE("proof_gen_bug", tout << "lit2pr_cached: #" << l << " " << pr << " " << pr->get_id() << "\n";);
   932              return pr;

   947          #define DUMP_AFTER_NUM_INVOCATIONS 213473
   948:         CTRACE("get_proof_bug_after", invocation_counter >= DUMP_AFTER_NUM_INVOCATIONS, tout << "START get_proof\n";);
   949  #endif

   981                  bool visited       = pr != nullptr;
   982:                 TRACE("get_proof_bug", if (pr != 0) tout << js->get_name() << "\n";);
   983:                 CTRACE("get_proof_bug_after", invocation_counter >= DUMP_AFTER_NUM_INVOCATIONS, if (pr != 0) tout << js->get_name() << "\n";);
   984:                 CTRACE("get_proof_bug_after", invocation_counter >= DUMP_AFTER_NUM_INVOCATIONS, if (pr != 0) js->display_debug_info(*this, tout););
   985                  prs.push_back(pr);

  1011                  m_ctx.literal2expr(l, l_exr);
  1012:                 TRACE("get_proof_bug",
  1013                        tout << "clause:\n";

  1024                        tout << "consequent:\n" << mk_pp(l_exr, m) << "\n";);
  1025:                 CTRACE("get_proof_bug_after",
  1026                         invocation_counter >= DUMP_AFTER_NUM_INVOCATIONS,

  1038                         tout << "consequent:\n" << mk_pp(l_exr, m) << "\n";);
  1039:                 TRACE("get_proof",
  1040                        tout << l.index() << " " << true_literal.index() << " " << false_literal.index() << " ";

  1042                        tout << mk_ll_pp(l_exr, m););
  1043:                 CTRACE("get_proof_bug_after",
  1044                         invocation_counter >= DUMP_AFTER_NUM_INVOCATIONS,

  1064          if (m_js2proof.find(js, pr)) {
  1065:             TRACE("proof_gen_bug", tout << "js2pr_cached: #" << js << " " << pr << " " << pr->get_id() << "\n";);
  1066              return pr;

  1068          SASSERT(js != nullptr);
  1069:         TRACE("proof_gen_bug", tout << js << "\n";);
  1070          m_todo_pr.push_back(tp_elem(js));

  1074      void conflict_resolution::reset() {
  1075:         TRACE("proof_gen_bug", tout << "reset_caches\n";);
  1076          m_new_proofs.reset();

  1089          SASSERT(js.get_kind() != b_justification::BIN_CLAUSE);
  1090:         CTRACE("visit_b_justification_bug", js.get_kind() == b_justification::AXIOM, tout << "l: " << l << "\n"; m_ctx.display(tout););
  1091  

  1125          SASSERT(pr);
  1126:         TRACE("proof_gen_bug", tout << "lit2pr_saved: #" << l << " " << pr << " " << pr->get_id() << "\n";);
  1127          m_lit2proof.insert(l, pr);
  1128          m_trail.push_back(pr);
  1129:         TRACE("mk_proof",
  1130                tout << mk_bounded_pp(m_ctx.bool_var2expr(l.var()), m, 10) << "\n";

  1250          else {
  1251:             TRACE("mk_transitivity",
  1252                    unsigned sz = prs1.size();

  1258          m_new_proofs.push_back(pr);
  1259:         TRACE("proof_gen_bug", tout << "eq2pr_saved: #" << lhs->get_owner_id() << " #" << rhs->get_owner_id() << "\n";);
  1260          m_eq2proof.insert(lhs, rhs, pr);

  1265          SASSERT(not_l == null_literal || conflict.get_kind() == b_justification::AXIOM || conflict.get_kind() == b_justification::JUSTIFICATION);
  1266:         TRACE("mk_conflict_proof", m_ctx.display_literals(tout << "lemma literals:", m_lemma) << "\n";);
  1267  

  1303                          m_new_proofs.push_back(pr);
  1304:                         TRACE("proof_gen_bug", tout << "js2pr_saved: #" << js << "\n";);
  1305                          m_trail.push_back(pr);

  1357              m_lemma_proof = m.mk_lemma(pr, fact);
  1358:         TRACE("mk_conflict_proof", tout << mk_pp(m_lemma_proof, m) << "\n";);
  1359          m_new_proofs.reset();

  1364          bool_var var = antecedent.var();
  1365:         CTRACE("conflict", !m_ctx.is_marked(var), tout << "processing antecedent: ";
  1366            m_ctx.display_literal_info(tout << antecedent << " ", antecedent);

  1409          while (true) {
  1410:             TRACE("unsat_core_trail", tout << consequent << ", idx: " << idx << " " << js.get_kind() << "\n";
  1411                    m_ctx.display_literal_smt2(tout, consequent) << "\n";

  1415                  clause * cls = js.get_clause();
  1416:                 TRACE("unsat_core_bug", m_ctx.display_clause_detail(tout, cls););
  1417                  unsigned num_lits = cls->get_num_literals();

  1456                  literal l = m_assigned_literals[idx];
  1457:                 CTRACE("unsat_core_bug", m_ctx.is_marked(l.var()), tout << "l: " << l << ", get_assign_level(l): " << m_ctx.get_assign_level(l) << "\n";);
  1458                  if (m_ctx.get_assign_level(l) < search_lvl)

  1476      end_unsat_core:
  1477:         TRACE("unsat_core", tout << "assumptions:\n"; m_ctx.display_literals(tout, m_assumptions); tout << "\n";);
  1478          reset_unmark_and_justifications(0, 0);

z3/src/smt/smt_conflict_resolution.h:
  127                  if (m_already_processed_eqs.insert_if_not_there(p)) {
  128:                     TRACE("conflict_detail_verbose", tout << "marking eq #" << p.first->get_owner_id() << " = #" << 
  129                            p.second->get_owner_id() << "\n";);

z3/src/smt/smt_consequences.cpp:
   54          expr* e = bool_var2expr(lit.var());
   55:         TRACE("context", tout << mk_pp(e, m) << "\n";);
   56          index_set s;

  101          auto add_antecedent = [&](literal l) {
  102:             CTRACE("context", !m_antecedents.contains(l.var()), 
  103                     tout << "untracked literal: " << l << " " 

  169                  literal lit = get_literal(k);
  170:                 TRACE("context", 
  171                        tout << "checking " << mk_pp(k, m) << " " 

  216      unsigned context::extract_fixed_eqs(expr_ref_vector& conseq) {
  217:         TRACE("context", tout << "extract fixed consequences\n";);
  218          auto are_equal = [&](expr* k, expr* v) {

  247                  mk_clause(literals.size(), literals.data(), nullptr);
  248:                 TRACE("context", display_literals_verbose(tout, literals.size(), literals.data()););
  249              }

  335          if (is_sat != l_true) {
  336:             TRACE("context", tout << is_sat << "\n";);
  337              return is_sat;

  343  
  344:         TRACE("context", display(tout););
  345  

  350          expr_ref val(m);
  351:         TRACE("context", model_pp(tout, *mdl););
  352          for (expr* v : vars) {

  364          app_ref eq(m);
  365:         TRACE("context", 
  366                tout << "vars: " << vars.size() << "\n";

  428              if (is_sat == l_true) {
  429:                 TRACE("context", display(tout););
  430                  delete_unfixed(unfixed);

  435                                                         unfixed.size(), num_fixed_eqs););
  436:             TRACE("context", display_consequence_progress(tout, num_iterations, m_var2val.size(), conseq.size(),
  437                                                         unfixed.size(), num_fixed_eqs););

  640              }
  641:             TRACE("context", tout << "checking fixed: " << mk_pp(c, m) << "\n";);
  642              tmp = m.mk_not(c);

  651                  assert_expr(a);
  652:             TRACE("context", tout << "checking unfixed: " << mk_pp(uf, m) << "\n";);
  653              lbool is_sat = check();            

z3/src/smt/smt_context_inv.cpp:
   57              clause * cls = *it;
   58:             TRACE("watch_list", tout << "l: "; display_literal(tout, l); tout << "\n";
   59                    display_clause(tout, cls); tout << "\n";);

   94              (is_true_eq && !m_cg_table.contains_ptr(n));
   95:         CTRACE("check_enode", !cg_inv,
   96                 tout << "n: #" << n->get_expr_id() << ", m_cg: #" << n->m_cg->get_expr_id() << ", contains: " << m_cg_table.contains(n) << "\n"; display(tout););

  118          for (clause * cls : v) {
  119:             CTRACE("missing_propagation", is_unit_clause(cls), display_clause_detail(tout, cls); tout << "\n";);
  120              SASSERT(!is_unit_clause(cls));

  161                          continue;
  162:                     CTRACE("missing_propagation", congruent(n, n2),
  163                             tout << mk_pp(n->get_expr(), m) << "\n" << mk_pp(n2->get_expr(), m) << "\n";

  176                  do {
  177:                     CTRACE("missing_propagation", get_assignment(n) != l_undef,
  178                             tout << mk_pp(first->get_expr(), m) << "\nassignment: " << get_assignment(first) << "\n" 

  211              if (m.is_or(n)) {
  212:                 CTRACE("relevancy_bug", !is_relevant(n), tout << "n: " << mk_ismt2_pp(n, m) << "\n";);
  213                  SASSERT(is_relevant(n));
  214:                 TRACE("check_relevancy", tout << "checking:\n" << mk_ll_pp(n, m) << "\n";);
  215                  SASSERT(m_relevancy_propagator->check_relevancy_or(to_app(n), true));

  217              else if (m.is_not(n)) {
  218:                 CTRACE("relevancy_bug", !is_relevant(to_app(n)->get_arg(0)), tout << "n: " << mk_ismt2_pp(n, m) << "\n";);
  219                  SASSERT(is_relevant(to_app(n)->get_arg(0)));

  221              else {
  222:                 CTRACE("relevancy_bug", !is_relevant(n), tout << "n: " << mk_ismt2_pp(n, m) << "\n";);
  223                  SASSERT(is_relevant(n));

  236                  enode * r = e->get_root();
  237:                 CTRACE("eqc_bool", get_assignment(e) != get_assignment(r), 
  238                         tout << "#" << e->get_expr_id() << "\n" << mk_pp(e->get_expr(), m) << "\n";

  264      bool context::check_th_diseq_propagation() const {
  265:         TRACE("check_th_diseq_propagation", tout << "m_propagated_th_diseqs.size() " << m_propagated_th_diseqs.size() << "\n";);
  266          unsigned num = get_num_bool_vars();

  273                  if (n->is_eq() && is_relevant(n) && get_assignment(v) == l_false && !m.is_iff(n->get_expr())) {
  274:                     TRACE("check_th_diseq_propagation", tout << "checking: #" << n->get_expr_id() << " " << mk_bounded_pp(n->get_expr(), m) << "\n";);
  275                      enode * lhs = n->get_arg(0)->get_root();

  280                          continue;
  281:                     TRACE("check_th_diseq_propagation", tout << "num. theory_vars: " << lhs->get_num_th_vars() << " " 
  282                            << mk_pp(lhs->get_expr()->get_sort(), m) << "\n";);

  286                          theory * th = get_theory(th_id);
  287:                         TRACE("check_th_diseq_propagation", tout << "checking theory: " << m.get_family_name(th_id) << "\n";);
  288                          // if the theory doesn't use diseqs, then the diseqs are not propagated.

  298                                          (rhs == lhs_prime && lhs == rhs_prime)) {
  299:                                         TRACE("check_th_diseq_propagation", tout << "ok v" << v << " " << get_assignment(v) << "\n";);
  300                                          found = true;

  304                              }
  305:                             CTRACE("check_th_diseq_propagation", !found,
  306                                     tout 

  326              if (n1->get_root() == n2->get_root()) {
  327:                 TRACE("diseq_bug", 
  328                        tout << "n1: #" << n1->get_expr_id() << ", n2: #" << n2->get_expr_id() <<

  373                      return true;
  374:                 CTRACE("model", !m.is_true(res), tout << n << " evaluates to " << res << "\n" << *m_proto_model << "\n";); 
  375                  if (m.is_false(res)) {

  381                      return true;
  382:                 CTRACE("model", !m.is_false(res), tout << n << " evaluates to " << res << "\n" << *m_proto_model << "\n";); 
  383                  if (m.is_true(res)) {

z3/src/smt/smt_context_pp.cpp:
  469          std::ofstream out(name);
  470:         TRACE("lemma", tout << name << "\n";);
  471          display_lemma_as_smt_problem(out, num_antecedents, antecedents, consequent, logic);

  521          std::ofstream out(name);
  522:         TRACE("lemma", tout << name << "\n";
  523                display_lemma_as_smt_problem(tout, num_antecedents, antecedents, num_eq_antecedents, eq_antecedents, consequent, logic);

z3/src/smt/smt_context.cpp:
   178  
   179:         TRACE("smt_context",
   180                src_ctx.display(tout);

   283          d.m_phase                  = !l.sign();
   284:         TRACE("assign_core", tout << (decision?"decision: ":"propagating: ") << l << " ";
   285                display_literal_smt2(tout, l) << "\n";

   288                );
   289:         TRACE("phase_selection", tout << "saving phase, is_pos: " << d.m_phase << " l: " << l << "\n";);
   290  

   341                  clause * cls = *it;
   342:                 CTRACE("bcp_bug", cls->get_literal(0) != not_l && cls->get_literal(1) != not_l, display_clause_detail(tout, cls);
   343                         tout << "not_l: "; display_literal(tout, not_l); tout << " " << not_l << "\n";);

   436              return;
   437:         TRACE("add_diseq",
   438                tout << "#" << t->get_enode(lhs)->get_owner_id() << " != "

   469          try {
   470:             TRACE("add_eq", tout << "assigning: #" << n1->get_owner_id() << " = #" << n2->get_owner_id() << "\n";);
   471:             TRACE("add_eq_detail", tout << "assigning\n" << enode_pp(n1, *this) << "\n" << enode_pp(n2, *this) << "\n";
   472                    tout << "kind: " << js.get_kind() << "\n";);

   479              if (r1 == r2) {
   480:                 TRACE("add_eq", tout << "redundant constraint.\n";);
   481                  return;

   485              if (r1->is_interpreted() && r2->is_interpreted()) {
   486:                 TRACE("add_eq", tout << "interpreted roots conflict.\n";);
   487                  set_conflict(mk_justification(eq_conflict_justification(n1, n2, js)));

   503  
   504:             TRACE("add_eq", tout << "merging: #" << r1->get_owner_id() << " #" << r2->get_owner_id() <<
   505                    " n1: #" << n1->get_owner_id() << "\n";);

   568              // If the add_eq_trail remains on the trail stack, then Z3 may crash when the destructor is invoked.
   569:             TRACE("add_eq", tout << "add_eq interrupted. This is unsafe " << m.limit().is_canceled() << "\n";);
   570              m_trail_stack.shrink(old_trail_size);

   581          for (enode * parent : enode::parents(r1)) {
   582:             CTRACE("add_eq", !parent->is_marked() && parent->is_cgc_enabled() && parent->is_true_eq() && m_cg_table.contains_ptr(parent), tout << parent->get_owner_id() << "\n";);
   583:             CTRACE("add_eq", !parent->is_marked() && parent->is_cgc_enabled() && !parent->is_true_eq() &&  parent->is_cgr() && !m_cg_table.contains_ptr(parent), 
   584                     tout << "cgr !contains " << parent->get_owner_id() << " " << mk_pp(parent->get_decl(), m) << "\n";

   592                     );
   593:             CTRACE("add_eq", !parent->is_marked() && parent->is_cgc_enabled() && !parent->is_true_eq() && !parent->is_cgr() &&  m_cg_table.contains_ptr(parent), tout << "!cgr contains " << parent->get_owner_id() << "\n";);
   594              SASSERT(parent->is_marked() || !parent->is_cgc_enabled() ||  parent->is_true_eq() || parent->is_cgr() == m_cg_table.contains_ptr(parent));

   630                  SASSERT(parent->get_num_args() == 2);
   631:                 TRACE("add_eq_bug", tout << "visiting: #" << parent->get_owner_id() << "\n";);
   632                  enode * lhs = parent->get_arg(0);

   662                      bool used_commutativity = pair.second;
   663:                     TRACE("cg", tout << "found new congruence: #" << parent->get_owner_id() << " = #" << parent_prime->get_owner_id()
   664                            << " used_commutativity: " << used_commutativity << "\n";);

   768          if (!r1->has_th_vars() && !r2->has_th_vars()) {
   769:             TRACE("merge_theory_vars", tout << "Neither have theory vars #" 
   770                    << mk_bounded_pp(n1->get_expr(), m) << " #" << mk_bounded_pp(n2->get_expr(), m) << "\n";);

   784              theory_var v1 = m_fparams.m_new_core2th_eq ? get_closest_var(n1, t1) : r1->m_th_var_list.get_var();
   785:             TRACE("merge_theory_vars",
   786                    tout << "v2: " << v2 << " #" << r2->get_owner_id() << ", v1: " << v1 << " #" << r1->get_owner_id()

   806                  r2->m_th_var_list.set_id(t1);
   807:                 TRACE("merge_theory_vars", tout << "push_new_th_diseqs v1: " << v1 << ", t1: " << t1 << "\n";);
   808                  push_new_th_diseqs(r2, v1, get_theory(t1));

   812              // r1 and/or r2 have more than one theory variable.
   813:             TRACE("merge_theory_vars",
   814                    tout << "#" << r1->get_owner_id() << " == #" << r2->get_owner_id() << "\n";);

   824  
   825:                 TRACE("merge_theory_vars", tout << get_theory(t2)->get_name() << ": " << v2 << " == " << v1 << "\n");
   826  

   844                  theory_var v2 = r2->get_th_var(t1);
   845:                 TRACE("merge_theory_vars", tout << get_theory(t1)->get_name() << ": " << v2 << " == " << v1 << "\n");
   846                  if (v2 == null_theory_var) {

   918          enode * r2 = r1->get_root();
   919:         TRACE("add_eq", tout << "undo_add_eq #" << r1->get_owner_id() << " #" << r2->get_owner_id() << "\n";);
   920  

   933              if (parent->is_cgc_enabled()) {
   934:                 CTRACE("add_eq", !parent->is_cgr() || !m_cg_table.contains_ptr(parent),
   935                         tout << "old num_parents: " << r2_num_parents 

   958          for (enode * parent : enode::parents(r1)) {
   959:             TRACE("add_eq_parents", tout << "visiting: #" << parent->get_owner_id() << "\n";);
   960              if (parent->is_cgc_enabled()) {

  1057          enode * r2 = n2->get_root();
  1058:         TRACE("add_diseq", tout << "assigning: #" << n1->get_owner_id() << " != #" << n2->get_owner_id() << "\n";
  1059                tout << mk_ll_pp(n1->get_expr(), m) << " != ";

  1069          if (r1 == r2) {
  1070:             TRACE("add_diseq_inconsistent", tout << "add_diseq #" << n1->get_owner_id() << " #" << n2->get_owner_id() << " inconsistency, scope_lvl: " << m_scope_lvl << "\n";);
  1071              //return false;

  1083              theory_var v2 = m_fparams.m_new_core2th_eq ? get_closest_var(n2, t1) : r2->m_th_var_list.get_var();
  1084:             TRACE("add_diseq", tout << "one theory diseq\n";
  1085                    tout << v1 << " != " << v2 << "\n";

  1099                  theory * th   = get_theory(t1);
  1100:                 TRACE("add_diseq", tout << m.get_family_name(t1) << "\n";);
  1101                  if (th->use_diseqs()) {

  1135          SASSERT((r != 0) == m_cg_table.contains(m_is_diseq_tmp));
  1136:         TRACE("is_diseq", tout << "r: " << r << "\n";);
  1137          if (r) {

  1142          }
  1143:         CTRACE("is_diseq_bug", is_diseq_slow(n1, n2), tout << "#" << n1->get_owner_id() << " #" << n2->get_owner_id() << "\n";);
  1144          return false;

  1156                   (parent->get_arg(1)->get_root() == n1->get_root() && parent->get_arg(0)->get_root() == n2->get_root()))) {
  1157:                 TRACE("is_diseq_bug", tout << "parent: #" << parent->get_owner_id() << ", parent->root: #" <<
  1158                        parent->get_root()->get_owner_id() << " assignment(parent): " << get_assignment(enode2bool_var(parent)) <<

  1183          if (r1->get_num_parents() < SMALL_NUM_PARENTS) {
  1184:             TRACE("is_ext_diseq", tout << enode_pp(n1, *this) << " " << enode_pp(n2, *this) << " " << depth << "\n";);
  1185              for (enode * p1 : enode::parents(r1)) {

  1192                  func_decl * f     = p1->get_decl();
  1193:                 TRACE("is_ext_diseq", tout << "p1: " << enode_pp(p1, *this) << "\n";);
  1194                  unsigned num_args = p1->get_num_args();

  1201                          continue;
  1202:                     TRACE("is_ext_diseq", tout << "p2: " << enode_pp(p2, *this) << "\n";);
  1203                      if (p1->get_root() != p2->get_root() && p2->get_decl() == f && p2->get_num_args() == num_args) {

  1215                          if (j == num_args) {
  1216:                             TRACE("is_ext_diseq", tout << "found parents: " << enode_pp(p1, *this) << " " << enode_pp(p2, *this) << "\n";);
  1217                              if (is_ext_diseq(p1, p2, depth - 1))

  1280                      enode * _arg = get_enode(arg);
  1281:                     CTRACE("eq_to_bug", args[i]->get_root() != _arg->get_root(),
  1282                             tout << "#" << args[i]->get_expr_id() << " #" << args[i]->get_root()->get_expr_id()

  1317          SASSERT(!inconsistent());
  1318:         CTRACE("propagate_atoms", !m_atom_propagation_queue.empty(), tout << m_atom_propagation_queue << "\n";);
  1319          for (unsigned i = 0; i < m_atom_propagation_queue.size() && !get_cancel_flag(); i++) {

  1323              lbool val  = get_assignment(v);
  1324:             TRACE("propagate_atoms", tout << "propagating atom, #" << bool_var2expr(v)->get_id() 
  1325                    << ", is_enode(): " << get_bdata(v).is_enode() << " tag: " 

  1346                  else {
  1347:                     TRACE("add_diseq", display_eq_detail(tout, bool_var2enode(v)););
  1348                      if (!add_diseq(get_enode(lhs), get_enode(rhs)) && !inconsistent()) {

  1362                  // becomes an unit-clause and the remaining literal is the negation of a quantifier.
  1363:                 CTRACE("assign_quantifier_bug", get_assignment(v) != l_true,
  1364                         tout << "#" << bool_var2expr(v)->get_id() << " val: " << get_assignment(v) << "\n";

  1411          lbool val  = get_assignment(v);
  1412:         TRACE("propagate_bool_var_enode_bug", tout << "var: " << v << " #" << bool_var2expr(v)->get_id() << "\n";);
  1413          SASSERT(v < m_b_internalized_stack.size());

  1415  
  1416:         CTRACE("mk_bool_var", !n, tout << "No enode for " << v << "\n";);
  1417          bool sign  = val == l_false;

  1447          if (!th->use_diseqs()) {
  1448:             TRACE("push_new_th_diseqs", tout << m.get_family_name(th->get_id()) << " not using diseqs\n";);
  1449              return;

  1451          theory_id th_id = th->get_id();
  1452:         TRACE("push_new_th_diseqs", tout << "#" << r->get_owner_id() << " " << mk_bounded_pp(r->get_expr(), m) << " v" << v << " th: " << th_id << "\n";);
  1453          for (enode * parent : r->get_parents()) {
  1454:             CTRACE("parent_bug", parent == 0, tout << "#" << r->get_owner_id() << ", num_parents: " << r->get_num_parents() << "\n"; display(tout););
  1455              if (parent->is_eq()) {

  1459                      enode * rhs = parent->get_arg(1);
  1460:                     TRACE("push_new_th_diseqs",
  1461                            tout << "#" << parent->get_owner_id() << " ";

  1465                            );
  1466:                     CTRACE("push_new_th_diseqs", lhs->get_root() != r->get_root() && rhs->get_root() != r->get_root(),
  1467                             tout << "lhs: #" << lhs->get_owner_id() << ", rhs: #" << rhs->get_owner_id() <<

  1494      inline lbool context::get_assignment_core(expr * n) const {
  1495:         CTRACE("get_assignment_bug", !b_internalized(n), tout << "n:\n" << mk_pp(n, m) << "\n"; display(tout););
  1496          SASSERT(b_internalized(n));

  1541          bool_var v = get_bool_var_of_id(owner->get_id());
  1542:         CTRACE("missing_propagation", v == null_bool_var, tout << mk_pp(owner, m) << "\n";);
  1543          return get_assignment(v);

  1577          }
  1578:         TRACE("propagate_relevancy", tout << "marking as relevant:\n" << mk_bounded_pp(n, m) << " " << m_scope_lvl << "\n";);
  1579          m_case_split_queue->relevant_eh(n);

  1698      bool context::propagate() {
  1699:         TRACE("propagate", tout << "propagating... " << m_qhead << ":" << m_assigned_literals.size() << "\n";);
  1700          while (true) {

  1744          if (!inconsistent()) {
  1745:             TRACE("set_conflict", display_literal_verbose(tout << m_scope_lvl << " ", not_l); display(tout << " ", js); );
  1746              m_conflict = js;

  1751      void context::assign_quantifier(quantifier * q) {
  1752:         TRACE("assumption", tout << mk_pp(q, m) << "\n";);
  1753          m_qmanager->assign_eh(q);

  1765      void context::rescale_bool_var_activity() {
  1766:         TRACE("case_split", tout << "rescale\n";);        
  1767          svector<double>::iterator it  = m_activity.begin();

  1815              if (m_phase_cache_on && d.m_phase_available) {
  1816:                 TRACE("phase_selection", tout << "using cached value, is_pos: " << m_bdata[var].m_phase << ", var: p" << var << "\n";);
  1817                  return m_bdata[var].m_phase;

  1819              else {
  1820:                 TRACE("phase_selection", tout << "setting to false\n";);
  1821                  return m_phase_default;

  1868                  if (counter % 100 == 0) {
  1869:                     TRACE("activity_profile",
  1870                            for (unsigned i=0; i<get_num_bool_vars(); i++) {

  1881          push_scope();
  1882:         TRACE("decide", tout << "splitting, lvl: " << m_scope_lvl << "\n";);
  1883  
  1884:         TRACE("decide_detail", tout << mk_pp(bool_var2expr(var), m) << "\n";);
  1885          

  1896          if (!is_pos) l.neg();
  1897:         TRACE("decide", tout << "case split " << l << "\n" << "activity: " << get_activity(var) << "\n";);
  1898          assign(l, b_justification::mk_axiom(), true);

  1936          scope & s = m_scopes.back();
  1937:         // TRACE("context", tout << "push " << m_scope_lvl << "\n";);
  1938  

  2024              m_clause_proof.del(*cls);
  2025:         CTRACE("context", !m_flushing, display_clause_smt2(tout << "deleting ", *cls) << "\n";);
  2026          if (!cls->deleted())

  2083              literal l                  = m_assigned_literals[i];
  2084:             CTRACE("assign_core", l.var() == 13, tout << "unassign " << l << "\n";);
  2085              m_assignment[l.index()]    = l_undef;

  2228                          continue; // node and its children will not be recreated during backtracking
  2229:                     TRACE("cached_generation", tout << "caching: #" << n->get_id() << " " << e->get_generation() << "\n";);
  2230                      m_cached_generation.insert(n, e->get_generation());

  2260      void context::reinit_clauses(unsigned num_scopes, unsigned num_bool_vars) {
  2261:         TRACE("reinit_clauses_bug", display_watch_lists(tout););
  2262          if (m_clauses_to_reinit.empty())

  2335  
  2336:                     TRACE("reinit_clauses", tout << "reinit clause:\n"; display_clause_detail(tout, cls); tout << "\n";
  2337                            tout << "activity: " << cls->get_activity() << ", num_bool_vars: " << num_bool_vars << ", scope_lvl: "

  2369          CASSERT("reinit_clauses", check_clauses(m_lemmas));
  2370:         TRACE("reinit_clauses_bug", display_watch_lists(tout););
  2371      }

  2383              assign(l, b_justification::mk_axiom());
  2384:             TRACE("reassert_units", tout << "reasserting #" << unit->get_id() << " " << sign << " @ " << m_scope_lvl << "\n";);
  2385          }

  2406  
  2407:             // TRACE("context", tout << "backtracking: " << num_scopes << " from " << m_scope_lvl << "\n";);
  2408:             TRACE("pop_scope_detail", display(tout););
  2409              SASSERT(num_scopes > 0);

  2418  
  2419:             TRACE("pop_scope", tout << "backtracking: " << num_scopes << ", new_lvl: " << new_lvl << "\n";);
  2420              scope & s = m_scopes[new_lvl];
  2421:             TRACE("context", tout << "backtracking new_lvl: " << new_lvl << "\n";);
  2422  

  2454  
  2455:             CTRACE("propagate_atoms", !m_atom_propagation_queue.empty(), tout << m_atom_propagation_queue << "\n";);
  2456  

  2482          reassert_units(units_to_reassert_lim);
  2483:         TRACE("pop_scope_detail", tout << "end of pop_scope: \n"; display(tout););
  2484          CASSERT("context", check_invariant());

  2589              if (cls->deleted()) {
  2590:                 TRACE("simplify_clauses_bug", display_clause(tout << "deleted\n", cls) << "\n";);
  2591                  del_clause(true, cls);

  2594              else if (simplify_clause(*cls)) {
  2595:                 TRACE("simplify_clauses_bug", display_clause_smt2(tout << "simplified\n", *cls) << "\n";);
  2596                  for (unsigned idx = 0; idx < 2; idx++) {

  2664          if (m_simp_qhead == sz || m_simp_counter > 0) {
  2665:             TRACE("simplify_clauses", tout << "m_simp_qhead: " << m_simp_qhead << " m_simp_counter: " << m_simp_counter << "\n";);
  2666              return;

  2669          if (m_aux_clauses.empty() && m_lemmas.empty()) {
  2670:             TRACE("simplify_clauses", tout << "no clauses to simplify\n";);
  2671              return;

  2673  
  2674:         TRACE("simplify_clauses_detail", tout << "before:\n"; display_clauses(tout, m_lemmas););
  2675  

  2708          m_stats.m_num_simplifications++;
  2709:         TRACE("simp_counter", tout << "simp_counter: " << m_simp_counter << " scope_lvl: " << m_scope_lvl << "\n";);
  2710:         TRACE("simplify_clauses_detail", tout << "after:\n"; display_clauses(tout, m_lemmas););
  2711          SASSERT(check_clauses(m_lemmas) && check_clauses(m_aux_clauses));

  2751          unsigned num_del_cls   = 0;
  2752:         TRACE("del_inactive_lemmas", tout << "sz: " << sz << ", start_at: " << start_at << ", end_at: " << end_at
  2753                << ", start_del_at: " << start_del_at << "\n";);

  2756              if (can_delete(cls)) {
  2757:                 TRACE("del_inactive_lemmas", tout << "deleting: "; display_clause(tout, cls); tout << ", activity: " <<
  2758                        cls->get_activity() << "\n";);

  2885          }
  2886:         TRACE("internalize", tout << this << " " << th->get_family_id() << "\n";);
  2887          SASSERT(std::find(m_theory_set.begin(), m_theory_set.end(), th) == m_theory_set.end());

  2996          flet<bool> l1(m_flushing, true);
  2997:         TRACE("flush", tout << "m_scope_lvl: " << m_scope_lvl << "\n";);
  2998          m_relevancy_propagator = nullptr;

  3020          SASSERT(is_well_sorted(m, e));
  3021:         TRACE("begin_assert_expr", tout << mk_pp(e, m) << " " << mk_pp(pr, m) << "\n";);
  3022:         TRACE("begin_assert_expr_ll", tout << mk_ll_pp(e, m) << "\n";);
  3023          pop_to_base_lvl();

  3027              m_asserted_formulas.assert_expr(e, pr);
  3028:         TRACE("end_assert_expr_ll", ast_mark m; m_asserted_formulas.display_ll(tout, m););
  3029      }

  3053      void context::mk_th_case_split(unsigned num_lits, literal * lits) {
  3054:         TRACE("theory_case_split", display_literals_verbose(tout << "theory case split: ", num_lits, lits); tout << std::endl;);
  3055          // If we don't use the theory case split heuristic,

  3086              }
  3087:             TRACE("theory_case_split", tout << "tracking case split literal set { ";
  3088                    for (unsigned i = 0; i < num_lits; ++i) {

  3120              literal l = m_assigned_literals[qhead];
  3121:             TRACE("theory_case_split", tout << "check literal " << l.index() << std::endl; display_literal_verbose(tout, l); tout << std::endl;);
  3122              // check if this literal participates in any theory case split

  3125              }
  3126:             TRACE("theory_case_split", tout << "assigned literal " << l.index() << " is a theory case split literal" << std::endl;);
  3127              // now find the sets of literals which contain l

  3130                  literal_vector case_split_set = *it;
  3131:                 TRACE("theory_case_split", tout << "found case split set { ";
  3132                        for(literal_vector::iterator set_it = case_split_set.begin(); set_it != case_split_set.end(); ++set_it) {

  3139                          b_justification js(l);
  3140:                         TRACE("theory_case_split", tout << "case split literal "; smt::display(tout, l2, m, m_bool_var2expr.data()); tout << std::endl;);
  3141                          if (l2 == true_literal || l2 == false_literal || l2 == null_literal) continue;

  3143                          if (inconsistent()) {
  3144:                             TRACE("theory_case_split", tout << "conflict detected!" << std::endl;);
  3145                              return false;

  3202          flet<bool> _internalizing(m_internalizing_assertions, true);
  3203:         TRACE("internalize_assertions", tout << "internalize_assertions()...\n";);
  3204          timeit tt(get_verbosity_level() >= 100, "smt.preprocessing");

  3231  
  3232:         TRACE("internalize_assertions", tout << "after internalize_assertions()...\n";
  3233                tout << "inconsistent: " << inconsistent() << "\n";);
  3234:         TRACE("after_internalize_assertions", display(tout););
  3235      }

  3359                  SASSERT(is_relevant(l));
  3360:                 TRACE("assumptions", tout << l << ":" << curr_assumption << " " << mk_pp(orig_assumption, m) << "\n";);
  3361              }

  3365          SASSERT(!asms.empty() || m_search_lvl == m_base_lvl);
  3366:         TRACE("after_internalization", display(tout););
  3367      }

  3369      void context::reset_assumptions() {
  3370:         TRACE("unsat_core_bug", tout << "reset " << m_assumptions << "\n";);
  3371          for (literal lit : m_assumptions) 

  3399              literal l = *it;
  3400:             TRACE("unsat_core_bug", tout << "answer literal: " << l << "\n";);
  3401              SASSERT(get_bdata(l.var()).m_assumption);

  3407                  m_unsat_core.push_back(orig_assumption);
  3408:                 TRACE("assumptions", tout << l << ": " << mk_pp(orig_assumption, m) << "\n";);
  3409              }

  3414          std::sort(m_unsat_core.data(), m_unsat_core.data() + m_unsat_core.size(), ast_lt_proc());
  3415:         TRACE("unsat_core_bug", tout << "unsat core:\n" << m_unsat_core << "\n";);
  3416          validate_unsat_core();

  3450      lbool context::check_finalize(lbool r) {
  3451:         TRACE("after_search", display(tout << "result: " << r << "\n");
  3452                m_case_split_queue->display(tout << "case splits\n");

  3559          if (!theory_assumptions.empty()) {
  3560:             TRACE("search", tout << "Adding theory assumptions to context" << std::endl;);
  3561              return check(0, nullptr, reset_cancel);

  3563          else {
  3564:             TRACE("before_search", display(tout););
  3565              return check_finalize(search());

  3621              add_theory_assumptions(asms);                
  3622:             TRACE("unsat_core_bug", tout << asms << "\n";);        
  3623              init_assumptions(asms);
  3624:             TRACE("before_search", display(tout););
  3625              r = search();

  3634          if (!check_preamble(true)) return l_undef;
  3635:         TRACE("before_search", display(tout););
  3636          setup_context(false);

  3677          m_next_progress_sample         = 0;
  3678:         TRACE("literal_occ", display_literal_num_occs(tout););
  3679      }

  3728          SASSERT(at_search_level());
  3729:         TRACE("search", display(tout); display_enodes_lbls(tout););
  3730:         TRACE("search_detail", m_asserted_formulas.display(tout););
  3731          init_search();
  3732          flet<bool> l(m_searching, true);
  3733:         TRACE("after_init_search", display(tout););
  3734          IF_VERBOSE(2, verbose_stream() << "(smt.searching)\n";);
  3735:         TRACE("search_lite", tout << "searching...\n";);
  3736          lbool    status            = l_undef;

  3742              status = bounded_search();
  3743:             TRACE("search_bug", tout << "status: " << status << ", inconsistent: " << inconsistent() << "\n";);
  3744:             TRACE("assigned_literals_per_lvl", display_num_assigned_literals_per_lvl(tout);
  3745                    tout << ", num_assigned: " << m_assigned_literals.size() << "\n";);

  3751  
  3752:         TRACE("guessed_literals",
  3753                expr_ref_vector guessed_lits(m);

  3810  
  3811:             TRACE("mbqi_bug_detail", tout << "before instantiating quantifiers...\n";);
  3812              if (!inconsistent()) 

  3842                         verbose_stream() << ")" << std::endl; verbose_stream().flush(););
  3843:             TRACE("assigned_literals_per_lvl", display_num_assigned_literals_per_lvl(tout); tout << "\n";);
  3844              counter = 0;

  3850  
  3851:         TRACE("bounded_search", tout << "starting bounded search...\n";);
  3852  

  3858                          first_propagate = false;
  3859:                         TRACE("after_first_propagate", display(tout););
  3860                      }

  3877                      if (m_num_conflicts_since_restart > m_restart_threshold && m_scope_lvl - m_base_lvl > 2) {
  3878:                         TRACE("search_bug", tout << "bounded-search return undef, inconsistent: " << inconsistent() << "\n";);
  3879                          return l_undef; // restart

  3882                      if (m_num_conflicts > m_fparams.m_max_conflicts) {
  3883:                         TRACE("search_bug", tout << "bounded-search return undef, inconsistent: " << inconsistent() << "\n";);
  3884                          m_last_search_failure = NUM_CONFLICTS;

  3911                  final_check_status fcs = final_check();
  3912:                 TRACE("final_check_result", tout << "fcs: " << fcs << " last_search_failure: " << m_last_search_failure << "\n";);
  3913                  switch (fcs) {

  3964      final_check_status context::final_check() {
  3965:         TRACE("final_check", tout << "final_check inconsistent: " << inconsistent() << "\n"; display(tout); display_normalized_enodes(tout););
  3966          CASSERT("relevancy", check_relevancy());

  3974          m_stats.m_num_final_checks++;
  3975:         TRACE("final_check_stats", tout << "m_stats.m_num_final_checks = " << m_stats.m_num_final_checks << "\n";);
  3976  

  3989          do {
  3990:             TRACE("final_check_step", tout << "processing: " << m_final_check_idx << ", result: " << result << "\n";);
  3991              final_check_status ok;

  3995                  ok = th->final_check_eh();
  3996:                 TRACE("final_check_step", tout << "final check '" << th->get_name() << " ok: " << ok << " inconsistent " << inconsistent() << "\n";);
  3997                  if (ok == FC_GIVEUP) {

  4003                  ok = m_qmanager->final_check_eh(true);
  4004:                 TRACE("final_check_step", tout << "quantifier  ok: " << ok << " " << "inconsistent " << inconsistent() << "\n";);
  4005              }

  4022  
  4023:         TRACE("final_check_step", tout << "result: " << result << "\n";);
  4024  
  4025          if (can_propagate()) {
  4026:             TRACE("final_check_step", tout << "can propagate: continue...\n";);
  4027              return FC_CONTINUE;

  4030          SASSERT(result != FC_DONE || check_th_diseq_propagation());
  4031:         TRACE("final_check_step", tout << "RESULT final_check: " << result << "\n";);
  4032          if (result == FC_GIVEUP && f != OK)

  4054              bool_var v = l.var();
  4055:             TRACE("forget_phase", tout << "forgetting phase of l: " << l << "\n";);
  4056              m_bdata[v].m_phase_available = false;

  4116              SASSERT(new_lvl < m_scope_lvl);
  4117:             TRACE("resolve_conflict_bug",
  4118                    tout << "m_scope_lvl: " << m_scope_lvl << ", new_lvl: " << new_lvl << ", lemma_intern_lvl: " << m_conflict_resolution->get_lemma_intern_lvl() << "\n";

  4150                  // check_proof(pr);
  4151:                 TRACE("context_proof", tout << mk_ll_pp(pr, m););
  4152:                 TRACE("context_proof_hack",
  4153                        static ast_mark visited;

  4182                          // bool_var v = get_bool_var(atom);
  4183:                         // CTRACE("resolve_conflict_crash", v == null_bool_var, tout << mk_ismt2_pp(atom, m) << "\n";);
  4184                          // SASSERT(v != null_bool_var);

  4193              reset_cache_generation();
  4194:             TRACE("resolve_conflict_bug",
  4195                    tout << "AFTER m_scope_lvl: " << m_scope_lvl << ", new_lvl: " << new_lvl << ", lemma_intern_lvl: " <<

  4211                      // the sign must have flipped when internalizing
  4212:                     CTRACE("resolve_conflict_bug", real_atom != bool_var2expr(l.var()), tout << mk_pp(real_atom, m) << "\n" << mk_pp(bool_var2expr(l.var()), m) << "\n";);
  4213                      SASSERT(real_atom == bool_var2expr(l.var()));

  4249                  m_units_to_reassert_sign.push_back(unit_sign);
  4250:                 TRACE("reassert_units", tout << "asserting #" << unit->get_id() << " " << unit_sign << " @ " << m_scope_lvl << "\n";);
  4251              }

  4253              m_conflict_resolution->release_lemma_atoms();
  4254:             TRACE("context_lemma", tout << "new lemma: ";
  4255                    literal_vector v(num_lits, lits);

  4428          expr * eq = mk_eq_atom(_lhs, _rhs);
  4429:         TRACE("assume_eq", tout << "creating interface eq:\n" << mk_pp(eq, m) << "\n";);
  4430          if (m.is_false(eq)) {

  4457              m_stats.m_num_interface_eqs++;
  4458:             TRACE("assume_eq", tout << "new internalization.\n";);
  4459          }

  4464              r = true;
  4465:             TRACE("assume_eq", tout << "marked as ieq.\n";);
  4466          }
  4467          if (get_assignment(v) == l_undef) {
  4468:             TRACE("assume_eq", tout << "variable is unassigned.\n";);
  4469              r = true;

  4471          if (relevancy() && !is_relevant(eq)) {
  4472:             TRACE("assume_eq", tout << "marking eq as relevant.\n";);
  4473              mark_as_relevant(eq);

  4475          }
  4476:         TRACE("assume_eq", tout << "variable value: " << get_assignment(v) << "\n";);
  4477:         TRACE("assume_eq", tout << "assume_eq result: " << r << "\n";);
  4478          return r;

  4506                          continue;
  4507:                     TRACE("is_shared", tout << enode_pp(n, *this) 
  4508                            << "\nis shared because of:\n" 

  4567              fcs = final_check();
  4568:             TRACE("opt", tout << (refinalize?"refinalize":"no-op") << " " << fcs << "\n";);
  4569          }

  4577          if (m_model || m_proto_model || has_case_splits()) return;
  4578:         TRACE("get_model",
  4579                display(tout);

  4585          if (fl == MEMOUT || fl == CANCELED || fl == NUM_CONFLICTS || fl == RESOURCE_LIMIT) {
  4586:             TRACE("get_model", tout << "last search failure: " << fl << "\n";);   
  4587          }     

  4592              m_qmanager->adjust_model(m_proto_model.get());
  4593:             TRACE("mbqi_bug", tout << "before complete_partial_funcs:\n"; model_pp(tout, *m_proto_model););
  4594              m_proto_model->complete_partial_funcs(false);
  4595:             TRACE("mbqi_bug", tout << "before cleanup:\n"; model_pp(tout, *m_proto_model););
  4596              m_proto_model->cleanup();
  4597:             TRACE("mbqi_bug", tout << "after cleanup:\n"; model_pp(tout, *m_proto_model););
  4598              IF_VERBOSE(11, model_pp(verbose_stream(), *m_proto_model););

  4605          }
  4606:         TRACE("context", tout << m_unsat_proof << "\n";);
  4607          return m_unsat_proof;

z3/src/smt/smt_context.h:
  1166              m_case_split_queue->activity_increased_eh(v);
  1167:             TRACE("case_split", tout << "v" << v << " " << m_bvar_inc << " -> " << act << "\n";);
  1168          }

z3/src/smt/smt_enode.cpp:
  59          }
  60:         TRACE("mk_enode_detail", tout << "new enode suppress_args: " << n->m_suppress_args << "\n";);
  61          SASSERT(n->m_suppress_args == suppress_args);

z3/src/smt/smt_farkas_util.cpp:
  320      expr_ref farkas_util::get() {
  321:         TRACE("arith", 
  322                for (unsigned i = 0; i < m_coeffs.size(); ++i) {

  356  
  357:         TRACE("arith", 
  358                for (unsigned i = 0; i < m_coeffs.size(); ++i) {

z3/src/smt/smt_for_each_relevant_expr.cpp:
   40                  if (s.contains('@')) {
   41:                     TRACE("for_each_relevant_expr", tout << "@ label: " << mk_pp(n, m_manager) << "\n";);
   42                      count += 1;

   76          if (count > 1 && m_first) {
   77:             TRACE("for_each_relevant_expr", tout << mk_pp(n, m_manager) << "\n";);
   78              m_first = false;

  110          if (count > 1 && m_first) {
  111:             TRACE("for_each_relevant_expr", tout << mk_pp(n, m_manager) << "\n";);
  112              m_first = false;

  123      void for_each_relevant_expr::operator()(expr * n) {
  124:         TRACE("for_each_relevant_expr", tout << "#" << n->get_id() << "\n";);
  125      }

  142      void for_each_relevant_expr::process(expr * n) {
  143:         TRACE("for_each_relevant_expr", tout << "processing:\n" << mk_bounded_pp(n, m_manager) << "\n";);
  144:         TRACE("for_each_relevant_expr", tout << "processing:\n" << mk_pp(n, m_manager) << "\n";);
  145          if (m_cache.contains(n))

  198          unsigned sz = n->get_num_args();
  199:         TRACE("for_each_relevant_expr", tout << val << " " << mk_bounded_pp(n, m_manager) << "\n";);
  200          for (unsigned i = 0; i < sz; i++) {

  206              if (m_cache.contains(arg)) {
  207:                 TRACE("for_each_relevant_expr", tout << "justified by: " << mk_bounded_pp(arg, m_manager) << "\n";);
  208                  return; // the current child justifies n.

  217  
  218:             TRACE("for_each_relevant_expr", tout << "to_process: " << mk_bounded_pp(arg, m_manager) << "\n";);
  219  

  273      void collect_relevant_label_lits::operator()(expr * n) {
  274:         TRACE("for_each_relevant_expr", 
  275                tout << "label: " << m_manager.is_label_lit(n) << " " << " " << get_assignment(n) 

  285          bool pos;
  286:         TRACE("for_each_relevant_expr", 
  287                tout << "label: " << m_manager.is_label(n) << " " << get_assignment(n) 

z3/src/smt/smt_implied_equalities.cpp:
  100                      m_solver.pop(1);
  101:                     TRACE("get_implied_equalities", tout << mk_pp(t, m) << " = " << mk_pp(s, m) << " " << (is_eq?"eq":"unrelated") << "\n";);
  102                      if (is_eq) {

  128                      m_stats_timer.stop();
  129:                     TRACE("get_implied_equalities", tout << mk_pp(t, m) << " = " << mk_pp(s, m) << " " << (is_eq?"eq":"unrelated") << "\n";);
  130                      if (is_eq) {

  202                  vl = (*model)(t);
  203:                 TRACE("get_implied_equalities", tout << mk_pp(t, m) << " |-> " << mk_pp(vl, m) << "\n";);
  204                  reduce_value(model, vl);
  205                  if (!m.is_value(vl)) {
  206:                     TRACE("get_implied_equalities", tout << "Not a value: " << mk_pp(vl, m) << "\n";);
  207                      non_values.insert(i);

  219                      m_solver.pop(1);
  220:                     TRACE("get_implied_equalities", tout << mk_pp(t, m) << " = " << mk_pp(s, m) << " " << is_sat << "\n";);
  221                      if (is_sat == l_false) {

  236              if (!non_values.empty()) {
  237:                 TRACE("get_implied_equalities", model_smt2_pp(tout, m, *model, 0););
  238                  get_implied_equalities_filter_basic(non_values, terms);

  353                  }
  354:                 TRACE("get_implied_equalities",
  355                        for (unsigned i = 0; i < num_terms; ++i) {

z3/src/smt/smt_induction.cpp.disabled:
  58      }
  59:     TRACE("induction", ctx.display(tout << "literal index: " << m_literal_index << "\n" << result << "\n"););
  60  

z3/src/smt/smt_internalizer.cpp:
   203                  // internalization over these follows top-down
   204:                 TRACE("deep_internalize", tout << "expression is deep: #" << n->get_id() << "\n" << mk_ll_pp(n, m););
   205                  ts_todo.push_back(expr_bool_pair(n, true));

   210          top_sort_expr(exprs, num_exprs, sorted_exprs);
   211:         TRACE("deep_internalize", for (auto & kv : sorted_exprs) tout << "#" << kv.first->get_id() << " " << kv.second << "\n"; );
   212          for (auto & kv : sorted_exprs) {

   228      void context::internalize_assertion(expr * n, proof * pr, unsigned generation) {
   229:         TRACE("internalize_assertion", tout << mk_pp(n, m) << "\n";); 
   230:         TRACE("internalize_assertion_ll", tout << mk_ll_pp(n, m) << "\n";); 
   231:         TRACE("generation", tout << "generation: " << m_generation << "\n";);
   232:         TRACE("incompleteness_bug", tout << "[internalize-assertion]: #" << n->get_id() << "\n";);
   233          flet<unsigned> l(m_generation, generation);

   313      void context::assert_distinct(app * n, proof * pr) {
   314:         TRACE("assert_distinct", tout << mk_pp(n, m) << "\n";);
   315          unsigned num_args = n->get_num_args();

   328              app_ref eq(m.mk_eq(fapp, val), m);
   329:             TRACE("assert_distinct", tout << "eq: " << mk_pp(eq, m) << "\n";);
   330              assert_default(eq, nullptr);

   367      void context::internalize_rec(expr * n, bool gate_ctx) {
   368:         TRACE("internalize", tout << "internalizing:\n" << mk_pp(n, m) << "\n";);
   369:         TRACE("internalize_bug", tout << "internalizing:\n" << mk_bounded_pp(n, m) << "\n";);
   370          if (is_var(n)) {

   389      void context::internalize_formula(expr * n, bool gate_ctx) {
   390:         TRACE("internalize_bug", tout << "internalize formula: #" << n->get_id() << ", gate_ctx: " << gate_ctx << "\n" << mk_pp(n, m) << "\n";);
   391          SASSERT(m.is_bool(n));

   404              bool_var v = get_bool_var(n);
   405:             TRACE("internalize_bug", tout << "#" << n->get_id() << " already has bool_var v" << v << "\n";);
   406              

   411                  if (e_internalized(n)) {
   412:                     TRACE("internalize_bug", tout << "forcing enode #" << n->get_id() << " to merge with t/f\n";);
   413                      enode * e = get_enode(to_app(n));

   416                  else {
   417:                     TRACE("internalize_bug", tout << "creating enode for #" << n->get_id() << "\n";);
   418                      mk_enode(to_app(n), 

   452          d.set_eq_flag();
   453:         TRACE("internalize", tout << mk_pp(n, m) << " " << literal(v, false) << "\n";);
   454          

   464      void context::internalize_distinct(app * n, bool gate_ctx) {
   465:         TRACE("distinct", tout << "internalizing distinct: " << mk_pp(n, m) << "\n";);
   466          SASSERT(!b_internalized(n));

   494          theory * th  = m_theories.get_plugin(n->get_family_id());
   495:         TRACE("datatype_bug", tout << "internalizing theory atom:\n" << mk_pp(n, m) << "\n";);
   496          if (!th || !th->internalize_atom(n, gate_ctx))
   497              return false;
   498:         TRACE("datatype_bug", tout << "internalization succeeded\n" << mk_pp(n, m) << "\n";);
   499          SASSERT(b_internalized(n));
   500:         TRACE("internalize_theory_atom", tout << "internalizing theory atom: #" << n->get_id() << "\n";);
   501          bool_var v        = get_bool_var(n);

   562      void context::internalize_quantifier(quantifier * q, bool gate_ctx) {
   563:         TRACE("internalize_quantifier", tout << mk_pp(q, m) << "\n";);
   564:         CTRACE("internalize_quantifier_zero", q->get_weight() == 0, tout << mk_pp(q, m) << "\n";);
   565          SASSERT(gate_ctx); // limitation of the current implementation

   584      void context::internalize_lambda(quantifier * q) {
   585:         TRACE("internalize_quantifier", tout << mk_pp(q, m) << "\n";);
   586          SASSERT(is_lambda(q));

   618              if (n->get_class_size() != 1) {
   619:                 TRACE("context", tout << "class size " << n->get_class_size() << " " << enode_pp(n, *this) << "\n");
   620                  return true;

   623                  if (!is_beta_redex(p, n)) {
   624:                     TRACE("context", tout << "not a beta redex " << enode_pp(p, *this) << "\n");
   625                      return true;

   637  
   638:         CTRACE("resolve_conflict_crash", m.is_not(n), tout << mk_ismt2_pp(n, m) << "\ngate_ctx: " << gate_ctx << "\n";);
   639  

   645          
   646:         CTRACE("internalize_bug", b_internalized(n), tout << mk_ll_pp(n, m) << "\n";);
   647          

   721          
   722:         CTRACE("internalize_bug", e_internalized(n), 
   723                 tout << "#" << n->get_id() << ", merge_tf: " << get_enode(n)->merge_tf() << "\n";);

   865          literal eq2_lit = get_literal(eq2);
   866:         TRACE("internalize_ite_term_bug",
   867                tout << mk_ismt2_pp(n, m) << "\n";

   877              relevancy_eh * eh = m_relevancy_propagator->mk_term_ite_relevancy_eh(n, eq1, eq2);
   878:             TRACE("ite_term_relevancy", tout << "#" << n->get_id() << " #" << eq1->get_id() << " #" << eq2->get_id() << "\n";);
   879              add_rel_watch(c_lit, eh);

   924          bool_var v  = m_b_internalized_stack.size();
   925:         TRACE("mk_bool_var", tout << "creating boolean variable: " << v << " for:\n" << mk_pp(n, m) << " " << n->get_id() << "\n";);
   926:         TRACE("mk_var_bug", tout << "mk_bool: " << v << "\n";);                
   927          set_bool_var(id, v);

   966          m_bool_var2expr[v]    = nullptr;
   967:         TRACE("undo_mk_bool_var", tout << "undo_bool: " << v << "\n" << mk_pp(n, m) << "\n" << "m_bdata.size: " << m_bdata.size()
   968                << " m_assignment.size: " << m_assignment.size() << "\n";);
   969:         TRACE("mk_var_bug", tout << "undo_mk_bool: " << v << "\n";);
   970          // bool_var_data & d     = m_bdata[v];

   984      enode * context::mk_enode(app * n, bool suppress_args, bool merge_tf, bool cgc_enabled) {
   985:         TRACE("mk_enode_detail", tout << mk_pp(n, m) << "\nsuppress_args: " << suppress_args << ", merge_tf: " << 
   986                merge_tf << ", cgc_enabled: " << cgc_enabled << "\n";);

   992              generation = _generation;
   993:             CTRACE("cached_generation", generation != m_generation,
   994                     tout << "cached_generation: #" << n->get_id() << " " << generation << " " << m_generation << "\n";);

   996          enode * e           = enode::mk(m, m_region, m_app2enode, n, generation, suppress_args, merge_tf, m_scope_lvl, cgc_enabled, true);
   997:         TRACE("mk_enode_detail", tout << "e.get_num_args() = " << e->get_num_args() << "\n";);
   998          if (m.is_unique_value(n))
   999              e->mark_as_interpreted();
  1000:         TRACE("mk_var_bug", tout << "mk_enode: " << id << "\n";);
  1001:         TRACE("generation", tout << "mk_enode: " << id << " " << generation << "\n";);
  1002          m_app2enode.setx(id, e, nullptr);

  1038          m_stats.m_num_mk_enode++;
  1039:         TRACE("mk_enode", tout << "created enode: #" << e->get_owner_id() << " for:\n" << mk_pp(n, m) << "\n";
  1040                if (e->get_num_args() > 0) {

  1043                });
  1044:         SCTRACE("causality", m_coming_from_quant, tout << "EN: #" << e->get_owner_id() << "\n";);
  1045  

  1063          expr * n              = m_e_internalized_stack.back();
  1064:         TRACE("undo_mk_enode", tout << "undo_enode: #" << n->get_id() << "\n" << mk_pp(n, m) << "\n";);
  1065:         TRACE("mk_var_bug", tout << "undo_mk_enode: " << n->get_id() << "\n";);
  1066          unsigned n_id         = n->get_id();

  1136      bool context::simplify_aux_clause_literals(unsigned & num_lits, literal * lits, literal_buffer & simp_lits) {
  1137:         TRACE("simplify_aux_clause_literals", display_literals(tout, num_lits, lits); tout << "\n";);
  1138          std::sort(lits, lits + num_lits);

  1145              case l_false:
  1146:                 TRACE("simplify_aux_clause_literals", display_literal_verbose(tout << get_assign_level(curr) << " " << get_scope_level() << " " << curr << ":", curr); tout << "\n"; );
  1147                  simp_lits.push_back(~curr);

  1189      bool context::simplify_aux_lemma_literals(unsigned & num_lits, literal * lits) {
  1190:         TRACE("simplify_aux_lemma_literals", display_literals(tout << "1) ", num_lits, lits) << "\n";);
  1191          std::sort(lits, lits + num_lits);
  1192:         TRACE("simplify_aux_lemma_literals", display_literals(tout << "2) ", num_lits, lits) << "\n";);
  1193          literal prev = null_literal;

  1213          num_lits = j;
  1214:         TRACE("simplify_aux_lemma_literals", display_literals(tout << "3) ", num_lits, lits) << "\n";);
  1215          return true;

  1377      clause * context::mk_clause(unsigned num_lits, literal * lits, justification * j, clause_kind k, clause_del_eh * del_eh) {
  1378:         TRACE("mk_clause", display_literals_verbose(tout << "creating clause: " << literal_vector(num_lits, lits) << "\n", num_lits, lits) << "\n";);
  1379          m_clause_proof.add(num_lits, lits, k, j);

  1419          }
  1420:         TRACE("mk_clause", display_literals_verbose(tout << "after simplification: " << literal_vector(num_lits, lits) << "\n", num_lits, lits) << "\n";);
  1421  

  1428                  m_justifications.push_back(j);
  1429:             TRACE("mk_clause", tout << "empty clause... setting conflict\n";);
  1430              set_conflict(j == nullptr ? b_justification::mk_axiom() : b_justification(j));

  1478                      cls->swap_lits(1, w2_idx);
  1479:                     TRACE("mk_th_lemma", display_clause(tout, cls); tout << "\n";);
  1480                  }

  1513              
  1514:             TRACE("add_watch_literal_bug", display_clause_detail(tout, cls););
  1515:             TRACE("mk_clause_result", display_clause_detail(tout, cls););
  1516              CASSERT("mk_clause", check_clause(cls));

  1555          justification * js = nullptr;
  1556:         TRACE("mk_th_axiom", display_literals_verbose(tout, num_lits, lits) << "\n";);
  1557  

  1592              proof * pr = mk_clause_def_axiom(num_lits, lits, nullptr);
  1593:             TRACE("gate_clause", tout << mk_ll_pp(pr, m););
  1594              mk_clause(num_lits, lits, mk_justification(justification_proof_wrapper(*this, pr)));

  1633                  proof * def = mk_clause_def_axiom(num_lits, lits, m.get_fact(pr));
  1634:                 TRACE("gate_clause", tout << mk_ll_pp(def, m) << "\n";
  1635                        tout << mk_ll_pp(pr, m););

  1684              // when the condition of an ite is assigned to true or false, the ite-parent must be notified.
  1685:             TRACE("propagate_relevant_ite", tout << "#" << n->get_id() << ", eh: " << eh << "\n";);
  1686              add_rel_watch(l, eh);

  1701          literal l = get_literal(n);
  1702:         TRACE("mk_and_cnstr", tout << "l: "; display_literal(tout, l); tout << "\n";);
  1703          literal_buffer buffer;

  1706              literal l_arg = get_literal(arg);
  1707:             TRACE("mk_and_cnstr", tout << "l_arg: "; display_literal(tout, l_arg); tout << "\n";);
  1708              mk_gate_clause(~l, l_arg);

  1732          if (sign) l.neg();
  1733:         TRACE("mk_iff_cnstr", tout << "l: " << l << ", l1: " << l1 << ", l2: " << l2 << "\n";);
  1734          mk_gate_clause(~l,  l1, ~l2);

z3/src/smt/smt_justification.cpp:
   52          memcpy(m_literals, lits, sizeof(literal) * num_lits);
   53:         TRACE("unit_resolution_justification_bug", tout << literal_vector(num_lits, lits) << "\n";);
   54          SASSERT(m_num_literals > 0);

   65          memcpy(m_literals, lits, sizeof(literal) * num_lits);
   66:         TRACE("unit_resolution_justification_bug", tout << literal_vector(num_lits, lits) << "\n";);
   67          SASSERT(num_lits != 0);

   99          }
  100:         TRACE("unit_resolution_justification_bug",
  101              tout << "in mk_proof\n" << literal_vector(m_num_literals, m_literals) << "\n";

  233              
  234:             TRACE("mp_iff_justification", tout << mk_pp(fact1, m) << "\n" << mk_pp(fact2, m) << "\n" <<
  235                    mk_pp(m.get_fact(pr), m) << "\n";);

z3/src/smt/smt_kernel.cpp:
  128          lbool r = m_imp->m_kernel.check(num_assumptions, assumptions);
  129:         TRACE("smt_kernel", tout << "check result: " << r << "\n";);
  130          return r;

z3/src/smt/smt_model_checker.cpp:
  167          
  168:         TRACE("model_checker", tout << "curr_model:\n"; model_pp(tout, *m_curr_model););
  169  

  172          }
  173:         TRACE("model_checker", tout << "q after applying interpretation:\n" << mk_ismt2_pp(tmp, m) << "\n";);
  174          ptr_buffer<expr> subst_args;

  191          r = m.mk_not(sk_body);
  192:         TRACE("model_checker", tout << "mk_neg_q_m:\n" << mk_ismt2_pp(r, m) << "\n";);
  193          m_aux_context->assert_expr(r);

  198          if (cex == nullptr || sks.empty()) {
  199:             TRACE("model_checker", tout << "no model is available\n";);
  200              return false;

  214              if (!sk_value) {
  215:                 TRACE("model_checker", tout << "Could not get value for " << sk_d->get_name() << "\n";);
  216                  return false; // get_some_value failed... giving up
  217              }
  218:             TRACE("model_checker", tout << "Got some value " << sk_value << "\n";);
  219  

  223                  if (sk_term != nullptr) {
  224:                     TRACE("model_checker", tout << "Found inverse " << mk_pp(sk_term, m) << "\n";);
  225                      SASSERT(!m.is_model_value(sk_term));

  229                  else {
  230:                     TRACE("model_checker", tout << "no inverse value for " << sk_value << "\n";);
  231                      return false;

  237                  if (sk_term != nullptr) {
  238:                     TRACE("model_checker", tout << "sk term " << mk_pp(sk_term, m) << "\n");
  239                      sk_value = sk_term;

  247              if (contains_model_value(sk_value)) {
  248:                 TRACE("model_checker", tout << "type compatible term " << mk_pp(sk_value, m) << "\n");
  249                  sk_value = get_type_compatible_term(sk_value);

  269  
  270:         TRACE("model_checker", tout << q->get_qid() << " found (use_inv: " << use_inv << ") new instance: " << bindings << "\ndefs:\n" << defs << "\n";);
  271          if (!defs.empty()) def = mk_and(defs);

  315              if (!sk_value) {
  316:                 TRACE("model_checker", tout << "no constant interpretation for " << mk_pp(sk, m) << "\n";);
  317                  return false; // get_some_value failed... aborting add_blocking_clause

  322          blocking_clause = m.mk_or(diseqs.size(), diseqs.data());
  323:         TRACE("model_checker", tout << "blocking clause:\n" << mk_ismt2_pp(blocking_clause, m) << "\n";);
  324          m_aux_context->assert_expr(blocking_clause);

  349          quantifier * flat_q = get_flat_quantifier(q);
  350:         TRACE("model_checker", tout << "model checking:\n" << expr_ref(flat_q->get_expr(), m) << "\n";);
  351          expr_ref_vector sks(m);

  354              return false;
  355:         TRACE("model_checker", tout << "skolems:\n" << sks << "\n";);
  356  

  359          
  360:         TRACE("model_checker", tout << "[complete] model-checker result: " << to_sat_str(r) << "\n";);
  361          if (r != l_true) {

  375              lbool r = m_aux_context->check();
  376:             TRACE("model_checker", tout << "[restricted] model-checker (" << (num_new_instances+1) << ") result: " << to_sat_str(r) << "\n";);
  377              if (r != l_true)

  386              if (num_new_instances >= m_max_cexs || !add_blocking_clause(cex.get(), sks)) {
  387:                 TRACE("model_checker", tout << "Add blocking clause failed new-instances: " << num_new_instances << " max-cex: " << m_max_cexs << "\n";);
  388                  // add_blocking_clause failed... stop the search for new counter-examples...

  394              // failed to create instances when restricting to inst sets... then use result of the complete model check
  395:             TRACE("model_checker", tout << "using complete_cex result:\n"; model_pp(tout, *complete_cex););
  396              add_instance(q, complete_cex.get(), sks, false);

  435  
  436:         TRACE("model_checker", tout << "MODEL_CHECKER INVOKED\n";
  437          tout << "model:\n"; model_pp(tout, *m_curr_model););

  446  
  447:         TRACE("model_checker", tout << "MODEL_CHECKER INVOKED\n";
  448                tout << "model:\n"; model_pp(tout, *m_curr_model););

  462  
  463:         TRACE("model_checker", tout << "model after check:\n"; model_pp(tout, *md););
  464:         TRACE("model_checker", tout << "model checker result: " << (num_failures == 0) << "\n";);
  465          m_max_cexs += m_params.m_mbqi_max_cexs;

  503  
  504:             TRACE("model_checker",
  505                    tout << "Check: " << mk_pp(q, m) << "\n";

  515                  }
  516:                 TRACE("model_checker", tout << "checking quantifier " << mk_pp(q, m) << " failed\n";);
  517                  num_failures++;

  533      bool model_checker::has_new_instances() {
  534:         TRACE("model_checker", tout << "instances: " << m_new_instances.size() << "\n";);
  535          return !m_new_instances.empty();

  547      void model_checker::assert_new_instances() {
  548:         TRACE("model_checker_bug_detail", tout << "assert_new_instances, inconsistent: " << m_context->inconsistent() << "\n";);
  549          ptr_buffer<enode> bindings;

  560                      if (!m_context->e_internalized(b)) {
  561:                         TRACE("model_checker", tout << "internalizing b:\n" << mk_pp(b, m) << "\n";);
  562                          m_context->internalize(b, false, gen);

  582  
  583:                 TRACE("model_checker_bug_detail", tout << "instantiating... q:\n" << mk_pp(q, m) << "\n";
  584                        tout << "inconsistent: " << m_context->inconsistent() << "\n";

  587                  m_context->add_instance(q, nullptr, num_decls, bindings.data(), inst.m_def, gen, gen, gen, dummy);
  588:                 TRACE("model_checker_bug_detail", tout << "after instantiating, inconsistent: " << m_context->inconsistent() << "\n";);
  589              }

z3/src/smt/smt_model_finder.cpp:
    95                  m_elems.erase(n);
    96:                 TRACE("model_finder", tout << mk_pp(n, m) << "\n";);
    97                  m.dec_ref(n);

   128                      if (!t_val) break;
   129:                     TRACE("model_finder", tout << mk_pp(t, m) << " " << mk_pp(t_val, m) << "\n";);
   130  

   572                              if (should_cleanup(n_val)) {
   573:                                 TRACE("model_finder", tout << "cleanup " << s << " " << mk_pp(n, m) << " " << mk_pp(n_val, m) << "\n";);
   574                                  to_delete.push_back(n);

   599                      r = nullptr;
   600:                     TRACE("model_finder", tout << "eval\n" << mk_pp(n, m) << "\n-----> null\n";);
   601                  }

   603                      r = tmp;
   604:                     TRACE("model_finder", tout << "eval\n" << mk_pp(n, m) << "\n----->\n" << mk_pp(r, m) << "\n";);
   605                  }

   683                  m_ks.push_back(r);
   684:                 TRACE("model_finder", tout << sort_ref(s, m) << " := " << "\n";);
   685                  return r;

   706                  SASSERT(m_model->get_const_interp(k_decl) == r);
   707:                 TRACE("model_finder", tout << mk_pp(r, m) << "\n";);
   708                  return r;

   716              bool assert_k_diseq_exceptions(app* k, ptr_vector<expr> const& exceptions) {
   717:                 TRACE("assert_k_diseq_exceptions", tout << "assert_k_diseq_exceptions, " << "k: " << mk_pp(k, m) << "\nexceptions:\n";
   718                  for (expr* e : exceptions) tout << mk_pp(e, m) << "\n";);

   734              void set_projection_else(node* n) {
   735:                 TRACE("model_finder", n->display(tout, m););
   736                  SASSERT(n->is_root());

   751                      sort* s = n->get_sort();
   752:                     TRACE("model_finder", tout << "trying to create k for " << mk_pp(s, m) << ", is_infinite: " << is_infinite(s) << "\n";);
   753                      if (is_infinite(s)) {

   784                          arith_rw.mk_add(e, one, e_plus_1);
   785:                         TRACE("mf_simp_bug", tout << "e:\n" << mk_ismt2_pp(e, m) << "\none:\n" << mk_ismt2_pp(one, m) << "\n";);
   786                          // Note: exceptions come from quantifiers bodies. So, they have generation 0.

   796                          bv_rw.mk_sub(e, one, e_minus_1);
   797:                         TRACE("mf_simp_bug", tout << "e:\n" << mk_ismt2_pp(e, m) << "\none:\n" << mk_ismt2_pp(one, m) << "\n";);
   798                          // Note: exceptions come from quantifiers bodies. So, they have generation 0.

   823                  }
   824:                 TRACE("model_finder_bug", tout << "values for the instantiation_set of @" << n->get_id() << "\n";
   825                  for (expr* v : values) {

   904                  n->set_proj(p);
   905:                 TRACE("model_finder", n->display(tout << p->get_name() << "\n", m););
   906              }

   924                  n->set_proj(p);
   925:                 TRACE("model_finder", n->display(tout << p->get_name() << "\n", m););
   926              }

   947                              fi = alloc(func_interp, m, f->get_arity());
   948:                             TRACE("model_finder", tout << "register " << f->get_name() << "\n";);
   949                              m_model->register_decl(f, fi);

   984                      instantiation_set const* s = n->get_instantiation_set();
   985:                     TRACE("model_finder", s->display(tout););
   986                      obj_map<expr, unsigned> const& elems = s->get_elems();

  1014                      n->insert(e, 0);
  1015:                     TRACE("model_finder", tout << "fresh constant: " << mk_pp(e, m) << "\n";);
  1016                  }

  1089                          new_fi->set_else(m.mk_app(f_aux, args.size(), args.data()));
  1090:                         TRACE("model_finder", tout << "Setting new interpretation for " << f->get_name() << "\n" <<
  1091                              mk_pp(new_fi->get_else(), m) << "\n";

  1125                  complete_partial_funcs(partial_funcs);
  1126:                 TRACE("model_finder", tout << "after auf_solver fixing the model\n";
  1127                        display_nodes(tout);

  1201                  node* n2 = s.get_uvar(q, m_var_j);
  1202:                 CTRACE("model_finder", n1->get_sort() != n2->get_sort(),
  1203                         tout << "sort bug:\n" << mk_ismt2_pp(q->get_expr(), m) << "\n" << mk_ismt2_pp(q, m) << "\n";

  1418              func_decl* get_array_func_decl(app* ground_array, auf_solver& s) {
  1419:                 TRACE("model_evaluator", tout << expr_ref(ground_array, m) << "\n";);
  1420                  expr* ground_array_interp = s.eval(ground_array, false);

  1446                  get_auf_arrays(get_array(), ctx, arrays);
  1447:                 TRACE("select_var",
  1448                      tout << "enodes matching: "; display(tout); tout << "\n";

  1687                  m_qinfo_vect.push_back(q.detach());
  1688:                 TRACE("model_finder", tout << "new quantifier qinfo: "; qi->display(tout); tout << "\n";);
  1689              }

  1711                  m_uvar_inst_sets(nullptr) {
  1712:                 CTRACE("model_finder_bug", has_quantifiers(m_flat_q->get_expr()),
  1713                      tout << mk_pp(q, m) << "\n" << mk_pp(m_flat_q, m) << "\n";);

  1816                  bool inv;
  1817:                 TRACE("is_var_plus_ground", tout << mk_pp(n, m) << "\n";
  1818                  tout << "is_var_plus_ground: " << is_var_plus_ground(n, inv, v, t) << "\n";

  1860                  inv = false; // true if invert the sign
  1861:                 TRACE("is_var_and_ground", tout << "is_var_and_ground: " << mk_ismt2_pp(lhs, m) << " " << mk_ismt2_pp(rhs, m) << "\n";);
  1862                  if (is_var(lhs) && is_ground(rhs)) {

  1864                      t = rhs;
  1865:                     TRACE("is_var_and_ground", tout << "var and ground\n";);
  1866                      return true;

  1870                      t = lhs;
  1871:                     TRACE("is_var_and_ground", tout << "ground and var\n";);
  1872                      return true;

  1949                      bool r = is_le_ge(atom) && is_var_and_ground(to_app(atom)->get_arg(0), to_app(atom)->get_arg(1), v, t);
  1950:                     CTRACE("is_x_gle_t", r, tout << "is_x_gle_t: " << mk_ismt2_pp(atom, m) << "\n--->\n"
  1951                          << mk_ismt2_pp(v, m) << " " << mk_ismt2_pp(t, m) << "\n";

  1969                                  mk_sub(tmp, one, t);
  1970:                             TRACE("is_x_gle_t", tout << "is_x_gle_t: " << mk_ismt2_pp(atom, m) << "\n--->\n"
  1971                                  << mk_ismt2_pp(v, m) << " " << mk_ismt2_pp(t, m) << "\n";

  2118              void process_literal(expr* atom, bool sign) {
  2119:                 CTRACE("model_finder_bug", is_ground(atom), tout << mk_pp(atom, m) << "\n";);
  2120                  SASSERT(!is_ground(atom));

  2352      void model_finder::register_quantifier(quantifier* q) {
  2353:         TRACE("model_finder", tout << "registering:\n" << q->get_id() << ": " << q << " " << &m_q2info << " " << mk_pp(q, m) << "\n";);
  2354          quantifier_info* new_info = alloc(quantifier_info, *this, m, q);

  2357          m_analyzer->operator()(new_info);
  2358:         TRACE("model_finder", tout << "after analyzer:\n"; new_info->display(tout););
  2359      }

  2424          m_auf_solver->fix_model(m_new_constraints);
  2425:         TRACE("model_finder",
  2426              for (quantifier* q : qs) {

  2440          sms(*mdl, qs, residue);
  2441:         TRACE("model_finder", tout << "model after processing simple macros:\n"; model_pp(tout, *mdl););
  2442      }

  2446          hms(*mdl, qs, residue);
  2447:         TRACE("model_finder", tout << "model after processing simple macros:\n"; model_pp(tout, *mdl););
  2448      }

  2453          nas(*mdl, qs, residue);
  2454:         TRACE("model_finder", tout << "model after processing non auf macros:\n"; model_pp(tout, *mdl););
  2455      }

  2477              return;
  2478:         TRACE("model_finder", tout << "trying to satisfy quantifiers, given model:\n"; model_pp(tout, *m););
  2479          cleanup_quantifier_infos(qs);

  2502          mf::instantiation_set const* r = m_auf_solver->get_uvar_inst_set(flat_q, flat_q->get_num_decls() - q->get_num_decls() + i);
  2503:         TRACE("model_finder", tout << "q: #" << q->get_id() << "\n" << mk_pp(q, m) << "\nflat_q: " << mk_pp(flat_q, m)
  2504              << "\ni: " << i << " " << flat_q->get_num_decls() - q->get_num_decls() + i << "\n";);

  2567              new_cnstr = m.mk_or(eqs.size(), eqs.data());
  2568:             TRACE("model_finder", tout << "assert_restriction:\n" << mk_pp(new_cnstr, m) << "\n";);
  2569              aux_ctx->assert_expr(new_cnstr);

  2579                  expr* c = m_new_constraints.get(i);
  2580:                 TRACE("model_finder_bug_detail", tout << "asserting new constraint: " << mk_pp(c, m) << "\n";);
  2581                  m_context->internalize(c, true);

z3/src/smt/smt_model_generator.cpp:
   65          for (theory* th : m_context->theories()) {
   66:             TRACE("model_generator_bug", tout << "init_model for theory: " << th->get_name() << "\n";);
   67              th->init_model(*this);

   99                  if (m.is_bool(s)) {
  100:                     CTRACE("model", m_context->get_assignment(r) == l_undef, 
  101                             tout << mk_pp(r->get_expr(), m) << "\n";);

  118                          else {
  119:                             TRACE("model", tout << "creating fresh value for #" << mk_pp(r->get_expr(), m) << "\n";);
  120                              proc = alloc(fresh_value_proc, mk_extra_fresh_value(r->get_sort()));

  140              n = m_model->get_fresh_value(s);
  141:             CTRACE("model", n == 0, 
  142                     tout << mk_pp(r->get_expr(), m) << "\nsort:\n" << mk_pp(s, m) << "\n";

  190                      continue; // r is associated with a fresh value...
  191:                 TRACE("mg_top_sort", tout << "fresh!" << src.get_value()->get_idx() << " -> #" << r->get_owner_id() << " " << mk_pp(r->get_sort(), m) << "\n";);
  192                  visit_child(source(r), colors, todo, visited);
  193:                 TRACE("mg_top_sort", tout << "visited: " << visited << ", todo.size(): " << todo.size() << "\n";);
  194              }

  209          }
  210:         TRACE("mg_top_sort",
  211                tout << "src: " << src << " ";

  226                                           svector<source> & sorted_sources) {
  227:         TRACE("mg_top_sort", tout << "process source, is_fresh: " << src.is_fresh_value() << " ";
  228                tout << src << ", todo.size(): " << todo.size() << "\n";);

  236              source curr = todo.back();
  237:             TRACE("mg_top_sort", tout << "current source, is_fresh: " << curr.is_fresh_value() << " ";
  238                    tout << curr << ", todo.size(): " << todo.size() << "\n";);

  246                  set_color(colors, curr, Black);
  247:                 TRACE("mg_top_sort", tout << "append " << curr << "\n";);
  248                  sorted_sources.push_back(curr);

  256          }
  257:         TRACE("mg_top_sort", tout << "END process_source, todo.size(): " << todo.size() << "\n";);
  258      }

  301          top_sort_sources(roots, root2proc, sources);
  302:         TRACE("sorted_sources",
  303                for (source const& curr : sources) {

  322                  sort * s = curr.get_value()->get_sort();
  323:                 TRACE("model_fresh_bug", tout << curr << " : " << mk_pp(s, m) << " " << curr.get_value()->get_value() << "\n";);
  324                  expr * val = m_model->get_fresh_value(s);
  325:                 TRACE("model_fresh_bug", tout << curr << " := #" << (val == nullptr ? UINT_MAX : val->get_id()) << "\n";);
  326                  m_asts.push_back(val);

  331                  SASSERT(n->get_root() == n);
  332:                 TRACE("mg_top_sort", tout << curr << "\n";);
  333                  dependencies.reset();

  339                      if (d.is_fresh_value()) {
  340:                         CTRACE("mg_top_sort", !d.get_value()->get_value(), 
  341                                 tout << "#" << n->get_owner_id() << " " << mk_pp(n->get_expr(), m) << " -> " << d << "\n";);

  346                          enode * child = d.get_enode();
  347:                         TRACE("mg_top_sort", tout << "#" << n->get_owner_id() << " (" << mk_pp(n->get_expr(), m) << "): " 
  348                                << mk_pp(child->get_expr(), m) << " " << mk_pp(child->get_root()->get_expr(), m) << "\n";);

  362                  func_decl * d = n->get_expr()->get_decl();
  363:                 TRACE("mg_top_sort", tout << d->get_name() << " " << (m_hidden_ufs.contains(d)?"hidden":"visible") << "\n";);
  364                  if (m_hidden_ufs.contains(d)) continue;

  427                  // The entry must be new because n->get_cg() == n
  428:                 TRACE("model", 
  429                        tout << "insert new entry for:\n" << mk_ismt2_pp(n->get_expr(), m) << "\nargs: ";

  483          unsigned num = m_context->get_num_macros();
  484:         TRACE("model", tout << "num. macros: " << num << "\n";);
  485          expr_ref v(m);

  489              fi->set_else(v);
  490:             TRACE("model", tout << f->get_name() << "\n" << mk_pp(v, m) << "\n";);
  491              m_model->register_decl(f, fi);

  496          SASSERT(!m_model);
  497:         TRACE("model_verbose", m_context->display(tout););
  498          init_model();

  504          register_macros();
  505:         TRACE("model", model_v2_pp(tout, *m_model, true););        
  506          return m_model.get();

z3/src/smt/smt_quantifier.cpp:
  214                  if (used_enodes.size() > 0) {
  215:                     STRACE("causality", tout << "New-Match: "<< static_cast<void*>(f););
  216:                     STRACE("triggers",  tout <<", Pat: "<< expr_ref(pat, m()););
  217:                     STRACE("causality", tout <<", Father:";);
  218                  }

  223                      if (orig == nullptr) {
  224:                         STRACE("causality", tout << " #" << substituted->get_owner_id(););
  225                      }
  226                      else {
  227:                         STRACE("causality", tout << " (#" << orig->get_owner_id() << " #" << substituted->get_owner_id() << ")";);
  228                      }

  230                  if (used_enodes.size() > 0) {
  231:                     STRACE("causality", tout << "\n";);
  232                  }

  315  
  316:             CTRACE("bindings", f != nullptr, 
  317                    tout << expr_ref(q, m()) << "\n";

  333              m_plugin->init_search_eh();
  334:             TRACE("smt_params", m_params.display(tout); );
  335          }

  641          void add(quantifier * q) override {
  642:             TRACE("model_finder", tout << "add " << q->get_id() << ": " << q << " " << m_fparams->m_mbqi << " " << mbqi_enabled(q) << "\n";);
  643              if (m_fparams->m_mbqi && mbqi_enabled(q)) {

  692                  if (!unary && j >= num_eager_multi_patterns) {
  693:                     TRACE("quantifier", tout << "delaying (too many multipatterns):\n" << mk_ismt2_pp(mp, m) << "\n"
  694                            << "j: " << j << " unary: " << unary << " m_params.m_qi_max_eager_multipatterns: " << m_fparams->m_qi_max_eager_multipatterns

  698                  else {
  699:                     TRACE("quantifier", tout << "adding:\n" << expr_ref(mp, m) << "\n";);
  700                      m_mam->add_pattern(q, mp);

  731              }
  732:             TRACE("mam_stats", m_mam->display(tout););
  733          }

z3/src/smt/smt_quick_checker.cpp:
  131          }
  132:         TRACE("collector", 
  133                tout << "candidates:\n";

  145          init(q);
  146:         TRACE("collector", tout << "model checking: #" << q->get_id() << "\n" << mk_pp(q, m_manager) << "\n";);
  147          collect(q->get_expr(), nullptr, 0);

  161      bool quick_checker::instantiate_unsat(quantifier * q) {
  162:         TRACE("quick_checker", tout << "instantiate instances unsatisfied by current model\n" << mk_pp(q, m_manager) << "\n";);
  163          m_candidate_vectors.reset();

  172      bool quick_checker::instantiate_not_sat(quantifier * q) {
  173:         TRACE("quick_checker", tout << "instantiate instances not satisfied by current model\n" << mk_pp(q, m_manager) << "\n";);
  174          m_candidate_vectors.reset();

  210          }
  211:         TRACE("quick_checker_sizes", tout << mk_pp(q, m_manager) << "\n"; for (unsigned i = 0; i < szs.size(); i++) tout << szs[i] << " "; tout << "\n";);
  212:         TRACE("quick_checker_candidates", 
  213                tout << "candidates:\n";

  226                  bool is_candidate = false;
  227:                 TRACE("quick_checker", tout << "processing bindings:";
  228                        for (unsigned i = 0; i < m_num_bindings; i++) tout << " #" << m_bindings[i]->get_owner_id();

  234                  if (is_candidate) {
  235:                     TRACE("quick_checker", tout << "found new candidate\n";);
  236:                     TRACE("quick_checker_sizes", tout << "found new candidate\n"; 
  237                            for (unsigned i = 0; i < m_num_bindings; i++) tout << "#" << m_bindings[i]->get_owner_id() << " "; tout << "\n";);

  331          expr * new_a = canonize(a);
  332:         TRACE("quick_checker_canonizer", tout << "before:\n" << mk_pp(a, m_manager) << "\nafter:\n" << mk_pp(new_a, m_manager) << "\n";);
  333          if (m_context.lit_internalized(new_a) && m_context.is_relevant(new_a)) {

z3/src/smt/smt_relevancy.cpp:
  274                  m_is_relevant.remove(n->get_id());
  275:                 TRACE("propagate_relevancy", tout << "unmarking:\n" << mk_ismt2_pp(n, get_manager()) << "\n";);
  276              }

  422          void propagate_relevant_ite(app * n) {
  423:             TRACE("propagate_relevant_ite", tout << "propagating relevancy for #" << n->get_id() << "\n" << mk_pp(n, get_manager()) << "\n";);
  424              mark_as_relevant(n->get_arg(0));

  426              case l_false:
  427:                 TRACE("propagate_relevant_ite", tout << "marking as relevant: " << mk_pp(n->get_arg(2), get_manager()) << "\n";);
  428                  mark_as_relevant(n->get_arg(2));

  430              case l_undef:
  431:                 TRACE("propagate_relevant_ite", tout << "ite c is unassigned\n";);
  432                  break;
  433              case l_true:
  434:                 TRACE("propagate_relevant_ite", tout << "marking as relevant: " << mk_pp(n->get_arg(1), get_manager()) << "\n";);
  435                  mark_as_relevant(n->get_arg(1));

  454                  expr * n = m_relevant_exprs.get(m_qhead);
  455:                 TRACE("propagate_relevancy_to_args", tout << "propagating relevancy to args of #" << n->get_id() << "\n";);
  456:                 TRACE("propagate_relevancy", tout << "marking as relevant:\n" << mk_bounded_pp(n, m) << "\n";);
  457                  SASSERT(is_relevant_core(n));

  526              for (unsigned i = 0; i < num_args; i++) {
  527:                 CTRACE("relevancy_bug", !is_relevant(n->get_arg(i)), tout << "n: " << mk_ismt2_pp(n, get_manager()) << "\ni: " << i << "\n";);
  528                  SASSERT(is_relevant(n->get_arg(i)));

  543                  }
  544:                 TRACE("check_relevancy", tout << "failed:\n" << mk_ll_pp(n, get_manager()); display(tout););
  545                  UNREACHABLE();

  570                  if (get_manager().is_bool(n)) {
  571:                     TRACE("ite_bug", tout << mk_bounded_pp(n, get_manager()) << "\n";);
  572                      SASSERT(is_relevant(n->get_arg(2)));

  602                  if (is_relevant(n)) {
  603:                     TRACE("check_relevancy", tout << "checking:\n" << mk_ll_pp(n, get_manager()) << "internalized: " << m_context.find_enode(n) << "\n";);
  604                      if (m.is_or(n)) {

  654          case l_false:
  655:             TRACE("ite_term_relevancy", tout << "marking else: #" << m_else_eq->get_id() << "\n";);
  656              rp.mark_as_relevant(m_else_eq);

  660          case l_true:
  661:             TRACE("ite_term_relevancy", tout << "marking then: #" << m_then_eq->get_id() << "\n";);
  662              rp.mark_as_relevant(m_then_eq);

z3/src/smt/smt_setup.cpp:
   51      void setup::operator()(config_mode cm) {
   52:         TRACE("internalize", tout << "setup " << &m_context << "\n";);
   53          SASSERT(m_context.get_scope_level() == 0);

   58          // }
   59:         TRACE("setup", tout << "configuring logical context, logic: " << m_logic << " " << cm << "\n";);
   60          

  140          IF_VERBOSE(100, verbose_stream() << "(smt.configuring)\n";);
  141:         TRACE("setup", tout << "setup, logic: " << m_logic << "\n";);
  142          // HACK: do not collect features for QF_BV and QF_AUFBV... since they do not use them...

  153              st.collect(fmls.size(), fmls.data());
  154:             TRACE("setup", st.display_primitive(tout););
  155              IF_VERBOSE(1000, st.display_primitive(verbose_stream()););

  236          setup_QF_UF();
  237:         TRACE("setup",
  238                tout << "st.m_num_theories: " << st.m_num_theories << "\n";

  280              throw default_exception("Benchmark has integer variables but it is marked as QF_RDL (real difference logic).");
  281:         TRACE("setup", tout << "setup_QF_RDL(st)\n";);
  282          check_no_uninterpreted_functions(st, "QF_RDL");

  306                  // if (!st.m_has_rational && !m_params.m_model && st.arith_k_sum_is_small()) {
  307:                 //   TRACE("rdl_bug", tout << "using theory_smi_arith\n";);
  308                  //    m_context.register_plugin(alloc(smt::theory_smi_arith, m_context));

  310                  // else {
  311:                 TRACE("rdl_bug", tout << "using theory_mi_arith\n";);
  312                  //setup_lra_arith();

  328      void setup::setup_QF_IDL() {
  329:         TRACE("setup", tout << "setup_QF_IDL()\n";);
  330          m_params.m_relevancy_lvl       = 0;

  343              throw default_exception("Benchmark has real variables but it is marked as QF_IDL (integer difference logic).");
  344:         TRACE("setup", tout << "setup QF_IDL, m_arith_k_sum: " << st.m_arith_k_sum << " m_num_diff_terms: " << st.m_num_arith_terms << "\n";
  345                st.display_primitive(tout););
  346:         TRACE("setup", tout << "setup_QF_IDL(st)\n";);
  347          check_no_uninterpreted_functions(st, "QF_IDL");

  368  
  369:         TRACE("setup", 
  370                tout << "RELEVANCY: " << m_params.m_relevancy_lvl << "\n";

  376          else if (!m_params.m_arith_auto_config_simplex && is_dense(st)) {
  377:             TRACE("setup", tout << "using dense diff logic...\n";);
  378              m_params.m_phase_selection = PS_CACHING_CONSERVATIVE;

  386              // if (st.arith_k_sum_is_small()) {
  387:             //    TRACE("setup", tout << "using small integer simplex...\n";
  388              //    m_context.register_plugin(alloc(smt::theory_si_arith, m_context));

  390              // else {
  391:             TRACE("setup", tout << "using big integer simplex...\n";);
  392              m_context.register_plugin(alloc(smt::theory_i_arith, m_context));

  397      void setup::setup_QF_UFIDL() {
  398:         TRACE("setup", tout << "setup_QF_UFIDL()\n";);
  399          m_params.m_relevancy_lvl    = 0;

  411      void setup::setup_QF_UFIDL(static_features & st) {
  412:         TRACE("setup", tout << "setup_QF_UFIDL(st)\n";);
  413          if (st.m_has_real)

  450      void setup::setup_QF_LRA() {
  451:         TRACE("setup", tout << "setup_QF_LRA()\n";);
  452          m_params.m_relevancy_lvl       = 0;

  488      void setup::setup_QF_LIA() {
  489:         TRACE("setup", tout << "setup_QF_LIA(st)\n";);
  490          m_params.m_relevancy_lvl       = 0;

  499          check_no_uninterpreted_functions(st, "QF_LIA");
  500:         TRACE("setup", tout << "QF_LIA setup\n";);
  501  

  557      void setup::setup_QF_BV() {
  558:         TRACE("setup", tout << "qf-bv\n";);
  559          m_params.m_relevancy_lvl       = 0;

  577      void setup::setup_QF_AX() {
  578:         TRACE("setup", tout << "QF_AX\n";);
  579          m_params.m_array_mode          = AR_SIMPLE;

  597      void setup::setup_QF_AUFLIA() {
  598:         TRACE("QF_AUFLIA", tout << "no static features\n";);
  599          m_params.m_array_mode          = AR_SIMPLE;

  614          if (st.m_num_clauses == st.m_num_units) {
  615:             TRACE("QF_AUFLIA", tout << "using relevancy: 0\n";);
  616              m_params.m_relevancy_lvl       = 0;

  630      void setup::setup_AUFLIA(bool simple_array) {
  631:         TRACE("setup", tout << "AUFLIA\n";);
  632          m_params.m_array_mode              = simple_array ? AR_SIMPLE : AR_FULL;

  647              m_params.m_ng_lift_ite = lift_ite_kind::LI_CONSERVATIVE;
  648:         TRACE("setup", tout << "max_eager_multipatterns: " << m_params.m_qi_max_eager_multipatterns << "\n";);
  649          m_context.register_plugin(alloc(smt::theory_i_arith, m_context));

  660      void setup::setup_AUFLIRA(bool simple_array) {
  661:         TRACE("setup", tout << "AUFLIRA\n";);
  662          m_params.m_array_mode              = simple_array ? AR_SIMPLE : AR_FULL;

  879      void setup::setup_datatypes() {
  880:         TRACE("datatype", tout << "registering theory datatype...\n";);
  881          m_context.register_plugin(alloc(theory_datatype, m_context));

  884      void setup::setup_recfuns() {
  885:         TRACE("recfun", tout << "registering theory recfun...\n";);
  886          theory_recfun * th = alloc(theory_recfun, m_context);

  952          st.collect(fmls.size(), fmls.data());
  953:         TRACE("setup", tout << "setup_unknown\n";);
  954          setup_arith();

  965      void setup::setup_unknown(static_features & st) {
  966:         TRACE("setup", tout << "setup_unknown\n";);
  967          if (st.m_num_quantifiers > 0) {

  981  
  982:         TRACE("setup",
  983                tout << "num non UF theories: " << st.num_non_uf_theories() << "\n";

z3/src/smt/smt_solver.cpp:
  198          lbool check_sat_core2(unsigned num_assumptions, expr * const * assumptions) override {
  199:             TRACE("solver_na2as", tout << "smt_solver::check_sat_core: " << num_assumptions << "\n";);
  200              return m_context.check(num_assumptions, assumptions);

z3/src/smt/smt_theory.cpp:
  137          app_ref eq(ctx.mk_eq_atom(a, b), get_manager());
  138:         TRACE("mk_var_bug", tout << "mk_eq: " << eq->get_id() << " " << a->get_id() << " " << b->get_id() << "\n";
  139                tout << mk_ll_pp(a, get_manager()) << "\n" << mk_ll_pp(b, get_manager()););		

z3/src/smt/smt_theory.h:
  507          bool assume_eqs(VarValueTable & table) {
  508:             TRACE("assume_eqs", tout << "starting...\n";);
  509              table.reset();

  514                  theory_var other = null_theory_var;
  515:                 TRACE("assume_eqs",
  516                        tout << "#" << n->get_owner_id() << " is_relevant_and_shared: " << is_relevant_and_shared(n) << "\n";);

  520                          enode * n2 = get_enode(other);
  521:                         TRACE("assume_eqs", tout << "value(#" << n->get_owner_id() << ") = value(#" << n2->get_owner_id() << ")\n";);
  522                          if (assume_eq(n, n2)) {
  523:                             TRACE("assume_eqs", tout << "new assumed eq\n";);
  524                              result = true;

z3/src/smt/spanning_tree_def.h:
   50  
   51:         TRACE("network_flow", {
   52              tout << pp_vector("Predecessors", m_pred) << pp_vector("Threads", m_thread); 

  158          
  159:         TRACE("network_flow", { 
  160              tout << "update_spanning_tree: (" << p << ", " << q << ") enters, (";

  204  
  205:         TRACE("network_flow", {
  206              tout << pp_vector("Predecessors", m_pred) << pp_vector("Threads", m_thread); 

z3/src/smt/theory_arith_aux.h:
   184          numeral r(1);
   185:         TRACE("lcm_bug", tout << "starting get_denominators_lcm...\n";);
   186          typename vector<row_entry>::const_iterator it  = m_entries.begin();

   190                  r = lcm(r, denominator(it->m_coeff));
   191:                 TRACE("lcm_bug", tout << "it->m_coeff: " << it->m_coeff << ", denominator(it->m_coeff): " << denominator(it->m_coeff) << ", r: " << r << "\n";);
   192              }

   524              if (!it->is_dead() && !it->m_coeff.is_int()) {
   525:                 TRACE("gomory_cut", display_row(tout, r, true););
   526                  return false;

   572              return;
   573:         TRACE("move_unconstrained_to_base", tout << "before...\n"; display(tout););
   574          int num = get_num_vars();

   590                      if (entry) {
   591:                         TRACE("move_unconstrained_to_base", tout << "moving v" << v << " to the base\n";);
   592                          row & r = m_rows[entry->m_row_id];

   602          }
   603:         TRACE("move_unconstrained_to_base", tout << "after...\n"; display(tout););
   604          CASSERT("arith", wf_rows());

   740  
   741:         TRACE("arith", tout << m_lits << " " << m_eqs.size() << "\n";);
   742          if (proofs_enabled) {

   877                      use_upper = !use_upper;
   878:                 TRACE("derived_bound", tout << "using " << (use_upper ? "upper" : "lower") << " bound of v" << v << "\n";);
   879                  bound * b  = get_bound(v, use_upper);

   888          }
   889:         TRACE("derived_bound", 
   890                tout << "explanation:\n";

   895                tout << "\n";);
   896:         DEBUG_CODE(CTRACE("derived_bound", k != val, tout << "k: " << k << ", k_norm: " << k_norm << ", val: " << val << "\n";););
   897          SASSERT(k == val);

   983              unbounded &= !get_bound(s, inc_s);
   984:             TRACE("opt", tout << "is v" << x << " safe to leave for v" << s 
   985                    << "? " << (is_unsafe?"no":"yes") << " " << (has_int?"int":"real") << " " << (unbounded?"unbounded":"bounded") << "\n";

  1042          theory_var v = internalize_term_core(term);
  1043:         TRACE("opt", tout << mk_pp(term, get_manager()) << " |-> v" << v << "\n";);
  1044          SASSERT(!is_quasi_base(v));

  1057      inf_eps_rational<inf_rational> theory_arith<Ext>::maximize(theory_var v, expr_ref& blocker, bool& has_shared) {
  1058:         TRACE("bound_bug", display_var(tout, v); display(tout););
  1059          if (ctx.get_fparams().m_threads > 1)

  1112          }
  1113:         TRACE("opt", tout << e << "\n";);
  1114          return e;

  1129          expr_ref result(b, m);
  1130:         TRACE("opt", tout << result << "\n";);
  1131          if (!ctx.b_internalized(b)) {

  1141              insert_bv2a(bv, a);
  1142:             TRACE("arith", tout << mk_pp(b, m) << "\n";
  1143                    display_atom(tout, a, false););            

  1351          }
  1352:         TRACE("opt", 
  1353                tout << (safe_gain(min_gain, max_gain)?"safe":"unsafe") << "\n";

  1416          }
  1417:         TRACE("opt",
  1418                tout << "v" << x << " := " << get_value(x) << " "

  1475              if (is_int(x_i)) {
  1476:                 TRACE("opt",
  1477                        tout << "v" << x_i << " a_ij " << a_ij << " "

  1492          }
  1493:         TRACE("opt",
  1494                tout << "v" << x_i << (is_int(x_i)?" int":" real") << " a_ij " << a_ij << " "

  1556  
  1557:             TRACE("opt", tout << "round: " << round << ", max: " << max << "\n"; display_row(tout, r, true); tout << "state:\n"; display(tout););
  1558              typename vector<row_entry>::const_iterator it  = r.begin_entries();

  1579                  if (!safe_to_leave) {
  1580:                     TRACE("opt", tout << "no variable picked\n";);
  1581                      has_bound = true;

  1584                  else if (curr_x_i == null_theory_var) {
  1585:                     TRACE("opt", tout << "v" << curr_x_j << " is unrestricted by other variables\n";);
  1586                      // we can increase/decrease curr_x_j as much as we want.

  1614  
  1615:             TRACE("opt", tout << "after traversing row:\nx_i: v" << x_i << ", x_j: v" << x_j << ", gain: " << max_gain << "\n";
  1616                    tout << "best efforts: " << best_efforts << " has shared: " << has_shared << "\n";);

  1626              if (x_j == null_theory_var) {
  1627:                 TRACE("opt", tout << "row is " << (max ? "maximized" : "minimized") << "\n";
  1628                        display_row(tout, r, true););

  1644                      update_value(x_j, max_gain);
  1645:                     TRACE("opt", tout << "moved v" << x_j << " to upper bound\n";);
  1646                      SASSERT(!maintain_integrality || valid_assignment());

  1655                      update_value(x_j, max_gain);
  1656:                     TRACE("opt", tout << "moved v" << x_j << " to lower bound\n";);
  1657                      SASSERT(!maintain_integrality || valid_assignment());

  1685                  if (inc) {
  1686:                     TRACE("opt", tout << "moved v" << x_j << " to upper bound\n";);
  1687                  }

  1689                      max_gain.neg();
  1690:                     TRACE("opt", tout << "moved v" << x_j << " to lower bound\n";);
  1691                  }

  1697              
  1698:             TRACE("opt", tout << "max: " << max << ", x_i: v" << x_i << ", x_j: v" << x_j << ", a_ij: " << a_ij << ", coeff: " << coeff << "\n";
  1699                    if (upper(x_i)) tout << "upper x_i: " << upper_bound(x_i) << " ";

  1713              if (!move_to_bound(x_i, inc_xi, best_efforts, has_shared)) {
  1714:                 TRACE("opt", tout << "can't move bound fully\n";);
  1715                  // break;                // break;

  1725          }
  1726:         TRACE("opt_verbose", display(tout););
  1727          return (best_efforts>0 || ctx.get_cancel_flag())?BEST_EFFORT:result;

  1761          if (safe_gain(min_gain, max_gain)) {
  1762:             TRACE("opt", tout << "Safe delta: " << max_gain << "\n";);
  1763              SASSERT(!unbounded_gain(max_gain));

  1806          if ((max && at_upper(v)) || (!max && at_lower(v))) {
  1807:             TRACE("opt", display_var(tout << "At " << (max?"max: ":"min: ") << mk_pp(e, get_manager()) << " \n", v););
  1808              return AT_BOUND; // nothing to be done...

  1824          if (r == OPTIMIZED) {
  1825:             TRACE("opt", tout << mk_pp(e, get_manager()) << " " << (max ? "max" : "min") << " value is: " << get_value(v) << "\n";
  1826                    display_row(tout, m_tmp_row, true); display_row_info(tout, m_tmp_row););

  1830          else if (r == UNBOUNDED) {
  1831:             TRACE("opt", display_var(tout << "unbounded: " << mk_pp(e, get_manager()) << "\n", v););
  1832          }
  1833          else {
  1834:             TRACE("opt", display_var(tout << "not optimized: " << mk_pp(e, get_manager()) << "\n", v););
  1835          }

  1857              bool r = propagate_core();
  1858:             TRACE("opt", tout << "after max/min round:\n"; display(tout););
  1859              return r;

  1937      fi_succeeded:
  1938:         TRACE("freedom_interval",
  1939                tout << "freedom variable for:\n";

  2018  #if 0
  2019:         TRACE("imply_eq", display_row_info(tout, m_tmp_row););
  2020          m_tmp_acc_lits.reset();

  2029              // v1 == v2
  2030:             TRACE("imply_eq", tout << "found new implied equality:\n";
  2031                    display_var(tout, v1); display_var(tout, v2););

  2139          }
  2140:         TRACE("arith_rand", tout << "candidates.size() == " << candidates.size() << "\n";);
  2141  

  2178          enode_vector::const_iterator end = r->end_parents();
  2179:         TRACE("shared", tout << ctx.get_scope_level() << " " <<  v << " " << r->get_num_parents() << "\n";);
  2180          for (; it != end; ++it) {

  2202              mutate_assignment();
  2203:         TRACE("assume_eq_int", display(tout););
  2204  
  2205          unsigned old_sz = m_assume_eq_candidates.size();
  2206:         TRACE("func_interp_bug", display(tout););
  2207          m_var_value_table.reset();

  2211              enode * n        = get_enode(v);
  2212:             TRACE("func_interp_bug", tout << mk_pp(n->get_expr(), get_manager()) << " -> " << m_value[v] << " root #" << n->get_root()->get_owner_id() << " " << is_relevant_and_shared(n) << "\n";);
  2213              if (!is_relevant_and_shared(n)) {

  2224              }
  2225:             TRACE("func_interp_bug", tout << "adding to assume_eq queue #" << n->get_owner_id() << " #" << n2->get_owner_id() << "\n";);
  2226              m_assume_eq_candidates.push_back(std::make_pair(other, v));

  2245              m_assume_eq_head++;
  2246:             CTRACE("func_interp_bug", 
  2247                     get_value(v1) == get_value(v2) && 

z3/src/smt/theory_arith_core.h:
    32          if (!m_found_unsupported_op) {
    33:             TRACE("arith", tout << "found non supported expression:\n" << mk_pp(n, m) << "\n";);
    34              ctx.push_trail(value_trail<bool>(m_found_unsupported_op));

    43          if (!m_found_underspecified_op) {
    44:             TRACE("arith", tout << "found underspecified expression:\n" << mk_pp(n, m) << "\n";);
    45              ctx.push_trail(value_trail<bool>(m_found_underspecified_op));

    84              if (counter % 1000 == 0) {
    85:                 TRACE("arith_adaptive", tout << "arith_conflicts: " << get_num_conflicts() << " total_conflicts: " << total_conflicts << " factor: " << f << "\n";);
    86              }

   106          bool is_int  = is_int_expr(n->get_expr());
   107:         TRACE("mk_arith_var", tout << mk_pp(n->get_expr(), m) << " is_int: " << is_int << "\n";);
   108          m_columns          .push_back(column());

   133          SASSERT(m_var_occs[r].empty());
   134:         TRACE("mk_arith_var",
   135                tout << "#" << n->get_owner_id() << " :=\n" << mk_ll_pp(n->get_expr(), m) << "\n";

   348      theory_var theory_arith<Ext>::internalize_add(app * n) {
   349:         TRACE("add_bug", tout << "n: " << mk_pp(n, m) << "\n";);
   350:         CTRACE("internalize_add_bug", n->get_num_args() == 2 && n->get_arg(0) == n->get_arg(1), tout << "n: " << mk_pp(n, m) << "\n";);
   351          SASSERT(m_util.is_add(n));

   381      theory_var theory_arith<Ext>::internalize_mul_core(app * t) {
   382:         TRACE("internalize_mul_core", tout << "internalizing...\n" << mk_pp(t, m) << "\n";);
   383          if (!m_util.is_mul(t))

   405          rational _val;
   406:         TRACE("arith", tout << m->get_num_args() << " " << mk_pp(m, get_manager()) << "\n";);
   407          SASSERT(m_util.is_mul(m));

   470      theory_var theory_arith<Ext>::internalize_mod(app * n) {
   471:         TRACE("arith_mod", tout << "internalizing...\n" << mk_pp(n, m) << "\n";);
   472          rational r(1);

   516  
   517:         TRACE("arith", tout << mk_pp(ante, m) << "\n" << mk_pp(conseq, m) << "\n";
   518                tout << s_ante << "\n" << s_conseq << "\n";

   549              expr_ref div(m), zero(m), eqz(m), eq(m);
   550:             TRACE("div_axiom_bug", tout << "expanding div_axiom for: " << mk_pp(p, m) << " / " << mk_pp(q, m) << "\n";);
   551              div         = m_util.mk_div(p, q);

   554              eq          = m.mk_eq(m_util.mk_mul(q, div), p);
   555:             TRACE("div_axiom_bug", tout << "eqz: " << mk_pp(eqz, m) << "\neq: " << mk_pp(eq, m) << "\n";);
   556              mk_axiom(eqz, eq);

   577              upper       = m_util.mk_le(mod, abs_divisor);
   578:             TRACE("div_axiom_bug",
   579                    tout << "eqz:   " << eqz << "\n";

   616                  mk_axiom(eqz, div_ge, false);
   617:                 TRACE("arith", tout << eqz << " " << div_ge << "\n");
   618              }

   726              return expr2var(n);
   727:         TRACE("to_real_bug", tout << "to-real\n" << mk_ismt2_pp(n, m) << "\n";);
   728          theory_var arg = internalize_term_core(to_app(n->get_arg(0)));

   798      theory_var theory_arith<Ext>::internalize_term_core(app * n) {
   799:         TRACE("arith_internalize_detail", tout << "internalize_term_core:\n" << mk_pp(n, m) << "\n";);
   800          if (ctx.e_internalized(n)) {

   850  
   851:         TRACE("arith_internalize_detail", tout << "before:\n" << mk_pp(n, m) << "\n";);
   852          if (!ctx.e_internalized(n))
   853              ctx.internalize(n, false);
   854:         TRACE("arith_internalize_detail", tout << "after:\n" << mk_pp(n, m) << "\n";);
   855          enode * e    = ctx.get_enode(n);

   897          set_var_row(s, r_id);
   898:         TRACE("init_row_bug", tout << "before:\n"; display_row_info(tout, r););
   899          if (lazy_pivoting_lvl() > 2) {

   908          }
   909:         TRACE("init_row_bug", tout << "after:\n"; display_row_info(tout, r););
   910          if (propagation_mode() != bound_prop_mode::BP_NONE)

   954      void theory_arith<Ext>::quasi_base_row2base_row(unsigned r_id) {
   955:         TRACE("quasi_base_row2base_row", tout << "quasi_base_row2base_row...\n";);
   956          buffer<linear_monomial> to_add;
   957          collect_vars(r_id, BASE, to_add);
   958:         TRACE("quasi_base_bug_detail",
   959                display_row_info(tout, r_id);

  1000          m_value[s]   = get_implied_value(s);
  1001:         TRACE("valid_row_assignment_bug", display_row_info(tout, r_id););
  1002          SASSERT(!has_var_kind(r_id, BASE));

  1019      void theory_arith<Ext>::mk_clause(literal l1, literal l2, unsigned num_params, parameter * params) {
  1020:         TRACE("arith", literal lits[2]; lits[0] = l1; lits[1] = l2; ctx.display_literals_verbose(tout, 2, lits); tout << "\n";);
  1021          ctx.mk_th_axiom(get_id(), l1, l2, num_params, params);

  1025      void theory_arith<Ext>::mk_clause(literal l1, literal l2, literal l3, unsigned num_params, parameter * params) {
  1026:         TRACE("arith", literal lits[3]; lits[0] = l1; lits[1] = l2; lits[2] = l3; ctx.display_literals_verbose(tout, 3, lits); tout << "\n";);
  1027          ctx.mk_th_axiom(get_id(), l1, l2, l3, num_params, params);

  1033          atoms & occs = m_var_occs[v];
  1034:         TRACE("mk_bound_axioms", tout << "add bound axioms for v" << v << " " << a1 << "\n";);
  1035          if (!ctx.is_searching()) {

  1045          atom_kind kind1 = a1->get_atom_kind();
  1046:         TRACE("mk_bound_axioms", display_atom(tout << "making bound axioms for " << a1 << " ", a1, true); tout << "\n";);
  1047  

  1056              atom_kind kind2 = a2->get_atom_kind();
  1057:             TRACE("mk_bound_axioms", display_atom(tout << "compare " << a2 << " ", a2, true); tout << "\n";);
  1058  

  1090      void theory_arith<Ext>::mk_bound_axiom(atom* a1, atom* a2) {
  1091:         TRACE("mk_bound_axioms", tout << a1 << " " << a2 << "\n";);
  1092          theory_var v = a1->get_var();

  1157      void theory_arith<Ext>::flush_bound_axioms() {
  1158:         CTRACE("arith_verbose", !m_new_atoms.empty(), tout << "flush bound axioms\n";);
  1159  

  1172              }
  1173:             CTRACE("arith", atoms.size() > 1,
  1174                    for (unsigned i = 0; i < atoms.size(); ++i) {

  1282      bool theory_arith<Ext>::internalize_atom(app * n, bool gate_ctx) {
  1283:         TRACE("arith_internalize", tout << "internalizing atom:\n" << mk_pp(n, m) << "\n";);
  1284          SASSERT(m_util.is_le(n) || m_util.is_ge(n) || m_util.is_is_int(n));

  1290              if (ctx.b_internalized(n)) {
  1291:                 TRACE("arith_internalize", tout << "term was re-internalized: #" << n->get_id() << "\n";);
  1292                  return true;

  1313          if (v == null_theory_var) {
  1314:             TRACE("arith_internalize", tout << "failed to internalize: #" << n->get_id() << "\n";);
  1315              return false;

  1317          if (ctx.b_internalized(n)) {
  1318:             TRACE("arith_internalize", tout << "term was re-internalized: #" << n->get_id() << "\n";);
  1319              return true;

  1340          insert_bv2a(bv, a);
  1341:         TRACE("arith_internalize", tout << "succeeded... v" << v << " " << kind << " " << k << "\n";
  1342                for (unsigned i = 0; i + 1 < occs.size(); ++i) tout << occs[i] << "\n";);

  1347      bool theory_arith<Ext>::internalize_term(app * term) {
  1348:         TRACE("arith_internalize", tout << "internalising term:\n" << mk_pp(term, m) << "\n";);
  1349          theory_var v = internalize_term_core(term);
  1350:         TRACE("arith_internalize", tout << "theory_var: " << v << "\n";);
  1351          return v != null_theory_var;

  1367                  n1 != n2) {
  1368:                 TRACE("mk_axioms_bug", tout << mk_bounded_pp(atom, m, 5) << "\n";);
  1369                  m_arith_eq_adapter.mk_axioms(n1, n2);

  1380      void theory_arith<Ext>::assign_eh(bool_var v, bool is_true) {
  1381:         TRACE("arith_verbose", tout << "p" << v << " := " << (is_true?"true":"false") << "\n";);
  1382          atom * a = get_bv2a(v);

  1391      void theory_arith<Ext>::relevant_eh(app * n) {
  1392:         TRACE("arith_relevant_eh", tout << "relevant_eh: " << mk_pp(n, m) << "\n";);
  1393          if (m_util.is_mod(n))

  1406      void theory_arith<Ext>::new_eq_eh(theory_var v1, theory_var v2) {
  1407:         TRACE("arith_new_eq_eh", tout << "#" << get_enode(v1)->get_owner_id() << " = #" << get_enode(v2)->get_owner_id() << "\n";);
  1408:         TRACE("arith_new_eq_eh_detail", tout << mk_pp(get_enode(v1)->get_expr(), m) << "\n" <<
  1409                mk_pp(get_enode(v2)->get_expr(), m) << "\n";);

  1462      void theory_arith<Ext>::new_diseq_eh(theory_var v1, theory_var v2) {
  1463:         TRACE("arith_new_diseq_eh", tout << mk_bounded_pp(get_enode(v1)->get_expr(), m) << "\n" <<
  1464                mk_bounded_pp(get_enode(v2)->get_expr(), m) << "\n";);

  1475      void theory_arith<Ext>::init_search_eh() {
  1476:         TRACE("arith_init_search", display(tout););
  1477          m_num_conflicts      = 0;

  1501  
  1502:             TRACE("arith", tout << "m_final_check_idx: " << m_final_check_idx << ", result: " << result << "\n";);
  1503              switch (m_final_check_idx) {

  1505                  ok = check_int_feasibility();
  1506:                 TRACE("arith", tout << "check_int_feasibility(), ok: " << ok << "\n";);
  1507                  break;

  1512                      ok = FC_DONE;
  1513:                 TRACE("arith", tout << "assume_eqs(), ok: " << ok << "\n";);
  1514                  break;

  1516                  ok = process_non_linear();
  1517:                 TRACE("arith", tout << "non_linear(), ok: " << ok << "\n";);
  1518                  break;

  1527              case FC_CONTINUE:
  1528:                 TRACE("arith",
  1529                        tout << "continue arith..."

  1535          if (result == FC_DONE && m_found_unsupported_op) {
  1536:             TRACE("arith", tout << "Found unsupported operation\n";);
  1537              result = FC_GIVEUP;

  1543      final_check_status theory_arith<Ext>::final_check_eh() {
  1544:         TRACE("arith_eq_adapter_info", m_arith_eq_adapter.display_already_processed(tout););
  1545:         TRACE("arith", display(tout););
  1546  

  1561          result = final_check_core();
  1562:         TRACE("arith", tout << "result: " << result << "\n";);
  1563          return result;

  1572      void theory_arith<Ext>::propagate() {
  1573:         TRACE("arith_propagate", tout << "propagate\n"; display(tout););
  1574          if (!process_atoms())

  1895              m_update_trail_stack.push_back(v);
  1896:             TRACE("save_value", tout << "v" << v << " = " << get_value(v) << "\n";);
  1897          }

  1909          CASSERT("arith", valid_row_assignment());
  1910:         TRACE("restore_assignment_bug", tout << "START restore_assignment...\n";);
  1911          for (theory_var v : m_update_trail_stack) {
  1912:             TRACE("restore_assignment_bug", tout << "restoring v" << v << " <- " << m_old_value[v] << "\n";);
  1913              SASSERT(!is_quasi_base(v));

  1979      void theory_arith<Ext>::pivot(theory_var x_i, theory_var x_j, numeral const & a_ij, bool apply_gcd_test) {
  1980:         TRACE("arith_pivoting", tout << "pivoting: v" << x_i << ", v" << x_j << "\n";);
  1981          m_stats.m_pivots++;

  2022          CASSERT("arith", valid_row_assignment());
  2023:         TRACE("arith_pivot", tout << "after pivoting:\n";
  2024                display(tout););
  2025:         TRACE("pivot_shape", display_rows_shape(tout););
  2026:         TRACE("pivot_stats", display_rows_stats(tout););
  2027          TRACE_CODE({

  2030              if (val % 100 == 0) {
  2031:                 TRACE("pivot_bignums", display_rows_bignums(tout););
  2032              }});

  2068          }
  2069:         CTRACE("eliminate", !Lazy && c.size() != 1,
  2070                 tout << "eliminating v" << x_i << ", Lazy: " << Lazy << ", c.size: " << c.size() << "\n";

  2089          CASSERT("arith", valid_row_assignment());
  2090:         TRACE("update_and_pivot_bug_detail", display(tout););
  2091          SASSERT(is_base(x_i));
  2092          inf_numeral theta = m_value[x_i];
  2093:         TRACE("update_and_pivot_bug", tout << "theta 1) " << theta << " " << x_i_new_val << "\n";);
  2094          theta -= x_i_new_val;
  2095:         TRACE("update_and_pivot_bug", tout << "theta 2) " << theta << " " << a_ij << "\n";);
  2096          theta /= a_ij;
  2097:         TRACE("update_and_pivot_bug", tout << "theta 3) " << theta << "\n";);
  2098          update_value(x_j, theta);
  2099:         CTRACE("arith", get_value(x_i) != x_i_new_val,
  2100                 tout << "x_i: " << x_i << ", x_j: " << x_j << ", a_ij: " << a_ij << ", x_i_new_val: " << x_i_new_val << "\n";

  2241      theory_var theory_arith<Ext>::select_pivot(theory_var x_i, bool is_below, numeral & out_a_ij) {
  2242:         TRACE("select_pivot", tout << "m_blands_rule: " << m_blands_rule << " v" << x_i << "\n";);
  2243:         CTRACE("select_pivot_info", x_i > 500, ctx.display(tout););
  2244          if (m_blands_rule)

  2264      bool theory_arith<Ext>::make_var_feasible(theory_var x_i) {
  2265:         CTRACE("arith_bug", !is_base(x_i),
  2266                 tout << "x_i: " << x_i << ", below_lower(x_i): " << below_lower(x_i) <<

  2281  
  2282:         TRACE("make_var_feasible", display_row(tout, get_var_row(x_i), false););
  2283  

  2287              SASSERT(is_base(x_i));
  2288:             TRACE("pivot_bug", display_row_info(tout, get_var_row(x_i)););
  2289              update_and_pivot(x_i, x_j, a_ij, get_bound(x_i, !is_below)->get_value());

  2300      theory_var theory_arith<Ext>::select_lg_error_var(bool least) {
  2301:         TRACE("select_pivot", tout << "starting...\n";);
  2302          theory_var  best = null_theory_var;

  2313              if (best == null_theory_var || (!least && curr_error > best_error) || (least && curr_error < best_error)) {
  2314:                 TRACE("select_pivot", tout << "best: " << best << " v" << v
  2315                        << ", best_error: " << best_error << ", curr_error: " << curr_error << "\n";);

  2351      bool theory_arith<Ext>::make_feasible() {
  2352:         TRACE("arith_make_feasible", tout << "make_feasible\n"; display(tout););
  2353          CASSERT("arith", wf_rows());

  2370                      if (num_repeated > blands_rule_threshold()) {
  2371:                         TRACE("blands_rule", tout << "using blands rule, " << num_repeated << "\n";);
  2372                          // std::cerr << "BLANDS RULE...\n";

  2380              if (!make_var_feasible(v)) {
  2381:                 TRACE("arith_make_feasible", tout << "make_feasible: unsat\n"; display(tout););
  2382                  return false;
  2383              }
  2384:             TRACE("arith_make_feasible_detail", display(tout););
  2385              if (ctx.get_cancel_flag()) {

  2388          }
  2389:         TRACE("arith_make_feasible", tout << "make_feasible: sat\n"; display(tout););
  2390          CASSERT("arith", wf_rows());

  2444  
  2445:         TRACE("sign_row_conflict", tout << "v" << x_i << " is_below: " << is_below << " delta: " << delta << "\n"; display_var(tout, x_i);
  2446                tout << "is_below_lower: " << below_lower(x_i) << ", is_above_upper: " << above_upper(x_i) << "\n";

  2487              if (!m_to_patch.contains(v) && get_value(v) < k) {
  2488:                 TRACE("to_patch_bug", tout << "need to be patched (assert_lower): "; display_var(tout, v););
  2489                  m_to_patch.insert(v);

  2515  
  2516:         TRACE("arith", display_bound(tout, b); tout << "v" << v << " <= " << k << "\n";);
  2517          bound * u = upper(v);

  2535              if (!m_to_patch.contains(v) && get_value(v) > k) {
  2536:                 TRACE("to_patch_bug", tout << "need to be patched (assert upper): "; display_var(tout, v););
  2537                  m_to_patch.insert(v);

  2556      bool theory_arith<Ext>::assert_bound(bound * b) {
  2557:         TRACE("assert_bound", display_bound(tout, b); display(tout););
  2558          theory_var v = b->get_var();

  2560          if (b->is_atom()) {
  2561:             CTRACE("unassigned_atoms", m_unassigned_atoms[v] <= 0, display_var(tout, v););
  2562              SASSERT(m_unassigned_atoms[v] > 0);

  2578  
  2579:         TRACE("arith_bound", tout << "result: " << result << "\n"; display(tout););
  2580          return result;

  2591          b2->push_justification(ante, numeral(1), coeffs_enabled());
  2592:         TRACE("arith_conflict", tout << "bound conflict v" << b1->get_var() << "\n";
  2593                display_bound(tout, b1, 0);

  2673                  if (skip_big_coeffs() && it->m_coeff.is_big()) {
  2674:                     TRACE("is_row_useful", tout << "skipping row that contains big number...\n"; display_row_info(tout, r););
  2675                      lower_idx = -2;

  2725                  if (curr == nullptr || implied_k > curr->get_value()) {
  2726:                     TRACE("arith_imply_bound",
  2727                            tout << "implying lower bound for v" << entry.m_var << " " << implied_k << " using row:\n";

  2736                  if (curr == nullptr || implied_k < curr->get_value()) {
  2737:                     TRACE("arith_imply_bound",
  2738                            tout << "implying upper bound for v" << entry.m_var << " " << implied_k << " using row:\n";

  2778                  implied_k /= it->m_coeff;
  2779:                 TRACE("arith_imply_bound",
  2780                        display_var(tout, it->m_var);

  2786                          // improved lower bound
  2787:                         TRACE("arith_imply_bound",
  2788                                tout << "implying lower bound for v" << it->m_var << " " << implied_k << " using row:\n";

  2798                          // improved upper bound
  2799:                         TRACE("arith_imply_bound",
  2800                                tout << "implying upper bound for v" << it->m_var << " " << implied_k << " using row:\n";

  2823          SASSERT(delta >= inf_numeral::zero());
  2824:         TRACE("arith_conflict", tout << "relax: " << relax_bounds() << " lits: " << ante.lits().size() << " eqs: " << ante.eqs().size() << " idx: " << idx << "\n";);
  2825          if (!relax_bounds() && (!ante.lits().empty() || !ante.eqs().empty())) {

  2838          typename vector<row_entry>::const_iterator end = r.end_entries();
  2839:         TRACE("arith_proof", display_row(tout, r, false); );
  2840          for (int idx2 = 0; it != end; ++it, ++idx2) {

  2847                  if (!relax_bounds() || delta.is_zero()) {
  2848:                     TRACE("propagate_bounds", tout << "push justification: v" << it->m_var << "\n";);
  2849                      b->push_justification(ante, it->m_coeff, coeffs_enabled());

  2871                  }
  2872:                 TRACE("propagate_bounds_bug", tout << "is_b_lower: " << is_b_lower << " k1: " << k_1 << " limit_k1: "
  2873                        << limit_k1 << " delta: " << delta << " coeff: " << coeff << "\n";);

  2884                      // TODO: check if the following line is a bottleneck
  2885:                     TRACE("arith", tout << "v" << a->get_bool_var() << " " << (val == l_true) << "\n";);
  2886  

  2913                  if (is_b_lower) {
  2914:                     TRACE("propagate_bounds", tout << "coeff: " << coeff << ", k_1 - k_2: " << k_1 - k_2 << ", delta: " << delta << "\n";);
  2915                      delta -= coeff*(k_1 - k_2);

  2917                  else {
  2918:                     TRACE("propagate_bounds", tout << "coeff: " << coeff << ", k_2 - k_1: " << k_2 - k_1 << ", delta: " << delta << "\n";);
  2919                      delta -= coeff*(k_2 - k_1);
  2920                  }
  2921:                 TRACE("propagate_bounds", tout << "delta (after replace): " << delta << "\n";);
  2922                  new_atom->push_justification(ante, coeff, coeffs_enabled());

  2945                          }
  2946:                         TRACE("propagate_bounds", tout << "v" << v << " >= " << k << ", v" << v << " >= " << k2 << ", delta: " << delta << "\n";
  2947                                display_row(tout, r););

  2961                          if (delta.is_nonneg()) {
  2962:                             TRACE("propagate_bounds", tout << "v" << v << " <= " << k << ", not v" << v << " >= " << k2 << ", delta: " << delta << "\n";
  2963                                    display_row(tout, r););

  2976                          if (delta.is_nonneg()) {
  2977:                             TRACE("propagate_bounds", tout << "v" << v << " >= " << k << ", not v" << v << " <= " << k2 << ", delta: " << delta << "\n";
  2978                                    display_row(tout, r););

  2987                          }
  2988:                         TRACE("propagate_bounds", tout << "v" << v << " <= " << k << ", v" << v << " <= " << k2 << ", delta: " << delta << "\n";
  2989                                display_row(tout, r););

  3004  
  3005:         TRACE("propagate_bounds",
  3006                ante.display(tout) << " --> ";

  3036      void theory_arith<Ext>::propagate_bounds() {
  3037:         TRACE("propagate_bounds_detail", display(tout););
  3038          for (unsigned r_idx : m_to_check) {

  3069          }
  3070:         TRACE("arith_eq", tout << "done\n";);
  3071          m_to_check.reset();

  3096          m_num_conflicts++;
  3097:         TRACE("arith_conflict",
  3098                if (proof_rule)

  3203          }
  3204:         TRACE("epsilon_bug", tout << "epsilon: " << m_epsilon << "\n";);
  3205      }

  3247                          // The choice of m_epsilon is making them equal.
  3248:                         TRACE("refine_epsilon",
  3249                                tout << "v" << v << " v" << v2 << " " << get_value(v) << " " << get_value(v2) << " " << value << std::endl;

  3262              m_epsilon = m_epsilon / two;
  3263:             TRACE("refine_epsilon", tout << "new epsilon..." << m_epsilon << std::endl;);
  3264          }

  3268      void theory_arith<Ext>::init_model(model_generator & mg) {
  3269:         TRACE("theory_arith", tout << "init model invoked...\n";
  3270                for (app* n : m_underspecified_ops) {

  3298          if (is_int(v) && !num.is_int()) {
  3299:             TRACE("arith", tout << "Truncating non-integer value. This is possible for non-linear constraints v" << v << " " << num << "\n";);
  3300              num = floor(num);

  3387          CASSERT("arith", valid_row_assignment());
  3388:         TRACE("arith_pop_scope_bug", display(tout););
  3389          // The m_update_trail_stack may not be empty.

  3403          m_asserted_qhead = s.m_asserted_qhead_old;
  3404:         TRACE("arith_pop_scope_bug", tout << "num_vars: " << get_num_vars() << ", num_old_vars: " << get_old_num_vars(num_scopes) << "\n";);
  3405          restore_nl_propagated_flag(s.m_nl_propagated_lim);

  3512                      del_row(get_var_row(v));
  3513:                     TRACE("arith_make_feasible", tout << "del row v" << v << "\n";);
  3514                      break;

  3518                          eliminate<false>(v, false);
  3519:                     TRACE("arith_make_feasible", tout << "del row v" << v << "\n";);
  3520                      del_row(get_var_row(v));

  3530                          del_row(get_var_row(v));
  3531:                         TRACE("arith_make_feasible", tout << "del row v" << v << "\n";);
  3532                      }
  3533                      else {
  3534:                         TRACE("arith_make_feasible", tout << "no row v" << v << "\n";);
  3535                      }

z3/src/smt/theory_arith_eq.h:
   45          value_sort_pair key(val, is_int_src(v));
   46:         TRACE("arith_eq", tout << mk_pp(get_enode(v)->get_expr(), get_manager()) << " = " << val << "\n";);
   47          theory_var v2;

   66  
   67:                     TRACE("arith_eq", tout << "propagate eq: v" << v << " = v" << v2 << "\n";
   68                            display_var(tout, v);

  177          if (ok % 100000 == 0) {
  178:             TRACE("arith_eq", 
  179                    tout << total << " " << ok << " " 

  218              return;
  219:         TRACE("arith_eq_verbose", tout << "checking if row " << rid << " can propagate equality.\n";
  220                display_row_info(tout, rid););

  248                      // 
  249:                     TRACE("arith_eq", tout << "fixed\n";);
  250                      lower(x2)->push_justification(ante, numeral::zero(), proofs_enabled());

  261                  collect_fixed_var_justifications(r, ante);
  262:                 TRACE("arith_eq", tout << "propagate eq using x-y=0 row:\n"; display_row_info(tout, r););
  263                  m_stats.m_offset_eqs++;

  296                              collect_fixed_var_justifications(r2, ante);
  297:                             TRACE("arith_eq", tout << "propagate eq two rows:\n"; 
  298                                    tout << "x  : v" << x << "\n";

  326          if (var2expr(x)->get_sort() != var2expr(y)->get_sort()) {
  327:             TRACE("arith", tout << mk_pp(var2expr(x), m) << " = " << mk_pp(var2expr(y), m) << "\n";);
  328              return;

  342                      antecedents.num_params(), antecedents.params("eq-propagate")));
  343:         TRACE("arith_eq", tout << "detected equality: #" << _x->get_owner_id() << " = #" << _y->get_owner_id() << "\n";
  344                display_var(tout, x);

z3/src/smt/theory_arith_int.h:
   149          if (v != null_theory_var) {
   150:             TRACE("find_infeasible_int_base_var", display_var(tout, v););
   151              return v;

   210          rational _k   = k.to_rational();
   211:         TRACE("arith_int", tout << "branching v" << v << " = " << get_value(v) << "\n";
   212                display_var(tout, v);

   222              IF_VERBOSE(10, verbose_stream() << "branch " << bound << "\n");
   223:             TRACE("arith_int", tout << mk_bounded_pp(bound, m) << "\n";);
   224              ctx.internalize(bound, true);

   255              if (b == null_theory_var) {
   256:                 TRACE("arith_int", display_row(tout << "null: ", r, true); );
   257                  continue;

   273              if (!is_tight) {
   274:                 TRACE("arith_int", 
   275                        display_row(tout << "!tight: ", r, true); 

   299                  if (!is_int(x)) {
   300:                     TRACE("arith_int", display_row(tout << "!int:  ", r, true); );
   301                      is_tight = false;

   327              }
   328:             TRACE("arith_int",
   329                    tout << "extracted row:\n";

   368          if (pol.empty()) {
   369:             TRACE("arith_int", tout << "The witness is trivial\n";);
   370              return false;

   390         
   391:         TRACE("arith_int", 
   392                tout << "cut: (or " << mk_pp(p1, get_manager()) << " " << mk_pp(p2, get_manager()) << ")\n";

   437      bool theory_arith<Ext>::is_gomory_cut_target(row const & r) {
   438:         TRACE("gomory_cut", r.display(tout););
   439          theory_var b = r.get_base_var();

   444              if (!it->is_dead() && it->m_var != b && (!at_bound(it->m_var) || !get_value(it->m_var).is_rational())) {
   445:                 TRACE("gomory_cut", tout << "row is not gomory cut target:\n";
   446                        display_var(tout, it->m_var);

   479          result = m_util.mk_ge(pol, m_util.mk_numeral(k, all_int));
   480:         TRACE("arith_mk_polynomial", tout << "before simplification:\n" << result << "\n";);
   481          proof_ref pr(m);
   482          get_context().get_rewriter()(result, result, pr);
   483:         TRACE("arith_mk_polynomial", tout << "after simplification:\n" << result << "\n";);
   484          SASSERT(is_well_sorted(get_manager(), result));

   517          if (constrain_free_vars(r) || !is_gomory_cut_target(r)) {
   518:             TRACE("gomory_cut", tout << "failed to apply gomory cut:\n";
   519                    tout << "constrain_free_vars(r):  " << constrain_free_vars(r) << "\n";);

   522  
   523:         TRACE("gomory_cut", tout << "applying cut at:\n"; display_row_info(tout, r););
   524          

   572                      }
   573:                     TRACE("gomory_cut_detail", tout << a_ij << "*v" << x_j << " k: " << k << "\n";);
   574                      pol.push_back(row_entry(new_a_ij, x_j));

   579                      numeral f_j = Ext::fractional_part(a_ij);
   580:                     TRACE("gomory_cut_detail", 
   581                            tout << a_ij << "*v" << x_j << "\n";

   609                          }
   610:                         TRACE("gomory_cut_detail", tout << "new_a_ij: " << new_a_ij << " k: " << k << "\n";);
   611                          pol.push_back(row_entry(new_a_ij, x_j));

   617  
   618:         CTRACE("empty_pol", pol.empty(), display_row_info(tout, r););
   619  

   644                  lcm_den = lcm(lcm_den, denominator(k));
   645:                 TRACE("gomory_cut_detail", tout << "k: " << k << " lcm_den: " << lcm_den << "\n";
   646                        for (unsigned i = 0; i < pol.size(); i++) {

   659                  }
   660:                 TRACE("gomory_cut_detail", tout << "after *lcm\n";
   661                        for (unsigned i = 0; i < pol.size(); i++) {

   667          }
   668:         TRACE("gomory_cut", tout << "new cut:\n" << bound << "\n"; ante.display(tout););
   669          literal l     = null_literal;

   703          numeral lcm_den = r.get_denominators_lcm();
   704:         TRACE("gcd_test_bug", r.display(tout); tout << "lcm: " << lcm_den << "\n";);
   705          numeral consts(0);

   739                  SASSERT(least_coeff.is_int());
   740:                 TRACE("gcd_test_bug", tout << "coeff: " << it->m_coeff << ", gcds: " << gcds 
   741                        << " least_coeff: " << least_coeff << " consts: " << consts << "\n";);

   752          if (!(consts / gcds).is_int()) {
   753:             TRACE("gcd_test", tout << "row failed the GCD test:\n"; display_row_info(tout, r););
   754              antecedents ante(*this);

   833          if (u1 < l1) {
   834:             TRACE("gcd_test", tout << "row failed the extended GCD test:\n"; display_row_info(tout, r););
   835              collect_fixed_var_justifications(r, ante);

   913                  continue;
   914:             TRACE("patch_int",
   915                    tout << "TARGET v" << v << " -> [";

   968      final_check_status theory_arith<Ext>::check_int_feasibility() {
   969:         TRACE("arith_int_detail", get_context().display(tout););
   970          if (!has_infeasible_int_var()) {
   971:             TRACE("arith", tout << "FC_DONE 1...\n"; display(tout););
   972              return FC_DONE;

   974  
   975:         TRACE("arith",
   976                int num = get_num_vars();

   987  
   988:         TRACE("arith_int_fracs_min_max",
   989                numeral max(0);

  1004          if (m_params.m_arith_ignore_int) {
  1005:             TRACE("arith", tout << "Ignore int: give up\n";);
  1006              return FC_GIVEUP;

  1016  
  1017:         TRACE("arith_int_freedom",
  1018                int num = get_num_vars();

  1041          
  1042:         TRACE("arith_int_inf",
  1043                int num = get_num_vars();

  1049  
  1050:         TRACE("arith_int_rows",
  1051                unsigned num = 0;

  1066              m_stats.m_patches_succ++;
  1067:             TRACE("arith_int_incomp", tout << "FC_DONE 2...\n"; display(tout););
  1068              return m_liberal_final_check || !m_changed_assignment ? FC_DONE : FC_CONTINUE;

  1083          // TODO: add giveup code
  1084:         TRACE("gomory_cut", tout << m_branch_cut_counter << ", " << m_params.m_arith_branch_cut_ratio << std::endl;);
  1085          if (m_branch_cut_counter % m_params.m_arith_branch_cut_ratio == 0) {
  1086:             TRACE("opt_verbose", display(tout););
  1087              move_non_base_vars_to_bounds();
  1088              if (!make_feasible()) {
  1089:                 TRACE("arith_int", tout << "failed to move variables to bounds.\n";);
  1090                  failed();

  1094              if (int_var != null_theory_var) {
  1095:                 TRACE("arith_int", tout << "v" << int_var << " does not have an integer assignment: " << get_value(int_var) << "\n";);
  1096                  SASSERT(is_base(int_var));

  1098                  if (!mk_gomory_cut(r)) {
  1099:                     TRACE("gomory_cut", tout << "silent failure\n";);
  1100                  }

  1111              if (int_var != null_theory_var) {
  1112:                 TRACE("arith_int", tout << "v" << int_var << " does not have an integer assignment: " << get_value(int_var) << "\n";);
  1113                  // apply branching 

z3/src/smt/theory_arith_inv.h:
   80              SASSERT(is_base(s) || is_quasi_base(s));
   81:             CTRACE("arith_bug", !(!is_base(s) || (!has_var_kind(r_id, BASE) && !has_var_kind(r_id, QUASI_BASE))),
   82                     display_row_info(tout, r_id););
   83              SASSERT(!is_base(s) || (!has_var_kind(r_id, BASE) && !has_var_kind(r_id, QUASI_BASE)));
   84:             CTRACE("arith_bug", is_quasi_base(s) && has_var_kind(r_id, QUASI_BASE), display_row_info(tout, r_id););
   85              SASSERT(!is_quasi_base(s) || !has_var_kind(r_id, QUASI_BASE));

   90                  if (!it->is_dead()) {
   91:                     CTRACE("row_bug", already_found[it->m_var], display_row_info(tout, r_id););
   92                      SASSERT(!already_found[it->m_var]);

   94                      column const & c = m_columns[it->m_var];
   95:                     CTRACE("row_bug", it->m_coeff.is_zero(), display_row_info(tout, r_id););
   96                      SASSERT(!it->m_coeff.is_zero());

  131                  row const & r = m_rows[it->m_row_id];
  132:                 CTRACE("wf_column", r.size() == 0, tout << "v" << v << ", it->m_row_id: " << it->m_row_id << "\n"; display_row_info(tout, r); display(tout););
  133                  SASSERT(r.size() != 0);

  160      bool theory_arith<Ext>::valid_row_assignment() const {
  161:         TRACE("valid_row_assignment", display(tout););
  162          typename vector<row>::const_iterator it  = m_rows.begin();

  184              }
  185:             CTRACE("valid_row_assignment_bug", !sum.is_zero(), tout << "checking: "; display_row_info(tout, r););
  186              SASSERT(sum.is_zero());

  196          for (theory_var v = 0; v < num; v++) {
  197:             CTRACE("bound_bug", below_lower(v) || above_upper(v), display_var(tout, v); display(tout););
  198              SASSERT(!below_lower(v));

  209              if (is_int(v) && !get_value(v).is_int()) {
  210:                 TRACE("bound_bug", display_var(tout, v); display(tout););
  211                  return false;

  225          }
  226:         TRACE("arith", display(tout););
  227          return false;

z3/src/smt/theory_arith_nl.h:
    85              continue;
    86:         TRACE("non_linear_bug", tout << "visiting row: " << ce.m_row_id << "\n";);
    87          already_visited_rows.insert(ce.m_row_id);

   100                  mark_var(re.m_var, vars, already_found);
   101:             CTRACE("non_linear", !re.is_dead() && is_fixed(re.m_var), tout << "skipped fixed\n");                
   102          }

   124          theory_var v = vars[idx];
   125:         TRACE("non_linear", tout << "marking dependents of: v" << v << "\n";);
   126          mark_dependents(v, vars, already_found, already_visited_rows);
   127      }
   128:     TRACE("non_linear", tout << "variables in non linear cluster: ";
   129            for (theory_var v : vars) tout << "v" << v << " "; tout << "\n";

   264  
   265:     TRACE("non_linear",
   266            display_interval(tout << "bound: ",i); tout << i << "\n";

   276  
   277:     TRACE("non_linear", display_interval(tout << "target after: ", target); tout << "\n";);
   278  }

   291      rational val;
   292: #define TR() TRACE("nl_evaluate", tout << "eval: " << mk_bounded_pp(n, get_manager(), 10) << "\n";\
   293      display_nested_form(tout, n); tout << "\ninterval: " << r << "\n";);

   330      else {
   331:         TRACE("nl_evaluate", tout << "is unknown\n";);
   332          return interval(m_dep_manager);

   374      dependency2new_bound(dep, *new_bound);
   375:     TRACE("non_linear", new_bound->display(*this, tout); tout << "\n";);
   376  }

   402          if (old_lower == nullptr || new_lower > old_lower->get_value()) {
   403:             TRACE("non_linear", tout << "NEW lower bound for v" << v << " " << mk_pp(var2expr(v), get_manager()) 
   404                    << " " << new_lower << "\n";

   426          if (old_upper == nullptr || new_upper < old_upper->get_value()) {
   427:             TRACE("non_linear", tout << "NEW upper bound for v" << v << " " << new_upper << "\n";
   428                    display_interval(tout, i); tout << "\n";);

   438      SASSERT(expr2var(n) != null_theory_var);
   439:     TRACE("non_linear", tout << "NL bounds for m: " << i << "\n" << mk_pp(n, get_manager()) << "\n";);
   440      return update_bounds_using_interval(expr2var(n), i);

   448      SASSERT(is_pure_monomial(m));
   449:     TRACE("nl_arith_bug", tout << "processing upward:\n" << mk_pp(m, get_manager()) << "\n";);
   450      buffer<var_power_pair> vp;

   455          unsigned power   = p.second;
   456:         TRACE("nl_arith_bug", tout << "interval before: " << new_bounds << "\n";
   457                theory_var v  = expr2var(var);

   461          mul_bound_of(var, power, new_bounds);
   462:         TRACE("nl_arith_bug", tout << "interval after: " << new_bounds << "\n";);
   463      }

   496      interval r = mk_interval_for(n);
   497:     TRACE("nl_arith_bug", tout << "m: " << mk_ismt2_pp(n, get_manager()) << "\nv: " << mk_ismt2_pp(v, get_manager()) <<
   498            "\npower: " << power << "\n";

   513  bool theory_arith<Ext>::propagate_nl_bounds(expr * m) {
   514:     TRACE("non_linear", tout << "propagate several bounds using:\n"; display_monomial(tout, m); tout << "\n";);
   515      bool result = propagate_nl_upward(m);

   540          auto p = analyze_monomial(m);
   541:         TRACE("propagate_nl_bound", tout << "m: " << mk_ismt2_pp(m, get_manager()) << "\n" << "p: " << p.first << "\n";);
   542          unsigned num_bad_vars = p.first;

   547          bool is_free_m = is_free(m);
   548:         TRACE("propagate_nl_bound", tout << "is_free_m: " << is_free_m << "\n";);
   549          if (num_bad_vars == 1 && is_free_m)

   604          v_val = get_value(curr, computed_epsilon);
   605:         TRACE("non_linear", tout << mk_pp(arg, get_manager()) << " = " << v_val << "\n";);
   606          val *= v_val;

   608      v_val = get_value(v, computed_epsilon);
   609:     TRACE("non_linear", tout << "v" << v << " := " << v_val << " == " << val << "\n";);
   610      return v_val == val;

   621      for (theory_var v : m_nl_monomials) {
   622:         TRACE("non_linear", tout << "v" << v << " is relevant: " << ctx.is_relevant(get_enode(v)) << "\n");
   623          if (ctx.is_relevant(get_enode(v)) && !check_monomial_assignment(v, computed_epsilon)) {
   624:             TRACE("non_linear", tout << "check_monomial_assignment failed for:\n" << mk_ismt2_pp(var2expr(v), get_manager()) << "\n";
   625                    display_var(tout, v););                

   643  theory_var theory_arith<Ext>::find_nl_var_for_branching() {
   644:     TRACE("nl_branching", tout << "looking for variable to branch...\n"; display(tout););
   645      theory_var target = null_theory_var;

   659                  theory_var curr = ctx.get_enode(arg)->get_th_var(get_id());
   660:                 TRACE("nl_branching", tout << "target: v" << target << ", curr: v" << curr << "\n";);
   661                  if (!is_fixed(curr) && is_int(curr)) {

   673                          n++;
   674:                         TRACE("nl_branching", tout << "n: " << n << "\n";);
   675                          if (m_random()%n == 0)

   680                  }
   681:                 TRACE("nl_branching", tout << "after target: v" << target << "\n";);
   682              }

   696  bool theory_arith<Ext>::branch_nl_int_var(theory_var v) {
   697:     TRACE("non_linear", tout << "BRANCHING on v" << v << "\n";);
   698      m_stats.m_nl_branching++;

   706          bound  = m_util.mk_eq(var2expr(v), m_util.mk_numeral(rational(0), true));
   707:     TRACE("non_linear", tout << "new bound:\n" << mk_pp(bound, get_manager()) << "\n";);
   708      ast_manager & m = get_manager();

   731          theory_var _var = expr2var(arg);
   732:         CTRACE("non_linear", is_fixed(_var), 
   733                 tout << mk_pp(arg, get_manager()) << " is fixed: " << lower_bound(_var) << "\n";);

   756      }
   757:     TRACE("arith", tout << mk_pp(m, get_manager()) << " " << r << "\n";);
   758      return r;

   782  bool theory_arith<Ext>::propagate_linear_monomial(theory_var v) {
   783:     TRACE("non_linear", tout << "checking whether v" << v << " became linear...\n";);
   784      if (m_data[v].m_nl_propagated)

   793      m_nl_propagated.push_back(v);
   794:     TRACE("non_linear", tout << "v" << v << " is linear " << mk_pp(m, get_manager()) << "\n";);
   795  

   797      numeral k                 = get_monomial_fixed_var_product(m);
   798:     TRACE("non_linear", tout << "new linear monomial... k: " << k << "\n";);
   799      expr *  x_n               = k.is_zero() ? nullptr : get_monomial_non_fixed_var(m);
   800:     TRACE("non_linear_bug", if (x_n != 0) { tout << "x_n: " << mk_bounded_pp(x_n, get_manager()) << "\nx_n: #" << x_n->get_id() << "\n"; });
   801      derived_bound * new_lower = nullptr;

   811          // where k = lower(x_1)*...*lower(x_{n-1})
   812:         TRACE("non_linear", tout << "x_n: " << mk_pp(x_n, get_manager()) << "\n";);
   813          k.neg();

   815          expr * rhs   = m_util.mk_add(m, k_x_n);
   816:         TRACE("non_linear_bug", tout << "rhs: " << mk_bounded_pp(rhs, get_manager(),5) << "\ninternalized: " << ctx.e_internalized(rhs) << "\n";);
   817          if (!has_var(rhs)) {

   820          }
   821:         TRACE("non_linear_bug", tout << "enode: " << ctx.get_enode(rhs) << " enode_id: " << ctx.get_enode(rhs)->get_owner_id() << "\n";);
   822          theory_var new_v = expr2var(rhs);

   832          // (= (* x_1 ... x_n) k)
   833:         TRACE("non_linear", tout << "all variables are fixed, and bound is: " << k << "\n";);
   834          new_lower    = alloc(derived_bound, v, inf_numeral(k), B_LOWER);

   867  
   868:             TRACE("non_linear", 
   869                    for (literal l : new_lower->m_lits) {

   875  
   876:             TRACE("non_linear",
   877                    for (literal l : new_lower->m_lits) {

   886  
   887:     TRACE("non_linear",
   888            new_lower->display(*this, tout << "lower: "); tout << "\n";

   905          return false;
   906:     TRACE("non_linear", tout << "propagating linear monomials...\n";);
   907      bool p = false;

   913      }
   914:     CTRACE("non_linear", p, display(tout););
   915      return p;

  1119          if (has_var(v) && !is_fixed(expr2var(v))) {                 
  1120:             TRACE("nl_info", tout << "adding occ: " << mk_bounded_pp(v, get_manager()) << "\n";); 
  1121              unsigned occs = 0;                                                  

  1158      SASSERT(!p.empty());
  1159:     TRACE("p2expr_bug", display_coeff_exprs(tout, p););
  1160      ptr_buffer<expr> args;

  1345  expr * theory_arith<Ext>::factor(expr * m, expr * var, unsigned d) {
  1346:     TRACE("factor", tout << "m: " << mk_pp(m, get_manager()) << "\nvar: " << mk_pp(var, get_manager()) << "\nd: " << d << "\n";);
  1347      if (d == 0)

  1372      SASSERT(idx == d);
  1373:     TRACE("factor_bug", tout << "new_args:\n"; for(unsigned i = 0; i < new_args.size(); i++) tout << mk_pp(new_args[i], get_manager()) << "\n";);
  1374      expr * result = mk_nary_mul(new_args.size(), new_args.data(), m_util.is_int(var));
  1375      m_nl_new_exprs.push_back(result);
  1376:     TRACE("factor", tout << "result: " << mk_pp(result, get_manager()) << "\n";);
  1377      return result;

  1387      unsigned d = get_min_degree(p, var);
  1388:     TRACE("horner_bug", tout << "poly:\n";
  1389            for (unsigned i = 0; i < p.size(); i++) { if (i > 0) tout << " + "; tout << p[i].first << "*" << mk_pp(p[i].second, get_manager()); } tout << "\n";

  1431  expr_ref theory_arith<Ext>::cross_nested(unsigned depth, buffer<coeff_expr> & p, expr * var) {
  1432:     TRACE("non_linear", tout << "p.size: " << p.size() << "\n";);
  1433      if (var == nullptr) {

  1455      if (in_monovariate_monomials(p, var, i1, a, n, i2, b, nm)) {        
  1456:         CTRACE("in_monovariate_monomials", n == nm,
  1457                 for (unsigned i = 0; i < p.size(); i++) {

  1496                  m_nl_new_exprs.push_back(new_expr);
  1497:                 TRACE("non_linear", tout << "new_expr:\n"; display_nested_form(tout, new_expr); tout << "\n";);
  1498                  buffer<coeff_expr> rest;

  1505                      return expr_ref(new_expr, get_manager());
  1506:                 TRACE("non_linear", tout << "rest size: " << rest.size() << ", i1: " << i1 << ", i2: " << i2 << "\n";);
  1507                  expr_ref h = cross_nested(depth + 1, rest, nullptr);

  1528      std::stable_sort(varinfo.begin(), varinfo.end(), var_num_occs_lt());
  1529:     TRACE("cross_nested", tout << "var num occs:\n";
  1530            for (auto const& kv : varinfo) {

  1540              continue;
  1541:         TRACE("cross_nested", tout << "nested form for var:\n" << mk_ismt2_pp(var, get_manager()) << "\n";
  1542                display_nested_form(tout, cn); tout << "\n";

  1544          interval i  = evaluate_as_interval(cn);
  1545:         TRACE("cross_nested", tout << "interval: " << i << "\n";);
  1546          v_dependency * d = nullptr;

  1551          if (d) {
  1552:             TRACE("cross_nested", tout << "nested form conflict: " << i << "\n";);
  1553              set_conflict(d);

  1569  
  1570:     TRACE("cross_nested", tout << "is_cross_nested_consistent:\n"; display_row(tout, r, false);
  1571            display(tout);

  1609  
  1610:     TRACE("cross_nested", tout << "checking problematic row...\n";);
  1611  

  1615  
  1616:     TRACE("non_linear", tout << "check problematic row:\n"; display_row(tout, r); display_row(tout, r, false););
  1617      buffer<coeff_expr> p;

  1623      SASSERT(!p.empty());
  1624:     CTRACE("cross_nested_bug", !c.is_one(), tout << "c: " << c << "\n"; display_row(tout, r); tout << "---> p (coeffs, exprs):\n"; display_coeff_exprs(tout, p););
  1625      return is_cross_nested_consistent(p);

  1737  void theory_arith<Ext>::add_row_to_gb(row const & r, grobner & gb) {
  1738:     TRACE("grobner", tout << "adding row to gb\n"; display_row(tout, r););
  1739      ptr_buffer<grobner::monomial> monomials;

  1749              monomials.push_back(new_m);
  1750:         TRACE("grobner",
  1751                tout << "monomial: " << mk_pp(m, get_manager()) << "\n";

  1840      set_conflict(b, ante, "arith_nl");
  1841:     TRACE("non_linear", for (literal lit : b.m_lits) ctx.display_literal_verbose(tout, lit) << "\n"; tout << "\n";); 
  1842  }

  1857      }
  1858:     TRACE("non_linear_bug", tout << "is_inconsistent, r: " << r << "\n";);
  1859      v_dependency * interval_deps = nullptr;

  1863          conflict      = true;
  1864:         TRACE("non_linear_bug", tout << "is inconsistent, interval_deps: " << interval_deps << "\n";);
  1865      }

  1868          conflict      = true;
  1869:         TRACE("non_linear_bug", tout << "is inconsistent, interval_deps: " << interval_deps << "\n";);
  1870      }

  1872      if (conflict) {
  1873:         TRACE("non_linear", tout << "conflicting interval for = 0 equation: " << r << "\n";);
  1874          set_conflict(m_dep_manager.mk_join(interval_deps, dep));

  1887      if (is_inconsistent(zero, eq->get_num_monomials(), eq->get_monomials(), eq->get_dependency())) {
  1888:         TRACE("non_linear", tout << "found conflict\n"; gb.display_equation(tout, *eq););
  1889          return true;

  2014          }
  2015:         TRACE("non_linear", tout << "found perfect square monomial m1: "; gb.display_monomial(tout, *m1); tout << "\n";);
  2016          // try to find another perfect square

  2024                  continue;
  2025:             TRACE("non_linear", tout << "found perfect square monomial m2: "; gb.display_monomial(tout, *m2); tout << "\n";);
  2026              // try to find -2*root(m1)*root(m2)

  2036                  // check if [0, oo) provides a better lowerbound than adding the intervals of m1, m2 and m1m2;
  2037:                 TRACE("non_linear", tout << "found perfect square (M1-M2)^2:\n";
  2038                        gb.display_monomial(tout, *m1); tout << "\n";

  2044                  if (I.minus_infinity() || I.get_lower_value().is_neg()) {
  2045:                     TRACE("non_linear", tout << "the lower bound improved when perfect square is eliminated.\n";);
  2046                      // Found improvement...

  2065      if (is_inconsistent(ge_zero, monomials.size(), monomials.data(), eq->get_dependency())) {
  2066:         TRACE("non_linear", tout << "found conflict\n"; gb.display_equation(tout, *eq););
  2067          return true;

  2112      proof_ref pr(get_manager());
  2113:     TRACE("gb_bug", tout << mk_ll_pp(pol, get_manager()) << "\n";);
  2114      s(pol, s_pol, pr);
  2115      if (!has_var(s_pol)) {
  2116:         TRACE("spol_bug", tout << "internalizing...\n" << mk_ll_pp(s_pol, get_manager()) << "\n";);
  2117          ctx.internalize(s_pol, false);

  2123      // v = k
  2124:     CTRACE("spol_bug", v == null_theory_var, tout << mk_ll_pp(s_pol, get_manager()) << "\n"; display(tout););
  2125      SASSERT(v != null_theory_var);

  2128      mk_derived_nl_bound(v, inf_numeral(k), B_UPPER, eq->get_dependency());
  2129:     TRACE("non_linear", tout << "inserted new equation into the tableau\n"; display_var(tout, v););
  2130      return true;

  2153      gb.get_equations(eqs);
  2154:     TRACE("grobner", tout << "after gb\n";
  2155            std::function<void(std::ostream& out, expr* v)> _fn = [&](std::ostream& out, expr* v) { out << "v" << expr2var(v); };

  2160          if (is_inconsistent(eq, gb) || is_inconsistent2(eq, gb)) {
  2161:             TRACE("grobner", tout << "inconsistent: "; gb.display_equation(tout, *eq););
  2162              return true;

  2164      }
  2165:     TRACE("grobner", tout << "not found\n"; );
  2166      return false;

  2176          unsigned num_monomials = eq->get_num_monomials();
  2177:         CTRACE("grobner_bug", num_monomials <= 0, gb.display_equation(tout, *eq););
  2178          if (num_monomials == 0)

  2188                  continue; // variable was already updated
  2189:             TRACE("non_linear", tout << "increased weight of: " << mk_bounded_pp(var, get_manager()) << "\n";);
  2190              gb.set_weight(var, next_weight);

  2192              gb.update_order();
  2193:             TRACE("non_linear", tout << "after updating order\n"; gb.display(tout););
  2194              modified = true;

  2211              if (!eq->is_linear_combination()) {
  2212:                     TRACE("non_linear", tout << "processing new equality:\n"; gb.display_equation(tout, *eq););
  2213:                     TRACE("non_linear_bug", tout << "processing new equality:\n"; gb.display_equation(tout, *eq););
  2214                      if (internalize_gb_eq(eq))

  2250      init_grobner(nl_cluster, gb);
  2251:     TRACE("non_linear", display(tout););
  2252      bool warn            = false;

  2256      do {
  2257:         TRACE("grobner", tout << "before grobner:\n";
  2258                std::function<void(std::ostream& out, expr* v)> _fn = [&](std::ostream& out, expr* v) { out << "v" << expr2var(v); };

  2261          update_statistics(gb);
  2262:         TRACE("non_linear_gb", tout << "after:\n"; gb.display(tout););
  2263          if (ctx.get_cancel_flag())

  2311      if (!m_params.m_nl_arith) {
  2312:         TRACE("non_linear", tout << "Non-linear is not enabled\n";);
  2313          return FC_GIVEUP;

  2315  
  2316:     TRACE("process_non_linear", display(tout););
  2317  
  2318      if (m_nl_rounds > m_params.m_nl_arith_rounds) {
  2319:         TRACE("non_linear", tout << "GIVEUP non linear problem...\n";);
  2320          IF_VERBOSE(3, verbose_stream() << "Max. non linear arithmetic rounds. Increase threshold using NL_ARITH_ROUNDS=<limit>\n";);

  2328      move_non_base_vars_to_bounds();
  2329:     TRACE("non_linear_verbose", tout << "processing non linear constraints...\n"; ctx.display(tout););
  2330      if (!make_feasible()) {
  2331:         TRACE("non_linear", tout << "failed to move variables to bounds.\n";);
  2332          failed();

  2396  
  2397:     TRACE("non_linear", display(tout););
  2398      

z3/src/smt/theory_array_bapa.cpp:
  154          void mk_th_axiom(unsigned n, literal* lits) {
  155:             TRACE("card", ctx().display_literals_verbose(tout, n, lits) << "\n";);
  156              IF_VERBOSE(10, ctx().display_literals_verbose(verbose_stream(), n, lits) << "\n");

  362                          mk_th_axiom(~sz_lit, le_lit, mk_literal(sel));
  363:                         TRACE("card", tout << idx << " " << sel << " " << i.m_size << "\n";);
  364                      }

  546              if (r == l_true) r = trace_call("ensure_no_overflow", ensure_no_overflow());
  547:             CTRACE("card", r != l_true, display(tout););
  548              switch (r) {

  625              }            
  626:             TRACE("card", tout << "ASSUMPTIONS: " << assumptions << "\n";);
  627          }

z3/src/smt/theory_array_base.cpp:
    42          if (!ctx.get_fparams().m_array_fake_support && !m_found_unsupported_op) {
    43:             TRACE("array", tout << mk_ll_pp(n, m) << "\n";);            
    44              ctx.push_trail(value_trail<bool>(m_found_unsupported_op));

    50          app * r = m.mk_app(get_family_id(), OP_SELECT, 0, nullptr, num_args, args);
    51:         TRACE("mk_var_bug", tout << "mk_select: " << r->get_id() << " num_args: " << num_args;
    52                for (unsigned i = 0; i < num_args; i++) tout << " " << args[i]->get_id();

    88      void theory_array_base::assert_axiom(unsigned num_lits, literal * lits) {
    89:         TRACE("array_axiom",
    90                tout << "literals:\n";

   122          expr * val = n->get_arg(num_args - 1);
   123:         TRACE("array", tout << mk_bounded_pp(sel, m) << " = " << mk_bounded_pp(val, m) << "\n";);
   124          if (m.proofs_enabled()) {

   131          else {
   132:             TRACE("mk_var_bug", tout << "mk_sel: " << sel->get_id() << "\n";);
   133              ctx.internalize(sel, false);

   149      void theory_array_base::assert_store_axiom2_core(enode * store, enode * select) {
   150:         TRACE("array", tout << "generating axiom2: #" << store->get_owner_id() << " #" << select->get_owner_id() << "\n";
   151                tout << mk_bounded_pp(store->get_expr(), m) << "\n" << mk_bounded_pp(select->get_expr(), m) << "\n";);

   178              if (idx1->get_root() == idx2->get_root()) {
   179:                 TRACE("array_bug", tout << "indexes are equal... skipping...\n";);
   180                  continue;

   186                  if (sel1 == sel2) {
   187:                     TRACE("array_bug", tout << "sel1 and sel2 are equal:\n";);
   188                      break;

   190                  init = true;
   191:                 TRACE("array", tout << mk_bounded_pp(sel1, m) << " " << mk_bounded_pp(sel2, m) << "\n";);
   192                  conseq = mk_eq(sel1, sel2, true);

   206              // ctx.mark_as_relevant(conseq_expr);
   207:             TRACE("array", tout << "asserting axiom2: " << ante << "\n";);
   208:             TRACE("array_map_bug", tout << "axiom2:\n";
   209                    tout << mk_ismt2_pp(idx1->get_expr(), m) << "\n=\n" << mk_ismt2_pp(idx2->get_expr(), m);

   229          if (ctx.add_fingerprint(store, store->get_owner_id(), select->get_num_args() - 1, select->get_args() + 1)) {
   230:             TRACE("array", tout << "adding axiom2 to todo queue\n";);
   231              m_axiom2_todo.push_back(std::make_pair(store, select)); 

   233          }
   234:         TRACE("array", tout << "axiom already instantiated: #" << store->get_owner_id() << " #" << select->get_owner_id() << "\n";);
   235          return false;

   301                  if (ctx.is_diseq(parent, other)) {
   302:                     TRACE("array_ext", tout << "selects are disequal\n";);
   303                      return true;

   322      void theory_array_base::assert_congruent(enode * a1, enode * a2) {
   323:         TRACE("array", tout << "congruent: #" << a1->get_owner_id() << " #" << a2->get_owner_id() << "\n";);
   324          SASSERT(is_array_sort(a1));

   355          expr_ref sel2(mk_select(args2.size(), args2.data()), m);
   356:         TRACE("ext", tout << mk_bounded_pp(sel1, m) << "\n" << mk_bounded_pp(sel2, m) << "\n";);
   357          literal n1_eq_n2     = mk_eq(e1, e2, true);

   531              if (ctx.is_shared(r) || is_select_arg(r)) {
   532:                 TRACE("array", tout << "new shared var: #" << r->get_owner_id() << "\n";);
   533                  theory_var r_th_var = r->get_th_var(get_id());

   539          }
   540:         TRACE("array", tout << "collecting shared vars...\n" << unsigned_vector(result.size(), (unsigned*)result.data())  << "\n";);
   541          unmark_enodes(to_unmark.size(), to_unmark.data());

   554          for (; it1 != end1; ++it1) {
   555:             TRACE("array_bug", tout << "mk_interface_eqs: processing: v" << *it1 << "\n";);
   556              theory_var  v1 = *it1;

   617      void theory_array_base::set_default(theory_var v, enode* n) {
   618:         TRACE("array", tout << "set default: " << v << " " << pp(n, m) << "\n";);
   619          v = mg_find(v);

   664              }
   665:             CTRACE("array", m_defaults[v], 
   666                     tout << pp(m_defaults[v]->get_root(), m) << "\n";

   741                                  
   742:                 TRACE("array", tout << "merge: " << pp(n, m) << " " << v << " " << w << "\n";);
   743              }

   999  
  1000:                     TRACE("array", tout << pp(n, m) << " " << mk_pp(range, m) << " " << range->is_infinite() << "\n";);
  1001                      if (range->is_infinite())

  1028          }
  1029:         TRACE("array", 
  1030                tout << pp(n->get_root(), m) << "\n";

z3/src/smt/theory_array_full.cpp:
  114              d->m_prop_upward = true;
  115:             TRACE("array", tout << "#" << v << "\n";);
  116              if (!m_params.m_array_delay_exp_axiom) {

  136      void theory_array_full::set_prop_upward(enode * n) {
  137:         TRACE("array", tout << pp(n, m) << "\n";);
  138          if (is_store(n)) {

  266          }
  267:         TRACE("array", tout << mk_pp(n, m) << "\n";);
  268  

  359              add_lambda(v1, n);
  360:         TRACE("array", 
  361                tout << pp(get_enode(v1), m) << "\n";

  370          var_data* d = m_var_data[v];
  371:         TRACE("array", tout << "v" << v << " " << pp(get_enode(v), m) << " " 
  372                << d->m_prop_upward << " " << m_params.m_array_delay_exp_axiom << "\n";);

  383      void theory_array_full::add_parent_select(theory_var v, enode * s) {
  384:         TRACE("array", 
  385                tout << v << " select parent: " << pp(s, m) << "\n";

  409      void theory_array_full::relevant_eh(app* n) {
  410:         TRACE("array", tout << mk_pp(n, m) << "\n";);
  411          theory_array::relevant_eh(n);

  470  
  471:         TRACE("array_map_bug", tout << "invoked instantiate_select_map_axiom\n";
  472                tout << sl->get_owner_id() << " " << mp->get_owner_id() << "\n";

  478  
  479:         TRACE("array_map_bug", tout << "new axiom\n";);
  480  
  481          m_stats.m_num_map_axiom++;
  482:         TRACE("array", 
  483                tout << mk_bounded_pp(mp->get_expr(), m) << "\n";

  513          
  514:         TRACE("array_map_bug",
  515                tout << "select-map axiom\n" << mk_ismt2_pp(sel1, m) << "\n=\n" << mk_ismt2_pp(sel2,m) << "\n";);

  533          }
  534:         TRACE("array", tout << mk_bounded_pp(map, m) << "\n";);
  535  

  559          SASSERT(is_const(cnst));
  560:         TRACE("array", tout << mk_bounded_pp(cnst->get_expr(), m) << "\n";);
  561          expr* val = cnst->get_arg(0)->get_expr();

  579          SASSERT(is_as_array(arr));
  580:         TRACE("array", tout << mk_bounded_pp(arr->get_owner(), m) << "\n";);
  581          expr* def = mk_default(arr->get_owner());

  600          quantifier* lam = m.is_lambda_def(arr->get_decl());
  601:         TRACE("array", tout << mk_pp(lam, m) << "\n" << mk_pp(e, m) << "\n");
  602          expr_ref_vector args(m);       

  676          expr * val = cnst->get_expr()->get_arg(0);
  677:         TRACE("array", tout << "new select-const axiom...\n";
  678                tout << "const: " << mk_bounded_pp(cnst->get_expr(), m) << "\n";

  711          expr_ref val(m.mk_app(f, sel_args.size()-1, sel_args.data()+1), m);
  712:         TRACE("array", tout << "new select-as-array axiom...\n";
  713                tout << "as-array: " << mk_bounded_pp(arr->get_expr(), m) << "\n";

  737  
  738:         TRACE("array", tout << mk_bounded_pp(store_app, m) << "\n";);
  739  

  828                  if (!ctx.is_beta_redex(p, n)) {
  829:                     TRACE("array", tout << "not a beta redex " << enode_pp(p, ctx) << "\n");
  830                      return true;

  838          SASSERT(v != null_theory_var);
  839:         TRACE("array", tout << "v" << v << "\n";);
  840          v = find(v);

  854      bool theory_array_full::try_assign_eq(expr* v1, expr* v2) {
  855:         TRACE("array", tout << mk_bounded_pp(v1, m) << "\n==\n" << mk_bounded_pp(v2, m) << "\n";);
  856          

z3/src/smt/theory_array.cpp:
   43          // v1 is the new root
   44:         TRACE("array", 
   45                tout << "merging v" << v1 << " v" << v2 << "\n"; display_var(tout, v1);

   57              add_parent_select(v1, d2->m_parent_selects[i]);
   58:         TRACE("array", tout << "after merge\n"; display_var(tout, v1););
   59      }

   70          var_data * d  = m_var_data[r];
   71:         TRACE("array", tout << mk_bounded_pp(n->get_expr(), m) << "\nis_array: " << is_array_sort(n) << ", is_select: " << is_select(n) <<
   72                ", is_store: " << is_store(n) << "\n";);

   91          d->m_parent_selects.push_back(s);
   92:         TRACE("array", tout << v << " " << mk_pp(s->get_expr(), m) << " " << mk_pp(get_enode(v)->get_expr(), m) << "\n";);
   93          m_trail_stack.push(push_back_trail<enode *, false>(d->m_parent_selects));

  144              }
  145:             TRACE("array", tout << "#" << v << "\n";);
  146              m_trail_stack.push(reset_flag_trail(d->m_prop_upward));

  198      void theory_array::instantiate_axiom1(enode * store) {
  199:         TRACE("array", tout << "axiom 1:\n" << mk_bounded_pp(store->get_expr(), m) << "\n";);
  200          SASSERT(is_store(store));

  205      void theory_array::instantiate_axiom2a(enode * select, enode * store) {
  206:         TRACE("array", tout << "axiom 2a: #" << select->get_owner_id() << " #" << store->get_owner_id() << "\n";);
  207          SASSERT(is_select(select));

  213      bool theory_array::instantiate_axiom2b(enode * select, enode * store) {
  214:         TRACE("array_axiom2b", tout << "axiom 2b: #" << select->get_owner_id() << " #" << store->get_owner_id() << "\n";);
  215          SASSERT(is_select(select));

  224      void theory_array::instantiate_extensionality(enode * a1, enode * a2) {
  225:         TRACE("array", tout << "extensionality: #" << a1->get_owner_id() << " #" << a2->get_owner_id() << "\n";);
  226          SASSERT(is_array_sort(a1));

  240      bool theory_array::internalize_term_core(app * n) {
  241:         TRACE("array_bug", tout << mk_bounded_pp(n, m) << "\n";);
  242          for (expr* arg : *n)

  268          }
  269:         TRACE("array_bug", tout << mk_bounded_pp(n, m) << "\n";);
  270          if (!internalize_term_core(n)) {

  311          var_data * d1 = m_var_data[v1];
  312:         TRACE("ext", tout << "extensionality: " << d1->m_is_array << "\n" 
  313                << mk_bounded_pp(get_enode(v1)->get_expr(), m, 5) << "\n" 

  325          if (m.is_ite(n)) {
  326:             TRACE("array", tout << "relevant ite " << mk_pp(n, m) << "\n";);
  327          }

  396              r = FC_GIVEUP;
  397:         CTRACE("array", r != FC_DONE || m_found_unsupported_op, tout << r << "\n";);
  398          return r;

z3/src/smt/theory_bv.cpp:
    67  
    68:         TRACE("bv", tout << "v" << v << " #" << owner->get_id() << "\n";
    69                for (unsigned i = 0; i < bv_size; i++) 

    89          
    90:         TRACE("bv", tout << "bit2bool: " << mk_pp(n, ctx.get_manager()) << "\n";);
    91          expr* first_arg = n->get_arg(0);

   235          SASSERT(m_bits[v1][idx] == ~m_bits[v2][idx]);
   236:         TRACE("bv_diseq_axiom", tout << "found new diseq axiom\n"; display_var(tout, v1); display_var(tout, v2););
   237          // found new disequality

   288              theory_id th_id       = ctx.get_var_theory(l.var());
   289:             TRACE("init_bits", tout << l << " " << th_id << "\n";);
   290              if (th_id == get_id()) {

   329              literal l           = ctx.get_literal(bit);
   330:             TRACE("init_bits", tout << "bit " << i << " of #" << n->get_owner_id() << "\n" << mk_bounded_pp(bit, m) << "\n";);
   331              add_bit(v, l);

   344          for (; wpos < sz; wpos++) {
   345:             TRACE("find_wpos", tout << "curr bit: " << bits[wpos] << "\n";);
   346              if (ctx.get_assignment(bits[wpos]) == l_undef) {
   347:                 TRACE("find_wpos", tout << "moved wpos of v" << v << " to " << wpos << "\n";);
   348                  return;

   353              if (ctx.get_assignment(bits[wpos]) == l_undef) {
   354:                 TRACE("find_wpos", tout << "moved wpos of v" << v << " to " << wpos << "\n";);
   355                  return;

   357          }
   358:         TRACE("find_wpos", tout << "v" << v << " is a fixed variable.\n";);
   359          fixed_var_eh(v);

   447          unsigned sz = get_bv_size(v1);
   448:         TRACE("bv", 
   449                tout << mk_pp(o1, m) << " = " << mk_pp(o2, m) << " " 

   497                      SASSERT(get_bv_size(v) == get_bv_size(v2));
   498:                     TRACE("fixed_var_eh", tout << "detected equality: v" << v << " = v" << v2 << "\n";
   499                            display_var(tout, v);

   554      bool theory_bv::get_fixed_value(app* x, numeral & result) const {
   555:         CTRACE("bv", !ctx.e_internalized(x), tout << "not internalized " << mk_pp(x, m) << "\n";);
   556          if (!ctx.e_internalized(x)) return false;

   599          SASSERT(!ctx.e_internalized(n));
   600:         TRACE("bv", tout << mk_bounded_pp(n, m) << "\n";);
   601          process_args(n);

   616          SASSERT(m_util.is_bv2int(n));
   617:         TRACE("bv2int_bug", tout << "bv2int:\n" << mk_pp(n, m) << "\n";);
   618          sort * int_sort = n->get_sort();

   652          literal l(mk_eq(n, sum, false));
   653:         TRACE("bv", 
   654                tout << mk_pp(n, m) << "\n";

   708          
   709:         TRACE("bv", 
   710                tout << mk_pp(lhs, m) << " == \n";

   724              lhs = n_bits.get(i);
   725:             TRACE("bv", tout << mk_pp(lhs, m) << " == " << mk_pp(rhs, m) << "\n";);
   726              l = literal(mk_eq(lhs, rhs, false));

   796          init_bits(e, bits);                                                                     \
   797:         TRACE("bv_verbose", tout << arg_bits << " " << bits << " " << new_bits << "\n";); \
   798      }

   891          SASSERT(term->get_family_id() == get_family_id());
   892:         TRACE("bv", tout << "internalizing term: " << mk_bounded_pp(term, m) << "\n";);
   893          if (approximate_term(term)) {

   947          default:
   948:             TRACE("bv_op", tout << "unsupported operator: " << mk_ll_pp(term, m) << "\n";);
   949              UNREACHABLE();

  1091      bool theory_bv::internalize_atom(app * atom, bool gate_ctx) {
  1092:         TRACE("bv", tout << "internalizing atom: " << mk_bounded_pp(atom, m) << "\n";);
  1093          SASSERT(atom->get_family_id() == get_family_id());

  1125                  if (!m_approximates_large_bvs) {
  1126:                     TRACE("bv", tout << "found large size bit-vector:\n" << mk_pp(n, m) << "\n";);
  1127                      ctx.push_trail(value_trail<bool>(m_approximates_large_bvs));

  1145      void theory_bv::new_eq_eh(theory_var v1, theory_var v2) {
  1146:         TRACE("bv_eq", tout << "new_eq: " << mk_pp(get_enode(v1)->get_expr(), m) << " = " << mk_pp(get_enode(v2)->get_expr(), m) << "\n";);
  1147:         TRACE("bv", tout << "new_eq_eh v" << v1 << " = v" << v2 << " @ " << ctx.get_scope_level() << 
  1148                " relevant1: " << ctx.is_relevant(get_enode(v1)) << 

  1224          }
  1225:         TRACE("bv", 
  1226                tout << mk_pp(get_enode(v1)->get_expr(), m) << " = " << mk_pp(get_enode(v2)->get_expr(), m) << " " 

  1237          atom * a      = get_bv2a(v);
  1238:         TRACE("bv", tout << "assert: p" << v << " #" << ctx.bool_var2expr(v)->get_id() << " is_true: " << is_true << " " << ctx.inconsistent() << "\n";);
  1239          if (a->is_bit()) {

  1275              theory_var v2         = next(v);
  1276:             TRACE("bv", tout << "propagating v" << v << " #" << get_enode(v)->get_owner_id() << "[" << idx << "] = " << val << " " << ctx.get_scope_level() << "\n";);
  1277              literal antecedent = bit;

  1285                  lbool   val2             = ctx.get_assignment(bit2);
  1286:                 TRACE("bv_bit_prop", tout << "propagating #" << get_enode(v2)->get_owner_id() << "[" << idx << "] = " << val2 << "\n";);
  1287:                 TRACE("bv", tout << bit << " -> " << bit2 << " " << val << " -> " << val2 << " " << ctx.get_scope_level() << "\n";);
  1288  

  1300                      if (ctx.inconsistent()) {
  1301:                         TRACE("bv", tout << "inconsistent " << bit <<  " " << bit2 << "\n";);
  1302                          m_prop_queue.reset();

  1309          m_prop_queue.reset();
  1310:         TRACE("bv_bit_prop", tout << "done propagating\n";);
  1311      }

  1318          SASSERT(consequent.var() != antecedent.var());
  1319:         TRACE("bv_bit_prop", tout << "assigning: " << consequent << " @ " << ctx.get_scope_level();
  1320                tout << " using "; ctx.display_literal(tout, antecedent); 

  1364              while (curr) {
  1365:                 TRACE("assign_bit_bug", tout << "curr->m_var: v" << curr->m_var << ", curr->m_idx: " << curr->m_idx << ", v2: v" << v2 << ", idx: " << idx << "\n";
  1366                        tout << "find(curr->m_var): v" << find(curr->m_var) << ", find(v2): v" << find(v2) << "\n";

  1378      void theory_bv::relevant_eh(app * n) {
  1379:         TRACE("arith", tout << "relevant: #" << n->get_id() << " " << ctx.e_internalized(n) << ": " << mk_pp(n, m) << "\n";);
  1380:         TRACE("bv", tout << "relevant: #" << n->get_id() << " " << ctx.e_internalized(n) << ": " << mk_pp(n, m) << "\n";);
  1381          if (m.is_bool(n)) {

  1412                  literal_vector & bits        = m_bits[v];
  1413:                 TRACE("bv", tout << "mark bits relevant: " << bits.size() << ": " << bits << "\n";);
  1414                  SASSERT(!is_bv(v) || bits.size() == get_bv_size(v));

  1443          theory::pop_scope_eh(num_scopes);
  1444:         TRACE("bv_verbose", m_find.display(tout << ctx.get_scope_level() << " - " 
  1445                                     << num_scopes << " = " << (ctx.get_scope_level() - num_scopes) << "\n"););

  1502      void theory_bv::merge_eh(theory_var r1, theory_var r2, theory_var v1, theory_var v2) {
  1503:         TRACE("bv", tout << "merging: v" << v1 << " #" << get_enode(v1)->get_owner_id() << " v" << v2 << " #" << get_enode(v2)->get_owner_id() << "\n";);
  1504:         TRACE("bv_bit_prop", tout << "merging: #" << get_enode(v1)->get_owner_id() << " #" << get_enode(v2)->get_owner_id() << "\n";);
  1505          if (!merge_zero_one_bits(r1, r2)) {
  1506:             TRACE("bv", tout << "conflict detected\n";);
  1507              return; // conflict was detected

  1512          bool changed = true;
  1513:         TRACE("bv", tout << "bits size: " << sz << "\n";);
  1514          if (sz == 0 && !m_bv2int.empty()) {

  1567                  lbool val2    = ctx.get_assignment(bit2);
  1568:                 TRACE("bv", tout << "merge v" << v1 << " " << bit1 << ":= " << val1 << " " << bit2 << ":= " << val2 << "\n";);
  1569                  if (val1 == l_undef && !ctx.is_relevant(bit1))

  1576                  if (val1 != l_undef && val2 != l_undef) {
  1577:                     TRACE("bv", tout << "inconsistent "; display_var(tout, v1); display_var(tout, v2); tout << "idx: " << idx << "\n";);
  1578                  }

  1919                  lbool val2   = ctx.get_assignment(bit2);
  1920:                 CTRACE("bv_bug", val1 != val2, 
  1921                         tout << "equivalence class is inconsistent, i: " << i << "\n";

z3/src/smt/theory_char.cpp:
  309      bool theory_char::final_check() {   
  310:         TRACE("seq", tout << "final check " << get_num_vars() << "\n";);
  311          m_var2value.reset();

  320              if (seq.is_char(e) && m_var2value[v] == UINT_MAX && get_char_value(v, c)) {
  321:                 CTRACE("seq_verbose", seq.is_char(e), tout << mk_pp(e, m) << " root: " << get_enode(v)->is_root() << " is_value: " << get_char_value(v, c) << "\n";);
  322                  enode* r = get_enode(v)->get_root();

  360                  }
  361:                 TRACE("seq", tout << "fresh: " << mk_pp(e, m) << " := " << c << "\n";);
  362                  for (enode* n : *get_enode(v)) 

  372      void theory_char::enforce_bits() {
  373:         TRACE("seq", tout << "enforce bits\n";);
  374          for (unsigned v = get_num_vars(); v-- > 0; ) {

  381      void theory_char::enforce_value_bound(theory_var v) {
  382:         TRACE("seq", tout << "enforce bound " << v << "\n";);
  383          enode* n = ensure_enode(seq.mk_char(seq.max_char()));

  397              std::swap(v, w);
  398:         TRACE("seq", tout << "enforce ackerman " << v << " " << w << "\n";);
  399          literal eq = mk_literal(m.mk_eq(get_expr(v), get_expr(w)));

z3/src/smt/theory_datatype.cpp:
   111              ctx.internalize(rhs, false);
   112:             TRACE("datatype", tout << "adding axiom:\n" << pp(lhs, m) << "\n=\n" << mk_pp(rhs, m) << "\n";);
   113              if (antecedent == null_literal) {

   126                  justification * js = ctx.mk_justification(dt_eq_justification(get_id(), ctx, antecedent, lhs, _rhs));
   127:                 TRACE("datatype", tout << "assigning... #" << lhs->get_owner_id() << " #" << _rhs->get_owner_id() << "\n";
   128                        tout << "v" << lhs->get_th_var(get_id()) << " v" << _rhs->get_th_var(get_id()) << "\n";);
   129:                 TRACE("datatype_detail", display(tout););
   130                  ctx.assign_eq(lhs, _rhs, eq_justification(js));

   140          app* e = n->get_expr();
   141:         TRACE("datatype_bug", tout << "creating axiom (= n (c (acc_1 n) ... (acc_m n))) for\n" 
   142              << mk_pp(c, m) << " " << mk_pp(e, m) << "\n";);

   203          SASSERT(c->get_root() == r->get_arg(0)->get_root());
   204:         TRACE("recognizer_conflict",
   205                tout << mk_ismt2_pp(c->get_expr(), m) << "\n" << mk_ismt2_pp(r->get_expr(), m) << "\n";);

   291      bool theory_datatype::internalize_atom(app * atom, bool gate_ctx) {
   292:         TRACE("datatype", tout << "internalizing atom:\n" << mk_pp(atom, m) << "\n";);
   293          return internalize_term(atom);

   297          force_push();
   298:         TRACE("datatype", tout << "internalizing term:\n" << mk_pp(term, m) << "\n";);
   299          unsigned num_args = term->get_num_args();

   384          // If the theory variable is not created for 'a', then a wrong model will be generated.
   385:         TRACE("datatype", tout << "apply_sort_cnstr: #" << n->get_owner_id() << " " << pp(n, m) << "\n";);
   386:         TRACE("datatype_bug", 
   387                tout << "apply_sort_cnstr:\n" << pp(n, m) << " ";

   418              return;
   419:         TRACE("datatype", tout << "assigning recognizer: #" << n->get_owner_id() << " is_true: " << is_true << "\n" 
   420                << enode_pp(n, ctx) << "\n";);

   448          force_push();
   449:         TRACE("datatype", tout << "relevant_eh: " << mk_pp(n, m) << "\n";);
   450          SASSERT(ctx.relevancy());

   564      void theory_datatype::occurs_check_explain(enode * app, enode * root) {
   565:         TRACE("datatype", tout << "occurs_check_explain " << mk_bounded_pp(app->get_expr(), m) << " <-> " << mk_bounded_pp(root->get_expr(), m) << "\n";);
   566  

   583  
   584:         TRACE("datatype",
   585                tout << "occurs_check\n";

   702      bool theory_datatype::occurs_check(enode * n) {
   703:         TRACE("datatype_verbose", tout << "occurs check: " << enode_pp(n, ctx) << "\n";);
   704          m_stats.m_occurs_check++;

   717  
   718:             TRACE("datatype_verbose", tout << "occurs check loop: " << enode_pp(app, ctx) << (op==ENTER?" enter":" exit")<< "\n";);
   719  

   841              result->add_dependency(arg);
   842:         TRACE("datatype", 
   843                tout << pp(n, m) << "\n";

   852          // v1 is the new root
   853:         TRACE("datatype", tout << "merging v" << v1 << " v" << v2 << "\n";);
   854          SASSERT(v1 == static_cast<int>(m_find.find(v1)));

   898              lbool val = ctx.get_assignment(recognizer);
   899:             TRACE("datatype", tout << "adding recognizer to v" << v << " rec: #" << recognizer->get_owner_id() << " val: " << val << "\n";);
   900              if (val == l_true) {

   940          }
   941:         CTRACE("datatype", d->m_recognizers.empty(), ctx.display(tout););
   942          SASSERT(!d->m_recognizers.empty());

   966          }
   967:         TRACE("datatype", tout << "propagate " << num_unassigned << " eqs: " << eqs.size() << "\n";);
   968          if (num_unassigned == 0) {

   970              SASSERT(!lits.empty());
   971:             TRACE("datatype_conflict", tout << mk_ismt2_pp(recognizer->get_expr(), m) << "\n";
   972                    for (literal l : lits) 

  1021  
  1022:         TRACE("datatype_bug", tout << "non_rec_c: " << non_rec_c->get_name() << " #rec: " << d->m_recognizers.size() << "\n";);
  1023  

  1065          app_ref r_app(m.mk_app(r, n->get_expr()), m);
  1066:         TRACE("datatype", tout << "creating split: " << mk_pp(r_app, m) << "\n";);
  1067          ctx.internalize(r_app, false);

z3/src/smt/theory_dense_diff_logic_def.h:
   125          if (!m_non_diff_logic_exprs) {
   126:             TRACE("non_diff_logic", tout << "found non diff logic expression:\n" << mk_pp(n, m) << "\n";);
   127              ctx.push_trail(value_trail<bool>(m_non_diff_logic_exprs));

   138          }
   139:         TRACE("ddl", tout << "internalizing atom:\n" << mk_pp(n, m) << "\n";);
   140          SASSERT(!ctx.b_internalized(n));

   169          else {
   170:             TRACE("ddl", tout << "failed to internalize:\n" << mk_pp(n, m) << "\n";);
   171              found_non_diff_logic_expr(n);

   173          }
   174:         TRACE("arith", tout << expr_ref(lhs, m) << " " << expr_ref(s, m) << " " << expr_ref(t, m) << "\n";);
   175          source = internalize_term_core(s);

   177          if (source == null_theory_var || target == null_theory_var) {
   178:             TRACE("ddl", tout << "failed to internalize:\n" << mk_pp(n, m) << "\n";);
   179              found_non_diff_logic_expr(n);

   194          m_matrix[target][source].m_occs.push_back(a);
   195:         TRACE("ddl", tout << "succeeded internalizing:\n" << mk_pp(n, m) << "\n";);
   196          return true;

   214          }
   215:         TRACE("ddl", tout << "internalizing term: " << mk_pp(term, m) << "\n";);
   216          theory_var v = internalize_term_core(term);
   217:         TRACE("ddl", tout << mk_pp(term, m) << "\ninternalization result: " << (v != null_theory_var) << "\n";);
   218          if (v == null_theory_var)

   224      void theory_dense_diff_logic<Ext>::internalize_eq_eh(app * atom, bool_var v) {
   225:         TRACE("ddl", tout << "eq-eh: " << mk_pp(atom, m) << "\n";);
   226          if (memory::above_high_watermark())

   257          if (ctx.has_th_justification(v, get_id())) {
   258:             TRACE("ddl", tout << "ignoring atom propagated by the theory.\n";);
   259              return;

   270          numeral  k   = a->get_offset();
   271:         TRACE("assign_profile", tout << "#" << get_enode(s)->get_owner_id() << " #" << get_enode(t)->get_owner_id() << " " << k << "\n";);
   272          if (l.sign()) {

   279          }
   280:         TRACE("ddl_detail", display(tout););
   281      }

   347              atom * a                      = *it;
   348:             TRACE("del_atoms", tout << "deleting: p" << a->get_bool_var() << "\n";);
   349              m_bv2atoms[a->get_bool_var()] = 0;

   351              theory_var t = a->get_target();
   352:             TRACE("del_atoms", tout << "m_matrix.size() " << m_matrix.size() << 
   353                    ", m_matrix[s].size() " << m_matrix[s].size() <<

   437      void theory_dense_diff_logic<Ext>::get_antecedents(theory_var source, theory_var target, literal_vector & result) {
   438:         TRACE("ddl", tout << "get_antecedents, source: #" << get_enode(source)->get_owner_id() << ", target: #" << get_enode(target)->get_owner_id() << "\n";);
   439:         CTRACE("ddl", !is_connected(source, target), display(tout););
   440          SASSERT(is_connected(source, target));

   490                  cell & s_x  = m_matrix[s][x];
   491:                 TRACE("ddl", 
   492                        tout << "s: #" << get_enode(s)->get_owner_id() << " x: #" << get_enode(x)->get_owner_id() << " new_dist: " << new_dist << "\n";

   559                          m_stats.m_num_propagations++;
   560:                         TRACE("ddl", tout << "asserting atom to true: "; display_atom(tout, a);
   561                                tout << "distance(#" << get_enode(source)->get_owner_id() << ", #" << get_enode(target)->get_owner_id()

   570                          m_stats.m_num_propagations++;
   571:                         TRACE("ddl", tout << "asserting atom to true: "; display_atom(tout, a);
   572                                tout << "distance(#" << get_enode(source)->get_owner_id() << ", #" << get_enode(target)->get_owner_id()

   582      inline void theory_dense_diff_logic<Ext>::add_edge(theory_var source, theory_var target, numeral const & offset, literal l) {
   583:         TRACE("ddl", tout << "trying adding edge: #" << get_enode(source)->get_owner_id() << " -- " << offset << " --> #" << get_enode(target)->get_owner_id() << "\n";);
   584          cell & c_inv = m_matrix[target][source];

   586              // conflict detected.
   587:             TRACE("ddl", tout << "conflict detected: #" << get_enode(source)->get_owner_id() << " #" << get_enode(target)->get_owner_id() <<
   588                    " offset: " << offset << ", c_inv.m_edge_id: " << c_inv.m_edge_id << ", c_inv.m_distance: " << c_inv.m_distance << "\n";);

   600          if (c.m_edge_id == null_edge_id || offset < c.m_distance) {
   601:             TRACE("ddl", tout << "adding edge: #" << get_enode(source)->get_owner_id() << " -- " << offset << " --> #" << get_enode(target)->get_owner_id() << "\n";);
   602              m_edges.push_back(edge(source, target, offset, l));

   638                      if (c.m_distance != k) {
   639:                         CTRACE("ddl", c.m_distance != k, tout << "i: " << i << " j: " << j << " k: " << k << " c.m_distance: " << c.m_distance << "\n";
   640                                display(tout););

   720              m_assignment[i].neg();
   721:         TRACE("ddl_model", 
   722                tout << "ddl model\n";

   764          m_epsilon = rational(1, 2);
   765:         TRACE("ddl", display(tout););
   766          typename edges::const_iterator it  = m_edges.begin();

   779              rational k_c = e.m_offset.get_infinitesimal().to_rational();
   780:             TRACE("ddl",
   781                    tout << e.m_source << " - " << e.m_target << " <= " << e.m_offset << "\n";

   787                  if (new_epsilon < m_epsilon) {
   788:                     TRACE("ddl", tout << "new epsilon: " << new_epsilon << "\n";);
   789                      m_epsilon = new_epsilon;

   812          }
   813:         TRACE("ddl_model", 
   814                tout << "ddl model\n";

   983          
   984:         TRACE("opt", S.display(tout); display(tout););
   985          

   991          }
   992:         TRACE("opt", S.display(tout); );    
   993          SASSERT(is_sat != l_false);

  1001              inf_rational r(-rational(val.first), -rational(val.second));
  1002:             TRACE("opt", tout << r << " " << "\n"; 
  1003                    S.display_row(tout, row, true););

  1017                  }
  1018:                 TRACE("opt", tout << core << "\n";);
  1019              }

  1033          default:
  1034:             TRACE("opt", tout << "unbounded\n"; );        
  1035              blocker = m.mk_false();

  1041      theory_var theory_dense_diff_logic<Ext>::add_objective(app* term) {
  1042:         TRACE("opt", tout << mk_pp(term, m) << "\n";);
  1043          objective_term objective;

  1075          expr_ref e(m), f(m), f2(m);
  1076:         TRACE("opt", tout << "mk_ineq " << v << " " << val << "\n";);
  1077          if (t.size() == 1 && t[0].second.is_one()) {

  1099              }
  1100:             TRACE("arith", tout << "block: " << f << "\n";);
  1101              return f;

z3/src/smt/theory_diff_logic_def.h:
    92      bool result = null_theory_var != mk_term(term);
    93:     CTRACE("arith", !result, tout << "Did not internalize " << mk_pp(term, m) << "\n";);
    94      if (!result) {
    95:         TRACE("non_diff_logic", tout << "Terms may not be internalized\n";);
    96          found_non_diff_logic_expr(term);

   171      if (!m_non_diff_logic_exprs) {
   172:         TRACE("non_diff_logic", tout << "found non diff logic expression:\n" << mk_pp(n, m) << "\n";);
   173          IF_VERBOSE(0, verbose_stream() << "(smt.diff_logic: non-diff logic expression " << mk_pp(n, m) << ")\n";); 

   279  
   280:     TRACE("arith", 
   281            tout << mk_pp(n, m) << "\n";

   290  void theory_diff_logic<Ext>::internalize_eq_eh(app * atom, bool_var v) {
   291:     TRACE("arith", tout << mk_pp(atom, m) << "\n";);
   292      app * lhs      = to_app(atom->get_arg(0));

   337  void theory_diff_logic<Ext>::push_scope_eh() {
   338:     TRACE("arith", tout << "push\n";);
   339      theory::push_scope_eh();

   349  void theory_diff_logic<Ext>::pop_scope_eh(unsigned num_scopes) {
   350:     TRACE("arith", tout << "pop " << num_scopes << "\n";);
   351      unsigned lvl     = m_scopes.size();

   360      m_graph.pop(num_scopes);
   361:     CTRACE("arith", !m_graph.is_feasible_dbg(), m_graph.display(tout););
   362      if (num_edges != m_graph.get_num_edges() && m_num_simplex_edges > 0) {

   377  
   378:     TRACE("arith_final", display(tout); );
   379      if (!is_consistent())

   390              !is_uninterp_const(n->get_expr())) {
   391:             TRACE("arith", tout << mk_pp(n->get_expr(), m) << "\n";);
   392              return FC_GIVEUP;

   520                  m_num_propagation_calls = 1;
   521:                 TRACE("arith_prop", tout << "propagating: " << m_num_propagation_calls << "\n";);
   522                  propagate_core();            

   524              else {
   525:                 TRACE("arith_prop", tout << "skipping propagation " << m_num_propagation_calls << "\n";);
   526              }

   538              bool do_propagate = (m_num_propagation_calls * m_agility > m_params.m_arith_adaptive_propagation_threshold);
   539:             TRACE("arith_prop", tout << (do_propagate?"propagating: ":"skipping ") 
   540                    << " " << m_num_propagation_calls 

   580  bool theory_diff_logic<Ext>::propagate_atom(atom* a) {
   581:     TRACE("arith", a->display(*this, tout); tout << "\n";);
   582      if (ctx.inconsistent()) {

   586      if (!m_graph.enable_edge(edge_id)) {
   587:         TRACE("arith", display(tout););
   588          set_neg_cycle_conflict();

   601  
   602:     TRACE("dl_activity", tout << "\n";);
   603  

   650  
   651:     TRACE("dl_activity", 
   652            tout << mk_pp(le, m) << "\n";

   669  #if 0
   670:     TRACE("arith",
   671            tout << "shortcut:\n";

   700      literal_vector const& lits = m_nc_functor.get_lits();
   701:     TRACE("arith_conflict", 
   702            tout << "conflict: ";

   748  
   749:     TRACE("arith", tout << mk_pp(n, m) << "\n";);
   750  

   811      theory_var v = theory::mk_var(n);
   812:     TRACE("diff_logic_vars", tout << "mk_var: " << v << "\n";);
   813      m_graph.init_var(v);

   851      if (is_interpreted(n)) {
   852:         TRACE("non_diff_logic", tout << "Variable should not be interpreted\n";);
   853          found_non_diff_logic_expr(n);
   854      }
   855:     TRACE("arith", tout << mk_pp(n, m) << " |-> " << v << "\n";);
   856      return v;

   904          rational k_c = w.get_infinitesimal().to_rational();
   905:         TRACE("arith", tout << "(n_x,k_x): " << n_x << ", " << k_x << ", (n_y,k_y): " 
   906                << n_y << ", " << k_y << ", (n_c,k_c): " << n_c << ", " << k_c << "\n";);

   909              if (new_delta < m_delta) {
   910:                 TRACE("arith", tout << "new delta: " << new_delta << "\n";);
   911                  m_delta = new_delta;

   935      }
   936:     TRACE("arith", tout << mk_pp(n->get_expr(), m) << " |-> " << num << "\n";);
   937      bool is_int = m_util.is_int(n->get_expr());

  1038          
  1039:         TRACE("diff_logic", 
  1040                tout << v1 << " .. " << v2 << "\n";

  1235  
  1236:     CTRACE("arith",!m_graph.is_feasible_dbg(), m_graph.display(tout););
  1237      SASSERT(m_graph.is_feasible_dbg());

  1240  
  1241:     TRACE("arith",
  1242            objective_term const& objective = m_objectives[v];

  1249  
  1250:     TRACE("opt", 
  1251            S.display(tout); 

  1262      }
  1263:     TRACE("opt", S.display(tout); );    
  1264      SASSERT(is_sat != l_false);

  1287          ensure_rational_solution(S);
  1288:         TRACE("opt", tout << r << " " << "\n"; 
  1289                S.display_row(tout, row, true);

  1299          }
  1300:         CTRACE("arith",!m_graph.is_feasible_dbg(), m_graph.display(tout););
  1301          SASSERT(m_graph.is_feasible_dbg());

  1306      default:
  1307:         TRACE("opt", tout << "unbounded\n"; );        
  1308          blocker = m.mk_false();

  1447      if (m_izero != null_theory_var) return;
  1448:     TRACE("arith", tout << "init zero\n";);
  1449      app* zero;

z3/src/smt/theory_dl.cpp:
   98                  }
   99:                 TRACE("theory_dl", tout << mk_pp(result, m_th.m()) << "\n";);
  100                  return result;

  116          bool internalize_atom(app * atom, bool gate_ctx) override {
  117:             TRACE("theory_dl", tout << mk_pp(atom, m()) << "\n";);
  118              if (ctx.b_internalized(atom)) {

  138          bool internalize_term(app * term) override {
  139:             TRACE("theory_dl", tout << mk_pp(term, m()) << "\n";);
  140              if (u().is_finite_sort(term)) {

  231              }
  232:             TRACE("theory_dl", tout << mk_pp(n, m()) << "\n";);
  233              theory_var var = mk_var(e);

  274          void assert_cnstr(expr* e) {
  275:             TRACE("theory_dl", tout << mk_pp(e, m()) << "\n";);
  276              if (m().has_trace_stream()) log_axiom_instantiation(e);

z3/src/smt/theory_fpa.cpp:
   63      app * theory_fpa::fpa_value_proc::mk_value(model_generator & mg, expr_ref_vector const & values) {
   64:         TRACE("t_fpa_detail",
   65                ast_manager & m = m_th.get_manager();

  128  
  129:         TRACE("t_fpa", tout << "result: [" <<
  130                         mpzm.to_string(sgn_z) << "," <<

  140  
  141:         TRACE("t_fpa_detail",
  142                ast_manager & m = m_th.get_manager();

  162  
  163:         TRACE("t_fpa", tout << "result: " << mk_ismt2_pp(result, m_th.get_manager()) << std::endl;);
  164  

  172          expr * ccnv;
  173:         TRACE("t_fpa", tout << "converting " << mk_ismt2_pp(e, m) << std::endl;);
  174  

  176              res = ccnv;
  177:             TRACE("t_fpa_detail", tout << "cached:" << std::endl;
  178              tout << mk_ismt2_pp(e, m) << std::endl << " -> " << std::endl <<

  183  
  184:             TRACE("t_fpa_detail", tout << "converted; caching:" << std::endl;
  185                                    tout << mk_ismt2_pp(e, m) << std::endl << " -> " << std::endl <<

  212  
  213:         CTRACE("t_fpa", !m.is_true(res), tout << "side condition: " << mk_ismt2_pp(res, m) << std::endl;);
  214          return res;

  219          if (m.is_true(e)) return;
  220:         TRACE("t_fpa_detail", tout << "asserting " << mk_ismt2_pp(e, m) << "\n";);
  221          if (m.has_trace_stream()) log_axiom_instantiation(e);

  231          ctx.attach_th_var(n, this, v);
  232:         TRACE("t_fpa", tout << "new theory var: " << mk_ismt2_pp(n->get_expr(), m) << " := " << v << "\n";);
  233      }

  235      bool theory_fpa::internalize_atom(app * atom, bool gate_ctx) {
  236:         TRACE("t_fpa_internalize", tout << "internalizing atom: " << mk_ismt2_pp(atom, m) << std::endl;);
  237          SASSERT(atom->get_family_id() == get_family_id());

  256      bool theory_fpa::internalize_term(app * term) {
  257:         TRACE("t_fpa_internalize", tout << "internalizing term: " << mk_ismt2_pp(term, m) << "\n";);
  258          SASSERT(term->get_family_id() == get_family_id());

  296      void theory_fpa::apply_sort_cnstr(enode * n, sort * s) {
  297:         TRACE("t_fpa", tout << "apply sort cnstr for: " << mk_ismt2_pp(n->get_expr(), m) << "\n";);
  298          SASSERT(s->get_family_id() == get_family_id());

  327  
  328:         TRACE("t_fpa", tout << "new eq: " << x << " = " << y << std::endl;
  329                         tout << mk_ismt2_pp(e_x->get_expr(), m) << std::endl << " = " << std::endl <<

  342  
  343:         TRACE("t_fpa_detail", tout << "xc = " << mk_ismt2_pp(xc, m) << std::endl <<
  344                                        "yc = " << mk_ismt2_pp(yc, m) << std::endl;);

  366  
  367:         TRACE("t_fpa", tout << "new diseq: " << x << " != " << y << std::endl;
  368                         tout << mk_ismt2_pp(e_x->get_expr(), m) << std::endl << " != " << std::endl <<

  415          m_trail_stack.pop_scope(num_scopes);
  416:         TRACE("t_fpa", tout << "pop " << num_scopes << "; now " << m_trail_stack.get_num_scopes() << "\n";);
  417          theory::pop_scope_eh(num_scopes);

  422  
  423:         TRACE("t_fpa", tout << "assign_eh for: " << v << " (" << is_true << "):\n" << mk_ismt2_pp(e, m) << "\n";);
  424  

  434      void theory_fpa::relevant_eh(app * n) {
  435:         TRACE("t_fpa", tout << "relevant_eh for: " << mk_ismt2_pp(n, m) << "\n";);
  436  

  467                      wu = m.mk_eq(m_converter.unwrap(wrapped, n->get_sort()), n);
  468:                     TRACE("t_fpa", tout << "w/u eq: " << std::endl << mk_ismt2_pp(wu, m) << std::endl;);
  469                      assert_cnstr(wu);

  488      void theory_fpa::reset_eh() {
  489:         TRACE("t_fpa", tout << "reset_eh\n";);
  490          pop_scope_eh(m_trail_stack.get_num_scopes());

  504      final_check_status theory_fpa::final_check_eh() {
  505:         TRACE("t_fpa", tout << "final_check_eh\n";);
  506          SASSERT(m_converter.m_extra_assertions.empty());

  510      void theory_fpa::init_model(model_generator & mg) {
  511:         TRACE("t_fpa", tout << "initializing model" << std::endl; display(tout););
  512          m_factory = alloc(fpa_value_factory, m, get_family_id());

  539      model_value_proc * theory_fpa::mk_value(enode * n, model_generator & mg) {
  540:         TRACE("t_fpa", tout << "mk_value for: " << mk_ismt2_pp(n->get_expr(), m) <<
  541                              " (sort " << mk_ismt2_pp(n->get_expr()->get_sort(), m) << ")\n";);

  559  
  560:         CTRACE("t_fpa_detail", !ctx.e_internalized(wrapped),
  561                  tout << "Model dependency not internalized: " <<

  577              vp->add_dependency(ctx.get_enode(a2));
  578:             TRACE("t_fpa_detail", tout << "Depends on: " <<
  579                    mk_ismt2_pp(a0, m) << " eq. cls. #" << get_enode(a0)->get_root()->get_expr()->get_id() << std::endl <<

  589              vp->add_dependency(ctx.get_enode(a0));
  590:             TRACE("t_fpa_detail", tout << "Depends on: " <<
  591                  mk_ismt2_pp(a0, m) << " eq. cls. #" << get_enode(a0)->get_root()->get_expr()->get_id() << std::endl;);

  605                  vp->add_dependency(en);
  606:                 TRACE("t_fpa_detail", tout << "Depends on: " << mk_ismt2_pp(wrapped, m) << " eq. cls. #" << en->get_root()->get_expr()->get_id() << std::endl;);
  607                  res = vp;

z3/src/smt/theory_lra.cpp:
   258          add_def_constraint_and_equality(var, lp::LE, rational(c));
   259:         TRACE("arith", tout << "add " << cnst << ", var = " << var << "\n";);
   260          return var;

   300          ctx().push_trail(push_back_vector<ptr_vector<expr>>(m_not_handled));
   301:         TRACE("arith", tout << "unsupported " << mk_pp(n, m) << "\n");
   302          m_not_handled.push_back(n);

   306          if (a.is_underspecified(n)) {
   307:             TRACE("arith", tout << "Unhandled: " << mk_pp(n, m) << "\n";);
   308              ctx().push_trail(push_back_vector<ptr_vector<app>>(m_underspecified));

   536              }
   537:             TRACE("arith", tout << "v" << v << " := " << mk_pp(t, m) << "\n" << vars << "\n";);
   538              m_solver->register_existing_terms();

   545      enode * mk_enode(app * n) {
   546:         TRACE("arith", tout << expr_ref(n, m) << " internalized: " << ctx().e_internalized(n) << "\n";);
   547          if (reflect(n))

   565      void mk_clause(literal l1, literal l2, unsigned num_params, parameter * params) {
   566:         TRACE("arith", literal lits[2]; lits[0] = l1; lits[1] = l2; ctx().display_literals_verbose(tout, 2, lits); tout << "\n";);
   567          ctx().mk_th_axiom(get_id(), l1, l2, num_params, params);

   570      void mk_clause(literal l1, literal l2, literal l3, unsigned num_params, parameter * params) {
   571:         TRACE("arith", literal lits[3]; lits[0] = l1; lits[1] = l2; lits[2] = l3; ctx().display_literals_smt2(tout, 3, lits); tout << "\n";);
   572          ctx().mk_th_axiom(get_id(), l1, l2, l3, num_params, params);

   728          }
   729:         TRACE("arith", 
   730                {

   749      void updt_unassigned_bounds(theory_var v, int inc) {
   750:         TRACE("arith", tout << "v" << v << " " << m_unassigned_bounds[v] << " += " << inc << "\n";);
   751          ctx().push_trail(vector_value_trail<unsigned, false>(m_unassigned_bounds, v));

   767      theory_var internalize_def(app* term, scoped_internalize_state& st) {
   768:         TRACE("arith", tout << expr_ref(term, m) << "\n";);
   769          if (ctx().e_internalized(term)) {

   803          theory_var v = mk_var(term);
   804:         TRACE("arith", tout << mk_bounded_pp(term, m) << " v" << v << "\n";);
   805  

   836                      SASSERT(lp::tv::is_term(vi));
   837:                     TRACE("arith_verbose", 
   838                            tout << "v" << v << " := " << mk_pp(term, m) 

   917      bool internalize_atom(app * atom, bool gate_ctx) {
   918:         TRACE("arith", tout << mk_pp(atom, m) << "\n";);
   919          SASSERT(!ctx().b_internalized(atom));

   947          else {
   948:             TRACE("arith", tout << "Could not internalize " << mk_pp(atom, m) << "\n";);
   949              found_unsupported(atom);

   960          m_bool_var2bound.insert(bv, b);
   961:         TRACE("arith_verbose", tout << "Internalized " << bv << ": " << mk_pp(atom, m) << "\n";);
   962          mk_bound_axioms(*b);

   985          enode * n2 = get_enode(rhs);
   986:         TRACE("arith_verbose", tout << mk_pp(atom, m) << " " << is_arith(n1) << " " << is_arith(n2) << "\n";);
   987          if (is_arith(n1) && is_arith(n2) && n1 != n2) 

   991      void assign_eh(bool_var v, bool is_true) {
   992:         TRACE("arith", tout << mk_pp(ctx().bool_var2expr(v), m) << " " << (literal(v, !is_true)) << "\n";);
   993          m_asserted_atoms.push_back(delayed_atom(v, is_true));

  1019      void new_eq_eh(theory_var v1, theory_var v2) {
  1020:         TRACE("arith", tout << "eq " << v1 << " == " << v2 << "\n";);
  1021          if (!is_int(v1) && !is_real(v1)) 

  1030      void new_diseq_eh(theory_var v1, theory_var v2) {
  1031:         TRACE("arith", tout << "v" << v1 << " != " << "v" << v2 << "\n";);
  1032          ++m_stats.m_assert_diseq;

  1036      void apply_sort_cnstr(enode* n, sort*) {
  1037:         TRACE("arith", tout << "sort constraint: " << pp(n, m) << "\n";);
  1038  #if 0

  1045      void push_scope_eh() {
  1046:         TRACE("arith", tout << "push\n";);
  1047          m_scopes.push_back(scope());

  1059      void pop_scope_eh(unsigned num_scopes) {
  1060:         TRACE("arith", tout << "pop " << num_scopes << "\n";);
  1061          if (num_scopes == 0) {

  1075              m_nla->pop(num_scopes);
  1076:         TRACE("arith", tout << "num scopes: " << num_scopes << " new scope level: " << m_scopes.size() << "\n";);
  1077      }

  1194          SASSERT(!is_infeasible());
  1195:         TRACE("arith", tout << term << "\n" << lp().constraints(););
  1196      }

  1201          }
  1202:         TRACE("arith", tout << expr_ref(p, m) << " " << expr_ref(q, m) << "\n";);
  1203          // if q is zero, then idiv and mod are uninterpreted functions.

  1285                  mk_axiom(eqz, mk_literal(div_ge));
  1286:                 TRACE("arith", tout << eqz << " " << div_ge << "\n");
  1287              }

  1389          expr_ref pinned(e, m);
  1390:         TRACE("mk_bool_var", tout << pinned << " " << pinned->get_id() << "\n";);
  1391          if (!ctx().e_internalized(e)) {

  1434              m_model_is_initialized = lp().init_model();
  1435:             TRACE("arith", display(tout << "update variable values " << m_model_is_initialized << "\n"););            
  1436          }

  1472          }
  1473:         TRACE("arith", 
  1474                for (theory_var v = 0; v < sz; ++v) {

  1485      bool assume_eqs() {        
  1486:         TRACE("arith", display(tout););
  1487          random_update();

  1502              theory_var other = m_model_eqs.insert_if_not_there(v);
  1503:             TRACE("arith", tout << "insert: v" << v << " := " << get_value(v) << " found: v" << other << "\n";);
  1504              if (other == v) {

  1508              if (n1->get_root() != n2->get_root()) {
  1509:                 TRACE("arith", tout << pp(n1, m) << " = " << pp(n2, m) << "\n";
  1510                        tout << pp(n1, m) << " = " << pp(n2, m) << "\n";

  1533              m_assume_eq_head++;
  1534:             CTRACE("arith", 
  1535                     is_eq(v1, v2) && n1->get_root() != n2->get_root(),

  1567          case l_true:
  1568:             TRACE("arith", display(tout));
  1569  

  1575              case l_undef:
  1576:                 TRACE("arith", tout << "check-lia giveup\n";);
  1577                  if (ctx().get_fparams().m_arith_ignore_int)

  1588              case l_undef:
  1589:                 TRACE("arith", tout << "check-nra giveup\n";);
  1590                  st = FC_GIVEUP;

  1603                  (void) e; // just in case TRACE() is a no-op
  1604:                 TRACE("arith", tout << "unhandled operator " << mk_pp(e, m) << "\n";);        
  1605                  st = FC_GIVEUP;

  1611          case l_undef:
  1612:             TRACE("arith", tout << "check feasible is undef\n";);
  1613              return m.inc() ? FC_CONTINUE : FC_GIVEUP;

  1617          }
  1618:         TRACE("arith", tout << "default giveup\n";);
  1619          return FC_GIVEUP;

  1673                  if (lower_bound) {
  1674:                     TRACE("arith", tout << "lower: " << offset << " / " << g << " = " << offset / g << " >= " << ceil(offset / g) << "\n";);
  1675                      offset = ceil(offset / g);

  1677                  else {
  1678:                     TRACE("arith", tout << "upper: " << offset << " / " << g << " = " << offset / g << " <= " << floor(offset / g) << "\n";);
  1679                      offset = floor(offset / g);

  1688  
  1689:         // CTRACE("arith", is_int,
  1690          //        lp().print_term(term, tout << "term: ") << "\n";

  1701  
  1702:         TRACE("arith", tout << t << ": " << atom << "\n";
  1703                lp().print_term(term, tout << "bound atom: ") << (lower_bound?" >= ":" <= ") << k << "\n";);

  1752                  if (!a.is_bounded(n)) {
  1753:                     TRACE("arith", tout << "unbounded " << expr_ref(n, m) << "\n";);
  1754                      continue;

  1761              
  1762:                 TRACE("arith", tout << get_value(v) << " != " << r1 << " div " << r2 << "\n";);
  1763                  rational div_r = div(r1.x, r2);

  1794  
  1795:                 TRACE("arith",
  1796                        tout << r1 << " div " << r2 << "\n";

  1898      lbool check_lia() {
  1899:         TRACE("arith",);
  1900          if (!m.inc()) {
  1901:             TRACE("arith", tout << "canceled\n";);
  1902              return l_undef;

  1914          case lp::lia_move::branch: {
  1915:             TRACE("arith", tout << "branch\n";);
  1916              app_ref b(m);

  1940                  return l_undef;
  1941:             TRACE("arith", tout << "cut\n";);
  1942              ++m_stats.m_gomory_cuts;

  1955              IF_VERBOSE(4, verbose_stream() << "cut " << b << "\n");
  1956:             TRACE("arith", dump_cut_lemma(tout, m_lia->get_term(), m_lia->get_offset(), m_explanation, m_lia->is_upper()););
  1957              literal lit(ctx().get_bool_var(b), false);
  1958:             TRACE("arith", 
  1959                    ctx().display_lemma_as_smt_problem(tout << "new cut:\n", m_core.size(), m_core.data(), m_eqs.size(), m_eqs.data(), lit);

  1965          case lp::lia_move::conflict:
  1966:             TRACE("arith", tout << "conflict\n";);
  1967              // ex contains unsat core

  1970          case lp::lia_move::undef:
  1971:             TRACE("arith", tout << "lia undef\n";);
  1972              lia_check = l_undef;

  2002              }
  2003:             TRACE("arith", tout << "is_lower: " << is_lower << " pos " << pos << "\n";);
  2004              app_ref atom(m);

  2042          if (!m.inc()) {
  2043:             TRACE("arith", tout << "canceled\n";);
  2044              return l_undef;

  2046          if (!m_nla) {
  2047:             TRACE("arith", tout << "no nla\n";);
  2048              return l_true;

  2072          unsigned usz   = m_underspecified.size();
  2073:         TRACE("shared", tout << ctx().get_scope_level() << " " <<  v << " " << r->get_num_parents() << "\n";);
  2074          if (r->get_num_parents() > 2*usz) {

  2129              api_bound* b = nullptr;
  2130:             TRACE("arith", tout << "propagate: " << literal(bv, !is_true) << "\n";
  2131                    if (!m_bool_var2bound.contains(bv)) tout << "not found\n");

  2146          case l_false:
  2147:             TRACE("arith", tout << "propagation conflict\n";);
  2148              get_infeasibility_explanation_and_set_conflict();

  2219  
  2220:         TRACE("arith", tout << "v" << v << " " << be.kind() << " " << be.m_bound << "\n";);
  2221  

  2224          if (m_unassigned_bounds[v] == 0 && !should_refine_bounds()) {
  2225:             TRACE("arith", tout << "return\n";);
  2226              return;

  2238              }
  2239:             TRACE("arith", tout << lit << " bound: " << *b << " first: " << first << "\n";);
  2240  

  2247              }
  2248:             CTRACE("arith", m_unassigned_bounds[v] == 0, tout << "missed bound\n";);
  2249              updt_unassigned_bounds(v, -1);
  2250:             TRACE("arith",
  2251                    ctx().display_literals_verbose(tout, m_core);

  2314  
  2315:         TRACE("arith", tout << "add-eq " << mk_pp(n1->get_expr(), m) << " == " << mk_pp(n2->get_expr(), m) << " " << n1->get_expr_id() << " == " << n2->get_expr_id() << "\n";);
  2316          if (n1->get_root() == n2->get_root())

  2502          
  2503:         CTRACE("arith", !m_new_bounds.empty(), tout << "flush bound axioms\n";);
  2504  

  2517              }            
  2518:             CTRACE("arith", atoms.size() > 1, 
  2519                     for (auto* a : atoms) a->display(tout) << "\n";);

  2653          bool find_glb = (is_true == (k == lp_api::lower_t));
  2654:         TRACE("arith_verbose", tout << "v" << v << " find_glb: " << find_glb << " is_true: " << is_true << " k: " << k << " is_lower: " << (k == lp_api::lower_t) << "\n";);
  2655          if (find_glb) {

  2692          m_core.push_back(lit1);
  2693:         TRACE("arith", 
  2694                ctx().display_literals_verbose(tout, m_core);

  2762          theory_var v = b.get_var();
  2763:         TRACE("arith", tout << mk_pp(get_owner(v), m) << "\n";);
  2764          if (static_cast<unsigned>(v) >= m_use_list.size()) {

  2768              if (ctx().get_assignment(vb->get_lit()) != l_undef) {
  2769:                 TRACE("arith_verbose", display_bound(tout << "assigned ", *vb) << "\n";);
  2770                  continue;

  2795              if (lit != null_literal) {
  2796:                 TRACE("arith",
  2797                        ctx().display_literals_verbose(tout, m_core);

  2804              else {
  2805:                 TRACE("arith_verbose", display_bound(tout << "skip ", *vb) << "\n";);
  2806              }

  2856          }
  2857:         TRACE("arith_verbose", tout << (is_lub?"lub":"glb") << " is " << r << "\n";);
  2858          return true;

  2872      void assert_bound(bool_var bv, bool is_true, api_bound& b) {
  2873:         TRACE("arith", tout << b << "\n";);
  2874          lp::constraint_index ci = b.get_constraint(is_true);

  2966              if (b.first == UINT_MAX || (is_lower? b.second < v : b.second > v)) {
  2967:                 TRACE("arith", tout << "tighter bound " << tv.to_string() << "\n";);
  2968                  m_history.push_back(vec[ti]);

  2975          else {
  2976:             TRACE("arith", tout << "not a term " << tv.to_string() << "\n";);
  2977              // m_solver already tracks bounds on proper variables, but not on terms.

  3008              rational val;
  3009:             TRACE("arith", tout << lp().get_variable_name(vi) << " " << v << "\n";);
  3010              if (v != null_theory_var && a.is_numeral(get_owner(v), val) && bound == val) {

  3048          theory_var v2 = lp().local_to_external(vi2);
  3049:         TRACE("arith", tout << "fixed: " << mk_pp(get_owner(v1), m) << " " << mk_pp(get_owner(v2), m) << "\n";);
  3050          // we expect lp() to ensure that none of these returns happen.

  3080          
  3081:         TRACE("arith",
  3082                for (auto c : m_core) 

  3119      lbool make_feasible() {
  3120:         TRACE("pcs",  tout << lp().constraints(););
  3121          auto status = lp().find_feasible_solution();
  3122:         TRACE("arith_verbose", display(tout););
  3123          if (lp().is_feasible())

  3126              return l_false;
  3127:         TRACE("arith", tout << "status treated as inconclusive: " << status << "\n";);
  3128              // TENTATIVE_UNBOUNDED, UNBOUNDED, TENTATIVE_DUAL_UNBOUNDED, DUAL_UNBOUNDED, 

  3192          ++m_stats.m_conflicts;
  3193:         TRACE("arith",
  3194                tout << "lemma scope: " << ctx().get_scope_level();

  3218              }
  3219:             TRACE("arith", ctx().display_literals_verbose(tout, m_core) << "\n";);
  3220              // DEBUG_CODE(

  3222              //         if (ctx().get_assignment(c) == l_true) {
  3223:             //             TRACE("arith", ctx().display_literal_verbose(tout, c) << " is true\n";);
  3224              //             SASSERT(false);

  3264          }
  3265:         TRACE("arith", display(tout););
  3266      }

  3273              m_todo_terms.push_back(std::make_pair(t, rational::one()));
  3274:             TRACE("nl_value", tout << "v" << v << " " << t.to_string() << "\n";);
  3275:             TRACE("nl_value", tout << "v" << v << " := w" << t.to_string() << "\n";
  3276                    lp().print_term(lp().get_term(t), tout) << "\n";);

  3283                  lp::lar_term const& term = lp().get_term(t);
  3284:                 TRACE("nl_value", lp().print_term(term, tout) << "\n";);
  3285                  scoped_anum r1(m_nla->am());

  3320              rational r = get_value(v);
  3321:             TRACE("arith", tout << mk_pp(o, m) << " v" << v << " := " << r << "\n";);
  3322              SASSERT("integer variables should have integer values: " && (!a.is_int(o) || r.is_int() || m.limit().is_canceled()));

  3332          if (lp().has_value(vi, val)) {
  3333:             TRACE("arith", tout << expr_ref(n->get_expr(), m) << " := " << val << "\n";);
  3334              if (is_int(n) && !val.is_int()) return false;

  3421          bool result = l_true != nctx.check();
  3422:         CTRACE("arith", !result, ctx().display_lemma_as_smt_problem(tout, core.size(), core.data(), eqs.size(), eqs.data(), false_literal););
  3423          return result;

  3435          bool result = l_true != nctx.check();
  3436:         CTRACE("arith", !result, ctx().display_lemma_as_smt_problem(tout, core.size(), core.data(), eqs.size(), eqs.data(), lit);
  3437                 display(tout););   

  3483          if (!is_registered_var(v)) {
  3484:             TRACE("arith", tout << "cannot get bound for v" << v << "\n";);
  3485              st = lp::lp_status::UNBOUNDED;

  3508              init_variable_values();
  3509:             TRACE("arith", display(tout << st << " v" << v << " vi: " << vi << "\n"););
  3510              auto val = value(v);

  3515              auto val = value(v);
  3516:             TRACE("arith", display(tout << st << " v" << v << " vi: " << vi << "\n"););
  3517              blocker = mk_gt(v);

  3521              SASSERT(st == lp::lp_status::UNBOUNDED);
  3522:             TRACE("arith", display(tout << st << " v" << v << " vi: " << vi << "\n"););
  3523              has_shared = false;

  3548          }
  3549:         TRACE("opt", tout << "v" << v << " " << val << " " << r << " " << e << "\n";);
  3550          return e;

  3553      theory_var add_objective(app* term) {
  3554:         TRACE("opt", tout << expr_ref(term, m) << "\n";);
  3555          theory_var v = internalize_def(term);

  3564      void term2coeffs(lp::lar_term const& term, u_map<rational>& coeffs, rational const& coeff) {
  3565:         TRACE("arith", lp().print_term(term, tout) << "\n";);
  3566          for (lp::lar_term::ival ti : term) {

  3577                  SASSERT(w >= 0);
  3578:                 TRACE("arith", tout << (tv.id()) << ": " << w << "\n";);
  3579              }

  3651          bool is_int = a.is_int(get_enode(v)->get_expr());
  3652:         TRACE("arith", display(tout << "v" << v << "\n"););
  3653          if (is_strict) {

  3672              m_bool_var2bound.insert(bv, a);
  3673:             TRACE("arith", tout << "internalized " << bv << ": " << mk_pp(b, m) << "\n";);
  3674          }

  3677          }
  3678:         TRACE("arith", tout << b << "\n";);
  3679          return expr_ref(b, m);            

z3/src/smt/theory_pb.cpp:
   253          unsigned bound = k();
   254:         TRACE("pb", th.display(tout << "assign: " << m_lit << " " << ~alit << " " << bound << "\n", *this, true););
   255  

   275              if (ctx.get_assignment(lit2) != l_false) {
   276:                 TRACE("pb", tout << "swap " << lit2 << "\n";);
   277                  std::swap(m_args[index], m_args[i]);

   284          if (bound != index && ctx.get_assignment(lit(bound)) == l_false) {
   285:             TRACE("pb", tout << "conflict " << lit(bound) << " " << alit << "\n";);
   286              set_conflict(th, alit);

   289  
   290:         TRACE("pb", tout << "no swap " << index << " " << alit << "\n";);
   291          // there are no literals to swap with,

   550  
   551:         TRACE("pb", display(tout, *c); tout << " := " << lit << " " << is_true << "\n";);        
   552          switch (is_true) {

   588          m_ineqs_trail.push_back(abv);
   589:         TRACE("pb", display(tout, *c););
   590          return true;

   626              fml = m.mk_iff(tmp, arg);
   627:             TRACE("pb", tout << "create proxy " << fml << "\n";);
   628              ctx.internalize(fml, false);

   949          m_stats.m_num_propagations++;
   950:         TRACE("pb", tout << "#prop: " << c.num_propagations() << " - " << c.lit() << " => " << l << "\n";
   951                display(tout, c, true) << "\n";);

   988      final_check_status theory_pb::final_check_eh() {
   989:         TRACE("pb", display(tout););
   990          DEBUG_CODE(validate_final_check(););

   997          init_watch(v);
   998:         TRACE("pb", tout << "assign: " << ~nlit << "\n";);
   999          ineqs = m_var_infos[v].m_lit_watch[nlit.sign()];

  1135  
  1136:         TRACE("pb", 
  1137                tout << "assign: " << c.lit() << "\n";

  1247  
  1248:         TRACE("pb", 
  1249                tout << "assign: " << literal(v,!is_true) << "\n";

  1499          m_stats.m_num_propagations++;
  1500:         TRACE("pb", tout << "#prop:" << c.m_num_propagations << " - " << lits;
  1501                tout << " => " << l << "\n";

  1514          m_stats.m_num_conflicts++;
  1515:         TRACE("pb", tout << "#prop:" << c.m_num_propagations << " - " << lits << "\n"; 
  1516                display(tout, c, true);); 

  1675          unsigned lvl = 0;
  1676:         TRACE("pb", tout << p << " " << ctx.get_assignment(p) << "\n";);
  1677  

  1799              m_bound = (m_bound + g - 1) / g;
  1800:             TRACE("pb", display_resolved_lemma(tout << "cut\n"););
  1801          }

  1809         
  1810:         TRACE("pb", display(tout, c, true); );
  1811  

  1866  
  1867:             TRACE("pb", 
  1868                    display_resolved_lemma(tout << conseq << "\n");

  1889                  else if (cjs && !is_proof_justification(*cjs)) {                    
  1890:                     TRACE("pb", tout << "not processing justification over: " << conseq << " " << typeid(*cjs).name() << "\n";);
  1891                      break;

  1902                  }
  1903:                 TRACE("pb", tout << literal_vector(cls.get_num_literals(), cls.begin()) << "\n";);
  1904                  break;                

  1920                  if (pbj == nullptr) {
  1921:                     TRACE("pb", tout << "skip justification for " << conseq << "\n";);
  1922                      bound = 0;

  1968  
  1969:         TRACE("pb", display_resolved_lemma(tout << "done\n"););
  1970          

  2009          SASSERT(validate_antecedents(m_antecedents));
  2010:         TRACE("pb", tout << "assign " << m_antecedents << " ==> " << alit << "\n";);
  2011          ctx.assign(alit, ctx.mk_justification(theory_propagation_justification(get_id(), ctx, m_antecedents.size(), m_antecedents.data(), alit, 0, nullptr)));

  2075          }
  2076:         CTRACE("pb", (sum >= c.k()),
  2077                 display(tout << "invalid assign" , c, true);

  2083      void theory_pb::validate_final_check() {
  2084:         TRACE("pb", tout << "validate " << m_var_infos.size() << "\n";);
  2085          for (auto & vi : m_var_infos) {

  2096          if (ctx.get_assignment(c.lit()) == l_undef) {
  2097:             TRACE("pb", display(tout << "is undef ", c, true););
  2098              return;

  2100          if (!ctx.is_relevant(c.lit())) {
  2101:             TRACE("pb", display(tout << "not relevant ", c, true););
  2102              return;

  2116          }
  2117:         TRACE("pb_verbose", display(tout << "validate: ", c, true);
  2118                tout << "sum: " << sum << " " << maxsum << " ";

  2128          if (ctx.get_assignment(c.lit()) == l_undef) {
  2129:             TRACE("pb", tout << c.lit() << " is undef\n";);
  2130              return;

  2132          if (!ctx.is_relevant(c.lit())) {
  2133:             TRACE("pb", tout << c.lit() << " is not relevant\n";);
  2134              return;

  2147          }
  2148:         TRACE("pb", display(tout << "validate: ", c, true);
  2149                tout << "sum: " << sum << " " << maxsum << " ";

z3/src/smt/theory_recfun.cpp:
  26  
  27: #define TRACEFN(x) TRACE("recfun", tout << x << '\n';)
  28  

  50      bool theory_recfun::internalize_atom(app * atom, bool gate_ctx) {
  51:         TRACE("recfun", tout << mk_pp(atom, m) << " " << u().has_defs() << "\n");
  52          if (!u().has_defs()) {

z3/src/smt/theory_seq.cpp:
   309  
   310: #define TRACEFIN(s) { TRACE("seq", tout << ">>" << s << "\n";); IF_VERBOSE(20, verbose_stream() << s << "\n"); }
   311  

   313      scoped_enable_trace() {
   314:         enable_trace("seq");
   315      }
   316      ~scoped_enable_trace() {
   317:         disable_trace("seq");
   318      }

   326      m_new_propagation = false;
   327:     TRACE("seq", display(tout << "level: " << ctx.get_scope_level() << "\n"););
   328:     TRACE("seq_verbose", ctx.display(tout););
   329  

   427          TRACEFIN("give_up");
   428:         TRACE("seq", tout << "unhandled: " << mk_pp(m_unhandled_expr, m) << "\n";);
   429          return FC_GIVEUP;

   433          TRACEFIN("is_solved");
   434:         TRACE("seq", display(tout););
   435          return FC_DONE;

   506  
   507:     TRACE("seq", tout << "Fixed: " << mk_bounded_pp(e, m, 2) << " " << lo << "\n";);
   508      literal a = mk_eq(len_e, m_autil.mk_numeral(lo, true), false);

   547  bool theory_seq::propagate_is_conc(expr* e, expr* conc) {
   548:     TRACE("seq", tout << mk_pp(conc, m) << " is non-empty\n";);
   549      literal lit = ~mk_eq_empty(e);

   594      if (!m_seq_rewrite.reduce_eq(e1, e2, m_new_eqs, change)) {
   595:         TRACE("seq", tout << "exclude " << mk_pp(o1, m) << " " << mk_pp(o2, m) << "\n";);
   596          m_exclude.update(o1, o2);

   600          if (m_exclude.contains(p.first, p.second)) {
   601:             TRACE("seq", tout << "excluded " << mk_pp(p.first, m) << " " << mk_pp(p.second, m) << "\n";);
   602              return true;

   712      if (!m_eqs.empty()) {
   713:         TRACE("seq", tout << "(seq.giveup " << m_eqs[0].ls << " = " << m_eqs[0].rs << " is unsolved)\n";);
   714          IF_VERBOSE(10, verbose_stream() << "(seq.giveup " << m_eqs[0].ls << " = " << m_eqs[0].rs << " is unsolved)\n";);

   717      if (!m_ncs.empty()) {
   718:         TRACE("seq", display_nc(tout << "(seq.giveup ", m_ncs[0]); tout << " is unsolved)\n";);
   719          IF_VERBOSE(10, display_nc(verbose_stream() << "(seq.giveup ", m_ncs[0]); verbose_stream() << " is unsolved)\n";);

   779      linearize(dep, eqs, lits);
   780:     TRACE("seq",
   781            tout << "scope: " << ctx.get_scope_level() << "\n";

   805  void theory_seq::set_conflict(enode_pair_vector const& eqs, literal_vector const& lits) {
   806:     TRACE("seq", display_deps(tout << "assert conflict:", lits, eqs););
   807      ctx.set_conflict(

   820      linearize(dep, eqs, lits);
   821:     TRACE("seq_verbose",
   822            tout << "assert: " << mk_bounded_pp(n1->get_expr(), m) << " = " << mk_bounded_pp(n2->get_expr(), m) << " <-\n";

   825  
   826:     TRACE("seq", 
   827            tout << "assert: " 

   908      bool changed = false;
   909:     TRACE("seq", 
   910            for (expr* l : ls) tout << "s#" << l->get_id() << " " << mk_bounded_pp(l, m, 2) << "\n";

   915          // equality is inconsistent.
   916:         TRACE("seq_verbose", tout << ls << " != " << rs << "\n";);
   917          set_conflict(deps);

   924      }
   925:     TRACE("seq",
   926            tout << "reduced to\n";

   934      if (new_eqs.empty()) {
   935:         TRACE("seq", tout << "solved\n";);
   936          return true;
   937      }
   938:     TRACE("seq_verbose", 
   939            tout << ls << " = " << rs << "\n";);

   952          else if (m_util.is_seq(li) || m_util.is_re(li)) {
   953:             TRACE("seq_verbose", tout << "inserting " << li << " = " << ri << "\n";);
   954              m_eqs.push_back(mk_eqdep(li, ri, deps));            

   959      }
   960:     TRACE("seq_verbose",
   961            if (!ls.empty() || !rs.empty()) tout << ls << " = " << rs << ";\n";

   996      enode* n2 = ensure_enode(r);    
   997:     TRACE("seq", tout << mk_bounded_pp(l, m, 2) << " ==> " << mk_bounded_pp(r, m, 2) << "\n"; display_deps(tout, deps);
   998            tout << "#" << n1->get_owner_id() << " ==> #" << n2->get_owner_id() << "\n";

  1036          m_eqs.push_back(depeq(m_eq_id++, lhs, rhs, deps));
  1037:         TRACE("seq", tout << "Propagate equal lengths " << l << " " << r << "\n";);
  1038          propagate_eq(deps, lits, l, r, true);

  1048          deps = mk_join(deps, lits);
  1049:         TRACE("seq", tout << "Propagate equal lengths " << l << " " << r << "\n" << "ls: " << ls << "\nrs: " << rs << "\n";);
  1050          m_eqs.push_back(depeq(m_eq_id++, lhs, rhs, deps));

  1061          if (len1 == len2 && 0 < j && j < rs.size() && reduce_length(1, j, true, ls, rs, deps)) {
  1062:             TRACE("seq", tout << "l equal\n";);
  1063              return true;

  1071          if (len1 == len2 && 0 < j && j < ls.size() && reduce_length(j, 1, true, ls, rs, deps)) {
  1072:             TRACE("seq", tout << "r equal\n";);
  1073              return true;

  1081          if (len1 == len2 && 0 < j && j < rs.size() && reduce_length(ls.size()-1, rs.size()-j, false, ls, rs, deps)) {
  1082:             TRACE("seq", tout << "l suffix equal\n";);
  1083              return true;

  1091          if (len1 == len2 && 0 < j && j < ls.size() && reduce_length(ls.size()-j, rs.size()-1, false, ls, rs, deps)) {
  1092:             TRACE("seq", tout << "r suffix equal\n";);
  1093              return true;

  1134          propagate_eq(deps, l, r, true);
  1135:         TRACE("seq", tout << "propagate eq\n" << m_eqs.size() << "\nlhs: " << lhs << "\nrhs: " << rhs << "\n";);
  1136          return true;

  1174          }
  1175:         TRACE("seq", tout << mk_pp(e, m) << "\n"; ctx.display_literals_verbose(tout, 4, _lits); tout << "\n";
  1176                for (unsigned i = 0; i < 4; ++i) tout << ctx.get_assignment(_lits[i]) << "\n";);

  1187              lits.append(2, _lits);
  1188:             TRACE("seq", ctx.display_literals_verbose(tout, 2, _lits); tout << "\n";);
  1189              return true;

  1200              lits.append(2, _lits);
  1201:             TRACE("seq", ctx.display_literals_verbose(tout << "pre length", 2, _lits); tout << "\n";);
  1202              return true;

  1212              lits.append(2, _lits);
  1213:             TRACE("seq", ctx.display_literals_verbose(tout << "post length " << len << "\n", 2, _lits) << "\n";);
  1214              return true;

  1226              lits.push_back(len_s_gt_l);
  1227:             TRACE("seq", ctx.display_literals_verbose(tout << "tail length " << len << "\n", lits) << "\n";);
  1228              return true;

  1231              lits.push_back(~len_s_gt_l);
  1232:             TRACE("seq", ctx.display_literals_verbose(tout << "tail length " << len << "\n", lits) << "\n";);
  1233              return true;

  1274      lbool is_gt = ctx.get_assignment(len_gt);
  1275:     TRACE("seq", ctx.display_literal_smt2(tout << len_gt << " := " << is_gt << "\n", len_gt) << "\n";);
  1276      

  1357      
  1358:     TRACE("seq", 
  1359            tout << "1:\n";

  1388                  c1->m_parent->m_expr == c2->m_parent->m_expr) {
  1389:                 TRACE("seq", tout << "parent: " << mk_pp(e1, m) << " " << mk_pp(c1->m_parent->m_expr, m) << "\n";);
  1390                  c1 = c1->m_parent;

  1423          else {
  1424:             TRACE("seq", tout << "Could not solve " << mk_pp(e1, m) << " = " << mk_pp(e2, m) << "\n";);
  1425              result = false;

  1446          }
  1447:         TRACE("seq", tout << "Could not set to empty: " << es << "\n";);
  1448          return false;

  1529          return;
  1530:     TRACE("seq", tout << mk_bounded_pp(e, m, 2) << "\n";);
  1531      m_length.push_back(l);

  2011                      else {
  2012:                         TRACE("seq", tout << "Not a string: " << tmp << "\n";);
  2013                      }

  2032                  }
  2033:                 // TRACE("seq", tout << src << " " << sbuffer << "\n";);
  2034              }

  2054          th.m_factory->add_trail(result);
  2055:         TRACE("seq", tout << pp(m_node, th.m) << " -> " << result << "\n";);
  2056          return to_app(result);

  2080      app* e = n->get_expr();
  2081:     TRACE("seq", tout << mk_pp(e, m) << "\n";);
  2082  

  2102          unsigned end = m_concat.size();
  2103:         TRACE("seq", tout << "sequence: " << start << " " << end << " " << mk_pp(e, m) << "\n";);
  2104          for (unsigned i = start; i < end; ++i) {

  2106              expr *c1;
  2107:             TRACE("seq", tout << "elem: " << mk_pp(c, m) << "\n";);
  2108              if (m_util.str.is_unit(c, c1)) {

  2113                  else {
  2114:                     TRACE("seq", tout << "not internalized " << mk_pp(c, m) << "\n";);
  2115                  }

  2126                  app_ref val(mk_value(to_app(c)), m);
  2127:                 TRACE("seq", tout << "WARNING: " << val << " is prone to result in incorrect model\n";);
  2128                  sv->add_string(val);

  2156      m_factory->add_trail(result);
  2157:     TRACE("seq", tout << mk_pp(e, m) << " -> " << result << "\n";);
  2158      m_rep.update(e, result, nullptr);

  2408      }
  2409:     TRACE("seq", tout << fmls << "\n";);
  2410  

  2422          k.get_model(mdl);
  2423:         TRACE("seq", tout << "failed to validate\n" << *mdl << "\n");
  2424          IF_VERBOSE(0, 

  2456      }
  2457:     TRACE("seq", tout << mk_bounded_pp(e, m, 2) << " expands to\n" << mk_bounded_pp(result, m, 2) << "\n";);
  2458      m_rewrite(result);
  2459:     TRACE("seq", tout << mk_bounded_pp(e, m, 2) << " rewrites to\n" << mk_bounded_pp(result, m, 2) << "\n";);
  2460      return true;

  2638              m_new_propagation = true;
  2639:             TRACE("seq", tout << "undef: " << mk_bounded_pp(e, m, 2) << "\n";
  2640                    tout << lit << "@ level: " << ctx.get_scope_level() << "\n";);

  2652      eqs = m_dm.mk_join(eqs, deps);
  2653:     TRACE("seq_verbose", tout << mk_pp(e0, m) << " |--> " << result << "\n";
  2654            if (eqs) display_deps(tout, eqs););

  2674      while (!m_replay.empty() && !ctx.inconsistent()) {
  2675:         TRACE("seq", tout << "replay at level: " << ctx.get_scope_level() << "\n";);
  2676          apply& app = *m_replay[m_replay.size() - 1];

  2687      if (!m_axiom_set.contains(e)) {
  2688:         TRACE("seq", tout << "add axiom " << mk_bounded_pp(e, m) << "\n";);
  2689          m_axioms.push_back(e);

  2696  void theory_seq::deque_axiom(expr* n) {
  2697:     TRACE("seq", tout << "deque: " << mk_bounded_pp(n, m, 2) << "\n";);
  2698      if (m_util.str.is_length(n)) {

  2761      zstring s;
  2762:     TRACE("seq", tout << mk_pp(n, m) << "\n";);
  2763      VERIFY(m_util.str.is_string(n, s));

  2858                  add_axiom(mk_literal(m_autil.mk_ge(len, m_autil.mk_int(0))));
  2859:                 TRACE("seq", tout << "literal has no length " << mk_pp(c, m) << "\n";);
  2860                  return false;            

  2864              else {
  2865:                 TRACE("seq", tout << "length has not been internalized " << mk_pp(c, m) << "\n";);
  2866                  return false;

  2869      }
  2870:     CTRACE("seq", !val.is_int(), tout << "length is not an integer\n";);
  2871      return val.is_int();

  2878  void theory_seq::ensure_nth(literal lit, expr* s, expr* idx) {
  2879:     TRACE("seq", tout << "ensure-nth: " << lit << " " << mk_bounded_pp(s, m, 2) << " " << mk_bounded_pp(idx, m, 2) << "\n";);
  2880      rational r;

  2951  void theory_seq::add_axiom(literal_vector & lits) {
  2952:     TRACE("seq", ctx.display_literals_verbose(tout << "assert " << lits << " :", lits) << "\n";);
  2953  

  3008      }
  3009:     TRACE("seq_verbose",
  3010            tout << "assert: #" << e1->get_id() << " " << mk_pp(e1, m) << " = " << mk_pp(e2, m) << " <- \n";

  3012  
  3013:     TRACE("seq",
  3014            tout << "assert:" << mk_bounded_pp(e1, m, 2) << " = " << mk_bounded_pp(e2, m, 2) << " <- \n";

  3037      literal lit(v, !is_true);
  3038:     TRACE("seq", tout << (is_true?"":"not ") << mk_bounded_pp(e, m) << "\n";);
  3039:     TRACE("seq", tout << (is_true?"":"not ") << mk_bounded_pp(e, m) << " " << ctx.get_scope_level() << " " << lit << "\n";);
  3040  

  3141      else {
  3142:         TRACE("seq", tout << mk_pp(e, m) << "\n";);
  3143          IF_VERBOSE(0, verbose_stream() << mk_pp(e, m) << "\n");

  3166      expr* e2 = n2->get_expr();
  3167:     TRACE("seq", tout << mk_bounded_pp(e1, m) << " = " << mk_bounded_pp(e2, m) << "\n";);
  3168      if (n1 != n2 && m_util.is_seq(e1)) {

  3178          expr_ref o2(e2, m);
  3179:         TRACE("seq", tout << mk_bounded_pp(o1, m) << " = " << mk_bounded_pp(o2, m) << "\n";);
  3180          m_eqs.push_back(mk_eqdep(o1, o2, deps));

  3203      expr_ref eq(m.mk_eq(e1, e2), m);
  3204:     TRACE("seq", tout << "new disequality " << ctx.get_scope_level() << ": " << mk_bounded_pp(eq, m, 2) << "\n";);
  3205      m_rewrite(eq);

  3320      if (m_has_seq) {
  3321:         TRACE("seq", tout << "add_theory_assumption\n";);
  3322          expr_ref dlimit = m_sk.mk_max_unfolding_depth(m_max_unfolding_depth);

  3333  bool theory_seq::should_research(expr_ref_vector & unsat_core) {
  3334:     TRACE("seq", tout << unsat_core << " " << m_util.has_re() << "\n";);
  3335      if (!m_has_seq) 

  3435      if (!canonize(e, deps, cont)) cont = e;
  3436:     TRACE("seq", tout << is_true << ": " << mk_bounded_pp(e, m, 2) << " -> " << mk_bounded_pp(cont, m, 2) << "\n";
  3437            if (deps) display_deps(tout, deps););

  3439          (m.is_false(cont) && is_true)) {
  3440:         TRACE("seq", display(tout); tout << ctx.get_assignment(ctx.get_literal(e)) << "\n";);
  3441          literal lit = ctx.get_literal(e);

  3447          (m.is_true(cont) && is_true)) {
  3448:         TRACE("seq", display(tout););
  3449          return true;

z3/src/smt/theory_special_relations.cpp:
   152          m_atoms.push_back(a);
   153:         TRACE("special_relations", tout << mk_pp(atm, m) << " : bv" << v << " v" << a->v1() << " v" << a->v2() << ' ' << gate_ctx << "\n";);
   154          m_bool_var2atom.insert(v, a);

   165              v = theory::mk_var(n);
   166:             TRACE("special_relations", tout << "v" << v << " := " << mk_pp(e, get_manager()) << "\n";);
   167              ctx.attach_th_var(n, this, v);

   185      final_check_status theory_special_relations::final_check_eh() {
   186:         TRACE("special_relations", tout << "\n";);
   187          for (auto const& kv : m_relations) {

   282                      justification* j = ctx.mk_justification(theory_propagation_justification(get_id(), ctx, 1, &lit, consequent));
   283:                     TRACE("special_relations", tout << "propagate: " << tc_app << "\n";);
   284                      ctx.assign(consequent, j);

   320                  if (r_graph.can_reach(r1, r2)) {
   321:                     TRACE("special_relations", 
   322                            tout << a.v1() << ": " << mk_pp(arg1, m) << " -> " 

   376                      ctx.set_true_first_flag(bv);
   377:                     TRACE("special_relations", tout << f_app << " is undefined\n";);
   378                      new_assertion = true;

   383          if (new_assertion) {
   384:             TRACE("special_relations", tout << "new assertion\n";);
   385              return l_false;

   397              }
   398:             TRACE("special_relations", tout << a.v1() << " !<= " << a.v2() << "\n";);
   399              target.reset();

   404                  // we already have v2 <= v1
   405:                 TRACE("special_relations", tout << "already: " << a.v2() << " <= " << a.v1() << "\n";);
   406                  continue;

   423                  r.m_graph.find_shortest_reachable_path(a.v2(), w, timestamp, r);
   424:                 TRACE("special_relations", tout << "added edge\n";);
   425                  r.m_explanation.push_back(a.explanation());

   466          literal_vector const& lits = r.m_explanation;
   467:         TRACE("special_relations", ctx.display_literals_verbose(tout, lits) << "\n";);
   468          vector<parameter> params;

   499          }
   500:         TRACE("special_relations", r.display(*this, tout << res << "\n"););
   501          return res;

   532                      literal_vector const& lits = r.m_explanation;
   533:                     TRACE("special_relations", ctx.display_literals_verbose(tout << mk_pp(x->get_expr(), m) << " = " << mk_pp(y->get_expr(), m) << "\n", lits) << "\n";);
   534                      IF_VERBOSE(20, ctx.display_literals_verbose(verbose_stream() << mk_pp(x->get_expr(), m) << " = " << mk_pp(y->get_expr(), m) << "\n", lits) << "\n";);

   591                  if (found_path) {
   592:                     TRACE("special_relations", tout << "check po conflict\n";);
   593                      r.m_explanation.push_back(a.explanation());

   647      void theory_special_relations::assign_eh(bool_var v, bool is_true) {
   648:         TRACE("special_relations", tout << "assign bv" << v << " " << (is_true?" <- true":" <- false") << "\n";);
   649          atom* a = m_bool_var2atom[v];

   706          }
   707:         TRACE("special_relations", g.display(tout););
   708      }

   733          }
   734:         TRACE("special_relations", g.display(tout););
   735      }

   783          }
   784:         TRACE("special_relations", r.m_graph.display(tout););
   785          r.pop(1);

   958              
   959:             TRACE("special_relations", tout << connected_body << "\n";);
   960              recfun_replace rep(m);

  1010      bool theory_special_relations::is_neighbour_edge(graph const& g, edge_id edge) const {
  1011:         CTRACE("special_relations_verbose", g.is_enabled(edge),
  1012                tout << edge << ": " << g.get_source(edge) << " " << g.get_target(edge) << " ";

  1040                      dl_var dst = g.get_target(e);
  1041:                     TRACE("special_relations", tout << v << " -> " << dst << "\n";);
  1042                      if (!processed[dst]) {

  1054          }
  1055:         TRACE("special_relations",
  1056                for (unsigned i = 0; i < sz; ++i) {

z3/src/smt/theory_str_mc.cpp:
   131          fixed_length_assumptions.push_back(final_diseq);
   132:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   133          fixed_length_lesson.insert(final_diseq, std::make_tuple(PFUN, f, f));

   185          fixed_length_assumptions.push_back(final_diseq);
   186:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   187          fixed_length_lesson.insert(final_diseq, std::make_tuple(NFUN, f, f));

   247          fixed_length_assumptions.push_back(final_diseq);
   248:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   249          fixed_length_lesson.insert(final_diseq, std::make_tuple(PFUN, f, f));

   300          fixed_length_assumptions.push_back(final_diseq);
   301:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   302          fixed_length_lesson.insert(final_diseq, std::make_tuple(NFUN, f, f));

   367          fixed_length_assumptions.push_back(final_diseq);
   368:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   369          fixed_length_lesson.insert(final_diseq, std::make_tuple(PFUN, f, f));

   427          fixed_length_assumptions.push_back(final_diseq);
   428:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   429          fixed_length_lesson.insert(final_diseq, std::make_tuple(NFUN, f, f));

   478              if (!zero_solution && polarity) {
   479:                 TRACE("str_fl", tout << "contradiction: regex has no zero-length solutions, but our string must be a solution" << std::endl;);
   480                  cex = m.mk_or(m.mk_not(f), m.mk_not(ctx.mk_eq_atom(mk_strlen(str), mk_int(0))));

   483              } else if (zero_solution && !polarity) {
   484:                 TRACE("str_fl", tout << "contradiction: regex has zero-length solutions, but our string must not be a solution" << std::endl;);
   485                  cex = m.mk_or(f, m.mk_not(ctx.mk_eq_atom(mk_strlen(str), mk_int(0))));

   488              } else {
   489:                 TRACE("str_fl", tout << "regex constraint satisfied without asserting constraints to subsolver" << std::endl;);
   490                  return true;

   553              rw(result);
   554:             TRACE("str_fl", tout << "regex path constraint: " << mk_pp(result, sub_m) << std::endl;);
   555  

   590                  } else {
   591:                     TRACE("str_fl", tout << "regex constraint satisfied without asserting constraints to subsolver" << std::endl;);
   592                      return true;

   635                  if (!var_hasLen || varLen_value.is_neg()) {
   636:                     TRACE("str_fl", tout << "variable " << mk_pp(term, m) << " has no length assignment or impossible length assignment - asserting conflict axiom" << std::endl;);
   637                      cex = expr_ref(m_autil.mk_ge(mk_strlen(term), mk_int(0)), m);

   639                  }
   640:                 TRACE("str_fl", tout << "creating character terms for variable " << mk_pp(term, m) << ", length = " << varLen_value << std::endl;);
   641                  chars = alloc(expr_ref_vector, m);

   685              }
   686:             TRACE("str_fl", tout << "reduce substring term: base=" << mk_pp(term, m) << " (length="<<base_chars.size()<<"), pos=" << pos.to_string() << ", len=" << len.to_string() << std::endl;);
   687              // Case 1: pos < 0 or pos >= strlen(base) or len < 0

   726              }
   727:             TRACE("str_fl", tout << "reduce str.at: base=" << mk_pp(base, m) << ", pos=" << pos_value.to_string() << std::endl;);
   728              if (pos_value.is_neg() || pos_value >= rational(base_chars.size())) {

   753              }
   754:             TRACE("str_fl", tout << "reduce int.to.str: n=" << iValue << std::endl;);
   755              if (iValue.is_neg()) {

   778          } else {
   779:             TRACE("str_fl", tout << "string term " << mk_pp(term, m) << " handled as uninterpreted function" << std::endl;);
   780              expr_ref_vector *chars = nullptr;

   784                  if (!uf_hasLen || ufLen_value.is_neg()) {
   785:                     TRACE("str_fl", tout << "uninterpreted function " << mk_pp(term, m) << " has no length assignment or impossible length assignment - asserting conflict axiom" << std::endl;);
   786                      cex = expr_ref(m_autil.mk_ge(mk_strlen(term), mk_int(0)), m);

   788                  }
   789:                 TRACE("str_fl", tout << "creating character terms for uninterpreted function " << mk_pp(term, m) << ", length = " << ufLen_value << std::endl;);
   790                  chars = alloc(expr_ref_vector, m);

   818          if (lhs_chars.size() != rhs_chars.size()) {
   819:             TRACE("str_fl", tout << "length information inconsistent: " << mk_pp(lhs, m) << " has " << lhs_chars.size() <<
   820                      " chars, " << mk_pp(rhs, m) << " has " << rhs_chars.size() << " chars" << std::endl;);

   829              fixed_length_assumptions.push_back(_e);
   830:             TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   831              fixed_length_lesson.insert(_e, std::make_tuple(rational(i), lhs, rhs));

   863          if (lhsLen != rhsLen) {
   864:             TRACE("str", tout << "skip disequality: len(lhs) = " << lhsLen << ", len(rhs) = " << rhsLen << std::endl;);
   865              return true;

   877          fixed_length_assumptions.push_back(final_diseq);
   878:         TRACE("str_fl", tout << "inserting into fixed_lesson" <<std::endl;);
   879          fixed_length_lesson.insert(final_diseq, std::make_tuple(NEQ, lhs, rhs));

   889  
   890:         TRACE("str",
   891              ast_manager & m = get_manager();

   922          for (expr * var : free_variables) {
   923:             TRACE("str_fl", tout << "initialize free variable " << mk_pp(var, m) << std::endl;);
   924              rational var_lenVal;
   925              if (!fixed_length_get_len_value(var, var_lenVal)) {
   926:                 TRACE("str_fl", tout << "free variable " << mk_pp(var, m) << " has no length assignment" << std::endl;);
   927                  expr_ref var_len_assertion(m_autil.mk_ge(mk_strlen(var), mk_int(0)), m);

   934              if (!fixed_length_reduce_string_term(subsolver, var, var_chars, str_counterexample)) {
   935:                 TRACE("str_fl", tout << "free variable " << mk_pp(var, m) << " caused a conflict; asserting and continuing" << std::endl;);
   936                  assert_axiom(str_counterexample);

   945                      if (!get_context().is_relevant(subformula)) {
   946:                         TRACE("str_fl", tout << "skip reducing formula " << mk_pp(f, m) << ", not relevant (and neither is its subformula)" << std::endl;);
   947                          continue;
   948                      } else {
   949:                         TRACE("str_fl", tout << "considering formula " << mk_pp(f, m) << ", its subformula is relevant but it is not" << std::endl;);
   950                      }
   951                  } else {
   952:                     TRACE("str_fl", tout << "skip reducing formula " << mk_pp(f, m) << ", not relevant" << std::endl;);
   953                      continue;

   965                      if (lhs_sort == str_sort) {
   966:                         TRACE("str_fl", tout << "reduce string equality: " << mk_pp(lhs, m) << " == " << mk_pp(rhs, m) << std::endl;);
   967                          expr_ref cex(m);

   977                      } else {
   978:                         TRACE("str_fl", tout << "skip reducing formula " << mk_pp(f, m) << ", not an equality over strings" << std::endl;);
   979                      }
   980                  } else if (u.str.is_in_re(f)) {
   981:                     TRACE("str_fl", tout << "reduce regex membership: " << mk_pp(f, m) << std::endl;);
   982                      expr_ref cex_clause(m);

   993                      if (m_params.m_FixedLengthRefinement) {
   994:                         TRACE("str_fl", tout << "abstracting out positive contains: " << mk_pp(f, m) << std::endl;);
   995                          abstracted_boolean_formulas.push_back(f);
   996                      } else {
   997:                         TRACE("str_fl", tout << "reduce positive contains: " << mk_pp(f, m) << std::endl;);
   998                          expr_ref cex(m);

  1007                  } else if (u.str.is_prefix(f)) {
  1008:                     TRACE("str_fl", tout << "reduce positive prefix: " << mk_pp(f, m) << std::endl;);
  1009                      expr_ref cex(m);

  1017                  } else if (u.str.is_suffix(f)) {
  1018:                     TRACE("str_fl", tout << "reduce positive suffix: " << mk_pp(f, m) << std::endl;);
  1019                      expr_ref cex(m);

  1031                          if (lhs_sort == str_sort) {
  1032:                             TRACE("str_fl", tout << "reduce string disequality: " << mk_pp(lhs, m) << " != " << mk_pp(rhs, m) << std::endl;);
  1033                              expr_ref cex(m);

  1044                      } else if (u.str.is_in_re(subterm)) {
  1045:                         TRACE("str_fl", tout << "reduce negative regex membership: " << mk_pp(f, m) << std::endl;);
  1046                          expr_ref cex_clause(m);

  1054                      } else if (u.str.is_contains(subterm)) {
  1055:                         TRACE("str_fl", tout << "reduce negative contains: " << mk_pp(subterm, m) << std::endl;);
  1056                          expr_ref cex(m);

  1064                      } else if (u.str.is_prefix(subterm)) {
  1065:                         TRACE("str_fl", tout << "reduce negative prefix: " << mk_pp(subterm, m) << std::endl;);
  1066                          expr_ref cex(m);

  1074                      } else if (u.str.is_suffix(subterm)) {
  1075:                         TRACE("str_fl", tout << "reduce negative suffix: " << mk_pp(subterm, m) << std::endl;);
  1076                          expr_ref cex(m);

  1084                      } else {
  1085:                         TRACE("str_fl", tout << "skip reducing formula " << mk_pp(f, m) << ", not a boolean formula we handle" << std::endl;);
  1086                      }
  1087                  } else {
  1088:                     TRACE("str_fl", tout << "skip reducing formula " << mk_pp(f, m) << ", not a boolean formula we handle" << std::endl;);
  1089                      continue;

  1091              } else {
  1092:                 TRACE("str_fl", tout << "skip reducing formula " << mk_pp(f, m) << ", not relevant to strings" << std::endl;);
  1093                  continue;

  1102              for (auto e : string_int_conversion_terms) {
  1103:                 TRACE("str_fl", tout << "pre-run check str-int term " << mk_pp(e, get_manager()) << std::endl;);
  1104                  expr* _arg;

  1113                      }
  1114:                     TRACE("str_fl", tout << "length of term is " << slen << std::endl;);
  1115  

  1117                      if (v.get_value(e, ival)) {
  1118:                         TRACE("str_fl", tout << "integer theory assigns " << ival << " to " << mk_pp(e, get_manager()) << std::endl;);
  1119                          // if ival is non-negative, because we know the length of arg, we can add a character constraint for arg

  1147                      } else {
  1148:                         TRACE("str_fl", tout << "integer theory has no assignment for " << mk_pp(e, get_manager()) << std::endl;);
  1149                          // consistency needs to be checked after the string is assigned

  1154                      if (v.get_value(e, ival)) {
  1155:                         TRACE("str_fl", tout << "integer theory assigns " << ival << " to " << mk_pp(e, m) << std::endl;);
  1156                          if (ival >= rational::zero() && ival <= rational(u.max_char())) {

  1171                      } else {
  1172:                         TRACE("str_fl", tout << "integer theory has no assignment for " << mk_pp(e, m) << std::endl;);
  1173                          // consistency needs to be checked after the string is assigned

  1183                      }
  1184:                     TRACE("str_fl", tout << "length of term is " << slen << std::endl;);
  1185                      rational ival;
  1186                      if (v.get_value(arg, ival)) {
  1187:                         TRACE("str_fl", tout << "integer theory assigns " << ival << " to " << mk_pp(arg, get_manager()) << std::endl;);
  1188                          zstring ival_str;

  1213                      } else {
  1214:                         TRACE("str_fl", tout << "integer theory has no assignment for " << mk_pp(arg, get_manager()) << std::endl;);
  1215                          // consistency needs to be checked after the string is assigned

  1220                      if (v.get_value(arg, ival)) {
  1221:                         TRACE("str_fl", tout << "integer theory assigns " << ival << " to " << mk_pp(arg, m) << std::endl;);
  1222                          if (ival >= rational::zero() && ival <= rational(u.max_char())) {

  1238                      } else {
  1239:                         TRACE("str_fl", tout << "integer theory has no assignment for " << mk_pp(arg, m) << std::endl;);
  1240                          // consistency needs to be checked after the string is assigned

  1251  
  1252:         TRACE("str_fl",
  1253                tout << "formulas asserted to subsolver:" << std::endl;

  1270          
  1271:         TRACE("str_fl", tout << "calling subsolver" << std::endl;);
  1272  

  1275          if (subproblem_status == l_true) {
  1276:             TRACE("str_fl", tout << "subsolver found SAT; reconstructing model" << std::endl;);
  1277              model_ref subModel;

  1298              }
  1299:             TRACE("str_fl",
  1300                  for (auto entry : model) {

  1328                  for (auto e : string_int_conversion_terms) {
  1329:                     TRACE("str_fl", tout << "post-run check str-int term " << mk_pp(e, get_manager()) << std::endl;);
  1330                      expr* _arg;

  1337                              rw(arg_subst);
  1338:                             TRACE("str_fl", tout << "ival = " << ival << ", string arg evaluates to " << mk_pp(arg_subst, m) << std::endl;);
  1339  

  1365                              rw(arg_subst);
  1366:                             TRACE("str_fl", tout << "ival = " << ival << ", string arg evaluates to " << mk_pp(arg_subst, m) << std::endl;);
  1367                              zstring arg_zstr;

  1394                              rw(e_subst);
  1395:                             TRACE("str_fl", tout << "ival = " << ival << ", string arg evaluates to " << mk_pp(e_subst, m) << std::endl;);
  1396  

  1434                              rw(e_subst);
  1435:                             TRACE("str_fl", tout << "ival = " << ival << ", string arg evaluates to " << mk_pp(e_subst, m) << std::endl;);
  1436                              zstring e_zstr;

  1472                      for (auto f : abstracted_boolean_formulas) {
  1473:                         TRACE("str_fl", tout << "refinement of boolean formula: " << mk_pp(f, m) << std::endl;);
  1474                          expr_ref f_new(m);

  1476                          rw(f_new);
  1477:                         TRACE("str_fl", tout << "after substitution and simplification, evaluates to: " << mk_pp(f_new, m) << std::endl;);
  1478                          // now there are three cases, depending on what f_new evaluates to:

  1495                              } else {
  1496:                                 TRACE("str_fl", tout << "error: unhandled refinement term " << mk_pp(f, m) << std::endl;);
  1497                                  NOT_IMPLEMENTED_YET();

  1508              if (m_params.m_FixedLengthNaiveCounterexamples) {
  1509:                 TRACE("str_fl", tout << "subsolver found UNSAT; constructing length counterexample" << std::endl;);
  1510                  for (auto e : fixed_length_used_len_terms) {

  1519              } else {
  1520:                 TRACE("str_fl", tout << "subsolver found UNSAT; reconstructing unsat core" << std::endl;);
  1521:                 TRACE("str_fl", tout << "unsat core has size " << subsolver.get_unsat_core_size() << std::endl;);
  1522                  bool negate_pre = false;
  1523                  for (unsigned i = 0; i < subsolver.get_unsat_core_size(); ++i) {
  1524:                     TRACE("str", tout << "entry " << i << " = " << mk_pp(subsolver.get_unsat_core_expr(i), m) << std::endl;);
  1525                      rational index;

  1527                      expr* rhs;
  1528:                     TRACE("str_fl", tout << fixed_length_lesson.size() << std::endl;);
  1529                      std::tie(index, lhs, rhs) = fixed_length_lesson.find(subsolver.get_unsat_core_expr(i));
  1530:                     TRACE("str_fl", tout << "lesson: " << mk_pp(lhs, m) << " == " << mk_pp(rhs, m) << " at index " << index << std::endl;);
  1531                      cex.push_back(refine(lhs, rhs, index));

  1543          } else { // l_undef
  1544:             TRACE("str_fl", tout << "WARNING: subsolver found UNKNOWN" << std::endl;);
  1545              return l_undef;

z3/src/smt/theory_str_regex.cpp:
    52              if (!ctx.b_internalized(str_in_re)) {
    53:                 TRACE("str", tout << "regex term " << mk_pp(str_in_re, m) << " not internalized; fixing and continuing" << std::endl;);
    54                  ctx.internalize(str_in_re, false);

    58              lbool current_assignment = ctx.get_assignment(str_in_re);
    59:             TRACE("str", tout << "regex term: " << mk_pp(str, m) << " in " << mk_pp(re, m) << " : " << current_assignment << std::endl;);
    60              if (current_assignment == l_undef) {

    65                  if (current_assignment == l_true && check_regex_length_linearity(re)) {
    66:                     TRACE("str", tout << "regex length constraints expected to be linear -- generating and asserting them" << std::endl;);
    67  

    89                          rw(top_level_length_constraint);
    90:                         TRACE("str", tout << "top-level length constraint: " << mk_pp(top_level_length_constraint, m) << std::endl;);
    91                          // assert and track length constraint

   112              if (get_len_value(str, exact_length_value)) {
   113:                 TRACE("str", tout << "exact length of " << mk_pp(str, m) << " is " << exact_length_value << std::endl;);
   114  
   115                  if (regex_terms_with_path_constraints.contains(str_in_re)) {
   116:                     TRACE("str", tout << "term " << mk_pp(str_in_re, m) << " already has path constraints set up" << std::endl;);
   117                      continue;

   165                          if (zero_solution) {
   166:                             TRACE("str", tout << "zero-length solution OK -- asserting empty path constraint" << std::endl;);
   167                              expr_ref_vector lhs_terms(m);

   179                          } else {
   180:                             TRACE("str", tout << "zero-length solution not admitted by this automaton -- asserting conflict clause" << std::endl;);
   181                              expr_ref_vector lhs_terms(m);

   201                      if (expected_complexity <= m_params.m_RegexAutomata_DifficultyThreshold || regex_get_counter(regex_fail_count, str_in_re) >= m_params.m_RegexAutomata_FailedAutomatonThreshold) {
   202:                         CTRACE("str", regex_get_counter(regex_fail_count, str_in_re) >= m_params.m_RegexAutomata_FailedAutomatonThreshold,
   203                                  tout << "failed automaton threshold reached for " << mk_pp(str_in_re, m) << " -- automatically constructing full automaton" << std::endl;);

   205                          if (aut == nullptr) {
   206:                             TRACE("str", tout << "ERROR: symbolic automaton construction failed, likely due to non-constant term in regex" << std::endl;);
   207                              return false;

   215                          regex_automaton_assumptions[re].push_back(new_aut);
   216:                         TRACE("str", tout << "add new automaton for " << mk_pp(re, m) << ": no assumptions" << std::endl;);
   217                          find_automaton_initial_bounds(str_in_re, aut);

   228              bool upper_bound_exists = upper_bound(str_len, upper_bound_value);
   229:             CTRACE("str", lower_bound_exists, tout << "lower bound of " << mk_pp(str, m) << " is " << lower_bound_value << std::endl;);
   230:             CTRACE("str", upper_bound_exists, tout << "upper bound of " << mk_pp(str, m) << " is " << upper_bound_value << std::endl;);
   231  

   286                      if (!last_ub.is_minus_one() || !need_assumption) {
   287:                         CTRACE("str", !need_assumption, tout << "using automaton with full length information" << std::endl;);
   288:                         CTRACE("str", need_assumption, tout << "using automaton with assumed upper bound of " << last_ub << std::endl;);
   289  

   292                                  upper_bound_value, refined_upper_bound);
   293:                         TRACE("str", tout << "refined upper bound is " << refined_upper_bound <<
   294                                  (solution_at_upper_bound?", solution at upper bound":", no solution at upper bound") << std::endl;);

   343                          if (aut == nullptr) {
   344:                             TRACE("str", tout << "ERROR: symbolic automaton construction failed, likely due to non-constant term in regex" << std::endl;);
   345                              return false;

   353                          regex_automaton_assumptions[re].push_back(new_aut);
   354:                         TRACE("str", tout << "add new automaton for " << mk_pp(re, m) << ": no assumptions" << std::endl;);
   355                          find_automaton_initial_bounds(str_in_re, aut);

   394                          if (!last_lb.is_zero() || !need_assumption) {
   395:                             CTRACE("str", !need_assumption, tout << "using automaton with full length information" << std::endl;);
   396:                             CTRACE("str", need_assumption, tout << "using automaton with assumed lower bound of " << last_lb << std::endl;);
   397                              rational refined_lower_bound;

   399                                      lower_bound_value, refined_lower_bound);
   400:                             TRACE("str", tout << "refined lower bound is " << refined_lower_bound <<
   401                                      (solution_at_lower_bound?", solution at lower bound":", no solution at lower bound") << std::endl;);

   453                              if (aut == nullptr) {
   454:                                 TRACE("str", tout << "ERROR: symbolic automaton construction failed, likely due to non-constant term in regex" << std::endl;);
   455                                  return false;

   463                              regex_automaton_assumptions[re].push_back(new_aut);
   464:                             TRACE("str", tout << "add new automaton for " << mk_pp(re, m) << ": no assumptions" << std::endl;);
   465                              find_automaton_initial_bounds(str_in_re, aut);

   489                              if (aut == nullptr) {
   490:                                 TRACE("str", tout << "ERROR: symbolic automaton construction failed, likely due to non-constant term in regex" << std::endl;);
   491                                  return false;

   499                              regex_automaton_assumptions[re].push_back(new_aut);
   500:                             TRACE("str", tout << "add new automaton for " << mk_pp(re, m) << ": no assumptions" << std::endl;);
   501                              find_automaton_initial_bounds(str_in_re, aut);

   581              eautomaton * aut_inter = nullptr;
   582:             CTRACE("str", !intersect_constraints.empty(), tout << "check intersection of automata constraints for " << mk_pp(str, m) << std::endl;);
   583              for (auto aut : intersect_constraints) {
   584:                 TRACE("str",
   585                        {

   595                      }
   596:                     TRACE("str", tout << "intersection difficulty is " << intersectionDifficulty << std::endl;);
   597                      if (intersectionDifficulty <= m_params.m_RegexAutomata_IntersectionDifficultyThreshold

   618                              if (aut_c == nullptr) {
   619:                                 TRACE("str", tout << "ERROR: symbolic automaton construction failed, likely due to non-constant term in regex" << std::endl;);
   620                                  return false;

   644              }
   645:             TRACE("str", tout << "intersected " << used_intersect_constraints.size() << " constraints" << std::endl;);
   646  

   669              conflict_lhs = mk_and(conflict_terms);
   670:             TRACE("str", tout << "conflict lhs: " << mk_pp(conflict_lhs, m) << std::endl;);
   671  

   679                      if (aut_inter->get_moves_from(initial_state).empty()) {
   680:                         TRACE("str", tout << "product automaton only accepts empty string" << std::endl;);
   681                          expr_ref rhs1(ctx.mk_eq_atom(str, mk_string("")), m);

   689              if (aut_inter != nullptr && aut_inter->is_empty()) {
   690:                 TRACE("str", tout << "product automaton is empty; asserting conflict clause" << std::endl;);
   691                  expr_ref conflict_clause(m.mk_not(mk_and(conflict_terms)), m);

   738          } else {
   739:             TRACE("str", tout << "WARNING: unknown regex term " << mk_pp(re, get_manager()) << std::endl;);
   740              return 1;

   778          } else {
   779:             TRACE("str", tout << "WARNING: unknown regex term " << mk_pp(re, get_manager()) << std::endl;);
   780              return 1;

   824          } else {
   825:             TRACE("str", tout << "WARNING: unknown regex term " << mk_pp(re, get_manager()) << std::endl;);
   826              return false;

   900          } else {
   901:             TRACE("str", tout << "WARNING: unknown regex term " << mk_pp(re, get_manager()) << std::endl;);
   902              lens.reset();

   967              } else {
   968:                 TRACE("str", tout << "subterm lengths:";
   969                  for(integer_set::iterator it = subterm_lens.begin(); it != subterm_lens.end(); ++it) {

  1025          } else {
  1026:             TRACE("str", tout << "WARNING: unknown regex term " << mk_pp(re, m) << std::endl;);
  1027              expr_ref retval(m_autil.mk_ge(lenVar, m_autil.mk_numeral(rational::zero(), true)), m);

  1286              SASSERT(char_val < 256);
  1287:             TRACE("str", tout << "rewrite character constant " << char_val << std::endl;);
  1288              zstring str_const(char_val);

  1291          } else if (is_var(cond)) {
  1292:             TRACE("str", tout << "substitute var" << std::endl;);
  1293              retval = ch_var;

  1303          } else if (m.is_bool(cond)) {
  1304:             TRACE("str", tout << "rewrite boolean term " << mk_pp(cond, m) << std::endl;);
  1305              app * a_cond = to_app(cond);

  1313              retval = m.mk_app(a_cond->get_decl(), rewritten_args.data());
  1314:             TRACE("str", tout << "final rewritten term is " << mk_pp(retval, m) << std::endl;);
  1315              return retval;
  1316          } else {
  1317:             TRACE("str", tout << "ERROR: unrecognized automaton path constraint " << mk_pp(cond, m) << ", cannot translate" << std::endl;);
  1318              retval = nullptr;

  1434                          if (u.is_const_char(range_lo, lo_val) && u.is_const_char(range_hi, hi_val)) {
  1435:                             TRACE("str", tout << "make range predicate from " << lo_val << " to " << hi_val << std::endl;);
  1436                              expr_ref cond_rhs(m);

  1448                          } else {
  1449:                             TRACE("str", tout << "warning: non-bitvectors in automaton range predicate" << std::endl;);
  1450                              UNREACHABLE();

  1484          expr_ref result(mk_or(ors));
  1485:         TRACE("str", tout << "regex path constraint: " << mk_pp(result, m) << "\n";);
  1486  

z3/src/smt/theory_str.cpp:
   212          if (m.is_true(_e)) return;
   213:         TRACE("str", tout << "asserting " << mk_ismt2_pp(_e, m) << std::endl;);
   214          expr_ref e(_e, m);

   226  
   227:         //TRACE("str", tout << "done asserting " << mk_ismt2_pp(e, get_manager()) << std::endl;);
   228      }

   246          ast_manager & m = get_manager();
   247:         TRACE("str", tout << "asserting implication " << mk_ismt2_pp(premise, m) << " -> " << mk_ismt2_pp(conclusion, m) << std::endl;);
   248          expr_ref axiom(m.mk_or(mk_not(m, premise), conclusion), m);

   259  
   260:         TRACE("str", tout << "internalizing term: " << mk_ismt2_pp(term, get_manager()) << std::endl;);
   261  

   283              theory_var v_arg = mk_var(arg);
   284:             TRACE("str", tout << "arg has theory var #" << v_arg << std::endl;); (void)v_arg;
   285          }

   287          theory_var v = mk_var(e);
   288:         TRACE("str", tout << "term has theory var #" << v << std::endl;); (void)v;
   289  
   290          if (opt_EagerStringConstantLengthAssertions && u.str.is_string(term)) {
   291:             TRACE("str", tout << "eagerly asserting length of string term " << mk_pp(term, m) << std::endl;);
   292              m_basicstr_axiom_todo.insert(e);

   308          theory_var v = mk_var(en); (void)v;
   309:         TRACE("str", tout << "refresh " << mk_pp(e, get_manager()) << ": v#" << v << std::endl;);
   310          if (e->get_sort() == u.str.mk_string_sort()) {

   315      theory_var theory_str::mk_var(enode* n) {
   316:         TRACE("str", tout << "mk_var for " << mk_pp(n->get_expr(), get_manager()) << std::endl;);
   317          if (!(n->get_expr()->get_sort() == u.str.mk_string_sort())) {

   320          if (is_attached_to_var(n)) {
   321:             TRACE("str", tout << "already attached to theory var" << std::endl;);
   322              return n->get_th_var(get_id());

   325              m_find.mk_var();
   326:             TRACE("str", tout << "new theory var v#" << v << " find " << m_find.find(v) << std::endl;);
   327              ctx.attach_th_var(n, this, v);

   368              cut_var_map[baseNode].push(varInfo);
   369:             TRACE("str", tout << "add var info for baseNode=" << mk_pp(baseNode, get_manager()) << ", node=" << mk_pp(node, get_manager()) << " [" << slevel << "]" << std::endl;);
   370          } else {

   376                  cut_var_map[baseNode].push(varInfo);
   377:                 TRACE("str", tout << "add var info for baseNode=" << mk_pp(baseNode, get_manager()) << ", node=" << mk_pp(node, get_manager()) << " [" << slevel << "]" << std::endl;);
   378              } else {

   385                      cut_var_map[baseNode].push(varInfo);
   386:                     TRACE("str", tout << "add var info for baseNode=" << mk_pp(baseNode, get_manager()) << ", node=" << mk_pp(node, get_manager()) << " [" << slevel << "]" << std::endl;);
   387                  } else if (cut_var_map[baseNode].top()->level == slevel) {
   388                      cut_var_map[baseNode].top()->vars.insert(node, 1);
   389:                     TRACE("str", tout << "add var info for baseNode=" << mk_pp(baseNode, get_manager()) << ", node=" << mk_pp(node, get_manager()) << " [" << slevel << "]" << std::endl;);
   390                  } else {

   415              cut_var_map[destNode].push(varInfo);
   416:             TRACE("str", tout << "merge var info for destNode=" << mk_pp(destNode, get_manager()) << ", srcNode=" << mk_pp(srcNode, get_manager()) << " [" << slevel << "]" << std::endl;);
   417          } else {

   424                  cut_var_map[destNode].push(varInfo);
   425:                 TRACE("str", tout << "merge var info for destNode=" << mk_pp(destNode, get_manager()) << ", srcNode=" << mk_pp(srcNode, get_manager()) << " [" << slevel << "]" << std::endl;);
   426              } else if (cut_var_map[destNode].top()->level == slevel) {
   427                  cut_vars_map_copy(cut_var_map[destNode].top()->vars, cut_var_map[srcNode].top()->vars);
   428:                 TRACE("str", tout << "merge var info for destNode=" << mk_pp(destNode, get_manager()) << ", srcNode=" << mk_pp(srcNode, get_manager()) << " [" << slevel << "]" << std::endl;);
   429              } else {

   481  
   482:         TRACE("str", tout << "creating integer variable " << name << " at scope level " << sLevel << std::endl;);
   483  

   503  
   504:         TRACE("str", tout << "creating string variable " << name << " at scope level " << sLevel << std::endl;);
   505  

   509  
   510:         TRACE("str", tout << "a->get_family_id() = " << a->get_family_id() << std::endl
   511                << "this->get_family_id() = " << this->get_family_id() << std::endl;);

   519          m_basicstr_axiom_todo.push_back(ctx.get_enode(a));
   520:         TRACE("str", tout << "add " << mk_pp(a, get_manager()) << " to m_basicstr_axiom_todo" << std::endl;);
   521  

   557  
   558:         TRACE("str", tout << "creating nonempty string variable " << name << " at scope level " << sLevel << std::endl;);
   559  

   769          while (can_propagate()) {
   770:             TRACE("str", tout << "propagating..." << std::endl;);
   771              while(true) {

   779                  if (end_count > start_count) {
   780:                     TRACE("str", tout << "new basic string axiom terms added -- checking again" << std::endl;);
   781                      continue;

   786              m_basicstr_axiom_todo.reset();
   787:             TRACE("str", tout << "reset m_basicstr_axiom_todo" << std::endl;);
   788  

   837                      } else {
   838:                         TRACE("str", tout << "BUG: unhandled library-aware term " << mk_pp(e->get_expr(), get_manager()) << std::endl;);
   839                          NOT_IMPLEMENTED_YET();

   843                  if (end_count > start_count) {
   844:                     TRACE("str", tout << "new library-aware terms added during axiom setup -- checking again" << std::endl;);
   845                      continue;

   889  
   890:         TRACE("str", tout << "attempting to flatten " << mk_pp(a_cat, m) << std::endl;);
   891  

   915              } else {
   916:                 TRACE("str", tout << "non-constant term in concat -- giving up." << std::endl;);
   917                  constOK = false;

   921          if (constOK) {
   922:             TRACE("str", tout << "flattened to \"" << flattenedString.encode() << '"' << std::endl;);
   923              expr_ref constStr(mk_string(flattenedString), m);

   935          app * a_cat = cat->get_expr();
   936:         TRACE("str", tout << "instantiating concat axiom for " << mk_ismt2_pp(a_cat, m) << std::endl;);
   937          if (!u.str.is_concat(a_cat)) {

   979  
   980:         TRACE("str", tout << "set up basic string axioms on " << mk_pp(str->get_expr(), m) << std::endl;);
   981  

   985              if (a_sort != str_sort) {
   986:                 TRACE("str", tout << "WARNING: not setting up string axioms on non-string term " << mk_pp(str->get_expr(), m) << std::endl;);
   987                  return;

   992          if (str->get_iscope_lvl() > ctx.get_scope_level()) {
   993:             TRACE("str", tout << "WARNING: skipping axiom setup on out-of-scope string term" << std::endl;);
   994              return;

  1006              u.str.is_string(str->get_expr(), strconst);
  1007:             TRACE("str", tout << "instantiating constant string axioms for \"" << strconst.encode() << '"' << std::endl;);
  1008              unsigned int l = strconst.length();

  1029                  SASSERT(lhs_ge_rhs);
  1030:                 TRACE("str", tout << "string axiom 1: " << mk_ismt2_pp(lhs_ge_rhs, m) << std::endl;);
  1031                  assert_axiom(lhs_ge_rhs);

  1053                  // build LHS <=> RHS and assert
  1054:                 TRACE("str", tout << "string axiom 2: " << mk_ismt2_pp(lhs, m) << " <=> " << mk_ismt2_pp(rhs, m) << std::endl;);
  1055                  literal l(mk_eq(lhs, rhs, true));

  1084  
  1085:         TRACE("str", tout << "string-eq length-eq axiom: "
  1086                << mk_ismt2_pp(premise, m) << " -> " << mk_ismt2_pp(conclusion, m) << std::endl;);

  1094          if (axiomatized_terms.contains(expr)) {
  1095:             TRACE("str", tout << "already set up CharAt axiom for " << mk_pp(expr, m) << std::endl;);
  1096              return;

  1100  
  1101:         TRACE("str", tout << "instantiate CharAt axiom for " << mk_pp(expr, m) << std::endl;);
  1102  

  1130          if (axiomatized_terms.contains(expr)) {
  1131:             TRACE("str", tout << "already set up prefixof axiom for " << mk_pp(expr, m) << std::endl;);
  1132              return;

  1135  
  1136:         TRACE("str", tout << "instantiate prefixof axiom for " << mk_pp(expr, m) << std::endl;);
  1137  

  1167          if (axiomatized_terms.contains(expr)) {
  1168:             TRACE("str", tout << "already set up suffixof axiom for " << mk_pp(expr, m) << std::endl;);
  1169              return;

  1172  
  1173:         TRACE("str", tout << "instantiate suffixof axiom for " << mk_pp(expr, m) << std::endl;);
  1174  

  1204          if (axiomatized_terms.contains(ex)) {
  1205:             TRACE("str", tout << "already set up Contains axiom for " << mk_pp(ex, m) << std::endl;);
  1206              return;

  1213          if (u.str.is_string(ex->get_arg(0), haystackStr) && u.str.is_string(ex->get_arg(1), needleStr)) {
  1214:             TRACE("str", tout << "eval constant Contains term " << mk_pp(ex, m) << std::endl;);
  1215              if (haystackStr.contains(needleStr)) {

  1238  
  1239:         TRACE("str", tout << "instantiate Contains axiom for " << mk_pp(ex, m) << std::endl;);
  1240  

  1255          if (axiomatized_terms.contains(ex)) {
  1256:             TRACE("str", tout << "already set up str.indexof axiom for " << mk_pp(ex, m) << std::endl;);
  1257              return;

  1269              if (m_autil.is_numeral(rwex)) {
  1270:                 TRACE("str", tout << "constant expression " << mk_pp(ex, m) << " simplifies to " << mk_pp(rwex, m) << std::endl;);
  1271                  assert_axiom(ctx.mk_eq_atom(ex, rwex));

  1291  
  1292:         TRACE("str", tout << "instantiate str.indexof axiom for " << mk_pp(ex, m) << std::endl;);
  1293  

  1358          if (axiomatized_terms.contains(e)) {
  1359:             TRACE("str", tout << "already set up extended str.indexof axiom for " << mk_pp(e, m) << std::endl;);
  1360              return;

  1364  
  1365:         TRACE("str", tout << "instantiate extended str.indexof axiom for " << mk_pp(e, m) << std::endl;);
  1366  

  1502          if (axiomatized_terms.contains(expr)) {
  1503:             TRACE("str", tout << "already set up LastIndexof axiom for " << mk_pp(expr, m) << std::endl;);
  1504              return;

  1507  
  1508:         TRACE("str", tout << "instantiate LastIndexof axiom for " << mk_pp(expr, m) << std::endl;);
  1509  

  1575          if (axiomatized_terms.contains(e)) {
  1576:             TRACE("str", tout << "already set up Substr axiom for " << mk_pp(e, m) << std::endl;);
  1577              return;

  1580  
  1581:         TRACE("str", tout << "instantiate Substr axiom for " << mk_pp(e, m) << std::endl;);
  1582  

  1693          if (axiomatized_terms.contains(ex)) {
  1694:             TRACE("str", tout << "already set up Replace axiom for " << mk_pp(ex, m) << std::endl;);
  1695              return;

  1698  
  1699:         TRACE("str", tout << "instantiate Replace axiom for " << mk_pp(ex, m) << std::endl;);
  1700  

  1752          if (axiomatized_terms.contains(ex)) {
  1753:             TRACE("str", tout << "already set up str.to-int axiom for " << mk_pp(ex, m) << std::endl;);
  1754              return;

  1757  
  1758:         TRACE("str", tout << "instantiate str.to-int axiom for " << mk_pp(ex, m) << std::endl;);
  1759  

  1802          if (axiomatized_terms.contains(ex)) {
  1803:             TRACE("str", tout << "already set up str.from-int axiom for " << mk_pp(ex, m) << std::endl;);
  1804              return;

  1807  
  1808:         TRACE("str", tout << "instantiate str.from-int axiom for " << mk_pp(ex, m) << std::endl;);
  1809  

  1837          if (axiomatized_terms.contains(ex)) {
  1838:             TRACE("str", tout << "already set up str.is_digit axiom for " << mk_pp(ex, m) << std::endl;);
  1839              return;

  1842  
  1843:         TRACE("str", tout << "instantiate str.is_digit axiom for " << mk_pp(ex, m) << std::endl;);
  1844          expr * string_term = nullptr;

  1865          if (axiomatized_terms.contains(ex)) {
  1866:             TRACE("str", tout << "already set up str.from_code axiom for " << mk_pp(ex, m) << std::endl;);
  1867              return;

  1869          axiomatized_terms.insert(ex);
  1870:         TRACE("str", tout << "instantiate str.from_code axiom for " << mk_pp(ex, m) << std::endl;);
  1871  

  1901          if (axiomatized_terms.contains(ex)) {
  1902:             TRACE("str", tout << "already set up str.to_code axiom for " << mk_pp(ex, m) << std::endl;);
  1903              return;

  1905          axiomatized_terms.insert(ex);
  1906:         TRACE("str", tout << "instantiate str.to_code axiom for " << mk_pp(ex, m) << std::endl;);
  1907  

  1938          if (axiomatized_terms.contains(ex)) {
  1939:             TRACE("str", tout << "already set up RegexIn axiom for " << mk_pp(ex, m) << std::endl;);
  1940              return;

  1943  
  1944:         TRACE("str", tout << "instantiate RegexIn axiom for " << mk_pp(ex, m) << std::endl;);
  1945  

  1957          ctx.attach_th_var(n, this, v);
  1958:         TRACE("str", tout << "new theory var: " << mk_ismt2_pp(n->get_expr(), get_manager()) << " := v#" << v << std::endl;);
  1959      }

  1961      void theory_str::reset_eh() {
  1962:         TRACE("str", tout << "resetting" << std::endl;);
  1963          m_trail_stack.reset();

  1999              do {
  2000:                 TRACE("str", tout << "checking whether " << mk_pp(eqc_nn1, m) << " and " << mk_pp(eqc_nn2, m) << " can be equal" << std::endl;);
  2001                  // inconsistency check: value
  2002                  if (!can_two_nodes_eq(eqc_nn1, eqc_nn2)) {
  2003:                     TRACE("str", tout << "inconsistency detected: " << mk_pp(eqc_nn1, m) << " cannot be equal to " << mk_pp(eqc_nn2, m) << std::endl;);
  2004                      expr_ref to_assert(mk_not(m, m.mk_eq(eqc_nn1, eqc_nn2)), m);

  2009                  if (!check_length_consistency(eqc_nn1, eqc_nn2)) {
  2010:                     TRACE("str", tout << "inconsistency detected: " << mk_pp(eqc_nn1, m) << " and " << mk_pp(eqc_nn2, m) << " have inconsistent lengths" << std::endl;);
  2011                      if (opt_NoQuickReturn_IntegerTheory){
  2012:                         TRACE("str", tout << "continuing in new_eq_check() due to opt_NoQuickReturn_IntegerTheory" << std::endl;);
  2013                      } else {

  2151  
  2152:         TRACE("str", tout << "simplifying parents of " << mk_ismt2_pp(nn, m)
  2153                << " with respect to " << mk_ismt2_pp(eq_str, m) << std::endl;);

  2161              enode * n_eq_enode = ctx.get_enode(n_eqNode);
  2162:             TRACE("str", tout << "considering all parents of " << mk_ismt2_pp(n_eqNode, m) << std::endl
  2163                    << "associated n_eq_enode has " << n_eq_enode->get_num_parents() << " parents" << std::endl;);

  2177                  app * a_parent = e_parent->get_expr();
  2178:                 TRACE("str", tout << "considering parent " << mk_ismt2_pp(a_parent, m) << std::endl;);
  2179  

  2191  
  2192:                         TRACE("str",
  2193                                tout << "simplify_parent #1:" << std::endl

  2200                          if (parentLen_exists && !arg1Len_exists) {
  2201:                             TRACE("str", tout << "make up len for arg1" << std::endl;);
  2202                              expr_ref implyL11(m.mk_and(ctx.mk_eq_atom(mk_strlen(a_parent), mk_int(parentLen)),

  2262  
  2263:                         TRACE("str",
  2264                                tout << "simplify_parent #2:" << std::endl

  2271                          if (parentLen_exists && !arg0Len_exists) {
  2272:                             TRACE("str", tout << "make up len for arg0" << std::endl;);
  2273                              expr_ref implyL11(m.mk_and(ctx.mk_eq_atom(mk_strlen(a_parent), mk_int(parentLen)),

  2332                          app * a_arg1 = to_app(arg1);
  2333:                         TRACE("str", tout << "simplify_parent #3" << std::endl;);
  2334                          expr * r_concat_arg0 = a_arg1->get_arg(0);

  2356                          app * a_arg0 = to_app(arg0);
  2357:                         TRACE("str", tout << "simplify_parent #4" << std::endl;);
  2358                          expr * l_concat_arg1 = a_arg0->get_arg(1);

  2389                                  if (concat_parent_arg0 == a_parent && u.str.is_string(concat_parent_arg1)) {
  2390:                                     TRACE("str", tout << "simplify_parent #5" << std::endl;);
  2391                                      expr * combinedStr = eval_concat(eq_str, concat_parent_arg1);

  2417                                  if (concat_parent_arg1 == a_parent && u.str.is_string(concat_parent_arg0)) {
  2418:                                     TRACE("str", tout << "simplify_parent #6" << std::endl;);
  2419                                      expr * combinedStr = eval_concat(concat_parent_arg0, eq_str);

  2466              }
  2467:             TRACE("str", tout << mk_ismt2_pp(node, m) << " is simplified to " << mk_ismt2_pp(resultAst, m) << std::endl;);
  2468  
  2469              if (in_same_eqc(node, resultAst)) {
  2470:                 TRACE("str", tout << "SKIP: both concats are already in the same equivalence class" << std::endl;);
  2471              } else {

  2514              expr_ref axr(ctx.mk_eq_atom(mk_strlen(n), mk_int(nnLen)), m);
  2515:             TRACE("str", tout << "inferred (Length " << mk_pp(n, m) << ") = " << nnLen << std::endl;);
  2516              assert_implication(axl, axr);

  2688  
  2689:         TRACE("str", tout << "nn1 = " << mk_ismt2_pp(nn1, m) << std::endl
  2690                << "nn2 = " << mk_ismt2_pp(nn2, m) << std::endl;);
  2691  
  2692:         TRACE("str", tout
  2693                << "len(" << mk_pp(a1_arg0, m) << ") = " << (a1_arg0_len_exists ? a1_arg0_len.to_string() : "?") << std::endl

  2708              }
  2709:             TRACE("str", tout << "SKIP: a1_arg0 == a2_arg0" << std::endl;);
  2710              return;

  2720              }
  2721:             TRACE("str", tout << "SKIP: a1_arg1 == a2_arg1" << std::endl;);
  2722              return;

  2728              if (in_same_eqc(a1_arg1, a2_arg1)) {
  2729:                 TRACE("str", tout << "SKIP: a1_arg0 =~ a2_arg0 and a1_arg1 =~ a2_arg1" << std::endl;);
  2730                  return;
  2731              } else {
  2732:                 TRACE("str", tout << "quick path 1-1: a1_arg0 =~ a2_arg0" << std::endl;);
  2733                  expr_ref premise(m.mk_and(ctx.mk_eq_atom(nn1, nn2), ctx.mk_eq_atom(a1_arg0, a2_arg0)), m);

  2739              if (in_same_eqc(a1_arg1, a2_arg1)) {
  2740:                 TRACE("str", tout << "quick path 1-2: a1_arg1 =~ a2_arg1" << std::endl;);
  2741                  expr_ref premise(m.mk_and(ctx.mk_eq_atom(nn1, nn2), ctx.mk_eq_atom(a1_arg1, a2_arg1)), m);

  2750              if (!in_same_eqc(a1_arg0, a2_arg0)) {
  2751:                 TRACE("str", tout << "quick path 2-1: len(nn1.arg0) == len(nn2.arg0)" << std::endl;);
  2752                  expr_ref ax_l1(ctx.mk_eq_atom(nn1, nn2), m);

  2762                  if (opt_NoQuickReturn_IntegerTheory) {
  2763:                     TRACE("str", tout << "bypassing quick return from the end of this case" << std::endl;);
  2764                  } else {

  2771              if (!in_same_eqc(a1_arg1, a2_arg1)) {
  2772:                 TRACE("str", tout << "quick path 2-2: len(nn1.arg1) == len(nn2.arg1)" << std::endl;);
  2773                  expr_ref ax_l1(ctx.mk_eq_atom(nn1, nn2), m);

  2782                  if (opt_NoQuickReturn_IntegerTheory) {
  2783:                     TRACE("str", tout << "bypassing quick return from the end of this case" << std::endl;);
  2784                  } else {

  2794  
  2795:         TRACE("str", tout << "new_nn1 = " << mk_ismt2_pp(new_nn1, m) << std::endl
  2796                << "new_nn2 = " << mk_ismt2_pp(new_nn2, m) << std::endl;);

  2798          if (new_nn1 == new_nn2) {
  2799:             TRACE("str", tout << "equal concats, return" << std::endl;);
  2800              return;

  2804              expr_ref detected(mk_not(m, ctx.mk_eq_atom(new_nn1, new_nn2)), m);
  2805:             TRACE("str", tout << "inconsistency detected: " << mk_ismt2_pp(detected, m) << std::endl;);
  2806              assert_axiom(detected);

  2814          if (!n1IsConcat && n2IsConcat) {
  2815:             TRACE("str", tout << "nn1_new is not a concat" << std::endl;);
  2816              if (u.str.is_string(a_new_nn1)) {

  2820          } else if (n1IsConcat && !n2IsConcat) {
  2821:             TRACE("str", tout << "nn2_new is not a concat" << std::endl;);
  2822              if (u.str.is_string(a_new_nn2)) {

  2828              // as much as possible. however, we make a defensive check here just in case
  2829:             TRACE("str", tout << "WARNING: nn1_new and nn2_new both simplify to non-concat terms" << std::endl;);
  2830              return;

  2931  
  2932:         TRACE("str", tout << "checking whether " << mk_pp(new_nn1, m) << " and " << mk_pp(new_nn1, m) << " might overlap." << std::endl;);
  2933  

  2942                      if (is_concat_eq_type1(new_nn1, new_nn2)) {
  2943:                         TRACE("str", tout << "Type 1 check." << std::endl;);
  2944                          expr * x = to_app(new_nn1)->get_arg(0);

  2949                          if (has_self_cut(m, y)) {
  2950:                             TRACE("str", tout << "Possible overlap found" << std::endl; print_cut_var(m, tout); print_cut_var(y, tout););
  2951                              return true;
  2952                          } else if (has_self_cut(x, n)) {
  2953:                             TRACE("str", tout << "Possible overlap found" << std::endl; print_cut_var(x, tout); print_cut_var(n, tout););
  2954                              return true;

  2980                          if (has_self_cut(m, y)) {
  2981:                             TRACE("str", tout << "Possible overlap found" << std::endl; print_cut_var(m, tout); print_cut_var(y, tout););
  2982                              return true;

  3007                          if (has_self_cut(x, n)) {
  3008:                             TRACE("str", tout << "Possible overlap found" << std::endl; print_cut_var(x, tout); print_cut_var(n, tout););
  3009                              return true;

  3049                          if (has_self_cut(m, y)) {
  3050:                             TRACE("str", tout << "Possible overlap found" << std::endl; print_cut_var(m, tout); print_cut_var(y, tout););
  3051                              return true;

  3056  
  3057:         TRACE("str", tout << "warning: unrecognized concat case" << std::endl;);
  3058          return false;

  3082  
  3083:         TRACE("str", tout << "process_concat_eq TYPE 1" << std::endl
  3084                << "concatAst1 = " << mk_ismt2_pp(concatAst1, mgr) << std::endl

  3088          if (!u.str.is_concat(to_app(concatAst1))) {
  3089:             TRACE("str", tout << "concatAst1 is not a concat function" << std::endl;);
  3090              return;

  3092          if (!u.str.is_concat(to_app(concatAst2))) {
  3093:             TRACE("str", tout << "concatAst2 is not a concat function" << std::endl;);
  3094              return;

  3108          if (x_len_exists && m_len_exists) {
  3109:             TRACE("str", tout << "length values found: x/m" << std::endl;);
  3110              if (x_len < m_len) {

  3119          if (splitType == -1 && y_len_exists && n_len_exists) {
  3120:             TRACE("str", tout << "length values found: y/n" << std::endl;);
  3121              if (y_len > n_len) {

  3129  
  3130:         TRACE("str", tout
  3131                << "len(x) = " << (x_len_exists ? x_len.to_string() : "?") << std::endl

  3175  
  3176:         TRACE("str", tout << "entry 1 " << (entry1InScope ? "in scope" : "not in scope") << std::endl
  3177                << "entry 2 " << (entry2InScope ? "in scope" : "not in scope") << std::endl;);

  3250                  loopDetected = true;
  3251:                 TRACE("str", tout << "AVOID LOOP: SKIPPED" << std::endl;);
  3252:                 TRACE("str", {print_cut_var(m, tout); print_cut_var(y, tout);});
  3253  

  3312  
  3313:                 TRACE("str", tout << "AVOID LOOP: SKIPPED" << std::endl;);
  3314:                 TRACE("str", {print_cut_var(m, tout); print_cut_var(y, tout);});
  3315  

  3368  
  3369:                 TRACE("str", tout << "AVOID LOOP: SKIPPED" << std::endl;);
  3370:                 TRACE("str", {print_cut_var(m, tout); print_cut_var(y, tout);});
  3371  

  3417  
  3418:                 TRACE("str", tout << "AVOID LOOP: SKIPPED" << std::endl;);
  3419:                 TRACE("str", {print_cut_var(x, tout); print_cut_var(n, tout);});
  3420  

  3459              } else {
  3460:                 TRACE("str", tout << "STOP: no split option found for two EQ concats." << std::endl;);
  3461              }

  3489  
  3490:         TRACE("str", tout << "process_concat_eq TYPE 2" << std::endl
  3491                << "concatAst1 = " << mk_ismt2_pp(concatAst1, mgr) << std::endl

  3495          if (!u.str.is_concat(to_app(concatAst1))) {
  3496:             TRACE("str", tout << "concatAst1 is not a concat function" << std::endl;);
  3497              return;

  3499          if (!u.str.is_concat(to_app(concatAst2))) {
  3500:             TRACE("str", tout << "concatAst2 is not a concat function" << std::endl;);
  3501              return;

  3576  
  3577:         TRACE("str", tout << "entry 1 " << (entry1InScope ? "in scope" : "not in scope") << std::endl
  3578                << "entry 2 " << (entry2InScope ? "in scope" : "not in scope") << std::endl;);

  3615  
  3616:         TRACE("str", tout << "Split type " << splitType << std::endl;);
  3617  

  3662  
  3663:                     TRACE("str", tout << "AVOID LOOP: SKIP" << std::endl;);
  3664:                     TRACE("str", {print_cut_var(m, tout); print_cut_var(y, tout);});
  3665  

  3701              }
  3702:             TRACE("str",
  3703                    tout

  3737                  // negate! It's impossible to split str with these lengths
  3738:                 TRACE("str", tout << "CONFLICT: Impossible to split str with these lengths." << std::endl;);
  3739                  expr_ref ax_l(mk_and(l_items), mgr);

  3767                      loopDetected = true;
  3768:                     TRACE("str", tout << "AVOID LOOP: SKIPPED" << std::endl;);
  3769:                     TRACE("str", {print_cut_var(m, tout); print_cut_var(y, tout);});
  3770  

  3818              } else {
  3819:                 TRACE("str", tout << "STOP: Should not split two EQ concats." << std::endl;);
  3820              }

  3848  
  3849:         TRACE("str", tout << "process_concat_eq TYPE 3" << std::endl
  3850                << "concatAst1 = " << mk_ismt2_pp(concatAst1, mgr) << std::endl

  3854          if (!u.str.is_concat(to_app(concatAst1))) {
  3855:             TRACE("str", tout << "concatAst1 is not a concat function" << std::endl;);
  3856              return;

  3858          if (!u.str.is_concat(to_app(concatAst2))) {
  3859:             TRACE("str", tout << "concatAst2 is not a concat function" << std::endl;);
  3860              return;

  3928  
  3929:         TRACE("str", tout << "entry 1 " << (entry1InScope ? "in scope" : "not in scope") << std::endl
  3930                << "entry 2 " << (entry2InScope ? "in scope" : "not in scope") << std::endl;);

  3970  
  3971:         TRACE("str", tout << "Split type " << splitType << std::endl;);
  3972  

  4008                  // negate! It's impossible to split str with these lengths
  4009:                 TRACE("str", tout << "CONFLICT: Impossible to split str with these lengths." << std::endl;);
  4010                  assert_axiom(mgr.mk_not(ax_l));

  4066                      loopDetected = true;
  4067:                     TRACE("str", tout << "AVOID LOOP: SKIPPED" << std::endl;);
  4068:                     TRACE("str", {print_cut_var(x, tout); print_cut_var(n, tout);});
  4069  

  4149                      loopDetected = true;
  4150:                     TRACE("str", tout << "AVOID LOOP: SKIPPED." << std::endl;);
  4151:                     TRACE("str", {print_cut_var(x, tout); print_cut_var(n, tout);});
  4152  

  4176              } else {
  4177:                 TRACE("str", tout << "STOP: should not split two eq. concats" << std::endl;);
  4178              }

  4201          ast_manager & mgr = get_manager();
  4202:         TRACE("str", tout << "process_concat_eq TYPE 4" << std::endl
  4203                << "concatAst1 = " << mk_ismt2_pp(concatAst1, mgr) << std::endl

  4207          if (!u.str.is_concat(to_app(concatAst1))) {
  4208:             TRACE("str", tout << "concatAst1 is not a concat function" << std::endl;);
  4209              return;

  4211          if (!u.str.is_concat(to_app(concatAst2))) {
  4212:             TRACE("str", tout << "concatAst2 is not a concat function" << std::endl;);
  4213              return;

  4234          if (str1Value.extract(0, commonLen) != str2Value.extract(0, commonLen)) {
  4235:             TRACE("str", tout << "Conflict: " << mk_ismt2_pp(concatAst1, mgr)
  4236                    << " has no common prefix with " << mk_ismt2_pp(concatAst2, mgr) << std::endl;);

  4301          ast_manager & mgr = get_manager();
  4302:         TRACE("str", tout << "process_concat_eq TYPE 5" << std::endl
  4303                << "concatAst1 = " << mk_ismt2_pp(concatAst1, mgr) << std::endl

  4307          if (!u.str.is_concat(to_app(concatAst1))) {
  4308:             TRACE("str", tout << "concatAst1 is not a concat function" << std::endl;);
  4309              return;

  4311          if (!u.str.is_concat(to_app(concatAst2))) {
  4312:             TRACE("str", tout << "concatAst2 is not a concat function" << std::endl;);
  4313              return;

  4334          if (str1Value.extract(str1Len - cLen, cLen) != str2Value.extract(str2Len - cLen, cLen)) {
  4335:             TRACE("str", tout << "Conflict: " << mk_ismt2_pp(concatAst1, mgr)
  4336                    << " has no common suffix with " << mk_ismt2_pp(concatAst2, mgr) << std::endl;);

  4401          ast_manager & mgr = get_manager();
  4402:         TRACE("str", tout << "process_concat_eq TYPE 6" << std::endl
  4403                << "concatAst1 = " << mk_ismt2_pp(concatAst1, mgr) << std::endl

  4407          if (!u.str.is_concat(to_app(concatAst1))) {
  4408:             TRACE("str", tout << "concatAst1 is not a concat function" << std::endl;);
  4409              return;

  4411          if (!u.str.is_concat(to_app(concatAst2))) {
  4412:             TRACE("str", tout << "concatAst2 is not a concat function" << std::endl;);
  4413              return;

  4500  
  4501:         TRACE("str", tout << "entry 1 " << (entry1InScope ? "in scope" : "not in scope") << std::endl
  4502                << "entry 2 " << (entry2InScope ? "in scope" : "not in scope") << std::endl;);

  4551  
  4552:             TRACE("str", tout << "AVOID LOOP: SKIPPED." << std::endl;);
  4553:             TRACE("str", print_cut_var(m, tout); print_cut_var(y, tout););
  4554  

  4669           if (m_autil.is_numeral(root_e->get_expr(), val) && val.is_int()) {
  4670:              TRACE("str", tout << mk_pp(e, get_manager()) << " ~= " << mk_pp(root_e->get_expr(), get_manager()) << std::endl;);
  4671               return true;
  4672           } else {
  4673:              TRACE("str", tout << "root of eqc of " << mk_pp(e, get_manager()) << " is not a numeral" << std::endl;);
  4674               return false;

  4680          if (opt_DisableIntegerTheoryIntegration) {
  4681:             TRACE("str", tout << "WARNING: integer theory integration disabled" << std::endl;);
  4682              return false;

  4692          if (opt_DisableIntegerTheoryIntegration) {
  4693:             TRACE("str", tout << "WARNING: integer theory integration disabled" << std::endl;);
  4694              return false;

  4704          if (opt_DisableIntegerTheoryIntegration) {
  4705:             TRACE("str", tout << "WARNING: integer theory integration disabled" << std::endl;);
  4706              return false;

  4710  
  4711:         TRACE("str", tout << "checking len value of " << mk_ismt2_pp(e, m) << std::endl;);
  4712  

  4737                  // debugging
  4738:                 TRACE("str", {
  4739                          tout << mk_pp(len, m) << ":" << std::endl

  4762                      val += val1;
  4763:                     TRACE("str", tout << "integer theory: subexpression " << mk_ismt2_pp(len, m) << " has length " << val1 << std::endl;);
  4764                  }
  4765                  else {
  4766:                     TRACE("str", tout << "integer theory: subexpression " << mk_ismt2_pp(len, m) << " has no length assignment; bailing out" << std::endl;);
  4767                      return false;

  4771  
  4772:         TRACE("str", tout << "length of " << mk_ismt2_pp(e, m) << " is " << val << std::endl;);
  4773          return val.is_int() && val.is_nonneg();

  4787          if (!ctx.e_internalized(n1)) {
  4788:             TRACE("str", tout << "WARNING: expression " << mk_ismt2_pp(n1, get_manager()) << " was not internalized" << std::endl;);
  4789              ctx.internalize(n1, false);

  4791          if (!ctx.e_internalized(n2)) {
  4792:             TRACE("str", tout << "WARNING: expression " << mk_ismt2_pp(n2, get_manager()) << " was not internalized" << std::endl;);
  4793              ctx.internalize(n2, false);

  4842  
  4843:         TRACE("str", tout << "varNode = " << mk_pp(varNode, m) << ", constNode = " << mk_pp(constNode, m) << std::endl;);
  4844  

  4853                  if (!contain_pair_bool_map.find(strAst, substrAst, boolVar)) {
  4854:                     TRACE("str", tout << "warning: no entry for boolVar in contain_pair_bool_map" << std::endl;);
  4855                  }

  4859  
  4860:                 TRACE("t_str_detail", tout << "considering Contains with strAst = " << mk_pp(strAst, m) << ", substrAst = " << mk_pp(substrAst, m) << "..." << std::endl;);
  4861  
  4862                  if (varNode != strAst && varNode != substrAst) {
  4863:                     TRACE("str", tout << "varNode not equal to strAst or substrAst, skip" << std::endl;);
  4864                      continue;
  4865                  }
  4866:                 TRACE("str", tout << "varNode matched one of strAst or substrAst. Continuing" << std::endl;);
  4867  

  4888  
  4889:                         TRACE("t_str_detail", tout << "strConst = " << strConst << ", subStrConst = " << subStrConst << "\n";);
  4890  

  4924                              if (counterEgFound) {
  4925:                                 TRACE("str", tout << "Inconsistency found!" << std::endl;);
  4926                                  break;

  4983                  if (!contain_pair_bool_map.find(strAst, substrAst, boolVar)) {
  4984:                     TRACE("str", tout << "warning: no entry for boolVar in contain_pair_bool_map" << std::endl;);
  4985                  }

  4989  
  4990:                 TRACE("t_str_detail", tout << "considering Contains with strAst = " << mk_pp(strAst, m) << ", substrAst = " << mk_pp(substrAst, m) << "..." << std::endl;);
  4991  
  4992                  if (varNode != strAst && varNode != substrAst) {
  4993:                     TRACE("str", tout << "varNode not equal to strAst or substrAst, skip" << std::endl;);
  4994                      continue;
  4995                  }
  4996:                 TRACE("str", tout << "varNode matched one of strAst or substrAst. Continuing" << std::endl;);
  4997  

  5001                      if (strAstHasVal) {
  5002:                         TRACE("str", tout << mk_pp(strAst, m) << " has constant eqc value " << mk_pp(strValue, m) << std::endl;);
  5003                          if (strValue != strAst) {

  5019                                      if (!strConst.contains(pieceStr)) {
  5020:                                         TRACE("str", tout << "Inconsistency found!" << std::endl;);
  5021                                          counterEgFound = true;

  5082  
  5083:                         TRACE("str",
  5084                                tout << "(Contains " << mk_pp(n1, m) << " " << mk_pp(subAst1, m) << ")" << std::endl;

  5180                                              if (contain_pair_bool_map.contains(tryKey1)) {
  5181:                                                 TRACE("str", tout << "(Contains " << mk_pp(eqSubVar1, m) << " " << mk_pp(eqSubVar2, m) << ")" << std::endl;);
  5182                                                  litems3.push_back(contain_pair_bool_map[tryKey1]);

  5205                                              if (contain_pair_bool_map.contains(tryKey2)) {
  5206:                                                 TRACE("str", tout << "(Contains " << mk_pp(eqSubVar2, m) << " " << mk_pp(eqSubVar1, m) << ")" << std::endl;);
  5207                                                  litems4.push_back(contain_pair_bool_map[tryKey2]);

  5227  
  5228:                         TRACE("str",
  5229                                tout << "(Contains " << mk_pp(str1, m) << " " << mk_pp(n1, m) << ")" << std::endl;

  5324                                              if (contain_pair_bool_map.contains(tryKey1)) {
  5325:                                                 TRACE("str", tout << "(Contains " << mk_pp(eqStrVar1, m) << " " << mk_pp(eqStrVar2, m) << ")" << std::endl;);
  5326                                                  litems3.push_back(contain_pair_bool_map[tryKey1]);

  5350                                              if (contain_pair_bool_map.contains(tryKey2)) {
  5351:                                                 TRACE("str", tout << "(Contains " << mk_pp(eqStrVar2, m) << " " << mk_pp(eqStrVar1, m) << ")" << std::endl;);
  5352                                                  litems4.push_back(contain_pair_bool_map[tryKey2]);

  5381          ast_manager & m = get_manager();
  5382:         TRACE("str", tout << "consistency check for contains wrt. " << mk_pp(n1, m) << " and " << mk_pp(n2, m) << std::endl;);
  5383  

  5388  
  5389:         TRACE("str", tout << "eqc of n1 is {";
  5390                for (expr * el : willEqClass) {

  5570      void theory_str::print_grounded_concat(expr * node, std::map<expr*, std::map<std::vector<expr*>, std::set<expr*> > > & groundedMap) {
  5571:         TRACE("str", tout << mk_pp(node, get_manager()) << std::endl;);
  5572          if (groundedMap.find(node) != groundedMap.end()) {

  5574                  (void) itor;
  5575:                 TRACE("str",
  5576                        tout << "\t[grounded] ";

  5588          } else {
  5589:             TRACE("str", tout << "not found" << std::endl;);
  5590          }

  5849          if (u.str.is_string(n1_curr, n1_curr_str) && u.str.is_string(n2_curr, n2_curr_str)) {
  5850:             TRACE("str", tout << "checking string constants: n1=" << n1_curr_str << ", n2=" << n2_curr_str << std::endl;);
  5851              if (n1_curr_str == n2_curr_str) {

  5908                      }
  5909:                     TRACE("str", tout << "concat arg: " << mk_pp(args[i], mgr) << " has len = " << argLen.to_string() << std::endl;);
  5910                      sumLen += argLen;

  5913                          expr_ref toAssert(mgr.mk_not(mk_and(items)), mgr);
  5914:                         TRACE("str", tout << "inconsistent length: concat (len = " << sumLen << ") <==> string constant (len = " << strLen << ")" << std::endl;);
  5915                          assert_axiom(toAssert);

  5923              if (oLen_exists && oLen != strLen) {
  5924:                 TRACE("str", tout << "inconsistent length: var (len = " << oLen << ") <==> string constant (len = " << strLen << ")" << std::endl;);
  5925                  expr_ref l(ctx.mk_eq_atom(n1, constStr), mgr);

  6001          if (conflict) {
  6002:             TRACE("str", tout << "inconsistent length detected in concat <==> concat" << std::endl;);
  6003              expr_ref toAssert(mgr.mk_not(mk_and(items)), mgr);

  6031                      if (sumLen > varLen) {
  6032:                         TRACE("str", tout << "inconsistent length detected in concat <==> var" << std::endl;);
  6033                          items.push_back(ctx.mk_eq_atom(mk_strlen(var), mk_int(varLen)));

  6052          if (var1Len_exists && var2Len_exists && var1Len != var2Len) {
  6053:             TRACE("str", tout << "inconsistent length detected in var <==> var" << std::endl;);
  6054              expr_ref_vector items(mgr);

  6134  
  6135:         TRACE("str", tout << mk_ismt2_pp(concat, m) << " == " << mk_ismt2_pp(str, m) << std::endl;);
  6136  

  6144              if (const_str.empty()) {
  6145:                 TRACE("str", tout << "quick path: concat == \"\"" << std::endl;);
  6146                  // assert the following axiom:

  6163              if (arg1 != a1 || arg2 != a2) {
  6164:                 TRACE("str", tout << "resolved concat argument(s) to eqc string constants" << std::endl;);
  6165                  expr_ref_vector item1(m);

  6188                  // Case 1: Concat(const, const) == const
  6189:                 TRACE("str", tout << "Case 1: Concat(const, const) == const" << std::endl;);
  6190                  zstring arg1_str, arg2_str;

  6196                      // Inconsistency
  6197:                     TRACE("str", tout << "inconsistency detected: \""
  6198                            << arg1_str << "\" + \"" << arg2_str <<

  6206                  // Case 2: Concat(var, const) == const
  6207:                 TRACE("str", tout << "Case 2: Concat(var, const) == const" << std::endl;);
  6208                  zstring arg2_str;

  6213                      // Inconsistency
  6214:                     TRACE("str", tout << "inconsistency detected: \""
  6215                            << arg2_str <<

  6227                          // Inconsistency
  6228:                         TRACE("str", tout << "inconsistency detected: "
  6229                                << "suffix of concatenation result expected \"" << secondPart << "\", "

  6245                  // Case 3: Concat(const, var) == const
  6246:                 TRACE("str", tout << "Case 3: Concat(const, var) == const" << std::endl;);
  6247                  zstring arg1_str;

  6252                      // Inconsistency
  6253:                     TRACE("str", tout << "inconsistency detected: \""
  6254                            << arg1_str <<

  6266                          // Inconsistency
  6267:                         TRACE("str", tout << "inconsistency detected: "
  6268                                << "prefix of concatenation result expected \"" << secondPart << "\", "

  6284                  // Case 4: Concat(var, var) == const
  6285:                 TRACE("str", tout << "Case 4: Concat(var, var) == const" << std::endl;);
  6286                  if (eval_concat(arg1, arg2) == nullptr) {

  6296                              if (arg1Len.is_neg()) {
  6297:                                 TRACE("str", tout << "length conflict: arg1Len = " << arg1Len << ", concatStrLen = " << concatStrLen << std::endl;);
  6298                                  expr_ref toAssert(m_autil.mk_ge(mk_strlen(arg1), mk_int(0)), m);

  6301                              } else if (arg1Len > concatStrLen) {
  6302:                                 TRACE("str", tout << "length conflict: arg1Len = " << arg1Len << ", concatStrLen = " << concatStrLen << std::endl;);
  6303                                  expr_ref ax_r1(m_autil.mk_le(mk_strlen(arg1), mk_int(concatStrLen)), m);

  6314                              if (arg2Len.is_neg()) {
  6315:                                 TRACE("str", tout << "length conflict: arg2Len = " << arg2Len << ", concatStrLen = " << concatStrLen << std::endl;);
  6316                                  expr_ref toAssert(m_autil.mk_ge(mk_strlen(arg2), mk_int(0)), m);

  6319                              } else if (arg2Len > concatStrLen) {
  6320:                                 TRACE("str", tout << "length conflict: arg2Len = " << arg2Len << ", concatStrLen = " << concatStrLen << std::endl;);
  6321                                  expr_ref ax_r1(m_autil.mk_le(mk_strlen(arg2), mk_int(concatStrLen)), m);

  6366                          if (entry1 == varForBreakConcat.end()) {
  6367:                             TRACE("str", tout << "key1 no entry" << std::endl;);
  6368                              entry1InScope = false;

  6371                              entry1InScope = true;
  6372:                             TRACE("str", tout << "key1 entry" << std::endl;);
  6373                              /*
  6374                                if (internal_variable_set.find((entry1->second)[0]) == internal_variable_set.end()) {
  6375:                               TRACE("str", tout << "key1 entry not in scope" << std::endl;);
  6376                                entry1InScope = false;
  6377                                } else {
  6378:                               TRACE("str", tout << "key1 entry in scope" << std::endl;);
  6379                                entry1InScope = true;

  6385                          if (entry2 == varForBreakConcat.end()) {
  6386:                             TRACE("str", tout << "key2 no entry" << std::endl;);
  6387                              entry2InScope = false;

  6390                              entry2InScope = true;
  6391:                             TRACE("str", tout << "key2 entry" << std::endl;);
  6392                              /*
  6393                                if (internal_variable_set.find((entry2->second)[0]) == internal_variable_set.end()) {
  6394:                               TRACE("str", tout << "key2 entry not in scope" << std::endl;);
  6395                                entry2InScope = false;
  6396                                } else {
  6397:                               TRACE("str", tout << "key2 entry in scope" << std::endl;);
  6398                                entry2InScope = true;

  6402  
  6403:                         TRACE("str", tout << "entry 1 " << (entry1InScope ? "in scope" : "not in scope") << std::endl
  6404                                << "entry 2 " << (entry2InScope ? "in scope" : "not in scope") << std::endl;);

  6487          if (lhs_sort != str_sort || rhs_sort != str_sort) {
  6488:             TRACE("str", tout << "skip equality: not String sort" << std::endl;);
  6489              return;

  6508              if (nn1_arg0 == nn2_arg0 && in_same_eqc(nn1_arg1, nn2_arg1)) {
  6509:                 TRACE("str", tout << "skip: lhs arg0 == rhs arg0" << std::endl;);
  6510                  return;

  6513              if (nn1_arg1 == nn2_arg1 && in_same_eqc(nn1_arg0, nn2_arg0)) {
  6514:                 TRACE("str", tout << "skip: lhs arg1 == rhs arg1" << std::endl;);
  6515                  return;

  6519          if (opt_DeferEQCConsistencyCheck) {
  6520:             TRACE("str", tout << "opt_DeferEQCConsistencyCheck is set; deferring new_eq_check call" << std::endl;);
  6521          } else {

  6544  
  6545:         TRACE("str",
  6546                tout << "lhs eqc:" << std::endl;

  6662                              if (will_result_in_overlap(concat_lhs, concat_rhs)) {
  6663:                                 TRACE("str", tout << "Concats " << mk_pp(concat_lhs, m) << " and "
  6664                                          << mk_pp(concat_rhs, m) << " will result in overlap; skipping." << std::endl;);
  6665                              } else {
  6666:                                 TRACE("str", tout << "Concats " << mk_pp(concat_lhs, m) << " and "
  6667                                          << mk_pp(concat_rhs, m) << " won't overlap. Simplifying here." << std::endl;);

  6674                      if (!found) {
  6675:                         TRACE("str", tout << "All pairs of concats expected to overlap, falling back." << std::endl;);
  6676                          simplify_concat_equality(*(eqc_concat_lhs.begin()), *(eqc_concat_rhs.begin()));

  6718          if (u.str.is_replace_all(ex) || u.str.is_replace_re(ex) || u.str.is_replace_re_all(ex)) {
  6719:             TRACE("str", tout << "ERROR: Z3str3 has encountered an unsupported operator. Aborting." << std::endl;);
  6720              m.raise_exception("Z3str3 encountered an unsupported operator.");

  6723          if (ex_sort == str_sort) {
  6724:             TRACE("str", tout << "setting up axioms for " << mk_ismt2_pp(ex, get_manager()) <<
  6725                    ": expr is of sort String" << std::endl;);

  6729              m_basicstr_axiom_todo.push_back(n);
  6730:             TRACE("str", tout << "add " << mk_pp(ex, m) << " to m_basicstr_axiom_todo" << std::endl;);
  6731  

  6744                  } else if (u.str.is_itos(ap)) {
  6745:                     TRACE("str", tout << "found string-integer conversion term: " << mk_pp(ex, get_manager()) << std::endl;);
  6746                      string_int_conversion_terms.push_back(ap);

  6749                  } else if (u.str.is_from_code(ap)) {
  6750:                     TRACE("str", tout << "found string-codepoint conversion term: " << mk_pp(ex, get_manager()) << std::endl;);
  6751                      string_int_conversion_terms.push_back(ap);

  6755                      // if ex is a variable, add it to our list of variables
  6756:                     TRACE("str", tout << "tracking variable " << mk_ismt2_pp(ap, get_manager()) << std::endl;);
  6757                      variable_set.insert(ex);

  6760                      theory_var v = mk_var(n);
  6761:                     TRACE("str", tout << "variable " << mk_ismt2_pp(ap, get_manager()) << " is #" << v << std::endl;);
  6762                      (void)v;

  6765          } else if (ex_sort == bool_sort && !is_quantifier(ex)) {
  6766:             TRACE("str", tout << "setting up axioms for " << mk_ismt2_pp(ex, get_manager()) <<
  6767                    ": expr is of sort Bool" << std::endl;);

  6782              } else {
  6783:                 TRACE("str", tout << "WARNING: Bool term " << mk_ismt2_pp(ex, get_manager()) << " not internalized. Delaying axiom setup to prevent a crash." << std::endl;);
  6784                  ENSURE(!search_started); // infinite loop prevention

  6788          } else if (ex_sort == int_sort) {
  6789:             TRACE("str", tout << "setting up axioms for " << mk_ismt2_pp(ex, get_manager()) <<
  6790                    ": expr is of sort Int" << std::endl;);

  6800                  } else if (u.str.is_stoi(ap)) {
  6801:                     TRACE("str", tout << "found string-integer conversion term: " << mk_pp(ex, get_manager()) << std::endl;);
  6802                      string_int_conversion_terms.push_back(ap);

  6805                  } else if (u.str.is_to_code(ex)) {
  6806:                     TRACE("str", tout << "found string-codepoint conversion term: " << mk_pp(ex, get_manager()) << std::endl;);
  6807                      string_int_conversion_terms.push_back(ap);

  6813              if (u.str.is_non_string_sequence(ex)) {
  6814:                 TRACE("str", tout << "ERROR: Z3str3 does not support non-string sequence terms. Aborting." << std::endl;);
  6815                  m.raise_exception("Z3str3 does not support non-string sequence terms.");
  6816              }
  6817:             TRACE("str", tout << "setting up axioms for " << mk_ismt2_pp(ex, get_manager()) <<
  6818                    ": expr is of wrong sort, ignoring" << std::endl;);

  6831      void theory_str::add_theory_assumptions(expr_ref_vector & assumptions) {
  6832:         TRACE("str", tout << "add overlap assumption for theory_str" << std::endl;);
  6833          const char* strOverlap = "!!TheoryStrOverlapAssumption!!";

  6848              if (e1 == e2) {
  6849:                 TRACE("str", tout << "overlap detected in unsat core, changing UNSAT to UNKNOWN" << std::endl;);
  6850                  return l_undef;

  6860  
  6861:         TRACE("str",
  6862                tout << "dumping all asserted formulas:" << std::endl;

  6869  
  6870:         TRACE("str",
  6871              expr_ref_vector formulas(get_manager());

  6889  
  6890:         TRACE("str", tout << "search started" << std::endl;);
  6891          search_started = true;

  6894      void theory_str::new_eq_eh(theory_var x, theory_var y) {
  6895:         //TRACE("str", tout << "new eq: v#" << x << " = v#" << y << std::endl;);
  6896:         TRACE("str", tout << "new eq: " << mk_ismt2_pp(get_enode(x)->get_expr(), get_manager()) << " = " <<
  6897                mk_ismt2_pp(get_enode(y)->get_expr(), get_manager()) << std::endl;);

  6911      void theory_str::new_diseq_eh(theory_var x, theory_var y) {
  6912:         //TRACE("str", tout << "new diseq: v#" << x << " != v#" << y << std::endl;);
  6913:         TRACE("str", tout << "new diseq: " << mk_ismt2_pp(get_enode(x)->get_expr(), get_manager()) << " != " <<
  6914                mk_ismt2_pp(get_enode(y)->get_expr(), get_manager()) << std::endl;);

  6918      void theory_str::relevant_eh(app * n) {
  6919:         TRACE("str", tout << "relevant: " << mk_ismt2_pp(n, get_manager()) << std::endl;);
  6920      }

  6924          expr * e = ctx.bool_var2expr(v);
  6925:         TRACE("str", tout << "assert: v" << v << " " << mk_pp(e, get_manager()) << " is_true: " << is_true << std::endl;);
  6926          DEBUG_CODE(

  6955          VERIFY(u.str.is_prefix(e, needle, haystack));
  6956:         TRACE("str", tout << "check consistency of prefix predicate: " << mk_pp(needle, m) << " prefixof " << mk_pp(haystack, m) << std::endl;);
  6957  

  6963                      if (! ('0' <= needleStringConstant[i] && needleStringConstant[i] <= '9')) {
  6964:                         TRACE("str", tout << "conflict: needle = \"" << needleStringConstant << "\" contains non-digit character, but is a prefix of int-to-string term" << std::endl;);
  6965                          expr_ref premise(ctx.mk_eq_atom(needle, mk_string(needleStringConstant)), m);

  6982          VERIFY(u.str.is_suffix(e, needle, haystack));
  6983:         TRACE("str", tout << "check consistency of suffix predicate: " << mk_pp(needle, m) << " suffixof " << mk_pp(haystack, m) << std::endl;);
  6984  

  6990                      if (! ('0' <= needleStringConstant[i] && needleStringConstant[i] <= '9')) {
  6991:                         TRACE("str", tout << "conflict: needle = \"" << needleStringConstant << "\" contains non-digit character, but is a suffix of int-to-string term" << std::endl;);
  6992                          expr_ref premise(ctx.mk_eq_atom(needle, mk_string(needleStringConstant)), m);

  7009          VERIFY(u.str.is_contains(e, haystack, needle)); // first string contains second one
  7010:         TRACE("str", tout << "check consistency of contains predicate: " << mk_pp(haystack, m) << " contains " << mk_pp(needle, m) << std::endl;);
  7011  

  7017                      if (! ('0' <= needleStringConstant[i] && needleStringConstant[i] <= '9')) {
  7018:                         TRACE("str", tout << "conflict: needle = \"" << needleStringConstant << "\" contains non-digit character, but int-to-string term contains it" << std::endl;);
  7019                          expr_ref premise(ctx.mk_eq_atom(needle, mk_string(needleStringConstant)), m);

  7035          sLevel += 1;
  7036:         TRACE("str", tout << "push to " << sLevel << std::endl;);
  7037          TRACE_CODE(if (is_trace_enabled("t_str_dump_assign_on_scope_change")) { dump_assignments(); });

  7058                          && internal_variable_set.find(ex) == internal_variable_set.end()) {
  7059:                         TRACE("str", tout << "WARNING: possible reference to out-of-scope variable " << mk_pp(ex, m) << std::endl;);
  7060                      }

  7078  
  7079:         TRACE("str", tout << "checking scopes of variables in the current assignment" << std::endl;);
  7080  

  7095          sLevel -= num_scopes;
  7096:         TRACE("str", tout << "pop " << num_scopes << " to " << sLevel << std::endl;);
  7097          candidate_model.reset();

  7112              while ((!val.empty()) && (val.top()->level != 0) && (val.top()->level >= sLevel)) {
  7113:                 // TRACE("str", tout << "remove cut info for " << mk_pp(e, get_manager()) << std::endl; print_cut_var(e, tout););
  7114                  // T_cut * aCut = val.top();

  7127          for (enode* e : m_basicstr_axiom_todo) {
  7128:             TRACE("str", tout << "consider deleting " << mk_pp(e->get_expr(), get_manager())
  7129                    << ", enode scope level is " << e->get_iscope_lvl()

  7139              for (expr * e : m_persisted_axioms) {
  7140:                 TRACE("str", tout << "persist axiom: " << mk_pp(e, get_manager()) << std::endl;);
  7141                  m_persisted_axiom_todo.push_back(e);

  7194              if (varMap[node] != 1) {
  7195:                 TRACE("str", tout << "new variable: " << mk_pp(node, get_manager()) << std::endl;);
  7196              }

  7248              if (m.is_eq(argAst)) {
  7249:                 TRACE("str", tout
  7250                        << "eq ast " << mk_pp(argAst, m) << " is between args of sort "

  7423              if (internal_variable_set.find(var) == internal_variable_set.end()) {
  7424:                 TRACE("str", tout << "new variable: " << mk_pp(var, m) << std::endl;);
  7425                  strVarMap[var] = 1;

  7576          // print some debugging info
  7577:         TRACE("str", trace_ctx_dep(tout, aliasIndexMap, var_eq_constStr_map,
  7578                                     var_eq_concat_map, var_eq_unroll_map,

  7624  
  7625:                     TRACE("str", tout << "var in unroll = " <<
  7626                            mk_ismt2_pp(itor2.first, m) << std::endl

  7793          // print the dependence map
  7794:         TRACE("str",
  7795                tout << "Dependence Map" << std::endl;

  7978          if (Ival_exists) {
  7979:             TRACE("str", tout << "integer theory assigns " << mk_pp(a, m) << " = " << Ival.to_string() << std::endl;);
  7980              // if that value is not -1, and we know the length of S, we can assert (str.to.int S) = Ival --> S = "0...(len(S)-len(Ival))...0" ++ "Ival"

  8008          } else {
  8009:             TRACE("str", tout << "integer theory has no assignment for " << mk_pp(a, m) << std::endl;);
  8010              expr_ref is_zero(ctx.mk_eq_atom(a, m_autil.mk_int(0)), m);

  8012              axiomAdd = true;
  8013:             TRACE("str", ctx.display(tout););
  8014          }

  8061              u.str.is_string(Sval_expr, Sval);
  8062:             TRACE("str", tout << "string theory assigns " << mk_pp(a, m) << " = \"" << Sval << "\"\n";);
  8063              // empty string --> integer value < 0

  8069                  if (firstChar == '0' && !(Sval == zstring("0"))) {
  8070:                     TRACE("str", tout << "str.from-int argument " << Sval << " contains leading zeroes" << std::endl;);
  8071                      expr_ref axiom(m.mk_not(ctx.mk_eq_atom(a, mk_string(Sval))), m);

  8094          } else {
  8095:             TRACE("str", tout << "string theory has no assignment for " << mk_pp(a, m) << std::endl;);
  8096              // see if the integer theory has assigned N yet

  8114              } else {
  8115:                 TRACE("str", tout << "integer theory has no assignment for " << mk_pp(N, m) << std::endl;);
  8116                  expr_ref is_zero(ctx.mk_eq_atom(N, m_autil.mk_int(0)), m);

  8118                  axiomAdd = true;
  8119:                 TRACE("str", ctx.display(tout););
  8120              }

  8151  
  8152:         TRACE("str", tout << "propagate_length_within_eqc: " << mk_ismt2_pp(var, m) << std::endl ;);
  8153  

  8180                  assert_implication(axl, axr);
  8181:                 TRACE("str", tout <<  mk_ismt2_pp(axl, m) << std::endl << "  --->  " << std::endl <<  mk_ismt2_pp(axr, m););
  8182                  res = true;

  8211                      // but all leaf nodes have length information
  8212:                     TRACE("str", tout << "* length pop-up: " <<  mk_ismt2_pp(concat, m) << "| = " << lenValue << std::endl;);
  8213                      std::set<expr*> leafNodes;

  8232                          assert_implication(axl, axr);
  8233:                         TRACE("str", tout <<  mk_ismt2_pp(axl, m) << std::endl << "  --->  " << std::endl <<  mk_ismt2_pp(axr, m)<< std::endl;);
  8234                          axiomAdded = true;

  8278  
  8279:         TRACE("str", tout << "final check" << std::endl;);
  8280          TRACE_CODE(if (is_trace_enabled("t_str_dump_assign")) { dump_assignments(); });

  8283          if (opt_DeferEQCConsistencyCheck) {
  8284:             TRACE("str", tout << "performing deferred EQC consistency check" << std::endl;);
  8285              std::set<enode*> eqc_roots;

  8295                  if (!(a->get_sort() == u.str.mk_string_sort())) {
  8296:                     TRACE("str", tout << "EQC root " << mk_pp(a, m) << " not a string term; skipping" << std::endl;);
  8297                  } else {
  8298:                     TRACE("str", tout << "EQC root " << mk_pp(a, m) << " is a string term. Checking this EQC" << std::endl;);
  8299                      // first call check_concat_len_in_eqc() on each member of the eqc

  8304                          if (!status) {
  8305:                             TRACE("str", tout << "concat-len check asserted an axiom on " << mk_pp(e_it->get_expr(), m) << std::endl;);
  8306                              found_inconsistency = true;

  8314                      if (e1 != e2) {
  8315:                         TRACE("str", tout << "deferred new_eq_check() over EQC of " << mk_pp(e1->get_expr(), m) << " and " << mk_pp(e2->get_expr(), m) << std::endl;);
  8316                          bool result = new_eq_check(e1->get_expr(), e2->get_expr());
  8317                          if (!result) {
  8318:                             TRACE("str", tout << "new_eq_check found inconsistencies" << std::endl;);
  8319                              found_inconsistency = true;

  8325              if (found_inconsistency) {
  8326:                 TRACE("str", tout << "Found inconsistency in final check! Returning to search." << std::endl;);
  8327                  return FC_CONTINUE;
  8328              } else {
  8329:                 TRACE("str", tout << "Deferred consistency check passed. Continuing in final check." << std::endl;);
  8330              }

  8358                  if (concat_lhs_haseqc && concat_rhs_haseqc && !var_haseqc) {
  8359:                     TRACE("str", tout << "backpropagate into " << mk_pp(var, m) << " = " << mk_pp(concat, m) << std::endl
  8360                            << "LHS ~= " << mk_pp(concat_lhs_str, m) << " RHS ~= " << mk_pp(concat_rhs_str, m) << std::endl;);

  8392          if (backpropagation_occurred) {
  8393:             TRACE("str", tout << "Resuming search due to axioms added by backpropagation." << std::endl;);
  8394              return FC_CONTINUE;

  8404              if (length_propagation_occurred) {
  8405:                 TRACE("str", tout << "Resuming search due to axioms added by length propagation." << std::endl;);
  8406                  return FC_CONTINUE;

  8410          if (!solve_regex_automata()) {
  8411:             TRACE("str", tout << "regex engine requested to give up!" << std::endl;);
  8412              return FC_GIVEUP;

  8421                      // this can be ignored, I think
  8422:                     TRACE("str", tout << "free internal variable " << mk_pp(itor.first, m) << " ignored" << std::endl;);
  8423                      continue;

  8427                  if (!hasEqcValue) {
  8428:                     TRACE("str", tout << "found free variable " << mk_pp(itor.first, m) << std::endl;);
  8429                      needToAssignFreeVars = true;

  8433                      // debug
  8434:                     // TRACE("str", tout << "variable " << mk_pp(itor->first, m) << " = " << mk_pp(eqcString, m) << std::endl;);
  8435                  }

  8465              if (addedStrIntAxioms) {
  8466:                 TRACE("str", tout << "Resuming search due to addition of string-integer conversion axioms." << std::endl;);
  8467                  return FC_CONTINUE;

  8488                              if (current_assignment == l_false) {
  8489:                                 TRACE("str", tout << "regex conflict: " << mk_pp(str, m) << " = \"" << strValue << "\" but must not be in the language " << mk_pp(re, m) << std::endl;);
  8490                                  expr_ref conflictClause(m.mk_or(m.mk_not(ctx.mk_eq_atom(str, mk_string(strValue))), str_in_re), m);

  8496                              if (current_assignment == l_true) {
  8497:                                 TRACE("str", tout << "regex conflict: " << mk_pp(str, m) << " = \"" << strValue << "\" but must be in the language " << mk_pp(re, m) << std::endl;);
  8498                                  expr_ref conflictClause(m.mk_or(m.mk_not(ctx.mk_eq_atom(str, mk_string(strValue))), m.mk_not(str_in_re)), m);

  8517                      if (!existNegativeContains) {
  8518:                         TRACE("str", tout << "All variables are assigned. Done!" << std::endl;);
  8519                          m_stats.m_solved_by = 2;

  8522                  } else {
  8523:                     TRACE("str", tout << "Assigning decoy values to free internal variables." << std::endl;);
  8524                      for (auto const &var : unused_internal_variables) {

  8532  
  8533:         CTRACE("str", needToAssignFreeVars,
  8534                 tout << "Need to assign values to the following free variables:" << std::endl;

  8547          {
  8548:             TRACE("str", tout << "free var map (#" << freeVar_map.size() << "):" << std::endl;
  8549                    for (auto const &freeVarItor1 : freeVar_map) {

  8562              // that work might be useless
  8563:             TRACE("str", tout << "using fixed-length model construction" << std::endl;);
  8564  

  8568              if (arith_fc_status != FC_DONE) {
  8569:                 TRACE("str", tout << "arithmetic solver not done yet, continuing search" << std::endl;);
  8570                  return FC_CONTINUE;
  8571              }
  8572:             TRACE("str", tout << "arithmetic solver done in final check" << std::endl;);
  8573  

  8588              } else { // model_status == l_undef
  8589:                 TRACE("str", tout << "fixed-length model construction found missing side conditions; continuing search" << std::endl;);
  8590                  return FC_CONTINUE;

  8594          if (opt_VerifyFinalCheckProgress && !finalCheckProgressIndicator) {
  8595:             TRACE("str", tout << "BUG: no progress in final check, giving up!!" << std::endl;);
  8596              m.raise_exception("no progress in theory_str final check");

  8629      void theory_str::init_model(model_generator & mg) {
  8630:         //TRACE("str", tout << "initializing model" << std::endl; display(tout););
  8631          m_factory = alloc(str_value_factory, get_manager(), get_family_id());

  8703      model_value_proc * theory_str::mk_value(enode * n, model_generator & mg) {
  8704:         TRACE("str", tout << "mk_value for: " << mk_ismt2_pp(n->get_expr(), get_manager()) <<
  8705                " (sort " << mk_ismt2_pp(n->get_expr()->get_sort(), get_manager()) << ")" << std::endl;);

  8716          } else {
  8717:             TRACE("str", tout << "WARNING: failed to find a concrete value, falling back" << std::endl;);
  8718              std::ostringstream unused;

  8732  
  8733:         TRACE("str_fl", tout << "finding length for " << mk_ismt2_pp(ex, m) << std::endl;);
  8734          if (u.str.is_string(ex)) {

  8780          } else if (u.str.is_replace(ex)) {
  8781:             TRACE("str_fl", tout << "replace is like contains---not in conjunctive fragment!" << std::endl;);
  8782              UNREACHABLE();

  8788      expr* theory_str::refine(expr* lhs, expr* rhs, rational offset) {
  8789:         // TRACE("str", tout << "refine with " << offset.get_unsigned() << std::endl;);
  8790          if (offset >= rational(0)) {

  8814      expr* theory_str::refine_eq(expr* lhs, expr* rhs, unsigned _offset) {
  8815:         TRACE("str_fl", tout << "refine eq " << _offset << std::endl;);
  8816          ast_manager & m = get_manager();

  8923              expr* sublen_eq = ctx.mk_eq_atom(left_sublen, right_sublen);
  8924:             TRACE("str", tout << "sublen_eq " << mk_pp(sublen_eq, m) << std::endl;);
  8925              diseqs.push_back(sublen_eq);

  8927          if (extra_left_cond != nullptr) {
  8928:             TRACE("str", tout << "extra_left_cond " << mk_pp(extra_left_cond, m) << std::endl;);
  8929              diseqs.push_back(extra_left_cond);

  8931          if (extra_right_cond != nullptr) {
  8932:             TRACE("str", tout << "extra_right_cond " << mk_pp(extra_right_cond, m) << std::endl;);
  8933              diseqs.push_back(extra_right_cond);

  8936              diseqs.push_back(m.mk_and(extra_deps.size(), extra_deps.data()));
  8937:             TRACE("str", tout << "extra_deps " << mk_pp(diseqs.get(diseqs.size()-1), m) << std::endl;);
  8938          }
  8939          expr* final_diseq = m.mk_and(diseqs.size(), diseqs.data());
  8940:         TRACE("str", tout << "learning not " << mk_pp(final_diseq, m) << std::endl;);
  8941          return final_diseq;

  8948          lesson = m.mk_not(m.mk_eq(lhs, rhs));
  8949:         TRACE("str", tout << "learning not " << mk_pp(lesson, m) << std::endl;);
  8950          return lesson;

  8954          //Can we learn something better?
  8955:         TRACE("str", tout << "learning not " << mk_pp(f, get_manager()) << std::endl;);
  8956          return f;

  8979          }
  8980:         TRACE("str", tout << "non string term!" << mk_pp(ex, m) << std::endl;);
  8981          return false;

z3/src/smt/theory_str.h:
   78          }
   79:         TRACE("t_str", tout << "unexpected sort in get_fresh_value(): " << mk_pp(s, m_manager) << std::endl;);
   80          UNREACHABLE(); return nullptr;

   95      void undo() override {
   96:         TRACE("t_str_binary_search", tout << "in binary_search_trail::undo()" << std::endl;);
   97          if (target.contains(entry)) {

  100              } else {
  101:                 TRACE("t_str_binary_search", tout << "WARNING: attempt to remove length tester from an empty stack" << std::endl;);
  102              }
  103          } else {
  104:             TRACE("t_str_binary_search", tout << "WARNING: attempt to access length tester map via invalid key" << std::endl;);
  105          }

z3/src/smt/theory_user_propagator.cpp:
   52      ctx.get_rewriter()(e, r);
   53:     TRACE("user_propagate", tout << "add " << mk_bounded_pp(e, m) << "\n");
   54      if (r != e) {

   89      expr* conseq) {
   90:     CTRACE("user_propagate", ctx.lit_internalized(conseq) && ctx.get_assignment(ctx.get_literal(conseq)) == l_true,
   91             ctx.display(tout << "redundant consequence: " << mk_pp(conseq, m) << "\n"));

  148      }
  149:     CTRACE("user_propagate", can_propagate(), tout << "can propagate\n");
  150      propagate();
  151:     CTRACE("user_propagate", ctx.inconsistent(), tout << "inconsistent\n");
  152      // check if it became inconsistent or something new was propagated/registered

  313      
  314:     TRACE("user_propagate", tout << "propagating #" << prop.m_conseq->get_id() << ": " << prop.m_conseq << "\n";
  315            for (auto const& [a,b] : m_eqs) tout << enode_pp(a, ctx) << " == " << enode_pp(b, ctx) << "\n";

  357  #endif
  358:         TRACE("user_propagate", ctx.display(tout););
  359      }

  369          return;
  370:     TRACE("user_propagate", tout << "propagating queue head: " << m_qhead << " prop queue: " << m_prop.size() << "\n");
  371      force_push();

z3/src/smt/theory_utvpi_def.h:
  100          th_var v = theory::mk_var(n);
  101:         TRACE("utvpi", tout << v << " " << mk_pp(n->get_expr(), m) << "\n";);
  102          m_graph.init_var(to_var(v));

  178              
  179:             TRACE("utvpi", tout << v1 << " .. " << v2 << "\n" << eq << "\n";);
  180              

  206          IF_VERBOSE(20, ctx.display_literals_smt2(verbose_stream() << "conflict:\n", lits));
  207:         TRACE("utvpi", ctx.display_literals_smt2(tout << "conflict:\n", lits););        
  208          

  233          auto str = msg.str();
  234:         TRACE("utvpi", tout << str;);
  235          warning_msg("%s", str.c_str());

  342          
  343:         TRACE("utvpi", 
  344                tout << mk_pp(n, m) << "\n";

  356          bool result = !ctx.inconsistent() && null_theory_var != mk_term(term);
  357:         CTRACE("utvpi", !result, tout << "Did not internalize " << mk_pp(term, m) << "\n";);
  358          return result;

  506      bool theory_utvpi<Ext>::propagate_atom(atom const& a) {
  507:         TRACE("utvpi", a.display(*this, tout); tout << "\n";);       
  508          int edge_id = a.get_asserted_edge();

  518      theory_var theory_utvpi<Ext>::mk_term(app* n) {
  519:         TRACE("utvpi", tout << mk_pp(n, m) << "\n";);
  520          

  642          }            
  643:         TRACE("utvpi", tout << (pos1?"$":"-$") << v1;
  644                if (terms.size() == 2) tout << (pos2?" + $":" - $") << v2;

  759  
  760:             TRACE("utvpi", 
  761                    tout << "Disparity: " << v1 << " - " << v2 << "\n";

  772              }    
  773:             TRACE("utvpi", display(tout););
  774              SASSERT(m_graph.is_feasible_dbg());     

  833              (void)ok;
  834:             CTRACE("utvpi", !ok, 
  835                     tout << "validation failed:\n";

  842                     );
  843:             // CTRACE("utvpi",  ok, tout << "validation success: " << mk_pp(e, m) << "\n";);
  844              SASSERT(ok);

  859          }
  860:         TRACE("utvpi", tout << "expression not handled: " << mk_pp(e, m) << "\n";);
  861          return false;

  892          }
  893:         TRACE("utvpi", tout << "expression not handled: " << mk_pp(e, m) << "\n";);
  894          UNREACHABLE();

  907          SASSERT(!is_int || num.is_int());
  908:         TRACE("utvpi", 
  909                expr* n = get_enode(v)->get_expr();

  919          rational num = mk_value(v, is_int);
  920:         TRACE("utvpi", tout << mk_pp(n->get_expr(), m) << " |-> " << num << "\n";);
  921          return alloc(expr_wrapper_proc, m_factory->mk_num_value(num, is_int));

z3/src/smt/theory_wmaxsat.cpp:
   69          }
   70:         TRACE("opt",
   71                tout << "cost save: ";

  104          (void)bv;
  105:         TRACE("opt", tout << "inc: " << ctx.inconsistent() << " enable: v" << m_bool2var[bv] 
  106                << " b" << bv << " " << mk_pp(var, get_manager()) << "\n" << wfml << "\n";);

  114          m_enabled[tv] = false;
  115:         TRACE("opt", tout << "disable: v" << tv << " b" << bv << " " << mk_pp(var, get_manager()) << "\n";);
  116      }

  166              m_zcost += w;
  167:             TRACE("opt", tout << "Assign v" << tv << " weight: " << w << " cost: " << m_zcost << " " << mk_pp(m_vars[m_bool2var[v]].get(), get_manager()) << "\n";);
  168              m_costs.push_back(tv);

  180          if (m_normalize) normalize();
  181:         TRACE("opt", tout << "cost: " << m_zcost << " min cost: " << m_zmin_cost << "\n";);
  182          return FC_DONE;

  247              m_cost_save.append(m_costs);
  248:             TRACE("opt",
  249                    tout << "costs: ";

  257          expr_ref result(m.mk_or(disj.size(), disj.data()), m);
  258:         TRACE("opt",
  259                tout << result << " weight: " << weight << "\n";

  281          }
  282:         TRACE("opt", ctx.display_literals_verbose(tout, lits); tout << "\n";);
  283          

  326          }
  327:         TRACE("opt", 
  328                ctx.display_literals_verbose(tout, lits.size(), lits.data()); 

z3/src/smt/proto_model/proto_model.cpp:
   91      m_eval.set_expand_array_equalities(false);
   92:     TRACE("model_evaluator", model_v2_pp(tout, *this, true););
   93      try {

   98          (void)ex;
   99:         TRACE("model_evaluator", tout << ex.msg() << "\n";);
  100          return false;

  130  expr* proto_model::cleanup_expr(expr_ref_vector& trail, expr* fi_else, func_decl_set& found_aux_fs) {
  131:     TRACE("model_bug", tout << "cleaning up:\n" << mk_pp(fi_else, m) << "\n";);
  132      trail.reset();

  172                  if (m_aux_decls.contains(f)) {
  173:                     TRACE("model_bug", tout << f->get_name() << "\n";);
  174                      found_aux_fs.insert(f);

  212  void proto_model::cleanup() {
  213:     TRACE("model_bug", model_v2_pp(tout, *this););
  214      func_decl_set found_aux_fs;

  229      }
  230:     // TRACE("model_bug", model_v2_pp(tout, *this););
  231      // remove auxiliary declarations that are not used.

  237              if (!found_aux_fs.contains(faux)) {
  238:                 TRACE("cleanup_bug", tout << "eliminating " << faux->get_name() << " " << faux->get_ref_count() << "\n";);
  239                  unregister_decl(faux);

  243      }
  244:     TRACE("model_bug", model_v2_pp(tout, *this););
  245  }

  384  model * proto_model::mk_model() {
  385:     TRACE("proto_model", model_v2_pp(tout << "mk_model\n", *this););
  386      model * mdl = alloc(model, m);

  401          sort * s = get_uninterpreted_sort(i);
  402:         TRACE("proto_model", tout << "copying uninterpreted sorts...\n" << mk_pp(s, m) << "\n";);
  403          ptr_vector<expr> const& buf = get_universe(s);

z3/src/smt/tactic/ctx_solver_simplify_tactic.cpp:
   99              return;
  100:         TRACE("ctx_solver_simplify_tactic", g.display(tout););
  101          expr_ref fml(m);

  113          SASSERT(m_solver.get_scope_level() == 0);
  114:         TRACE("ctx_solver_simplify_tactic",
  115                for (expr* f : fmls) {

  121          {
  122:             // enable_trace("after_search");
  123              m_solver.push();

  129              lbool is_sat = m_solver.check();
  130:             TRACE("ctx_solver_simplify_tactic", tout << "is non-equivalence sat?: " << is_sat << "\n";);
  131              if (is_sat == l_true) {

  133                  m_solver.get_model(mdl);
  134:                 TRACE("ctx_solver_simplify_tactic", 
  135                        tout << "result is not equivalent to input\n";

  205              if (m.is_bool(e) && simplify_bool(n, res)) {
  206:                 TRACE("ctx_solver_simplify_tactic",
  207                      m_solver.display(tout) << "\n";

z3/src/smt/tactic/smt_tactic_core.cpp:
   56          updt_params_core(p);
   57:         TRACE("smt_tactic", tout << "p: " << p << "\n";);
   58      }

   84      void updt_params(params_ref const & p) override {
   85:         TRACE("smt_tactic", tout << "updt_params: " << p << "\n";);
   86          updt_params_core(p);

  133              smt::kernel * new_ctx = alloc(smt::kernel, m, m_params, m_params_ref);
  134:             TRACE("smt_tactic", tout << "logic: " << o.m_logic << "\n";);
  135              new_ctx->set_logic(o.m_logic);

  160              tactic_report report("smt", *in);
  161:             TRACE("smt_tactic", tout << this << "\nAUTO_CONFIG: " << fparams().m_auto_config << " HIDIV0: " << fparams().m_hi_div0 << " "
  162                    << " PREPROCESS: " << fparams().m_preprocess << "\n";

  166                    tout << "nnf: " << fparams().m_nnf_cnf << "\n";);
  167:             TRACE("smt_tactic_params", m_params.display(tout););
  168:             TRACE("smt_tactic_detail", in->display(tout););
  169:             TRACE("smt_tactic_memory", tout << "wasted_size: " << m.get_allocator().get_wasted_size() << "\n";);
  170              scoped_init_ctx  init(*this, m);

  178                  extract_clauses_and_dependencies(in, clauses, assumptions, bool2dep, fmc);
  179:                 TRACE("mus", in->display_with_dependencies(tout);
  180                        tout << clauses << "\n";);

  211              catch(...) {
  212:                 TRACE("smt_tactic", tout << "exception\n";);
  213                  m_ctx->collect_statistics(m_stats);

  218              proof_ref pr(m_ctx->get_proof(), m);
  219:             TRACE("smt_tactic", tout << r << " " << pr << "\n";);
  220              switch (r) {

  245                  if (m_fail_if_inconclusive && !in->unsat_preserved()) {
  246:                     TRACE("smt_tactic", tout << "failed to show to be unsat...\n";);
  247                      throw tactic_exception("under-approximated goal found to be unsat");

z3/src/smt/tactic/unit_subsumption_tactic.cpp:
   75          m_context.pop(2);
   76:         TRACE("unit_subsumption_tactic", g->display(tout); r->display(tout););
   77      }

  106          if (is_unsat) {            
  107:             TRACE("unit_subsumption_tactic", tout << "Removing clause " << i << "\n";);
  108              m_is_deleted.set(i, true);

z3/src/solver/check_logic.cpp:
  330      void fail_non_diff(expr * t) {
  331:         TRACE("check_logic", tout << mk_pp(t, m) << "\n";);
  332          fail("logic only supports difference arithmetic");

z3/src/solver/combined_solver.cpp:
  128      solver* translate(ast_manager& m, params_ref const& p) override {
  129:         TRACE("solver", tout << "translate\n";);
  130          solver* s1 = m_solver1->translate(m, p);

  179          m_solver2->push();        
  180:         TRACE("pop", tout << "push\n";);
  181      }

  183      void pop(unsigned n) override {
  184:         TRACE("pop", tout << n << "\n";);
  185          switch_inc_mode();

z3/src/solver/mus.cpp:
   61          m_lit2expr.push_back(lit);
   62:         TRACE("mus", tout << idx << ": " << mk_pp(lit, m) << "\n" << m_lit2expr << "\n";);
   63          return idx;

   82          expr_ref_vector core_exprs(m);
   83:         TRACE("mus", m_solver.display(tout););
   84          while (!unknown.empty()) { 
   85              IF_VERBOSE(12, verbose_stream() << "(mus reducing core: " << unknown.size() << " new core: " << mus.size() << ")\n";);
   86:             TRACE("mus", display_vec(tout << "core:  ", unknown); display_vec(tout << "mus:   ", mus););
   87              expr* lit = unknown.back();

  114                      }
  115:                     TRACE("mus", tout << "core exprs:" << core_exprs << "\n";
  116                          display_vec(tout << "core:", unknown);

  166              case l_true: {
  167:                 TRACE("mus", tout << "literal can be satisfied: " << mk_pp(lit, m) << "\n";);
  168                  mss.push_back(lit);

  185              case l_false:
  186:                 TRACE("mus", tout << "literal is in a core: " << mk_pp(lit, m) << "\n";);
  187                  nmcs.push_back(mk_not(m, lit));

z3/src/solver/solver_na2as.cpp:
  39          SASSERT(m.is_bool(a));
  40:         TRACE("solver_na2as", tout << "asserting\n" << mk_ismt2_pp(t, m) << "\n" << mk_ismt2_pp(a, m) << "\n";);
  41          m_assumptions.push_back(a);

  65      append_assumptions app(m_assumptions, num_assumptions, assumptions);
  66:     TRACE("solver_na2as", display(tout););
  67      return check_sat_core2(m_assumptions.size(), m_assumptions.data());

z3/src/solver/solver_pool.cpp:
  285          std::ofstream out(file_name);
  286:         STRACE("spacer.ind_gen", tout << "Dumping benchmark to " << file_name << "\n";);
  287          if (!out) {

z3/src/solver/solver2tactic.cpp:
  109          local_solver->assert_expr(clauses);
  110:         TRACE("solver2tactic", tout << "clauses asserted\n";);
  111          lbool r;

  118          }
  119:         TRACE("solver2tactic", tout << "check sat result " << r << "\n";);
  120          proof* pr = local_solver->get_proof();

z3/src/solver/tactic2solver.cpp:
  191      m_result = nullptr;
  192:     TRACE("pop", tout << m_scopes.size() << "\n";);
  193  }

  196      m_last_assertions_valid = false;
  197:     TRACE("pop", tout << m_scopes.size() << " " << n << "\n";);
  198      n = std::min(m_scopes.size(), n);

  230      labels_vec labels;
  231:     TRACE("tactic", g->display(tout););
  232      try {

  250          }
  251:         CTRACE("tactic", md.get(), tout << *md.get() << "\n";);
  252:         TRACE("tactic", 
  253                if (m_mc) m_mc->display(tout << "mc:\n");

  260      catch (z3_error & ex) {
  261:         TRACE("tactic2solver", tout << "exception: " << ex.msg() << "\n";);
  262          m_result->m_proof = pr;

  265      catch (z3_exception & ex) {
  266:         TRACE("tactic2solver", tout << "exception: " << ex.msg() << "\n";);
  267          m_result->set_status(l_undef);

z3/src/solver/assertions/asserted_formulas.cpp:
  164      if (m_smt_params.m_preprocess) {
  165:         TRACE("assert_expr_bug", tout << r << "\n";);
  166          set_eliminate_and(false); // do not eliminate and before nnf.

  173          }
  174:         TRACE("assert_expr_bug", tout << "after...\n" << r << "\n" << pr << "\n";);
  175      }

  179      push_assertion(r, pr, m_formulas);
  180:     TRACE("asserted_formulas_bug", tout << "after assert_expr\n"; display(tout););
  181  }

  198      SASSERT(inconsistent() || m_qhead == m_formulas.size() || m.limit().is_canceled());
  199:     TRACE("asserted_formulas_scopes", tout << "before push: " << m_scopes.size() << "\n");
  200      m_scoped_substitution.push();

  211      commit();
  212:     TRACE("asserted_formulas_scopes", tout << "after push: " << m_scopes.size() << "\n");
  213  }

  227      
  228:     TRACE("asserted_formulas_scopes", tout << "before pop " << num_scopes << " of " << m_scopes.size() << "\n";);
  229      m_bv_sharing.pop_scope(num_scopes);

  241      flush_cache();
  242:     TRACE("asserted_formulas_scopes", tout << "after pop " << num_scopes << "\n";);
  243  }

  278  
  279:     TRACE("before_reduce", display(tout););
  280      CASSERT("well_sorted", check_well_sorted());

  309      IF_VERBOSE(10, verbose_stream() << "(smt.simplifier-done :num-exprs " << get_total_size() << ")\n";);
  310:     TRACE("after_reduce", display(tout););
  311:     TRACE("after_reduce_ll", ast_mark visited; display_ll(tout, visited););
  312:     TRACE("macros", m_macro_manager.display(tout););
  313      flush_cache();

  332      IF_VERBOSE(10000, verbose_stream() << "total size: " << get_total_size() << "\n";);
  333:     TRACE("reduce_step_ll", ast_mark visited; display_ll(tout, visited););
  334      CASSERT("well_sorted",check_well_sorted());
  335:     TRACE("after_reduce", display(tout << s.id() << "\n"););
  336      if (inconsistent() || canceled()) {
  337:         TRACE("after_reduce_ll", ast_mark visited; display_ll(tout, visited););
  338          return false;

  431  void asserted_formulas::apply_quasi_macros() {
  432:     TRACE("before_quasi_macros", display(tout););
  433      vector<justified_expr> new_fmls;

  441      }
  442:     TRACE("after_quasi_macros", display(tout););
  443      reduce_and_solve();

  453      unsigned sz = m_formulas.size();
  454:     TRACE("nnf_bug", tout << "i: " << i << " sz: " << sz << "\n";);
  455      for (; i < sz; i++) {
  456          expr * n    = m_formulas[i].get_fml();
  457:         TRACE("nnf_bug", tout << "processing:\n" << mk_pp(n, m) << "\n";);
  458          proof_ref pr(m_formulas[i].get_proof(), m);

  510      af.swap_asserted_formulas(new_fmls);
  511:     TRACE("asserted_formulas", af.display(tout););
  512      post_op();

  548          unsigned prop = num_prop;
  549:         TRACE("propagate_values", display(tout << "before:\n"););
  550          unsigned i  = m_qhead;

  557          m_scoped_substitution.push();
  558:         TRACE("propagate_values", tout << "middle:\n"; display(tout););
  559          i = sz;

  565          flush_cache();
  566:         TRACE("propagate_values", tout << "after:\n"; display(tout););
  567          delta_prop = prop - num_prop;

  572      }
  573:     TRACE("asserted_formulas", tout << num_prop << "\n";);
  574      if (num_prop > 0)

  602          if (is_gt(lhs, rhs)) {
  603:             TRACE("propagate_values", tout << "insert " << mk_pp(lhs, m) << " -> " << mk_pp(rhs, m) << "\n";);
  604              m_scoped_substitution.insert(lhs, rhs, pr);

  607          if (is_gt(rhs, lhs)) {
  608:             TRACE("propagate_values", tout << "insert " << mk_pp(rhs, m) << " -> " << mk_pp(lhs, m) << "\n";);
  609              pr1 = m.proofs_enabled() ? m.mk_symmetry(pr) : nullptr;

  612          }
  613:         TRACE("propagate_values", tout << "incompatible " << mk_pp(n, m) << "\n";);
  614      }

  716      if (is_quantifier(f) && simplify_inj_axiom(m, to_quantifier(f), n)) {
  717:         TRACE("inj_axiom", tout << "simplifying...\n" << mk_pp(f, m) << "\n" << n << "\n";);
  718      }

z3/src/solver/assertions/asserted_formulas.h:
  127          bool should_apply() const override { return af.m_smt_params.m_distribute_forall && af.has_quantifiers(); }
  128:         void post_op() override { af.reduce_and_solve();  TRACE("asserted_formulas", af.display(tout);); }
  129      };

z3/src/tactic/goal.cpp:
  258      if (pr) {
  259:         CTRACE("goal", f != m().get_fact(pr), tout << mk_pp(f, m()) << "\n" << mk_pp(pr, m()) << "\n";);
  260          SASSERT(f == m().get_fact(pr));

  604          if (pr(i) && m().get_fact(pr(i)) != form(i)) {
  605:             TRACE("tactic", tout << mk_ismt2_pp(pr(i), m()) << "\n" << mk_ismt2_pp(form(i), m()) << "\n";);
  606              SASSERT(m().get_fact(pr(i)) == form(i));

z3/src/tactic/tactic.cpp:
   36          m_watch.start();
   37:         TRACE("tactic", g.display_with_proofs(tout << id << "\n"););
   38          SASSERT(g.is_well_formed());

   43          double end_memory = static_cast<double>(memory::get_allocation_size())/static_cast<double>(1024*1024);
   44:         TRACE("tactic", m_goal.display(tout << m_id << "\n");
   45                if (m_goal.mc()) m_goal.mc()->display(tout);

  191      }
  192:     TRACE("tactic",
  193            tout << "r.size(): " << r.size() << "\n";

  197          pr = r[0]->pr(0);
  198:         CTRACE("tactic", pr, tout << pr << "\n";);
  199      }    

z3/src/tactic/tactical.cpp:
   281      void updt_params(params_ref const & p) override {
   282:         TRACE("nary_tactical_updt_params", tout << "updt_params: " << p << "\n";);
   283          for (tactic* t : m_ts) t->updt_params(p);

  1080      void updt_params(params_ref const & p) override {
  1081:         TRACE("using_params", 
  1082                tout << "before p: " << p << "\n";

  1088          
  1089:         TRACE("using_params", 
  1090                tout << "after p: " << p << "\n";

z3/src/tactic/aig/aig.cpp:
   147      void delete_node(aig * n) {
   148:         TRACE("aig_lit_count", tout << "deleting: "; display_ref(tout, n); tout << "\n";);
   149          SASSERT(m_num_aigs > 0);

   445          void cache_result(expr * t, aig_lit const & r) {
   446:             TRACE("expr2aig", tout << "caching:\n" << mk_bounded_pp(t, m.m()) << "\n---> "; m.display_ref(tout, r); tout << "\n";); 
   447              SASSERT(!m_cache.contains(t));

   777              else {
   778:                 CTRACE("aig2expr", !is_cached(n), tout << "invalid get_cached for "; m.display_ref(tout, n); tout << "\n";);
   779                  SASSERT(is_cached(n));

   870              cache_result(n, r);
   871:             TRACE("aig2expr", tout << "caching AND "; m.display_ref(tout, n); tout << "\n";);
   872          }

   888              cache_result(n, r);
   889:             TRACE("aig2expr", tout << "caching ITE/IFF "; m.display_ref(tout, n); tout << "\n";);
   890          }

   938                      // do nothing
   939:                     TRACE("aig2expr", tout << "skipping aux AND "; m.display_ref(tout, n); tout << "\n";);
   940                      break;

  1139              aig_lit c = right(n);
  1140:             TRACE("max_sharing", 
  1141                    tout << "trying (and "; m.display_ref(tout, a); 

  1152                  m.dec_ref(bc);
  1153:                 TRACE("max_sharing", tout << "improved:\n"; m.display(tout, o); tout << "---->\n"; m.display(tout, r););
  1154                  return true;

  1157              
  1158:             TRACE("max_sharing", 
  1159                    tout << "trying (and "; m.display_ref(tout, a); 

  1170                  m.dec_ref(ac);
  1171:                 TRACE("max_sharing", tout << "improved:\n"; m.display(tout, o); tout << "---->\n"; m.display(tout, r););
  1172                  return true;

  1184              aig_lit c = right(right(n));
  1185:             TRACE("max_sharing", 
  1186                    tout << "trying (and (and "; m.display_ref(tout, a); 

  1197                  m.dec_ref(ab);
  1198:                 TRACE("max_sharing", tout << "improved:\n"; m.display(tout, o); tout << "---->\n"; m.display(tout, r););
  1199                  return true;

  1203              aig_lit ac = m.mk_and(a, c);
  1204:             TRACE("max_sharing", 
  1205                    tout << "trying (and (and "; m.display_ref(tout, a); 

  1215                  m.dec_ref(ac);
  1216:                 TRACE("max_sharing", tout << "improved:\n"; m.display(tout, o); tout << "---->\n"; m.display(tout, r););
  1217                  return true;

  1269                  aig * n    = fr.m_node;
  1270:                 TRACE("max_sharing", tout << "processing "; m.display_ref(tout, n); tout << " idx: " << fr.m_idx << "\n";);
  1271                  switch (fr.m_idx) {

  1292              aig_lit r = m_result_stack.back();
  1293:             TRACE("max_sharing", tout << "r.is_null(): " << r.is_null() << "\n";);
  1294              SASSERT(r.is_null() || ref_count(r) >= 1);

  1303              m_result_stack.pop_back();
  1304:             TRACE("max_sharing", tout << "result:\n"; m.display(tout, r););
  1305              m.dec_ref_result(r);

  1351          aig_lit r = mk_node(r1, r2);
  1352:         TRACE("mk_and_bug", 
  1353                display(tout, r1);

z3/src/tactic/arith/add_bounds_tactic.cpp:
  126              report_tactic_progress(":added-bounds", proc.m_num_bounds);
  127:             TRACE("add_bounds", g->display(tout););
  128          }

z3/src/tactic/arith/arith_bounds_tactic.cpp:
   78          expr* e1, *e2;
   79:         TRACE("arith_subsumption", s->display(tout); );
   80          for (unsigned i = 0; i < s->size(); ++i) {

  142          result.push_back(s.get());
  143:         TRACE("arith_subsumption", s->display(tout); );
  144      }

z3/src/tactic/arith/bound_manager.cpp:
  106  void bound_manager::operator()(expr * f, expr_dependency * d) {
  107:     TRACE("bound_manager", tout << "processing:\n" << mk_ismt2_pp(f, m()) << "\n";);
  108      expr * v;

  141          norm(n, k);
  142:     TRACE("bound_manager", tout << "found bound for:\n" << mk_ismt2_pp(v, m()) << "\n";);
  143      bool strict = is_strict(k);

  239      }
  240:     TRACE("bound_manager", tout << "bounds: " << lo << " " << hi << "\n";);
  241      insert_lower(v, false, lo, d);

z3/src/tactic/arith/bound_propagator.cpp:
  273      }
  274:     TRACE("bound_propagator_detail", tout << "new lower x" << x << " " << m.to_string(k) << " strict: " << strict << "\n";);
  275  

  280              if (bk == DERIVED) {
  281:                 TRACE("bound_propagator_detail", tout << "false alarm\n";);
  282                  m_false_alarms++;

  288      if (bk == DERIVED) {
  289:         TRACE("bound_propagator_derived", tout << "new lower x" << x << " " << m.to_string(k) << " strict: " << strict << "\n";);
  290          m_propagations++;

  296      double approx_k = m.get_double(k);
  297:     TRACE("new_bound", tout << "x" << x << " lower: " << m.to_string(k) << " approx: " << approx_k << "\n";);
  298  #ifdef RELAX_BOUNDS
  299      approx_k = PRECISION*floor(approx_k*INV_PRECISION + TOLERANCE);
  300:     TRACE("new_bound", tout << "x" << x << " lower: " << m.to_string(k) << " relaxed approx: " << approx_k << "\n";);
  301  #endif

  325  
  326:     TRACE("bound_propagator_detail", tout << "new upper x" << x << " " << m.to_string(k) << " strict: " << strict << "\n";);
  327  

  332              if (bk == DERIVED) {
  333:                 TRACE("bound_propagator_detail", tout << "false alarm\n";);
  334                  m_false_alarms++;

  341          m_propagations++;
  342:         TRACE("bound_propagator_derived", tout << "new upper x" << x << " " << m.to_string(k) << " strict: " << strict << "\n";);
  343      }

  348      double approx_k = m.get_double(k);
  349:     TRACE("new_bound", tout << "x" << x << " upper: " << m.to_string(k) << " approx: " << approx_k << "\n";);
  350  #ifdef RELAX_BOUNDS
  351      approx_k = PRECISION*ceil(approx_k*INV_PRECISION - TOLERANCE);
  352:     TRACE("new_bound", tout << "x" << x << " upper: " << m.to_string(k) << " relaxed approx: " << approx_k << "\n";);
  353  #endif

  376  bool bound_propagator::relevant_bound(var x, double new_k) const {
  377:     TRACE("bound_propagator_detail", tout << "relevant_bound x" << x << " " << new_k << " LOWER: " << LOWER << "\n";
  378            if (LOWER && has_lower(x)) tout << "old: " << m.to_string(m_lowers[x]->m_k) << " | " << m_lowers[x]->m_approx_k << "\n";

  399              if (new_k <= b->m_approx_k + improvement) {
  400:                 TRACE("bound_propagator", tout << "LOWER new: " << new_k << " old: " << b->m_approx_k << " improvement is too small\n";);
  401                  return false; // improvement is too small

  405              if (new_k >= b->m_approx_k - improvement) {
  406:                 TRACE("bound_propagator", tout << "UPPER new: " << new_k << " old: " << b->m_approx_k << " improvement is too small\n";);
  407                  return false; // improvement is too small

  451          SASSERT(inconsistent());
  452:         TRACE("bound_propagator", tout << "inconsistency detected: x" << x << "\n"; display(tout););
  453      }

  467          unsigned ts = b->m_timestamp; 
  468:         TRACE("bound_propagator_detail", tout << "propagating x" << x << "\n";);
  469          m_qhead++;

  512  
  513:     TRACE("bound_propagator_detail", tout << "propagating using eq: "; m_eq_manager.display(tout, *eq); tout << "\n";);
  514      // ll = (Sum_{a_i < 0} -a_i*lower(x_i)) + (Sum_{a_i > 0} -a_i * upper(x_i)) 

  680          bound * b_j = (m.is_neg(a_j) == neg_a_i) ? m_uppers[x_j] : m_lowers[x_j];
  681:         TRACE("bound_propagator_step_detail", tout << "k: " << m.to_string(k) << " b_j->m_k: " << m.to_string(b_j->m_k) << 
  682                " a_j: " << m.to_string(a_j) << "\n";);

  687      }
  688:     TRACE("bound_propagator_step_detail", tout << "k: " << m.to_string(k) << "\n";);
  689      m.neg(k);
  690      m.div(k, a_i, k);
  691:     TRACE("bound_propagator_step", tout << "propagating lower x" << x_i << " " << m.to_string(k) << " strict: " << strict << " using\n";
  692            m_eq_manager.display(tout, *eq); tout << "\n"; display_bounds_of(tout, *eq););

  724      m.div(k, a_i, k);
  725:     TRACE("bound_propagator_step", tout << "propagating upper x" << x_i << " " << m.to_string(k) << " strict: " << strict << " using\n";
  726            m_eq_manager.display(tout, *eq); tout << "\n"; display_bounds_of(tout, *eq););

z3/src/tactic/arith/bv2int_rewriter.cpp:
   86          m_trail.push_back(logx);
   87:         TRACE("bv2int_rewriter", tout << mk_pp(v, m) << " |-> " << mk_pp(logx, m) << "\n";);
   88          m_power2.insert(v, logx);

  239          result = m_bv.mk_bv2int(m_bv.mk_bv_urem(s1, t1));
  240:         TRACE("bv2int_rewriter", tout << result << "\n";);
  241          return BR_DONE;

  254          result = m_bv.mk_bv2int(m_bv.mk_bv_urem(u1, t1));
  255:         TRACE("bv2int_rewriter", tout << result << "\n";);
  256          return BR_DONE;

z3/src/tactic/arith/bv2real_rewriter.cpp:
  317      SASSERT(!overflow.is_one());
  318:     TRACE("bv2real_rewriter", 
  319            tout << mk_pp(s, m()) << " " << overflow << "\n";);

  338  
  339:     TRACE("bv2real_rewriter", 
  340            tout << mk_pp(s, m()) << " " << overflow << "\n";);

  362  br_status bv2real_rewriter::mk_app_core(func_decl * f, unsigned num_args, expr * const * args, expr_ref & result) {
  363:     TRACE("bv2real_rewriter", 
  364            tout << mk_pp(f, m()) << " ";

  471  
  472:         TRACE("bv2real_rewriter", tout << "mk_le\n";);
  473  

  548          result    = m().mk_and(e1, e2, e3);
  549:         TRACE("bv2real_rewriter", tout << "\n";);
  550          return BR_DONE;

z3/src/tactic/arith/card2bv_tactic.cpp:
  56                      goal_ref_buffer & result) override {
  57:         TRACE("card2bv-before", g->display(tout););
  58          result.reset();

  71              rw1(g->form(idx), new_f1, new_pr1);
  72:             TRACE("card2bv", tout << "Rewriting " << new_f1 << "\n" << new_pr1 << std::endl;);
  73              rw2(false, new_f1, new_f2, new_pr2);
  74:             TRACE("card2bv", tout << "Rewriting " << new_f2 << "\n" << new_pr2 << std::endl;);
  75              if (m.proofs_enabled()) {

z3/src/tactic/arith/degree_shift_tactic.cpp:
  178              
  179:             TRACE("degree_shift", display_candidates(tout););
  180          }

  268              result.push_back(g.get());
  269:             TRACE("degree_shift", g->display(tout); if (mc) mc->display(tout););
  270          }

z3/src/tactic/arith/diff_neq_tactic.cpp:
  170                  expr * f = g.form(i);
  171:                 TRACE("diff_neq_tactic", tout << "processing: " << mk_ismt2_pp(f, m) << "\n";);
  172                  if (u.is_le(f, lhs, rhs))

  292                      throw tactic_exception(m.limit().get_cancel_msg());
  293:                 TRACE("diff_neq_tactic", display_model(tout););
  294                  var x = m_stack.size();

  299              }
  300:             TRACE("diff_neq_tactic", display_model(tout););
  301              return true;

  326              compile(*g);
  327:             TRACE("diff_neq_tactic", g->display(tout); display(tout););
  328              bool r = search();

z3/src/tactic/arith/factor_tactic.cpp:
  175              m_expr2poly.to_polynomial(rhs, p2, d2);
  176:             TRACE("factor_tactic_bug",
  177                    tout << "lhs: " << mk_ismt2_pp(lhs, m) << "\n";

  192              polynomial::factors fs(m_pm);
  193:             TRACE("factor_tactic_bug", tout << "p: " << p << "\n";);
  194              m_pm.factor(p, fs, m_fparams);
  195              SASSERT(fs.distinct_factors() > 0);
  196:             TRACE("factor_tactic_bug", tout << "factors:\n"; fs.display(tout); tout << "\n";);
  197              if (fs.distinct_factors() == 1 && fs.get_degree(0) == 1)

z3/src/tactic/arith/fix_dl_var_tactic.cpp:
   48          void throw_failed(expr * ctx1, expr * ctx2 = nullptr) {
   49:             TRACE("fix_dl_var", tout << mk_ismt2_pp(ctx1, m) << "\n"; if (ctx2) tout << mk_ismt2_pp(ctx2, m) << "\n";);
   50              throw failed();

  106              else {
  107:                 CTRACE("fix_dl_var", m_util.is_add(lhs, t, ms),
  108                         s = 0;

  199              r2 = most_occs(m_occs, best2);
  200:             TRACE("fix_dl_var", 
  201                    if (r1) {

  251              m_produce_models    = g->models_enabled();
  252:             TRACE("fix_dl_var", g->display(tout););
  253  

z3/src/tactic/arith/fm_tactic.cpp:
   200          void operator()(model_ref & md) override {
   201:             TRACE("fm_mc", model_v2_pp(tout, *md); display(tout););
   202              model::scoped_model_completion _sc(*md, true);

   220                  bool has_lower = false, has_upper = false;
   221:                 TRACE("fm_mc", tout << "processing " << x->get_name() << "\n";);
   222                  for (expr* cl : m_clauses[i]) {

   226                      case NONE: 
   227:                         TRACE("fm_mc", tout << "no bound for:\n" << mk_ismt2_pp(cl, m) << "\n";);
   228                          break;
   229                      case LOWER: 
   230:                         TRACE("fm_mc", tout << "lower bound: " << val << " for:\n" << mk_ismt2_pp(cl, m) << "\n";);
   231                          if (val_e)

   236                      case UPPER: 
   237:                         TRACE("fm_mc", tout << "upper bound: " << val << " for:\n" << mk_ismt2_pp(cl, m) << "\n";);
   238                          if (val_e)

   287                  }
   288:                 TRACE("fm_mc", tout << x->get_name() << " --> " << mk_ismt2_pp(x_val, m) << "\n";);
   289                  md->register_decl(x, x_val);
   290              }
   291:             TRACE("fm_mc", model_v2_pp(tout, *md););
   292          }

   523              expr * lhs, * rhs;
   524:             TRACE("is_occ_bug", tout << mk_pp(t, m) << "\n";);
   525              if (m_util.is_le(t, lhs, rhs) || m_util.is_ge(t, lhs, rhs)) {

   599              for (unsigned i = 0; i < num_vars; i++) {
   600:                 TRACE("mk_constraint_bug", tout << "xs[" << i << "]: " << xs[i] << "\n";);
   601                  cnstr->m_xs[i] = xs[i];

   791                  if (subsumes(c, *c2)) {
   792:                     TRACE("fm_subsumption", display(tout, c); tout << "\nsubsumed:\n"; display(tout, *c2); tout << "\n";);
   793                      c2->m_dead = true;

   862                      continue;
   863:                 TRACE("is_occ_bug", tout << "not OCC:\n" << mk_ismt2_pp(f, m) << "\n";);
   864                  quick_for_each_expr(proc, visited, f);

  1013              SASSERT(m_var2expr.get(x) == t);
  1014:             TRACE("to_var_bug", tout << mk_ismt2_pp(t, m) << " --> " << x << "\n";);
  1015              return x;

  1112              
  1113:             TRACE("to_var_bug", tout << "before mk_constraint: "; for (unsigned i = 0; i < xs.size(); i++) tout << " " << xs[i]; tout << "\n";);
  1114              

  1123              
  1124:             TRACE("to_var_bug", tout << "add_constraint: "; display(tout, *new_c); tout << "\n";);
  1125              VERIFY(register_constraint(new_c));

  1136                  m_inconsistent = true;
  1137:                 TRACE("add_constraint_bug", tout << "is false "; display(tout, *c); tout << "\n";);
  1138                  return false;

  1159              else {
  1160:                 TRACE("add_constraint_bug", tout << "all variables are forbidden "; display(tout, *c); tout << "\n";);
  1161                  m_new_goal->assert_expr(to_expr(*c), nullptr, c->m_dep);

  1215              std::stable_sort(x_cost_vector.begin(), x_cost_vector.end(), x_cost_lt(m_is_int));
  1216:             TRACE("fm",
  1217                    for (auto const& [v,c] : x_cost_vector) 

  1394                  // literal is true
  1395:                 TRACE("fm", tout << "resolution " << x << " consequent literal is always true: \n";
  1396                        display(tout, l);

  1438              if (tautology) {
  1439:                 TRACE("fm", tout << "resolution " << x << " tautology: \n";
  1440                        display(tout, l);

  1448              if (new_lits.empty() && new_xs.empty() && (new_c.is_neg() || (new_strict && new_c.is_zero()))) {
  1449:                 TRACE("fm", tout << "resolution " << x << " inconsistent: \n";
  1450                        display(tout, l);

  1466  
  1467:             TRACE("fm", tout << "resolution " << x << "\n";
  1468                    display(tout, l);

  1489                  mark_constraints_dead(x);
  1490:                 TRACE("fm", tout << "variables was eliminated (trivial case)\n";);
  1491                  return true;

  1507              
  1508:             TRACE("fm_bug", tout << "eliminating " << mk_ismt2_pp(m_var2expr.get(x), m) << "\nlowers:\n";
  1509                    display_constraints(tout, l); tout << "uppers:\n"; display_constraints(tout, u););

  1517                      if (m_inconsistent || num_new_cnstrs > limit) {
  1518:                         TRACE("fm", tout << "too many new constraints: " << num_new_cnstrs << "\n";);
  1519                          del_constraints(new_constraints.size(), new_constraints.data());

  1542              }
  1543:             TRACE("fm", tout << "variables was eliminated old: " << num_old_cnstrs << " new_constraints: " << sz << "\n";);
  1544              return true;

  1552                          expr * new_f = to_expr(*c);
  1553:                         TRACE("fm_bug", tout << "asserting...\n" << mk_ismt2_pp(new_f, m) << "\nnew_dep: " << c->m_dep << "\n";);
  1554                          m_new_goal->assert_expr(new_f, nullptr, c->m_dep);

  1593              else {
  1594:                 TRACE("fm", display(tout););
  1595                  

  1627              result.push_back(m_new_goal.get());
  1628:             TRACE("fm", m_new_goal->display(tout););
  1629          }

z3/src/tactic/arith/lia2card_tactic.cpp:
   84              }
   85:             TRACE("pbsum", tout << expr_ref(m.mk_app(f, sz, es), m) << " ==>\n" <<  result << "\n";);
   86  

  196                  m_bounds.insert(x, bound(lo.get_unsigned(), hi.get_unsigned(), b));
  197:                 TRACE("pb", tout << "add bound " << lo << " " << hi << ": " << mk_pp(x, m) << "\n";);
  198              }

  321          else {
  322:             TRACE("pb", tout << "Can't handle " << mk_pp(x, m) << "\n";);
  323              ok = false;

z3/src/tactic/arith/lia2pb_tactic.cpp:
   96              void throw_failed(expr * n) {
   97:                 TRACE("lia2pb", tout << "Failed at:\n" << mk_ismt2_pp(n, m_owner.m) << "\n";);
   98                  throw failed();

  201              
  202:             TRACE("lia2pb", m_bm.display(tout););
  203              

  257                      }
  258:                     TRACE("lia2pb", tout << mk_ismt2_pp(x, m) << " -> " << dep << "\n";);
  259                      subst.insert(x, def, nullptr, dep);

z3/src/tactic/arith/linear_equation.cpp:
   70      
   71:     TRACE("linear_equation_mk", tout << "lcm: " << m.to_string(l) << "\n";);
   72      

   75      for (unsigned i = 0; i < sz; i++) {
   76:         TRACE("linear_equation_mk", tout << "before as[" << i << "]: " << m.to_string(as[i]) << "\n";);
   77          m.mul(l, as[i], as[i]);
   78:         TRACE("linear_equation_mk", tout << "after as[" << i << "]: " << m.to_string(as[i]) << "\n";);
   79          SASSERT(m.is_int(as[i]));

   98  
   99:     TRACE("linear_equation_bug", for (unsigned i = 0; i < sz; i++) tout << m.to_string(as[i]) << "*x" << xs[i] << " "; tout << "\n";);
  100      

  120  
  121:     TRACE("linear_equation_bug", 
  122            tout << "g: " << m.to_string(g) << "\n";

z3/src/tactic/arith/nla2bv_tactic.cpp:
   86          void operator()(goal & g, model_converter_ref & mc) {
   87:             TRACE("nla2bv", g.display(tout);
   88                    tout << "Muls: " << count_mul(g) << "\n";

  102              substitute_vars(g);
  103:             TRACE("nla2bv", g.display(tout << "substitute vars\n"));
  104              reduce_bv2int(g);
  105              reduce_bv2real(g);
  106:             TRACE("nla2bv", g.display(tout << "after reduce\n"));
  107              mc = m_fmc.get();

  113              IF_VERBOSE(TACTIC_VERBOSITY_LVL, verbose_stream() << "(nla->bv :sat-preserving " << m_is_sat_preserving << ")\n";);
  114:             TRACE("nla2bv_verbose", g.display(tout));
  115:             TRACE("nla2bv", tout << "Muls: " << count_mul(g) << "\n");
  116              g.inc_depth();

  137                  m_subst.insert(kv.m_key, w);
  138:                 TRACE("nla2bv", tout << mk_ismt2_pp(kv.m_key, m_manager) << " " << mk_ismt2_pp(w, m_manager) << "\n";);
  139              }

  177              }
  178:             TRACE("nla2bv", 
  179                    for (unsigned i = 0; i < sz; ++i) {

  232              else {
  233:                 TRACE("nla2bv", tout << "no bounds for " << mk_ismt2_pp(n, m_manager) << "\n";);
  234                  set_satisfiability_preserving(false);

  354                  else if (n->get_family_id() != m.get_basic_family_id()) {
  355:                     TRACE("nla2bv", tout << "Not supported: " << mk_ismt2_pp(n, m) << "\n";);
  356                      m_in_supported_fragment = false;

z3/src/tactic/arith/normalize_bounds_tactic.cpp:
   72              for (; it != end; ++it) {
   73:                 TRACE("normalize_bounds_tactic", 
   74                        rational val; bool strict;

  132              }
  133:             TRACE("normalize_bounds_tactic", in->display(tout););
  134              in->inc_depth();

z3/src/tactic/arith/pb2bv_model_converter.cpp:
  58  void pb2bv_model_converter::operator()(model_ref & md) {
  59:     TRACE("pb2bv", tout << "converting model:\n"; model_v2_pp(tout, *md); display(tout););
  60      arith_util a_util(m);

z3/src/tactic/arith/pb2bv_tactic.cpp:
   54          void throw_non_pb(expr * n) {
   55:             TRACE("pb2bv", tout << "Not pseudo-Boolean: " << mk_ismt2_pp(n, m) << "\n";);
   56              throw non_pb(n);

  229                      t = m_saved_res;
  230:                     TRACE("pb2bv_convert", tout << mk_ismt2_pp(s, m) << "\n-->\n" << mk_ismt2_pp(t, m) << "\n";);
  231                      return true;

  427                  
  428:                     TRACE("pb2bv_bv", tout << "BV Cardinality: " << mk_ismt2_pp(tmp.back(), m) << std::endl;);
  429                      r = tmp.back();

  433  
  434:             TRACE("pb2bv_bv_detail", tout << "encoding:\n"; display(tout, m_p, m_c);); 
  435              // [Leo] improving number of bits needed.

  451          
  452:             TRACE("num_bits_bug", tout << "bits: " << bits << " sum: " << sum << " size: " << m_p.size() << "\n";);
  453          

  513          void mk_pbc(polynomial & m_p, numeral & m_c, expr_ref & r, bool enable_split) {
  514:             TRACE("mk_pbc", display(tout, m_p, m_c); );
  515              if (m_c.is_nonpos()) {

  534              }
  535:             TRACE("mk_pbc", tout << "GCD = " << a_gcd << "; Normalized: "; display(tout, m_p, m_c); tout << "\n"; );
  536              it  = m_p.begin();

  548              polynomial clause;
  549:             TRACE("split_bug", display(tout, m_p, m_c););
  550              if (enable_split)
  551                  split(m_p, m_c, clause);
  552:             TRACE("split_bug", display(tout, m_p, m_c); display(tout, clause, rational(1)););
  553              if (clause.empty()) {

  560                  bitblast_pbc(clause, numeral(1), r2);
  561:                 TRACE("split_bug", tout << mk_ismt2_pp(r1, m) << "\nAND\n" << mk_ismt2_pp(r2, m) << "\n";);
  562                  m_b_rw.mk_and(r1, r2, r);

  584          void throw_non_pb(expr * n) {        
  585:             TRACE("pb2bv", tout << "Not pseudo-Boolean: " << mk_ismt2_pp(n, m) << "\n";);
  586              throw non_pb(n);

  592          bool is_eq_vector(polynomial const & p, numeral const & c) {
  593:             TRACE("is_eq_vector", display(tout, p, c););
  594              unsigned sz = p.size();

  655                          // redundant 0 <= x, 1 >= x
  656:                         TRACE("pb2bv", tout << "discarding:\n" << mk_ismt2_pp(t, m) << "\n";);
  657                          SASSERT(pos);                        

  680                  if (k == EQ) {
  681:                     TRACE("pb2bv_bug", tout << "c: " << c << "\n";);
  682                      if (!c.is_zero() && !c.is_one()) {

  698                          if (c >= numeral(1)) {
  699:                             TRACE("pb2bv", tout << "discarding:\n" << mk_ismt2_pp(t, m) << "\n";);
  700                              r = m.mk_true();

  711                          if (c.is_nonpos()) {
  712:                             TRACE("pb2bv", tout << "discarding:\n" << mk_ismt2_pp(t, m) << "\n";);
  713                              // x >= a <= 0

  723                      }
  724:                     CTRACE("pb2bv", !(c.is_zero() || c.is_one()),
  725                             tout << "BUG: " << mk_ismt2_pp(t, m) << "\nk: " << k << " " << c << "\n";);

  729  
  730:                     CTRACE("pb2bv_bug", !((c.is_zero() && k == LE) || (c.is_one() && k == GE)),
  731                             tout << "c: " << c << ", k: " << k << "\n";

  803                  if (is_eq_vector(m_p, m_c)) {
  804:                     TRACE("is_eq_vector", tout << "found eq vector\n";);
  805                      unsigned sz = m_p.size();

  831                  mk_pbc(m_p2, m_c2, r2, false);
  832:                 TRACE("pb2bv_convert", tout << mk_ismt2_pp(t, m) << "\n";
  833                        display(tout, m_p, m_c);

  902                          goal_ref_buffer & result) {
  903:             TRACE("pb2bv", g->display(tout););
  904              fail_if_proof_generation("pb2bv", g);

  917              
  918:             TRACE("pb2bv", m_bm.display(tout););
  919  

  940                          convert(to_app(atom), new_f, pos, true);
  941:                         TRACE("pb2bv_convert", tout << "pos: " << pos << "\n" << mk_ismt2_pp(atom, m) << "\n--->\n" << mk_ismt2_pp(new_f, m) << "\n";); 
  942                      }

z3/src/tactic/arith/probe_arith.cpp:
  138      void throw_found(expr* e) {
  139:         TRACE("probe", tout << expr_ref(e, m) << ": " << sort_ref(e->get_sort(), m) << "\n";);
  140          throw found();

  440      void throw_found(expr* e) {
  441:         TRACE("probe", tout << expr_ref(e, m) << ": " << sort_ref(e->get_sort(), m) << "\n";);
  442          throw found();

  617                  if (!u.is_numeral(n->get_arg(1))) {
  618:                     TRACE("arith", tout << "non-linear " << expr_ref(n, m) << "\n";);
  619                      throw_found();

  623                  if (!u.is_numeral(n->get_arg(1))) {
  624:                     TRACE("arith", tout << "non-linear " << expr_ref(n, m) << "\n";);
  625                      throw_found();

  634              default:
  635:                 TRACE("arith", tout << "non-linear " << expr_ref(n, m) << "\n";);
  636                  throw_found();

z3/src/tactic/arith/propagate_ineqs_tactic.cpp:
  375      void find_ite_bounds(expr * root) {
  376:         TRACE("find_ite_bounds_bug", display_bounds(tout););
  377          expr * n = root;

  386          while (true) {
  387:             TRACE("find_ite_bounds_bug", tout << mk_ismt2_pp(n, m) << "\n";);
  388  

  403  
  404:             TRACE("find_ite_bounds_bug", tout << "x: " << mk_ismt2_pp(x, m) << ", y: " << mk_ismt2_pp(y, m) << "\n";
  405                    if (target) { 

  413              if (!is_unbounded(x)) {
  414:                 TRACE("find_ite_bounds_bug", tout << "x is already bounded\n";);
  415                  break;

  426                      has_l = false;
  427:                     TRACE("find_ite_bounds_bug", tout << "y does not have lower\n";);
  428                  }

  435                      has_u = false;
  436:                     TRACE("find_ite_bounds_bug", tout << "y does not have upper\n";);
  437                  }

  448                          has_l = false;
  449:                         TRACE("find_ite_bounds_bug", tout << "y does not have lower\n";);
  450                      }

  460                          has_u = false;
  461:                         TRACE("find_ite_bounds_bug", tout << "y does not have upper\n";);
  462                      }

  472              if (n == nullptr) {
  473:                 TRACE("find_ite_bounds", tout << "found bounds for: " << mk_ismt2_pp(target, m) << "\n";
  474                        tout << "has_l: " << has_l << " " << nm.to_string(l_min) << " l_strict: " << l_strict << "\n";

  497          bp.propagate();
  498:         TRACE("find_ite_bounds", display_bounds(tout););
  499      }

  512          
  513:         TRACE("propagate_ineqs_tactic", g->display(tout); display_bounds(tout); tout << "bound propagator:\n"; bp.display(tout););
  514  

  529          
  530:         TRACE("propagate_ineqs_tactic", tout << "after propagation:\n"; display_bounds(tout); bp.display(tout););
  531:         TRACE("propagate_ineqs_tactic", r->display(tout););
  532      }

z3/src/tactic/arith/purify_arith_tactic.cpp:
  301              m_new_cnstrs.push_back(cnstr);
  302:             TRACE("purify_arith", tout << mk_pp(cnstr, m()) << "\n";);
  303          }

  767          r(q->get_expr(), new_body, new_body_pr);
  768:         TRACE("purify_arith", 
  769                tout << "body: " << mk_ismt2_pp(q->get_expr(), m()) << "\nnew_body: " << new_body << "\n";);

  794          sz = r.cfg().m_new_cnstrs.size();
  795:         TRACE("purify_arith", tout << r.cfg().m_new_cnstrs << "\n";);
  796:         TRACE("purify_arith", tout << r.cfg().m_new_cnstr_prs << "\n";);
  797          for (unsigned i = 0; i < sz; i++) {

  925              tactic_report report("purify-arith", *g);
  926:             TRACE("goal", g->display(tout););
  927              bool produce_proofs = g->proofs_enabled();

z3/src/tactic/arith/recover_01_tactic.cpp:
  302          
  303:             TRACE("recover_01", tout << x->get_name() << " --> " << mk_ismt2_pp(x_def, m) << "\n";);
  304              subst->insert(m.mk_const(x), x_def);

  375              result.push_back(new_goal.get());
  376:             TRACE("recover_01", new_goal->display(tout); if (new_goal->mc()) new_goal->mc()->display(tout););
  377              SASSERT(new_goal->is_well_formed());

z3/src/tactic/bv/bit_blaster_model_converter.cpp:
  68          }
  69:         TRACE("model_converter",
  70                tout << "bits that should not be included in the model:\n";

  83                  continue;
  84:             TRACE("model_converter", tout << "non-bit: " << f->get_name() << "\n";);
  85              expr * fi     = old_model->get_const_interp(f);

  87          }
  88:         TRACE("model_converter", tout << "after copy non bits:\n"; model_pp(tout, *new_model););
  89          new_model->copy_func_interps(*old_model);
  90          new_model->copy_usort_interps(*old_model);
  91:         TRACE("model_converter", tout << "after copying functions and sorts:\n"; model_pp(tout, *new_model););
  92      }

z3/src/tactic/bv/bit_blaster_tactic.cpp:
  61              
  62:             TRACE("before_bit_blaster", g->display(tout););
  63              m_num_steps = 0;

  81                      change = true;                    
  82:                     TRACE("bit_blaster", tout << mk_pp(curr, m()) << " -> " << new_curr << "\n";);
  83                      g->update(idx, new_curr, new_pr, g->dep(idx));

  94              result.push_back(g.get());
  95:             TRACE("after_bit_blaster", g->display(tout); if (g->mc()) g->mc()->display(tout); tout << "\n";);
  96              m_rewriter->cleanup();

z3/src/tactic/bv/bv_bound_chk_tactic.cpp:
  61          const br_status st = reduce_app_core(f, num, args, result, result_pr);
  62:         CTRACE("bv_bound_chk_step", st != BR_FAILED,
  63              tout << f->get_name() << "\n";

z3/src/tactic/bv/bv_bounds_tactic.cpp:
  263          bool assert_expr(expr * t, bool sign) override {
  264:             TRACE("bv", tout << expr_ref(t, m) << "\n";);
  265              while (m.is_not(t, t)) {

  278  
  279:                 TRACE("bv", tout << (sign?"(not ":"") << mk_pp(t, m) << (sign ? ")" : "") << ": " << mk_pp(t1, m) << " in " << b << "\n";);
  280                  map::obj_map_entry* e = m_bound.find_core(t1);

  342  
  343:             CTRACE("bv", result != 0, tout << mk_pp(t, m) << " " << b << " (ctx: " << ctx << ") (intr: " << intr << "): " << result << "\n";);
  344              if (sign && result != 0)

  434          void pop(unsigned num_scopes) override {
  435:             TRACE("bv", tout << "pop: " << num_scopes << "\n";);
  436              if (m_scopes.empty())

  572  
  573:                 TRACE("bv", tout << (sign?"(not ":"") << mk_pp(t, m) << (sign ? ")" : "") << ": " << mk_pp(t1, m) << " in " << b << "\n";);
  574                  map::obj_map_entry* e = m_bound.find_core(t1);

  643  
  644:             TRACE("bv", tout << mk_pp(t, m) << " " << b << " (ctx: " << ctx << ") (intr: " << intr << "): " << r << "\n";);
  645              if (sign && was_updated)

  711          void pop(unsigned num_scopes) override {
  712:             TRACE("bv", tout << "pop: " << num_scopes << "\n";);
  713              if (m_scopes.empty())

z3/src/tactic/bv/bv_size_reduction_tactic.cpp:
  147                  if (is_uninterp_const(lhs) && m_util.is_numeral(rhs, val, bv_sz)) {
  148:                     TRACE("bv_size_reduction", tout << (negated?"not ":"") << mk_ismt2_pp(f, m) << std::endl; );
  149                      // v <= k

  162                  else if (is_uninterp_const(rhs) && m_util.is_numeral(lhs, val, bv_sz)) {
  163:                     TRACE("bv_size_reduction", tout << (negated?"not ":"") << mk_ismt2_pp(f, m) << std::endl; );
  164                      // k <= v

  180                  if (is_uninterp_const(lhs) && m_util.is_numeral(rhs, val, bv_sz)) {
  181:                     TRACE("bv_size_reduction", tout << (negated?"not ":"") << mk_ismt2_pp(f, m) << std::endl; );
  182                      // v <= k

  188                  else if (is_uninterp_const(rhs) && m_util.is_numeral(lhs, val, bv_sz)) {
  189:                     TRACE("bv_size_reduction", tout << (negated?"not ":"") << mk_ismt2_pp(f, m) << std::endl; );
  190                      // k <= v

  214              return;
  215:         TRACE("before_bv_size_reduction", g.display(tout););
  216          m_produce_models = g.models_enabled();

  245              if (!(m_signed_lowers.empty() || m_signed_uppers.empty())) {
  246:                 TRACE("bv_size_reduction", 
  247                        tout << "m_signed_lowers: " << std::endl;

  260                          numeral u = m_util.norm(entry->get_data().m_value, bv_sz, true);
  261:                         TRACE("bv_size_reduction", tout << l << " <= " << k->get_decl()->get_name() << " <= " << u << "\n";);
  262                          expr * new_def = nullptr;

  280                                      unsigned i_nb = l_nb;
  281:                                     TRACE("bv_size_reduction", tout << " l <= " << k->get_decl()->get_name() << " <= u <= 0 " << " --> " << i_nb << " bits\n";);
  282                                      if (i_nb < v_nb) {

  290                                      unsigned i_nb = ((l_nb > u_nb) ? l_nb : u_nb) + 1;
  291:                                     TRACE("bv_size_reduction", tout << " l <= " << k->get_decl()->get_name() << " <= 0 <= u " << " --> " << i_nb << " bits\n";);
  292                                      if (i_nb < v_nb) {

  301                                  unsigned v_nb = m_util.get_bv_size(k);
  302:                                 TRACE("bv_size_reduction", tout << l << " <= " << k->get_decl()->get_name() << " <= " << u << " --> " << u_nb << " bits\n";);
  303                                  if (u_nb < v_nb) {

  327              if (!(m_unsigned_lowers.empty() && m_unsigned_uppers.empty())) {
  328:                 TRACE("bv_size_reduction", 
  329                      tout << "m_unsigned_lowers: " << std::endl;

  354  
  355:                     TRACE("bv_size_reduction", tout << l << " <= " << v->get_decl()->get_name() << " <= " << u << "\n";);
  356                      expr * new_def = 0;

  386                          num_reduced++;
  387:                         TRACE("bv_size_reduction", tout << "New definition = " << mk_ismt2_pp(new_def, m) << "\n";);
  388                      }

  415          report_tactic_progress(":bv-reduced", num_reduced);
  416:         TRACE("after_bv_size_reduction", g.display(tout); if (m_mc) m_mc->display(tout););
  417      }

  424      fail_if_unsat_core_generation("bv-size-reduction", g);
  425:     TRACE("goal", g->display(tout););
  426      result.reset();

z3/src/tactic/bv/bvarray2uf_rewriter.cpp:
  113              bv_f = m_manager.mk_fresh_func_decl("f_t", "", 1, &domain, range);
  114:             TRACE("bvarray2uf_rw", tout << "for " << mk_ismt2_pp(e, m_manager) << " new func_decl is " << mk_ismt2_pp(bv_f, m_manager) << std::endl; );
  115              if (m_fmc) {

  124          else {
  125:             TRACE("bvarray2uf_rw", tout << "for " << mk_ismt2_pp(e, m_manager) << " found " << mk_ismt2_pp(bv_f, m_manager) << std::endl; );
  126          }

  166  
  167:         TRACE("bvarray2uf_rw", tout << "(ite " << c << ", " << f_t->get_name()
  168              << ", " << f_f->get_name() << ")" << std::endl;);

  191  
  192:         TRACE("bvarray2uf_rw", tout << "result: " << mk_ismt2_pp(result, m_manager) << ")" << std::endl;);
  193          res = BR_DONE;

  199      else if (f->get_family_id() == null_family_id) {
  200:         TRACE("bvarray2uf_rw", tout << "UF APP: " << f->get_name() << std::endl; );
  201  

  227      else if (m_array_util.get_family_id() == f->get_family_id()) {
  228:         TRACE("bvarray2uf_rw", tout << "APP: " << f->get_name() << std::endl; );
  229  

  233              expr * i = args[1];
  234:             TRACE("bvarray2uf_rw", tout <<
  235                  "select; array: " << mk_ismt2_pp(t, m()) <<

  311                      expr * v = args[2];
  312:                     TRACE("bvarray2uf_rw", tout <<
  313                          "store; array: " << mk_ismt2_pp(s, m()) <<

  342                          extra_assertions.push_back(ground_atom);
  343:                         TRACE("bvarray2uf_rw", tout << "ground atom: " << mk_ismt2_pp(ground_atom, m()) << std::endl; );
  344                      }

  352  
  353:     CTRACE("bvarray2uf_rw", res == BR_DONE, tout << "result: " << mk_ismt2_pp(result, m()) << std::endl; );
  354      return res;

  358  {
  359:     TRACE("bvarray2uf_rw_q", tout << "pre_visit: " << mk_ismt2_pp(t, m()) << std::endl;);
  360  

  362          quantifier * q = to_quantifier(t);
  363:         TRACE("bvarray2uf_rw_q", tout << "pre_visit quantifier [" << q->get_id() << "]: " << mk_ismt2_pp(q->get_expr(), m()) << std::endl;);
  364          sort_ref_vector new_bindings(m_manager);

z3/src/tactic/bv/elim_small_bv_tactic.cpp:
   71              unsigned idx, sort * s, expr * e, expr * replacement) {
   72:             TRACE("elim_small_bv", tout << "replace idx " << idx << " with " << mk_ismt2_pp(replacement, m) <<
   73                  " in " << mk_ismt2_pp(e, m) << std::endl;);

   90  
   91:             TRACE("elim_small_bv", tout << "substitution: " << std::endl;
   92                                      for (unsigned k = 0; k < substitution.size(); k++) {

  105              m_simp(res, res, pr);
  106:             TRACE("elim_small_bv", tout << "replace done: " << mk_ismt2_pp(res, m) << std::endl;);
  107  

  111          br_status reduce_app(func_decl * f, unsigned num, expr * const * args, expr_ref & result, proof_ref & result_pr) {
  112:             TRACE("elim_small_bv_app", expr_ref tmp(m.mk_app(f, num, args), m); tout << "reduce " << tmp << std::endl; );
  113              return BR_FAILED;

  125              }
  126:             TRACE("elim_small_bv", tout << "reduce_quantifier " << mk_ismt2_pp(q, m) << std::endl; );
  127              unsigned long long num_steps = 0;

  143                      unsigned bv_sz = m_util.get_bv_size(s);
  144:                     TRACE("elim_small_bv", tout << "eliminating " << q->get_decl_name(i) <<
  145                          "; sort = " << mk_ismt2_pp(s, m) <<

  171                  
  172:                 TRACE("elim_small_bv", tout << "new bodies: " << std::endl;
  173                        for (unsigned k = 0; k < new_bodies.size(); k++)

  189  
  190:             TRACE("elim_small_bv", tout << "elimination result: " << mk_ismt2_pp(result, m) << std::endl; );
  191  

  197          bool pre_visit(expr * t) {
  198:             TRACE("elim_small_bv_pre", tout << "pre_visit: " << mk_ismt2_pp(t, m) << std::endl;);
  199              if (is_quantifier(t)) {
  200                  quantifier * q = to_quantifier(t);
  201:                 TRACE("elim_small_bv", tout << "pre_visit quantifier [" << q->get_id() << "]: " << mk_ismt2_pp(q->get_expr(), m) << std::endl;);
  202                  sort_ref_vector new_bindings(m);

z3/src/tactic/bv/max_bv_sharing_tactic.cpp:
  129                          if (r != nullptr) {
  130:                             TRACE("bv_sharing_detail", tout << "reusing args: " << i << " " << j << "\n";);
  131                              _args[i] = r;

  173              while (true) {
  174:                 TRACE("bv_sharing_detail", tout << "tree-loop: num_args: " << num_args << "\n";);
  175                  unsigned j  = 0;

z3/src/tactic/core/blast_term_ite_tactic.cpp:
  78                  if (!m.is_bool(args[i]) && m.is_ite(args[i], c, t, e)) {
  79:                     TRACE("blast_term_ite", result = m.mk_app(f, num_args, args); tout << result << "\n";);
  80                      expr_ref e1(m), e2(m);

z3/src/tactic/core/cofactor_elim_term_ite.cpp:
  109                  bool form_ctx = fr.m_form_ctx;
  110:                 TRACE("cofactor", tout << "processing, form_ctx: " << form_ctx << "\n" << mk_bounded_pp(t, m) << "\n";);
  111  

  148                          m_has_term_ite.mark(t);
  149:                         TRACE("cofactor", tout << "saving candidate: " << form_ctx << "\n" << mk_bounded_pp(t, m) << "\n";);
  150                          save_candidate(t, form_ctx);

  165      expr * get_first(expr * t) { 
  166:         TRACE("cofactor", tout << mk_ismt2_pp(t, m) << "\n";);
  167          typedef std::pair<expr *, unsigned> frame;

  224      expr * get_best(expr * t) {
  225:         TRACE("cofactor", tout << mk_ismt2_pp(t, m) << "\n";);
  226          typedef std::pair<expr *, unsigned> frame;

  299          visited.reset();
  300:         CTRACE("cofactor", best != 0, tout << "best num-occs: " << best_occs << "\n" << mk_ismt2_pp(best, m) << "\n";);
  301          return best;

  360                          m_value = to_app(lhs); 
  361:                         TRACE("cofactor", tout << "term:\n" << mk_ismt2_pp(m_term, m) << "\nvalue: " << mk_ismt2_pp(m_value, m) << "\n";);
  362                      }

  365                          m_value = to_app(rhs);
  366:                         TRACE("cofactor", tout << "term:\n" << mk_ismt2_pp(m_term, m) << "\nvalue: " << mk_ismt2_pp(m_value, m) << "\n";);
  367                      }

  447                  unsigned step = 0;
  448:                 TRACE("cofactor_ite", tout << "cofactor target:\n" << mk_ismt2_pp(s, m) << "\n";);
  449                  expr_ref curr(m);

  469                      curr = m.mk_ite(c, pos_cofactor, neg_cofactor);
  470:                     TRACE("cofactor", tout << "cofactor_ite step: " << step << "\n" << mk_ismt2_pp(curr, m) << "\n";);
  471                  }

  524              unsigned step = 0;
  525:             TRACE("cofactor", tout << "cofactor target:\n" << mk_ismt2_pp(t, m) << "\n";);
  526              expr_ref curr(m);

  555                  }
  556:                 TRACE("cofactor", 
  557                        tout << "cofactor_ite step: " << step << "\n";

  577                  expr * t   = fr.first;
  578:                 TRACE("cofactor_bug", tout << "processing: " << t->get_id() << " :first " << fr.second << "\n";);
  579                  if (!is_app(t)) {

  606                      expr * new_arg = nullptr;
  607:                     TRACE("cofactor_bug", tout << "collecting child: " << arg->get_id() << "\n";);
  608                      m_cache.find(arg, new_arg);

  634                  SASSERT(new_t.get() != 0);
  635:                 TRACE("cofactor_bug", tout << "caching: " << t->get_id() << "\n";);
  636  #if 0

z3/src/tactic/core/ctx_simplify_tactic.cpp:
   84  
   85:     CTRACE("assert_eq_bug", m_assertions.contains(t),
   86             tout << "t:\n" << mk_ismt2_pp(t, m) << "\nval:\n" << mk_ismt2_pp(val, m) << "\n";

  183              for (unsigned i = 0; i < m_cache.size(); i++) {
  184:                 CTRACE("ctx_simplify_tactic_bug", m_cache[i].m_from,
  185                         tout << "i: " << i << "\n" << mk_ismt2_pp(m_cache[i].m_from, m) << "\n";

  208      bool shared(expr * t) const {
  209:         TRACE("ctx_simplify_tactic_bug", tout << mk_pp(t, m) << "\n";);
  210          return t->get_ref_count() > 1 && m_occs.get_num_occs(t) > 1;

  229          unsigned id = from->get_id();
  230:         TRACE("ctx_simplify_tactic_cache", tout << "caching " << id << " @ " << scope_level() << "\n" << mk_ismt2_pp(from, m) << "\n--->\n" << mk_ismt2_pp(to, m) << "\n";);
  231          m_cache.reserve(id+1);

  274              SASSERT(to_delete->m_lvl == lvl);
  275:             TRACE("ctx_simplify_tactic_cache", tout << "uncaching: " << to_delete->m_lvl << "\n" <<
  276                    mk_ismt2_pp(key, m) << "\n--->\n" << mk_ismt2_pp(to_delete->m_to, m) << "\nrestoring:\n";

  330          checkpoint();
  331:         TRACE("ctx_simplify_tactic_detail", tout << "processing: " << mk_bounded_pp(t, m) << "\n";);
  332          if (is_cached(t, r) || m_simp->simplify(t, r)) {

  347          SASSERT(r.get() != 0);
  348:         TRACE("ctx_simplify_tactic_detail", tout << "result:\n" << mk_bounded_pp(t, m) << "\n---->\n" << mk_bounded_pp(r, m) << "\n";);
  349      }

  465                  expr * args[3] = { new_c.get(), new_t.get(), new_e.get() };
  466:                 TRACE("ctx_simplify_tactic_ite_bug",
  467                        tout << "mk_ite\n" << mk_ismt2_pp(new_c.get(), m) << "\n" << mk_ismt2_pp(new_t.get(), m)

  486              simplify(arg, new_arg);
  487:             CTRACE("ctx_simplify_tactic_bug", new_arg.get() == 0, tout << mk_ismt2_pp(arg, m) << "\n";);
  488              SASSERT(new_arg);

  554      void process(expr * s, expr_ref & r) {
  555:         TRACE("ctx_simplify_tactic", tout << "simplifying:\n" << mk_ismt2_pp(s, m) << "\n";);
  556          SASSERT(scope_level() == 0);

  561          SASSERT(r.get() != 0);
  562:         TRACE("ctx_simplify_tactic", tout << "result\n" << mk_ismt2_pp(r, m) << " :num-steps " << m_num_steps << "\n";
  563                tout << "old size: " << expr_size(s) << " new size: " << expr_size(r) << "\n";);

z3/src/tactic/core/dom_simplify_tactic.cpp:
   93          change = false;
   94:         TRACE("simplify", 
   95                for (auto & kv : m_doms) {

  138      extract_tree();
  139:     TRACE("simplify", display(tout););
  140      return true;

  235          else {
  236:             TRACE("simplify", tout << new_c << "\n" << new_t << "\n" << new_e << "\n";);
  237              r = m.mk_ite(new_c, new_t, new_e);

  247      (*m_simplifier)(r);
  248:     CTRACE("simplify", e != r, tout << "depth: " << m_depth << " " << mk_pp(e, m) << " -> " << r << "\n";);
  249      return r;

  299      }
  300:     CTRACE("simplify", e0 != r, tout << "depth before: " << m_depth << " " << mk_pp(e0, m) << " -> " << r << "\n";);
  301      (*m_simplifier)(r);
  302      cache(e0, r);
  303:     CTRACE("simplify", e0 != r, tout << "depth: " << m_depth << " " << mk_pp(e0, m) << " -> " << r << "\n";);
  304      --m_depth;

  400              }
  401:             CTRACE("simplify", r != g.form(i), tout << r << " " << mk_pp(g.form(i), m) << "\n";);
  402              change |= r != g.form(i);

  421              change |= r != g.form(i);
  422:             CTRACE("simplify", r != g.form(i), tout << r << " " << mk_pp(g.form(i), m) << "\n";);
  423              proof_ref new_pr(m);

  553  
  554:         TRACE("simplify", tout << t->get_id() << ": " << mk_bounded_pp(t, m) << " " << (sign?" - neg":" - pos") << "\n";);
  555  

  574              if (is_gt(lhs, rhs)) {
  575:                 TRACE("propagate_values", tout << "insert " << mk_pp(lhs, m) << " -> " << mk_pp(rhs, m) << "\n";);
  576                  m_scoped_substitution.insert(lhs, rhs, pr);

  579              if (is_gt(rhs, lhs)) {
  580:                 TRACE("propagate_values", tout << "insert " << mk_pp(rhs, m) << " -> " << mk_pp(lhs, m) << "\n";);
  581                  m_scoped_substitution.insert(rhs, lhs, m.mk_symmetry(pr));

  583              }
  584:             TRACE("propagate_values", tout << "incompatible " << mk_pp(n, m) << "\n";);
  585          }

z3/src/tactic/core/elim_uncnstr_tactic.cpp:
   98              v = m().mk_fresh_const(nullptr, t->get_sort());
   99:             TRACE("elim_uncnstr_bug", tout << "eliminating:\n" << mk_ismt2_pp(t, m()) << "\n";);
  100:             TRACE("elim_uncnstr_bug_ll", tout << "eliminating:\n" << mk_bounded_pp(t, m()) << "\n";);
  101              m_fresh_vars.push_back(v);

  784          bool produce_proofs = g->proofs_enabled();
  785:         TRACE("goal", g->display(tout););
  786          tactic_report report("elim-uncnstr", *g);

  795          bool modified = true;
  796:         TRACE("elim_uncnstr", tout << "unconstrained variables...\n";
  797                  for (expr * v : m_vars) tout << mk_ismt2_pp(v, m()) << " "; 

  826                  }
  827:                 TRACE("elim_uncnstr", if (m_mc) m_mc->display(tout); else tout << "no mc\n";);
  828                  m_mc = nullptr;

  831                  g->inc_depth();
  832:                 TRACE("goal", g->display(tout););
  833                  return;

z3/src/tactic/core/injectivity_tactic.cpp:
  154                  if (!is_axiom(goal->form(i), f, g)) continue;
  155:                 TRACE("injectivity", tout << "Marking " << f->get_name() << " as injective" << std::endl;);
  156                  inj_map.insert(f, g);

  210              SASSERT(a->get_arg(0)->get_sort() == b->get_arg(0)->get_sort());
  211:             TRACE("injectivity", tout << "Rewriting (= " << mk_ismt2_pp(args[0], m()) <<
  212                                                " " << mk_ismt2_pp(args[1], m()) << ")" << std::endl;);

  241          m_manager(m) {
  242:         TRACE("injectivity", tout << "constructed new tactic" << std::endl;);
  243          m_map = alloc(InjHelper, m);

z3/src/tactic/core/nnf_tactic.cpp:
   42          m_nnf(nullptr) {
   43:         TRACE("nnf", tout << "nnf_tactic constructor: " << p << "\n";);
   44      }

   56      void operator()(goal_ref const & g, goal_ref_buffer & result) override {
   57:         TRACE("nnf", tout << "params: " << m_params << "\n"; g->display(tout););
   58          tactic_report report("nnf", *g);

  110      new_p.set_sym("mode", symbol("full"));
  111:     TRACE("nnf", tout << "mk_nnf: " << new_p << "\n";);
  112      return using_params(mk_snf_tactic(m, p), new_p);

z3/src/tactic/core/pb_preprocess_tactic.cpp:
  159              rec const& r = it->m_value;
  160:             TRACE("pb", tout << mk_pp(e, m) << " " << r.pos.size() << " " << r.neg.size() << "\n";);
  161              if (r.pos.empty()) {                

  300                      start = end;
  301:                     TRACE("pb", tout << fml1 << "\n";);
  302                  }

  304                  g->update(i, fml2, nullptr, g->dep(i));
  305:                 TRACE("pb", tout << fml2 << "\n";);
  306              }

  485          expr* fml2 = g->form(idx2);
  486:         TRACE("pb", tout << mk_pp(fml1, m) << " " << mk_pp(fml2, m) << "\n";);
  487          expr_ref_vector args1(m), args2(m);

  502                  return;            
  503:             TRACE("pb", tout << mk_pp(x, m) << "\n";);
  504              rec const& r = m_vars.find(to_app(x));

  547  
  548:         TRACE("pb",
  549                tout << "resolve: " << mk_pp(fml1, m) << "\n" << mk_pp(fml2, m) << "\n" << tmp1 << "\n";

  615                  if (tmp != f) {
  616:                     TRACE("pb", tout << mk_pp(f, m) << " -> " << tmp 
  617                            << " by " << mk_pp(e, m) << " |-> " << mk_pp(v, m) << "\n";);

z3/src/tactic/core/propagate_values_tactic.cpp:
  105          if (is_shared_eq(new_curr, lhs, value, inverted)) {
  106:             TRACE("shallow_context_simplifier_bug", tout << "found eq:\n" << mk_ismt2_pp(new_curr, m) << "\n" << mk_ismt2_pp(new_pr, m) << "\n";);
  107              if (inverted && new_pr) new_pr = m.mk_symmetry(new_pr);

  125  
  126:         TRACE("shallow_context_simplifier_bug", tout << mk_ismt2_pp(curr, m) << "\n---->\n" << new_curr << "\n" << new_pr << "\n";);
  127          if (new_curr != curr) {

  159          while (true) {
  160:             TRACE("propagate_values", tout << "while(true) loop\n"; m_goal->display_with_dependencies(tout););
  161              if (forward) {

  195              IF_VERBOSE(100, verbose_stream() << "starting new round, goal size: " << m_goal->num_exprs() << std::endl;);
  196:             TRACE("propagate_values", tout << "round finished\n"; m_goal->display(tout); tout << "\n";);
  197          }

  202          SASSERT(m_goal->is_well_formed());
  203:         TRACE("propagate_values", tout << "end\n"; m_goal->display(tout););
  204:         TRACE("propagate_values_core", m_goal->display_with_dependencies(tout););
  205          m_goal = nullptr;

z3/src/tactic/core/reduce_args_tactic.cpp:
  183          
  184:         TRACE("reduce_args", tout << "non_candidates:\n";
  185                  for (func_decl* d : non_candidates)

  262  
  263:         TRACE("reduce_args", tout << "decl2args:" << std::endl;
  264                for (auto const& [k, v] : decl2args) {

  444              return;
  445:         TRACE("reduce_args", g.display(tout););
  446          tactic_report report("reduce-args", g);

  472  
  473:         TRACE("reduce_args", g.display(tout); if (g.mc()) g.mc()->display(tout););
  474      }

z3/src/tactic/core/reduce_invertible_tactic.cpp:
   72                      sub.insert(p, new_v);
   73:                     TRACE("invertible_tactic", tout << mk_pp(p, m) << " " << new_v << "\n";);
   74                      change = true;

   95              if (mc) g->add(mc.get());
   96: 	    TRACE("invertible_tactic", g->display(tout););
   97  	    g->inc_depth();

   99          result.push_back(g.get());
  100: 	CTRACE("invertible_tactic", g->mc(), g->mc()->display(tout););
  101      }

  368                  (*mc)->add(v, def);
  369:                 TRACE("invertible_tactic", tout << def << "\n";);
  370              }

  418          if (m.is_eq(p, e1, e2)) {
  419:             TRACE("invertible_tactic", tout << mk_pp(v, m) << "\n";);
  420              if (mc && has_diagonal(e1)) {

  536                  if (!occurs_under_nested_q(v, new_body) && t.is_invertible(v, p, new_v, nullptr, vars.size())) {
  537:                     TRACE("invertible_tactic", tout << mk_pp(v, m) << " " << mk_pp(p, m) << "\n";);
  538                      t.mark_inverted(p);

z3/src/tactic/core/simplify_tactic.cpp:
  64          }
  65:         TRACE("simplifier", g.display(tout););
  66          g.elim_redundancies();
  67:         TRACE("after_simplifier_detail", g.display_with_dependencies(tout););
  68      }

z3/src/tactic/core/solve_eqs_tactic.cpp:
   101              m_num_occs.find(t, num);
   102:             TRACE("solve_eqs_check_occs", tout << mk_ismt2_pp(t, m_manager) << " num_occs: " << num << " max: " << m_max_occs << "\n";);
   103              return num <= m_max_occs;

   391                  }
   392:                 TRACE("solve_eqs_bug2", tout << "eliminating: " << mk_ismt2_pp(f, m()) << "\n";);
   393                  return true;

   461              
   462:             TRACE("solve_eqs", 
   463                    tout << "candidate vars:\n";

   507                  if (j != idx && !check_eq_compat_rec(occ, cache, g.form(j), v, eq, all_e)) {
   508:                     TRACE("solve_eqs", tout << "occurs goal " << mk_pp(eq, m()) << "\n";);
   509                      return false;

   538                          if (j != p.m_index && is_marked(args[j])) {
   539:                             TRACE("solve_eqs", tout << "occurs and " << mk_pp(eq, m()) << " " << mk_pp(args[j], m()) << "\n";);
   540                              return false;

   548                                  if (!check_eq_compat_rec(occ, cache, args[j], v, eq, all_e)) {
   549:                                     TRACE("solve_eqs", tout << "occurs or " << mk_pp(eq, m()) << " " << mk_pp(args[j], m()) << "\n";);
   550                                      return false;

   672              
   673:             TRACE("solve_eqs", g.display(tout););
   674              for (unsigned idx = 0; !g.inconsistent() && idx < size; idx++) {

   680                  rw(tmp, tmp2, pr2);
   681:                 TRACE("solve_eqs", tout << mk_pp(f, m()) << "\n->\n" << tmp << "\n->\n" << tmp2 
   682                        << "\n" << pr1 << "\n" << pr2 << "\n" << mk_pp(g.pr(idx), m()) << "\n";);

   704              SASSERT(m_candidates.size() == m_vars.size());
   705:             TRACE("solve_eqs_bug", tout << "sorting vars...\n";);
   706              m_ordered_vars.reset();

   732                      m_num_steps++;
   733:                     TRACE("solve_eqs_bug", tout << "processing:\n" << mk_ismt2_pp(t, m()) << "\n";);
   734                      if (t->get_ref_count() > 1 && done.is_marked(t)) {

   841                         verbose_stream() << "\n";);
   842:             TRACE("solve_eqs", 
   843                    tout << "ordered vars:\n";

   876              m_subst->reset();
   877:             TRACE("solve_eqs", 
   878                    tout << "after normalizing variables\n";

   898                  expr * f = g.form(idx);
   899:                 TRACE("gaussian_leak", tout << "processing:\n" << mk_ismt2_pp(f, m()) << "\n";);
   900                  if (m_candidate_set.is_marked(f)) {

   912  
   913:                 TRACE("solve_eqs_subst", tout << mk_ismt2_pp(f, m()) << "\n--->\n" << mk_ismt2_pp(new_f, m()) << "\n";);
   914                  m_num_steps += m_r->get_num_steps() + 1;

   924              g.elim_true();
   925:             TRACE("solve_eqs", g.display(tout << "after applying substitution\n"););
   926  #if 0

  1002              tactic_report report("solve_eqs", *g);
  1003:             TRACE("goal", g->display(tout););
  1004              m_produce_models = g->models_enabled();

  1036                      save_elim_vars(mc);
  1037:                     TRACE("solve_eqs_round", g->display(tout); if (mc) mc->display(tout););
  1038                      if (rounds > 10 && m_ordered_vars.size() == 1)

z3/src/tactic/core/special_relations_tactic.cpp:
   32      bool is_match = m_pm.match_quantifier_index(to_quantifier(f), patterns, index);
   33:     TRACE("special_relations", tout << "check " << is_match << " " << mk_pp(f, m) << "\n";
   34            if (is_match) tout << patterns << " " << index << "\n";);

  115  
  116:     TRACE("special_relations", m_pm.display(tout););
  117  }

  156          default:
  157:             TRACE("special_relations", tout << "unprocessed feature " << feature << "\n";);
  158              break;

z3/src/tactic/core/split_clause_tactic.cpp:
  102          tactic_report report("split-clause", *in);
  103:         TRACE("before_split_clause", in->display(tout););
  104          ast_manager & m = in->m();

z3/src/tactic/core/symmetry_reduce_tactic.cpp:
  154                      num_sym_break_preds++;
  155:                     TRACE("symmetry_reduce", tout << "member predicate: " << mk_pp(mem, m()) << "\n";);
  156                      fml = m().mk_and(fml.get(), mem);

  203              P.push_back(it->m_value);
  204:             TRACE("symmetry_reduce",
  205                  for (unsigned i = 0; i < it->m_value.size(); ++i) {

  420          bool result = check_swap(fml, p[0], p[1]) && check_cycle(fml, p);
  421:         TRACE("symmetry_reduce", 
  422                if (result) {

  542          unsigned cts_delta = compute_cts_delta(t, cts, consts);
  543:         TRACE("symmetry_reduce", tout << mk_pp(t, m()) << " " << weight << " " << cts_delta << "\n";);
  544          for (unsigned i = 1; i < T.size(); ++i) {

  550              unsigned cts_delta1 = compute_cts_delta(t1, cts, consts);
  551:             TRACE("symmetry_reduce", tout << mk_pp(t1, m()) << " " << weight1 << " " << cts_delta1 << "\n";);
  552              if ((t->get_num_args() == t1->get_num_args() && (weight1 > weight || cts_delta1 < cts_delta)) || 

  578          for_each_expr(mem, t);
  579:         TRACE("symmetry_reduce",
  580                tout << "Term: " << mk_pp(t, m()) << "\n";

z3/src/tactic/core/tseitin_cnf_tactic.cpp:
  195              default:
  196:                 TRACE("tseitin_cnf_bug", tout << f->get_name() << "\n";);
  197                  UNREACHABLE();

  836  
  837:             TRACE("tseitin_cnf", g->display(tout););
  838  

z3/src/tactic/fd_solver/bounded_int2bv_solver.cpp:
  196              }
  197:             TRACE("int2bv", tout << mk_pp(kv.m_key, m) << " " << value << "\n";);
  198              mc->add(kv.m_key, value);

  296                  }
  297:                 TRACE("pb", tout << lo << " <= " << hi << " offset: " << offset << "\n"; tout << mk_pp(e, m) << " |-> " << t << "\n";);
  298                  sub.insert(e, t);

  300              else {
  301:                 TRACE("pb", 
  302                        tout << "unprocessed entry: " << mk_pp(e, m) << "\n";

  333          }
  334:         TRACE("int2bv", bm.display(tout););
  335          expr_safe_replace sub(m);

  350                  m_solver->assert_expr(fml2);
  351:                 TRACE("int2bv", tout << fml2 << "\n";);
  352              }

z3/src/tactic/fd_solver/smtfd_solver.cpp:
   406  
   407:         void add(expr* f, char const* msg) { m_lemmas.push_back(f); TRACE("smtfd", tout << msg << " " << mk_bounded_pp(f, m, 2) << "\n";); }
   408  

   548              if (f2.m_val_offset == f1.m_val_offset) {
   549:                 TRACE("smtfd_verbose", tout << "fresh: " << mk_pp(f, m, 2) << "\n";);
   550                  return;

   554              if (eq) {
   555:                 TRACE("smtfd_verbose", tout << "eq: " << " " << mk_bounded_pp(t, m, 2) << " " << mk_bounded_pp(f2.m_t, m, 2) << "\n";);
   556                  return;

   565              }            
   566:             TRACE("smtfd_verbose", tout << "diff: " << mk_bounded_pp(f1.m_t, m, 2) << " " << mk_bounded_pp(f2.m_t, m, 2) << "\n";);
   567              m_context.add(m.mk_implies(mk_and(m_args), m.mk_eq(f1.m_t, f2.m_t)), __FUNCTION__);

   799              if (round == 0 && is_uf(t)) {
   800:                 TRACE("smtfd_verbose", tout << "check-term: " << mk_bounded_pp(t, m, 2) << "\n";);
   801                  enforce_congruence(to_app(t)->get_decl(), to_app(t), s);

   862                      expr_ref val = model_value(f.m_t);
   863:                     TRACE("smtfd_verbose", tout << mk_bounded_pp(f.m_t, m, 2) << " := " << val << "\n";);
   864                      fi->insert_new_entry(args.data(), val);

   932              expr_ref vA = eval_abs(a);
   933:             TRACE("smtfd", tout << mk_bounded_pp(t, m, 2) << "\n";);
   934              enforce_congruence(vA, t, a->get_sort());                                 

   950              if (val1 != val2) {
   951:                 TRACE("smtfd", tout << "select/store: " << mk_bounded_pp(t, m, 2) << "\n";);
   952                  m_context.add(m.mk_eq(sel, stored_value), __FUNCTION__);

   995              if (val1 != val2 && !m.is_true(eqV)) {
   996:                 TRACE("smtfd", tout << "select/store: " << mk_bounded_pp(t, m, 2) << "\n";);                
   997                  m_context.add(m.mk_or(m.mk_eq(sel, t), mk_and(eqs)), __FUNCTION__);

  1069                  if (!tA.find(fT, fA) && t->get_sort() == m.get_sort(fT.m_t->get_arg(0))) {
  1070:                     TRACE("smtfd", tout << "not found\n";);
  1071                      add_select_store_axiom(t, fT);

  1085              SASSERT(t->get_sort() == a->get_sort());
  1086:             TRACE("smtfd", tout << mk_bounded_pp(t, m, 2) << " " << mk_bounded_pp(f.m_t, m, 2) << "\n";);
  1087              expr_ref eq = mk_eq_idxs(t, f.m_t);

  1181              if (!m.is_true(eval_abs(ext))) {
  1182:                 TRACE("smtfd", tout << mk_bounded_pp(a, m, 2) << " " << mk_bounded_pp(b, m, 2) << "\n";);
  1183                  m_context.add(ext, __FUNCTION__);            

  1436              }
  1437:             TRACE("smtfd", 
  1438                    tout << mk_pp(q, m) << "\n";

  1463              model_ref mdl;
  1464:             TRACE("smtfd", tout << "check: " << r << "\n";);
  1465              

  1471                  m_solver->get_model(mdl);
  1472:                 TRACE("smtfd", tout << *mdl << "\n";);
  1473  

  1495                  m_context.rewrite(body);
  1496:                 TRACE("smtfd", tout << "vals: " << vals << "\n" << body << "\n";);
  1497                  if (is_forall(q)) {

  1654                  m_assertions_qhead = m_assertions.size();
  1655:                 TRACE("smtfd", tout << "flush: " << m_assertions_qhead << " " << mk_bounded_pp(fml, m, 3) << "\n";);
  1656                  fml = abs(fml);

  1666              init_assumptions(num_assumptions, assumptions, asms);
  1667:             TRACE("smtfd", 
  1668                    for (unsigned i = 0; i < num_assumptions; ++i) {

  1671                    display(tout << asms << "\n"););
  1672:             TRACE("smtfd_verbose", m_fd_sat_solver->display(tout););
  1673  

  1685              init_model_assumptions(num_assumptions, assumptions, asms);
  1686:             TRACE("smtfd", display(tout << asms << "\n" << *m_model << "\n"););
  1687              lbool r = m_fd_core_solver->check_sat(asms);

  1690                  m_fd_core_solver->get_unsat_core(core);
  1691:                 TRACE("smtfd", display(tout << core << "\n"););
  1692                  SASSERT(asms.contains(m_toggles.back()));

  1706              
  1707:             TRACE("smtfd", m_context.display(tout););
  1708              for (expr* f : m_context) {

  1735  
  1736:             TRACE("smtfd", 
  1737                    tout << "axioms: " << m_axioms << "\n";

  1907          void flush_atom_defs() {
  1908:             CTRACE("smtfd", !m_abs.atom_defs().empty(), for (expr* f : m_abs.atom_defs()) tout << mk_bounded_pp(f, m, 4) << "\n";);
  1909              for (expr* f : m_abs.atom_defs()) {

  1918              expr_ref _fml(fml, m);
  1919:             TRACE("smtfd", tout << mk_bounded_pp(fml, m, 3) << "\n";);
  1920:             CTRACE("smtfd", m_axioms.contains(fml), 
  1921                     tout << "formula:\n" << _fml << "\n";

  1928              _fml = abs(fml);
  1929:             TRACE("smtfd", tout << mk_bounded_pp(_fml, m, 3) << "\n";);
  1930              m_fd_sat_solver->assert_expr(_fml);

  1936              expr_ref fml(m.mk_not(mk_and(core)), m);
  1937:             TRACE("smtfd", tout << "block:\n" << mk_bounded_pp(fml, m, 3) << "\n" << mk_bounded_pp(abs(fml), m, 3) << "\n";);
  1938              assert_fd(fml);

  2004                  round = 0;
  2005:                 TRACE("smtfd_verbose", 
  2006                        for (expr* f : m_context) tout << "refine " << mk_bounded_pp(f, m, 3) << "\n";

z3/src/tactic/fpa/fpa2bv_model_converter.cpp:
  35  void fpa2bv_model_converter::convert(model_core * mc, model * float_mdl) {
  36:     TRACE("fpa2bv_mc", tout << "BV Model: " << std::endl;
  37          for (unsigned i = 0; i < mc->get_num_constants(); i++)

  71          if (!seen.contains(f)) {
  72:             TRACE("fpa2bv_mc", tout << "Keeping: " << mk_ismt2_pp(f, m) << std::endl;);
  73              func_interp * val = mc->get_func_interp(f)->copy();

z3/src/tactic/fpa/fpa2bv_tactic.cpp:
   48  
   49:             TRACE("fpa2bv", g->display(tout << "BEFORE: " << std::endl););
   50  

  100  
  101:             TRACE("fpa2bv", g->display(tout << "AFTER:\n");
  102              if (g->mc()) g->mc()->display(tout); tout << std::endl; );

z3/src/tactic/portfolio/solver_subsumption_tactic.cpp:
  147      void operator()(goal_ref const& g, goal_ref_buffer& result) override {
  148:         TRACE("tactic", tout << "params: " << m_params << "\n"; g->display(tout););
  149          tactic_report report("subsumption", *g);

z3/src/tactic/sls/bvsls_opt_engine.cpp:
   40      SASSERT(m_bv_util.is_bv(objective));
   41:     TRACE("sls_opt", tout << "objective: " << (_maximize?"maximize":"minimize") << " " <<
   42                              mk_ismt2_pp(objective, m()) << std::endl;);

   46      if (initial_model.get() != nullptr) {
   47:         TRACE("sls_opt", tout << "Initial model provided: " << std::endl;
   48                          for (unsigned i = 0; i < initial_model->get_num_constants(); i++) {

   59  
   60:     TRACE("sls_opt", tout << "initial model is sat? " << is_sat << std::endl;);
   61  

  100  
  101:     TRACE("sls_opt", tout << "sat: " << res.is_sat << "; optimum: " << mk_ismt2_pp(res.optimum, m()) << std::endl;);
  102  

  123  
  124:     TRACE("sls_opt", tout << "Initial opt model:" << std::endl; m_obj_tracker.show_model(tout););    
  125  

  153                  // Can't improve and can't randomize; can't do anything other than bail out.
  154:                 TRACE("sls_opt", tout << "Got stuck; bailing out." << std::endl;);
  155                  IF_VERBOSE(10, verbose_stream() << "No local improvements possible." << std::endl;);

  161              m_stats.m_moves++;
  162:             TRACE("sls_opt", tout << "New optimum: " << m_mpz_manager.to_string(score) << std::endl;);
  163              IF_VERBOSE(10, verbose_stream() << "New optimum: " << m_mpz_manager.to_string(score) << std::endl;);

  187              if (mdl->get_const_interp(fd) != val)
  188:                 TRACE("sls_opt", tout << "model disagreement on " << fd->get_name() << ": " <<
  189                  mk_ismt2_pp(val, m()) << " != " << mk_ismt2_pp(mdl->get_const_interp(fd), m()) << std::endl;);

  219  
  220:         TRACE("sls_whatif", tout << "WHAT IF " << fd->get_name() << " WERE " << m_mpz_manager.to_string(temp) <<
  221                " --> " << r << "; score=" << m_mpz_manager.to_string(cur_best) << std::endl;);

  231      {
  232:         TRACE("sls_whatif_failed", tout << "WHAT IF " << fd->get_name() << " WERE " << m_mpz_manager.to_string(temp) <<
  233                " --> unsatisfied hard constraints" << std::endl;);

  355              if (m_hard_tracker.is_sat()) {
  356:                 TRACE("sls_opt", tout << "Randomizing " << random_fd->get_name() << " to " <<
  357                                           m_mpz_manager.to_string(random_val) << std::endl;);                

z3/src/tactic/sls/sls_engine.cpp:
  103          if (!mdl.is_true(a)) {
  104:             TRACE("sls", tout << "Evaluation: false\n";);
  105              return false;

  116  
  117:     TRACE("sls_top", tout << "Score distribution:";
  118            for (expr* e : m_assertions) 

  172  #ifdef Z3DEBUG
  173:     TRACE("sls_whatif", tout << "WHAT IF " << fd->get_name() << " WERE " << m_mpz_manager.to_string(temp) <<
  174              " --> " << r << std::endl;);

  288  
  289:         TRACE("sls", tout << "Randomization candidates: ";
  290          for (unsigned i = 0; i < unsat_constants.size(); i++)

  550              mc = model2model_converter(mdl.get());
  551:             TRACE("sls_model", mc->display(tout););
  552          }

z3/src/tactic/sls/sls_evaluator.h:
  487  
  488:         TRACE("sls_eval", tout << "(" << fd->get_name();
  489                              for (unsigned i = 0; i < n_args; i++)

  518              m_tracker.value2mpz(temp, check_res);
  519:             CTRACE("sls", !m_mpz_manager.eq(check_res, result), 
  520                              tout << "EVAL BUG: IS " << m_mpz_manager.to_string(result) << 

  806  
  807:         TRACE("sls",    tout << "Randomization candidate: " << unsat_constants[r]->get_name() << std::endl;
  808                          tout << "Locally randomized model: " << std::endl; 

z3/src/tactic/sls/sls_tactic.cpp:
  68          
  69:         TRACE("sls", g->display(tout););
  70          tactic_report report("sls", *g);

z3/src/tactic/sls/sls_tracker.h:
  436  
  437:         TRACE("sls", tout << "Initial model:" << std::endl; show_model(tout); );
  438  

  631      void randomize(ptr_vector<expr> const & as) {
  632:         TRACE("sls", tout << "Abandoned model:" << std::endl; show_model(tout); );
  633  

  641  
  642:         TRACE("sls", tout << "Randomized model:" << std::endl; show_model(tout); );
  643      }              

  645      void reset(ptr_vector<expr> const & as) {
  646:         TRACE("sls", tout << "Abandoned model:" << std::endl; show_model(tout); );
  647  

  695      double score_bool(expr * n, bool negated = false) {
  696:         TRACE("sls_score", tout << ((negated)?"NEG ":"") << "BOOL: " << mk_ismt2_pp(n, m_manager) << std::endl; );
  697  

  752                  res = (m_mpz_manager.eq(v0, v1)) ? 0.0 : 1.0;
  753:                 TRACE("sls_score", tout << "V0 = " << m_mpz_manager.to_string(v0) << " ; V1 = " << 
  754                                          m_mpz_manager.to_string(v1) << std::endl; );

  757                  res = m_mpz_manager.eq(v0, v1) ? 1.0 : 0.0;
  758:                 TRACE("sls_score", tout << "V0 = " << m_mpz_manager.to_string(v0) << " ; V1 = " << 
  759                                          m_mpz_manager.to_string(v1) << std::endl; );

  773                  res = 1.0 - (hamming_distance / (double) bv_sz);
  774:                 TRACE("sls_score", tout << "V0 = " << m_mpz_manager.to_string(v0) << " ; V1 = " << 
  775                                          m_mpz_manager.to_string(v1) << " ; HD = " << hamming_distance << 

  817              }
  818:             TRACE("sls_score", tout << "x = " << m_mpz_manager.to_string(x) << " ; y = " << 
  819                                      m_mpz_manager.to_string(y) << " ; SZ = " << bv_sz << std::endl; );

  844                  }
  845:                 TRACE("sls_score", tout << "x = " << m_mpz_manager.to_string(x) << " ; y = " << 
  846                                          m_mpz_manager.to_string(y) << " ; SZ = " << bv_sz << std::endl; );

  860                  }
  861:                 TRACE("sls_score", tout << "x = " << m_mpz_manager.to_string(x) << " ; y = " << 
  862                                          m_mpz_manager.to_string(y) << " ; SZ = " << bv_sz << std::endl; );

  905  
  906:         TRACE("sls_score", tout << "SCORE = " << res << std::endl; );
  907          return res;

z3/src/tactic/smtlogics/qfufbv_tactic.cpp:
  62  
  63:         TRACE("goal", g->display(tout););
  64          // running implementation

z3/src/tactic/smtlogics/quant_tactics.cpp:
  81      qi_p.set_str("qi.cost", "0");
  82:     TRACE("qi_cost", qi_p.display(tout); tout << "\n" << qi_p.get_str("qi.cost", "<null>") << "\n";);
  83      tactic * st = and_then(mk_no_solve_eq_preprocessor(m),

z3/src/tactic/ufbv/macro_finder_tactic.cpp:
  43              tactic_report report("macro-finder", *g);
  44:             TRACE("macro-finder", g->display(tout););
  45  

z3/src/tactic/ufbv/ufbv_rewriter.cpp:
   62          int smaller = is_smaller(lhs, rhs);
   63:         TRACE("demodulator", tout << "testing is_demodulator:\n"
   64                << mk_pp(lhs, m) << "\n"

  199      SASSERT(large && small);
  200:     TRACE("demodulator_fwd", tout << "INSERT: " << mk_pp(demodulator, m) << std::endl; );
  201  

  220  void ufbv_rewriter::remove_fwd_idx(func_decl * f, quantifier * demodulator) {
  221:     TRACE("demodulator_fwd", tout << "REMOVE: " << std::hex << (size_t)demodulator << std::endl; );
  222  

  270      if (it != m_fwd_idx.end()) {
  271:         TRACE("demodulator_bug", tout << "trying to rewrite: " << f->get_name() << " args:\n";
  272                tout << m_new_args << "\n";);

  282  
  283:             TRACE("demodulator_bug", tout << "Matching with demodulator: " << mk_pp(d, m) << std::endl; );
  284  

  287              if (m_match_subst(large, l_s.second, m_new_args.data(), np)) {
  288:                 TRACE("demodulator_bug", tout << "succeeded...\n" << mk_pp(l_s.second, m) << "\n===>\n" << mk_pp(np, m) << "\n";);
  289                  return true;

  314                      recursive = true;
  315:                     TRACE("demodulator", tout << "Detected demodulator cycle: " <<
  316                          mk_pp(a, m) << " --> " << mk_pp(v, m) << std::endl;);

  337  
  338:     TRACE("demodulator", tout << "rewrite: " << mk_pp(n, m) << std::endl; );
  339      app * a;

  345      while (!m_rewrite_todo.empty()) {
  346:         TRACE("demodulator_stack", tout << "STACK: " << std::endl;
  347                for (unsigned i = 0; i < m_rewrite_todo.size(); i++)

  400                              m_bsimp.mk_app(f, m_new_args.size(), m_new_args.data(), na);
  401:                         TRACE("demodulator_bug", tout << "e:\n" << mk_pp(e, m) << "\nnew_args: \n";
  402                                tout << m_new_args << "\n";

  438  
  439:     TRACE("demodulator", tout << "rewrite result: " << mk_pp(r, m) << std::endl; );
  440  

  602                  if (can_rewrite(d, lhs)) {
  603:                     TRACE("demodulator", tout << "Rescheduling: " << std::endl << mk_pp(d, m) << std::endl; );
  604                      //     remove d from m_fwd_idx

  621      if (m.proofs_enabled()) {
  622:         TRACE("tactic", tout << "PRE_DEMODULATOR=true is not supported when proofs are enabled.";);
  623          // Let us not waste time with proof production

  628  
  629:     TRACE("demodulator", tout << "before demodulator:\n";
  630                           for ( unsigned i = 0 ; i < n ; i++ )

  665              // np is a demodulator that allows us to replace 'large' with 'small'.
  666:             TRACE("demodulator", tout << "Found demodulator: " << std::endl;
  667                                   tout << mk_pp(large.get(), m) << std::endl << " ---> " <<

  669  
  670:             TRACE("demodulator_s", tout << "Found demodulator: " << std::endl;
  671                                     tout << to_app(large)->get_decl()->get_name() <<

  696          new_exprs.push_back(e);
  697:         TRACE("demodulator", tout << mk_pp(e, m) << std::endl; );
  698      }

  703                  new_exprs.push_back(e);
  704:                 TRACE("demodulator", tout << mk_pp(e, m) << std::endl; );
  705              }

  708  
  709:     TRACE("demodulator", tout << "after demodulator:\n" << new_exprs << "\n";);
  710  }

z3/src/test/algebraic.cpp:
  338  static void tst_eval_sign() {
  339:     enable_trace("anum_eval_sign");
  340      reslimit rl;

  419  static void tst_isolate_roots() {
  420:     enable_trace("isolate_roots");
  421      reslimit rl;

  634  
  635:     // enable_trace("resultant_bug");
  636:     // enable_trace("poly_sign");
  637:     disable_trace("algebraic");
  638:     // enable_trace("mpbq_bug");
  639:     // enable_trace("mpz_mul2k");
  640:     // enable_trace("mpz_gcd");
  641      tst_root();

z3/src/test/ast.cpp:
   46  //     ENSURE(v1 == v3);
   47: //     TRACE("ast", tout << "resetting v1\n";);
   48  //     v1.reset();
   49: //     TRACE("ast", tout << "overwriting v3\n";);
   50  //     v3 = v2;

   85  //     n = m.mk_var(1);
   86: //     TRACE("ast", tout << n->get_id() << "\n";);
   87  }

  144  void tst_ast() {
  145:     TRACE("ast", 
  146            tout << "sizeof(ast):  " << sizeof(ast) << "\n";

  149            );
  150:     TRACE("ast", tout << "sizeof(foo): " << sizeof(foo) << "\n";);
  151      tst1();

z3/src/test/bit_blaster.cpp:
   69          unsigned actual = to_int(mdl, out); \
   70:         TRACE("bit_blaster", \
   71              display(tout, out); \

  199  //     blaster.mk_ule(sz, a.c_ptr(), b.c_ptr(), out); 
  200: //     TRACE("bit_blaster", tout << mk_pp(out, m) << "\n";);
  201  //     blaster.mk_sle(sz, a.c_ptr(), b.c_ptr(), out);
  202: //     TRACE("bit_blaster", tout << mk_pp(out, m) << "\n";);
  203  }

  212  //     blaster.mk_eqs(sz, a.c_ptr(), b); 
  213: //     TRACE("bit_blaster", display(tout, b, false););
  214  }

  224  //     blaster.mk_shl(sz, a.c_ptr(), b.c_ptr(), c);
  225: //     TRACE("bit_blaster", tout << "shl\n"; display(tout, c););
  226  //     c.reset();
  227  //     blaster.mk_lshr(sz, a.c_ptr(), b.c_ptr(), c);
  228: //     TRACE("bit_blaster", tout << "lshr\n"; display(tout, c););
  229  //     c.reset();
  230  //     blaster.mk_ashr(sz, a.c_ptr(), b.c_ptr(), c);
  231: //     TRACE("bit_blaster", tout << "ashr " << c.size() << "\n"; display(tout, c, false););
  232  }

z3/src/test/chashtable.cpp:
  123          if (rand() % 3 == 2) {
  124:             TRACE("chashtable", tout << "erase " << v << "\n";);
  125              s.erase(v);

  129          else {
  130:             TRACE("chashtable", tout << "insert " << v << "\n";);
  131              s.insert(v);

z3/src/test/ddnf.cpp:
  203  void tst_ddnf1() {
  204:     enable_trace("ddnf");
  205      unsigned W = 2;

z3/src/test/diff_logic.cpp:
   87      ENSURE(!g.is_feasible_dbg());
   88:     TRACE("diff_logic", g.display(tout););
   89      struct proc {

  108      ENSURE(g.is_feasible_dbg());
  109:     TRACE("diff_logic", g.display(tout););
  110  }

  140      add_edge(g, 9, 10, 1, 910);
  141:     TRACE("diff_logic", g.display(tout););
  142  

z3/src/test/doc.cpp:
  226          result = dm.project(m2, to_delete, d);
  227:         TRACE("doc",
  228                for (unsigned i = 0; i < m_vars.size(); ++i) {

  252          project(*d, m2, to_delete, result);
  253:         TRACE("doc",              
  254                dm.display(tout, *d) << "\n";

  344          if (res != l_false) {
  345:             TRACE("doc",
  346                    tout << mk_pp(fml1, m) << "\n";

  461              fml2 = to_formula(d2, dm);
  462:             TRACE("doc", 
  463                    d1.display(dm, tout) << "\n";

  465              d1.intersect(dm, d2);
  466:             TRACE("doc", d1.display(dm, tout) << "\n";);
  467              ENSURE(d1.well_formed(dm));

z3/src/test/egraph.cpp:
  133  void tst_egraph() {
  134:     enable_trace("euf");
  135      test3();

z3/src/test/expr_substitution.cpp:
  64     
  65: //    enable_trace("th_rewriter_step");
  66  //    rw(a, new_a, pr);

z3/src/test/get_implied_equalities.cpp:
  77  static void tst_get_implied_equalities2() {
  78:     //enable_trace("after_search");
  79:     //enable_trace("get_implied_equalities");
  80:     //enable_trace("implied_equalities");
  81      Z3_config cfg = Z3_mk_config();

z3/src/test/heap.cpp:
   97              if (!h.contains(val)) {
   98:                 TRACE("heap", tout << "inserting: " << val << "\n";);
   99                  h.insert(val);
  100:                 TRACE("heap", dump_heap(h, tout););
  101                  ENSURE(h.contains(val));

  106              if (h.contains(val)) {
  107:                 TRACE("heap", tout << "removing: " << val << "\n";);
  108                  h.erase(val);
  109:                 TRACE("heap", dump_heap(h, tout););
  110                  ENSURE(!h.contains(val));

  120                  if (old_v < new_v) {
  121:                     TRACE("heap", tout << "value of: " << val << " increased old: " << old_v << " new: " << new_v << "\n";);
  122                      h.increased(val);

  124                  else {
  125:                     TRACE("heap", tout << "value of: " << val << " decreased old: " << old_v << " new: " << new_v << "\n";);
  126                      h.decreased(val);

  138      // enable_debug("heap");
  139:     enable_trace("heap");
  140      unsigned i = 0;

z3/src/test/inf_rational.cpp:
  24      inf_rational n(rational(0), false);
  25:     TRACE("inf_rational", tout << n << "\n";);
  26      ENSURE(n < inf_rational::zero());

z3/src/test/interval.cpp:
  458  void tst_interval() {
  459:     // enable_trace("interval_bug");
  460      // tst_float();
  461      // return;
  462:     // enable_trace("interval_nth_root");
  463      // tst_pi();

z3/src/test/list.cpp:
  33      ENSURE(append(r, static_cast<list<int> *>(nullptr), static_cast<list<int> *>(nullptr)) == nullptr);
  34:     TRACE("list", display(tout, l2->begin(), l2->end()); tout << "\n";);
  35      list<int> * l5 = append(r, l4, l2);
  36:     TRACE("list", display(tout, l5->begin(), l5->end()); tout << "\n";);
  37      list<int> * l6 = append(r, l5, l5);
  38      (void) l6;
  39:     TRACE("list", display(tout, l6->begin(), l6->end()); tout << "\n";);
  40  }

z3/src/test/mpf.cpp:
  84  void tst_mpf() {
  85:     enable_trace("mpf_mul_bug");
  86      bug_set_int();

z3/src/test/mpff.cpp:
  117  
  118: //  if (!qm.le(qa, qt)) { TRACE("mpff_bug", tout << fa << "\n" << qa << "\n" << qt << "\n";); UNREACHABLE(); }
  119  

  122  static void tst_ ## OP ## _core(int64_t n1, uint64_t d1, int64_t n2, uint64_t d2, unsigned precision = 2, unsigned exp = 0) { \
  123:     TRACE("mpff_bug", tout << n1 << "/" << d1 << ", " << n2 << "/" << d2 << "\n";); \
  124      unsynch_mpq_manager qm;                                             \

  612  void tst_mpff() {
  613:     disable_trace("mpff");
  614:     enable_trace("mpff_trace");
  615:     // enable_trace("mpff_bug");
  616:     // enable_trace("mpff_to_mpq");
  617      //

z3/src/test/mpz.cpp:
  151      (void)is_eq;
  152:     CTRACE("mpz_2k", !is_eq, tout << "div: " << m.to_string(v) << ", k: " << k << " r: " << m.to_string(x) << ", expected: " << m.to_string(y) << "\n";);
  153      ENSURE(is_eq);

  179      (void)is_eq;
  180:     CTRACE("mpz_2k", !is_eq, tout << "mul: " << m.to_string(v) << ", k: " << k << " r: " << m.to_string(x) << ", expected: " << m.to_string(y) << "\n";);
  181      ENSURE(is_eq);

  507  void tst_mpz() {
  508:     disable_trace("mpz");
  509:     enable_trace("mpz_2k");
  510      tst_pw2();

z3/src/test/nlarith_util.cpp:
  27  
  28:     enable_trace("nlarith");
  29      nlarith::util u(M);

z3/src/test/nlsat.cpp:
   61  static void tst3() {
   62:     enable_trace("nlsat_interval");
   63      reslimit rl;

  247  static void tst4() {
  248:     enable_trace("nlsat_interval");
  249      reslimit rl;

z3/src/test/no_overflow.cpp:
   95  
   96:     TRACE("no_overflow", tout << "test_add: bvsize = " << bvsize << ", is_signed = " << is_signed << "\n";);
   97  

  180  
  181:     TRACE("no_overflow", tout << "test_sub: bvsize = " << bvsize << ", is_signed = " << is_signed << "\n";);
  182  

  294  
  295:     TRACE("no_overflow", tout << "test_neg: bvsize = " << bvsize << "\n";);
  296  

  342  
  343:     TRACE("no_overflow", tout << "test_mul: bvsize = " << bvsize << ", is_signed = " << is_signed << "\n";);
  344  

  448  
  449:     TRACE("no_overflow", tout << "test_div: bvsize = " << bvsize << "\n";);
  450  

  573  
  574:     TRACE("no_overflow", tout << "test_" << params.name << "_equiv: bvsize = " << bvsize << ", is_signed = " << is_signed << "\n";);
  575  

z3/src/test/object_allocator.cpp:
   94                  cell * c = object_coeff_pairs[idx].first;
   95:                 CTRACE("object_allocator", c->m_coeff != rational(object_coeff_pairs[idx].second), tout << c->m_coeff << " != " << rational(object_coeff_pairs[idx].second) << "\n";);
   96                  ENSURE(c->m_coeff == rational(object_coeff_pairs[idx].second));

  112      }
  113:     TRACE("object_allocator", tout << "num. resets: " << num_resets << "\n";);
  114  }

  118      tst2();
  119:     TRACE("object_allocator", tout << "num. allocated cells: " << cell::g_num_allocated_cells << "\nnum. deallocated cells: " << cell::g_num_deallocated_cells << 
  120            "\nnum. recycled cells: " << cell::g_num_recycled_cells << "\n";);

z3/src/test/old_interval.cpp:
  197      tst2();
  198:     enable_trace("interval_bug");
  199      interval_tester tester;

z3/src/test/optional.cpp:
  30      ENSURE(*v == 10);
  31:     TRACE("optional", tout << sizeof(v) << "\n";);
  32  }

  38      OptFoo(int x, int y):m_x(x), m_y(y) {
  39:     TRACE("optional", tout << "OptFoo created: " << m_x << " : " << m_y << "\n";);
  40      }

  42      ~OptFoo() {
  43:     TRACE("optional", tout << "OptFoo deleted: " << m_x << " : " << m_y << "\n";);
  44      }

  55      ENSURE(v->m_y == 300);
  56:     TRACE("optional", tout << sizeof(v) << "\n";);
  57  }

  65      ENSURE(*v == &x);
  66:     TRACE("optional", tout << sizeof(v) << "\n";);
  67      ENSURE(*(*v) == 10);

z3/src/test/parray.cpp:
   51      m.push_back(a1, 10, a2);
   52:     TRACE("parray", 
   53            m.display_info(tout, a1); tout << "\n";

   58      m.push_back(a1, 30, a1);
   59:     TRACE("parray", 
   60            m.display_info(tout, a1); tout << "\n";

   71      ENSURE(m.get(a3, 1) == 100);
   72:     TRACE("parray", 
   73            m.display_info(tout, a1); tout << "\n";

   79      ENSURE(m.size(a2) == 2);
   80:     TRACE("parray", 
   81            m.display_info(tout, a1); tout << "\n";

   93      
   94:     TRACE("parray", tout << "tst2\n";);
   95      dummy_value_manager<int> vm;

  107          m.push_back(a2, i+101);
  108:     TRACE("parray", 
  109            m.display_info(tout, a1); tout << "\n";

  111      ENSURE(m.get(a1, 0) == 0);
  112:     TRACE("parray", 
  113            m.display_info(tout, a1); tout << "\n";

  120      }
  121:     TRACE("parray", 
  122            m.display_info(tout, a1); tout << "\n";

  124      m.unshare(a1);
  125:     TRACE("parray", 
  126            m.display_info(tout, a1); tout << "\n";

  136  
  137:     TRACE("parray", tout << "tst3\n";);
  138      dummy_value_manager<int> vm;

  166      }
  167:     TRACE("parray", 
  168            m.display_info(tout, a1); tout << "\n";

  173      ENSURE(m.get(a1, 10) == 10);
  174:     TRACE("parray", 
  175            tout << "after rerooting...\n";

  193      ENSURE(m.get(a3, 18) == 40);
  194:     TRACE("parray", 
  195            tout << "after many gets...\n";

  201      m.unshare(a1);
  202:     TRACE("parray", 
  203            tout << "after unshare...\n";

  209      m.reroot(a4);
  210:     TRACE("parray", 
  211            tout << "after reroot...\n";

  217      m.unshare(a2);
  218:     TRACE("parray", 
  219            tout << "after second unshare...\n";

  246  static void tst4() {
  247:     TRACE("parray", tout << "tst4\n";);
  248      ast_manager m;

  264      m2.pop_back(a1);
  265:     TRACE("parray", 
  266            m2.display_info(tout, a1); tout << "\n";

  269      m2.reroot(a1);
  270:     TRACE("parray", 
  271            m2.display_info(tout, a1); tout << "\n";

  305  void tst_parray() {
  306:     // enable_trace("parray_mem");
  307      tst1<true>();

z3/src/test/polynomial.cpp:
   257      polynomial_ref r2(m);
   258:     TRACE("polynomial", tout << "QUASI_RESULTANT: q, sqrt2.....\n";);
   259      r2  = quasi_resultant(q, sqrt2, 0);
   260:     // TRACE("polynomial", tout << "QUASI_RESULTANT: sqrt2, q.....\n";);
   261      // std::cout << "r2: " << r2 << "\n";

  1342                       rational expected) {
  1343:     TRACE("eval_bug", tout << "tst_eval, " << p << "\n";);
  1344      std::cout << "p: " << p << "\nx" << x0 << " -> " << v0 << "\nx" << x1 << " -> " << v1 << "\nx" << x2 << " -> " << v2 << "\n";

  1511  static void tst_gcd2() {
  1512:     // enable_trace("mgcd");
  1513      polynomial::numeral_manager nm;

  1601  static void tst_gcd3() {
  1602:     enable_trace("polynomial_gcd");
  1603:     enable_trace("polynomial_gcd_detail");
  1604:     enable_trace("mpzzp");
  1605      polynomial::numeral_manager nm;

  1627  static void tst_gcd4() {
  1628:     enable_trace("mgcd");
  1629:     // enable_trace("CRA");
  1630      polynomial::numeral_manager nm;

  1652  static void tst_newton_interpolation() {
  1653:     // enable_trace("newton");
  1654      polynomial::numeral_manager nm;

  1816      set_verbosity_level(1000);
  1817:     // enable_trace("factor");
  1818:     // enable_trace("poly_bug");
  1819:     // enable_trace("factor_bug");
  1820:     disable_trace("polynomial");
  1821:     enable_trace("psc_chain_classic");
  1822:     enable_trace("Lazard");
  1823:     // enable_trace("eval_bug");
  1824:     // enable_trace("mgcd");
  1825      tst_psc();

  1852      tst_translate();
  1853:     // enable_trace("mpz_gcd");
  1854      tst_vars();
  1855      tst_sqf();
  1856:     enable_trace("resultant");
  1857:     enable_trace("psc");
  1858:     disable_trace("polynomial");
  1859:     enable_trace("pseudo_remainder");
  1860:     enable_trace("resultant_bug");
  1861      tst_sqrt();

z3/src/test/polynorm.cpp:
  137  
  138:         TRACE("polynorm",
  139                tout << mk_pp(coefficient, m) << "\n";

z3/src/test/qe_arith.cpp:
  596      return;
  597: //    enable_trace("qe");
  598      testI(example8);    

z3/src/test/quant_elim.cpp:
  18  
  19:     //    enable_trace("bit2int");
  20:     //enable_trace("gomory_cut");
  21:     enable_trace("final_check_arith");
  22:     enable_trace("arith_final_check");
  23:     //enable_trace("arith_branching");
  24:     enable_trace("theory_arith_int");
  25:     enable_trace("presburger");
  26:     enable_trace("quant_elim");
  27:     // enable_trace("arith_simplifier_plugin");
  28:     // enable_trace("non_linear");
  29:     // enable_trace("gomory_cut_detail");
  30:     // enable_trace("arith");
  31:     // enable_trace("bv");
  32:     // enable_trace("after_search");
  33:     // enable_trace("bv_bit_prop");
  34  

z3/src/test/random.cpp:
  24      random_gen r(0);
  25:     TRACE("random", 
  26            for (unsigned i = 0; i < 1000; i++) {

z3/src/test/rational.cpp:
   95      ENSURE(rational(3,4) <  rational(7,8));
   96:     TRACE("rational", tout << rational(3,4) << "\n";);
   97:     TRACE("rational", tout << rational(7,9) << "\n";);
   98:     TRACE("rational", tout << rational(-3,7) << "\n";);
   99:     TRACE("rational", tout << rational(5,8) << "\n";);
  100:     TRACE("rational", tout << rational(4,2) << "\n";);
  101      ENSURE(rational(3) + rational(2) == rational(5));

  114      rational r3("20000000000000000000000000000000000/6");
  115:     TRACE("rational", tout << r1 << std::endl;);
  116:     TRACE("rational", tout << r2 << std::endl;);
  117:     TRACE("rational", tout << r3 << std::endl;);
  118  

  209      rational n1 = power(rational(2), 32);
  210:     TRACE("rational", tout << "n1: " << n1 << "\n";);
  211      rational n2 = div(n1, rational(2));
  212      rational n3 = div(rational(2), n2);
  213:     TRACE("rational", 
  214            tout << "n1: " << n1 << "\n";

  218      rational n5 = div(n4, rational(2));
  219:     TRACE("rational", 
  220            tout << "n4: " << n4 << "\n";

  226      rational n1("4294967293");
  227:     TRACE("rational", tout << "n1: " << n1 << "\n";);
  228      rational n2 = div(n1, rational(2));

  235      n1 /= n2;
  236:     TRACE("rational", tout << n1 << " " << n2 << " " << n1.is_big() << " " << n2.is_big() << "\n";);
  237      n1 *= n2;
  238:     TRACE("rational", tout << "after: " << n1 << " " << n2 << "\n";);
  239      ENSURE(n1.is_minus_one());

  307          extended_gcd(n, p, gcd, x, y);
  308:         TRACE("gcd", tout << n << " " << p << ": " << gcd << " " << x << " " << y << "\n";);
  309          ENSURE(!mod(n, rational(2)).is_one() || mod(n * x, p).is_one()); 

  470  void tst_rational() {
  471:     TRACE("rational", tout << "starting rational test...\n";);
  472      std::cout << "sizeof(rational): " << sizeof(rational) << "\n";

z3/src/test/rcf.cpp:
   73  static void tst2() {
   74:     enable_trace("mpz_matrix");
   75      unsynch_mpq_manager nm;

  166  void tst_rcf() {
  167:     enable_trace("rcf_clean");
  168:     enable_trace("rcf_clean_bug");
  169      tst_denominators();

z3/src/test/sat_lookahead.cpp:
  24      }
  25: //    enable_trace("sat");
  26      reslimit limit;

z3/src/test/simple_parser.cpp:
  38      p.parse_string("(+ x (* y x))", r);
  39:     TRACE("simple_parser", tout << mk_pp(r, m) << "\n";);
  40      p.parse_string("(+ x (* y x) x)", r);

  42      (void)vals;
  43:     TRACE("simple_parser",
  44            tout << mk_pp(r, m) << "\n";

  48      p.parse_string("(+ x))", r); // <<< this is accepted
  49:     TRACE("simple_parser", tout << mk_pp(r, m) << "\n";);
  50      p.parse_string(")x)", r); // error
  51      p.parse_string("(+ x (* 10 y) 2)", r);
  52:     TRACE("simple_parser", 
  53            tout << mk_pp(r, m) << "\n";

  55      p.parse_string("(ite (and (> x 3) (<= y 4))  2 10)", r);
  56:     TRACE("simple_parser", 
  57            tout << mk_pp(r, m) << "\n";

  59      p.parse_string("(ite (or (> x 3) (<= y 4))  2 10)", r);
  60:     TRACE("simple_parser", 
  61            tout << mk_pp(r, m) << "\n";

z3/src/test/simplifier.cpp:
   15      Z3_ast r = Z3_simplify(ctx, e);
   16:     TRACE("simplifier", 
   17            tout << Z3_ast_to_string(ctx, e) << " -> ";

   36      ENSURE(Z3_simplify(ctx, e) == Z3_mk_true(ctx));
   37:     TRACE("simplifier", tout << Z3_ast_to_string(ctx, e) << "\n";);
   38  

  151      ENSURE(Z3_mk_true(ctx) == b);
  152:     TRACE("simplifier", tout << Z3_ast_to_string(ctx, a) << "\n";);
  153:     TRACE("simplifier", tout << Z3_ast_to_string(ctx, b) << "\n";);
  154  

  181  
  182:     TRACE("simplifier", tout << Z3_ast_to_string(ctx, rxy) << "\n";);
  183:     TRACE("simplifier", tout << Z3_ast_to_string(ctx, Z3_simplify(ctx, Z3_mk_eq(ctx, x2, x3))) << "\n";);
  184      // ENSURE(rxy == Z3_mk_true(ctx));

  191              
  192:             TRACE("simplifier", 
  193                    tout << Z3_ast_to_string(ctx, exy);

  203  
  204:     TRACE("simplifier", 
  205            tout << Z3_ast_to_string(ctx,  Z3_simplify(ctx, sel1)) << "\n";

z3/src/test/small_object_allocator.cpp:
  17      char * p2 = new (soa) char[13];
  18:     TRACE("small_object_allocator", 
  19            tout << "p1: " << (void*)p1 << " q1: " << (void*)q1 << " p2: " << (void*)p2 << "\n";);

  23      char * p3 = new (soa) char[13];
  24:     TRACE("small_object_allocator", tout << "p3: " << (void*)p3 << "\n";);
  25      soa.deallocate(13,p3);

  30      char * r4 = new (soa) char[1];
  31:     TRACE("small_object_allocator", 
  32            tout << "r1: " << (void*)r1 << " r2: " << (void*)r2 << " r3: " << (void*)r3 << " r4: " << (void*)r4 << "\n";);

  39      r3 = new (soa) char[1];
  40:     TRACE("small_object_allocator", 
  41            tout << "r1: " << (void*)r1 << " r2: " << (void*)r2 << " r3: " << (void*)r3 << " r4: " << (void*)r4 << "\n";);

z3/src/test/sorting_network.cpp:
  221          model_smt2_pp(std::cout, m, *model, 0);
  222:         TRACE("pb", model_smt2_pp(tout, m, *model, 0););
  223      }

  269      if (res == l_true) {
  270:         TRACE("pb",
  271                unsigned sz = solver.size();

  277          model_smt2_pp(std::cout, m, *model, 0);
  278:         TRACE("pb", model_smt2_pp(tout, m, *model, 0););
  279      }

  326      if (res == l_true) {
  327:         TRACE("pb",
  328                unsigned sz = solver.size();

  334          model_smt2_pp(std::cout, m, *model, 0);
  335:         TRACE("pb", model_smt2_pp(tout, m, *model, 0););
  336      }

  375      if (res == l_true) {
  376:         TRACE("pb",
  377                unsigned sz = solver.size();

  383          model_smt2_pp(std::cout, m, *model, 0);
  384:         TRACE("pb", model_smt2_pp(tout, m, *model, 0););
  385      }

z3/src/test/string_buffer.cpp:
  35    }
  36:   TRACE("string_buffer", tout << b.c_str() << "\n";);
  37    ENSURE(strlen(b.c_str()) == 10000);

z3/src/test/substitution.cpp:
  22  
  23:     enable_trace("subst_bug");
  24  

  43  
  44:     TRACE("substitution", subst.display(tout););
  45:     TRACE("substitution", tout << ok1 << " " << ok2 << "\n";);
  46      subst.display(std::cout);
  47      subst.apply(v1.get(), res);
  48:     TRACE("substitution", tout << mk_pp(res, m) << "\n";);
  49  

  57      subst.apply(q, res);
  58:     TRACE("substitution", tout << mk_pp(q, m) << "\n->\n" << mk_pp(res, m) << "\n";);
  59  

z3/src/test/theory_pb.cpp:
   49      void fuzz() {
   50:         enable_trace("pb");
   51          unsigned nr = 0;

  133      
  134:     enable_trace("pb");
  135      for (unsigned N = 4; N < 11; ++N) {

  140              std::cout.flush();
  141:             TRACE("pb", tout << "k " << k << ": " << lits << "\n";);
  142  

  148                      ctx.assign(l, nullptr, false);
  149:                     TRACE("pb", tout << "assign: " << l << "\n";
  150                            ctx.display(tout););

  160                  ctx.assign(l, nullptr, false);
  161:                 TRACE("pb", ctx.display(tout););
  162                  VERIFY(l_true == ctx.check());

z3/src/test/trigo.cpp:
  112          unsigned d = PREC;
  113:         TRACE("sine", tout << "next-val : " << n << "/" << d << "\n";);
  114          fm.set(a, EBITS, SBITS, MPF_ROUND_TOWARD_POSITIVE, n, d);

  163  void tst_trigo() {
  164:     // enable_trace("sine");
  165:     // enable_trace("sine_bug");
  166:     // enable_trace("mpf_mul_bug");
  167      std::ofstream out("trigo-lemmas.math");

z3/src/test/upolynomial.cpp:
   125              // Fourier sequence may also be used to check if the interval is isolating
   126:             TRACE("upolynomial",
   127                    tout << "lowers[i]: " << bqm.to_string(lowers[i]) << "\n";

   142              unsigned dab = um.descartes_bound_a_b(q_sqf.size(), q_sqf.data(), bqm, lowers[i], uppers[i]);
   143:             TRACE("upolynomial", tout << "Descartes bound: " << dab << "\n";);
   144              VERIFY(dab == 1);

   898      fs.multiply(_r);
   899:     TRACE("upolynomial", tout << "_r: "; um.display(tout, _r); tout << "\n_p: "; um.display(tout, _p); tout << "\n";);
   900      ENSURE(um.eq(_p, _r));

  1062      set_verbosity_level(1000);
  1063:     enable_trace("mpz_gcd");
  1064:     enable_trace("normalize_bug");
  1065:     enable_trace("factor_bug");
  1066:     enable_trace("factor");
  1067:     // enable_trace("mpzp_inv_bug");
  1068:     // enable_trace("mpz");
  1069      tst_gcd();

  1082      tst_convert_q2bq();
  1083:     enable_trace("div_bug");
  1084:     enable_trace("mpbq_bug");
  1085      tst_translate_q();

z3/src/test/var_subst.cpp:
  54          expr_ref r = instantiate(m, q, cnsts.data());
  55:         TRACE("var_subst", tout << "quantifier:\n" << mk_pp(q, m) << "\nresult:\n" << mk_pp(r, m) << "\n";);
  56      }

z3/src/test/lp/gomory_test.h:
   59      void real_case_in_gomory_cut(const mpq & a, unsigned x_j, mpq & k, lar_term& pol, explanation & expl, const mpq& f_0, const mpq& one_minus_f_0) {
   60:         TRACE("gomory_cut_detail_real", tout << "real\n";);
   61          mpq new_a;

   85          }
   86:         TRACE("gomory_cut_detail_real", tout << a << "*v" << x_j << " k: " << k << "\n";);
   87          pol.add_monomial(new_a, x_j);

   94          mpq f_j =  fractional_part(a);
   95:         TRACE("gomory_cut_detail", 
   96                tout << a << " x_j = " << x_j << ", k = " << k << "\n";

  125          }
  126:         TRACE("gomory_cut_detail", tout << "new_a: " << new_a << " k: " << k << "\n";);
  127          t.add_monomial(new_a, x_j);

  140          if (pol.size() == 1) {
  141:             TRACE("gomory_cut_detail", tout << "pol.size() is 1" << std::endl;);
  142              unsigned v = pol[0].second;

  157          } else {
  158:             TRACE("gomory_cut_detail", tout << "pol.size() > 1" << std::endl;);
  159              lcm_den = lcm(lcm_den, denominator(k));
  160:             TRACE("gomory_cut_detail", tout << "k: " << k << " lcm_den: " << lcm_den << "\n";
  161                    for (unsigned i = 0; i < pol.size(); i++) {

  173              }
  174:             TRACE("gomory_cut_detail", tout << "after *lcm\n";
  175                    for (unsigned i = 0; i < pol.size(); i++) {

  184          }
  185:         TRACE("gomory_cut_detail", tout << "k = " << k << std::endl;);
  186          lp_assert(k.is_int());

  196      void mk_gomory_cut(lar_term& t, mpq& k, explanation & expl, unsigned inf_col, vector<std::pair<mpq, unsigned>> & row) {
  197:         enable_trace("gomory_cut");
  198:         enable_trace("gomory_cut_detail");
  199  
  200:         TRACE("gomory_cut",
  201                tout << "applying cut at:\n"; print_row(tout, row); 

  233  
  234:         TRACE("gomory_cut", tout<<"new cut :"; print_term(t, tout); tout << " >= " << k << std::endl;);
  235  

z3/src/test/lp/lp.cpp:
    75      t = to_sum(cn.get_nex_creator().simplify(t));
    76:     TRACE("nla_test", tout << "t=" << *t << '\n';);
    77      cn.run(t);

    81  #if Z3DEBUG
    82:     enable_trace("nla_cn");
    83:     enable_trace("nla_cn_details");
    84:     // enable_trace("nla_cn_details_");
    85:     enable_trace("nla_test");
    86      nex_creator r;

   127          [](const nex* n) {
   128:                            TRACE("nla_cn_test", tout << *n << "\n";);
   129                             return false;

   133                      r);
   134:     enable_trace("nla_cn");
   135:     enable_trace("nla_cn_details");
   136:     // enable_trace("nla_cn_details_");
   137:     enable_trace("nla_test");
   138      

   148      auto simp_two_a_plus_bc = r.simplify(two_a_plus_bc);
   149:     TRACE("nla_test", tout << * simp_two_a_plus_bc << "\n";);
   150      ENSURE(nex_creator::equal(simp_two_a_plus_bc, two_a_plus_bc));

   156      
   157:     TRACE("nla_test", tout << "before simplify " << *three_ab_square << "\n";);
   158      three_ab_square = to_mul(r.simplify(three_ab_square));
   159:     TRACE("nla_test", tout << *three_ab_square << "\n";);
   160      const rational& s = three_ab_square->coeff();

   162      auto m = r.mk_mul(a, a);
   163:     TRACE("nla_test_", tout << "m = " << *m << "\n";);
   164      /*

   169      n->add_child(r.mk_scalar(rational(1)));
   170:     TRACE("nla_test_", tout << "n = " << *n << "\n";); 
   171      m->add_child_in_power(n, 3);
   172      n->add_child_in_power(r.mk_scalar(rational(1, 3)), 2);
   173:     TRACE("nla_test_", tout << "m = " << *m << "\n";); 
   174      
   175      nex_sum * e = r.mk_sum(a, r.mk_sum(b, m));
   176:     TRACE("nla_test", tout << "before simplify e = " << *e << "\n";);
   177      e = to_sum(r.simplify(e));
   178:     TRACE("nla_test", tout << "simplified e = " << *e << "\n";);
   179      ENSURE(e->children().size() > 2);

   182          nex* ce = r.mk_mul(r.clone(ex), r.mk_scalar(rational(3)));        
   183:         TRACE("nla_test", tout << "before simpl ce = " << *ce << "\n";);        
   184          ce = r.simplify(ce);
   185:         TRACE("nla_test", tout << "simplified ce = " << *ce << "\n";);        
   186          e_m->add_child(ce);

   188      e->add_child(e_m);    
   189:     TRACE("nla_test", tout << "before simplify sum e = " << *e << "\n";);
   190      e = to_sum(r.simplify(e));
   191:     TRACE("nla_test", tout << "simplified sum e = " << *e << "\n";);
   192  
   193      nex * pr = r.mk_mul(a, b, b);
   194:     TRACE("nla_test", tout << "before simplify pr = " << *pr << "\n";);
   195      r.simplify(pr);
   196:     TRACE("nla_test", tout << "simplified sum e = " << *pr << "\n";);
   197      */

   205  //         [](const nex* n) {
   206: //             TRACE("nla_test", tout <<"cn form = " <<  *n << "\n";
   207                    

   212  //         []{ return 1; }, cr);
   213: //     enable_trace("nla_test");
   214: //     enable_trace("nla_cn");
   215: //     enable_trace("nla_cn_test");
   216: //     enable_trace("nla_cn_details");
   217: //     //    enable_trace("nla_cn_details_");
   218: //     enable_trace("nla_test_details");
   219  //     cr.set_number_of_vars(20);

   240  //     clone = to_sum(cr.simplify(clone));
   241: //     TRACE("nla_test", tout << "clone = " << *clone << "\n";);
   242  //     //    test_cn_on_expr(cr.mk_sum(aad,  abcd, aaccd, add, eae, eac, ed), cn);

   252  //         [](const nex* n) {
   253: //             TRACE("nla_test", tout <<"cn form = " <<  *n << "\n";);
   254  //             return false;

   257  //         []{ return 1; }, cr);
   258: //     enable_trace("nla_test");
   259: //     enable_trace("nla_cn_test");
   260: //     //    enable_trace("nla_cn");
   261: //     //   enable_trace("nla_test_details");
   262  //     cr.set_number_of_vars(20);

   298  //     ENSURE(cr.is_simplified(clone));
   299: //     TRACE("nla_test", tout << "clone = " << *clone << "\n";);
   300  //     //    test_cn_on_expr(cr.mk_sum(aad,  abcd, aaccd, add, eae, eac, ed), cn);
   301  //     test_cn_on_expr(to_sum(clone), cn);
   302: //     TRACE("nla_test", tout << "done\n";);
   303  //     test_cn_on_expr(cr.mk_sum(abd,  abc, cbd, acd), cn);
   304: //     TRACE("nla_test", tout << "done\n";);*/
   305  // #endif
   306  //     // test_cn_on_expr(a*b*b*d*d + a*b*b*c*d + c*b*b*d);
   307: //     // TRACE("nla_test", tout << "done\n";);
   308  //     // test_cn_on_expr(a*b*d + a*b*c + c*b*d);

  2927      var_index y = solver.add_named_var(_y, true, "y");
  2928:     enable_trace("lar_solver");
  2929:     enable_trace("cube");
  2930      vector<std::pair<mpq, var_index>> pairs;

z3/src/test/lp/nla_solver_test.cpp:
  155      std::cout << "test_basic_lemma_for_mon_neutral_from_factors_to_monomial_0\n";
  156:     enable_trace("nla_solver");
  157:     TRACE("nla_solver",);
  158      lp::lar_solver s;

  235      std::cout << "test_basic_lemma_for_mon_neutral_from_factors_to_monomial_1\n";
  236:     TRACE("nla_solver",);
  237      lp::lar_solver s;

  302      std::cout << "test_basic_lemma_for_mon_zero_from_factors_to_monomial\n";
  303:     enable_trace("nla_solver");
  304      lp::lar_solver s;

  371      std::cout << "test_basic_lemma_for_mon_zero_from_monomial_to_factors\n";
  372:     enable_trace("nla_solver");
  373      lp::lar_solver s;

  424      std::cout << "test_basic_lemma_for_mon_neutral_from_monomial_to_factors\n";
  425:     enable_trace("nla_solver");
  426      lp::lar_solver s;

  494  void test_horner() {
  495:     enable_trace("nla_solver");
  496      /*    lp::lar_solver s;

  539  void test_basic_sign_lemma() {
  540:     enable_trace("nla_solver");
  541      lp::lar_solver s;

  598  void test_order_lemma_params(bool var_equiv, int sign) {
  599:     /*    enable_trace("nla_solver");
  600      lp::lar_solver s;

  735      /*
  736:     enable_trace("nla_solver");
  737      lp::lar_solver s;

  801  void test_tangent_lemma_rat() {
  802:     enable_trace("nla_solver");
  803      lp::lar_solver s;

  829  void test_tangent_lemma_reg() {
  830:     enable_trace("nla_solver");
  831      lp::lar_solver s;

  857      /*
  858:     enable_trace("nla_solver");
  859      lp::lar_solver s;

z3/src/util/bit_vector.cpp:
  42   
  43:     TRACE("bit_vector", tout << "expanding: " << new_size << " capacity: " << m_capacity << " num words: " 
  44            << num_words(new_size) << "\n";);

  66  
  67:     TRACE("bit_vector",
  68            tout << "num_bits: " << m_num_bits << "\n";

z3/src/util/chashtable.h:
   92                        unsigned & used_slots) {
   93:         TRACE("chashtable", tout << "copy_table...\n";);
   94          SASSERT(target_slots >= source_slots);

  132  #if 0
  133:         TRACE("chashtable", 
  134                for (unsigned i = 0; i < source_capacity; i++) {

z3/src/util/gparams.cpp:
  600  void gparams::set(char const * name, char const * value) {
  601:     TRACE("gparams", tout << "setting [" << name << "] <- '" << value << "'\n";);
  602      SASSERT(g_imp);

  642  params_ref const& gparams::get_ref() {
  643:     TRACE("gparams", tout << "gparams::get_ref()\n";);
  644      SASSERT(g_imp);

  677  void gparams::init() {
  678:     TRACE("gparams", tout << "gparams::init()\n";);
  679      ALLOC_MUTEX(gparams_mux);

  683  void gparams::finalize() {
  684:     TRACE("gparams", tout << "gparams::finalize()\n";);
  685      dealloc(g_imp);

z3/src/util/hwf.cpp:
  132  
  133:     TRACE("mpf_dbg", tout << " f = " << f << " e = " << e << std::endl;);
  134  

  142  
  143:     TRACE("mpf_dbg", tout << "set: res = " << to_string(o) << std::endl;);
  144  }

z3/src/util/memory_manager.cpp:
  223      deallocate(p);
  224:     TRACE_CODE(if (!g_finalizing) TRACE("memory", tout << "dealloc " << std::hex << p << std::dec << " " << file << ":" << line << "\n";););
  225  }

  228      void * r = allocate(s);
  229:     TRACE("memory", tout << "alloc " << std::hex << r << std::dec << " " << file << ":" << line << " " << obj << " " << s << "\n";);
  230      return r;

z3/src/util/min_cut.cpp:
  34      m_edges[i].push_back(edge(j, capacity));
  35:     TRACE("spacer.mincut", tout << "adding edge (" << i << "," << j << ")\n";);    
  36  }

z3/src/util/mpbq.cpp:
  165      rational _r = to_rational(r);
  166:     TRACE("mpbq_bug", tout << "add a: " << _a << ", b: " << _b << ", r: " << _r << ", expected: " << (_a + _b) << "\n";);
  167      SASSERT(_a + _b == _r);

  193      rational _r = to_rational(r);
  194:     TRACE("mpbq_bug", tout << "sub a: " << _a << ", b: " << _b << ", r: " << _r << ", expected: " << (_a - _b) << "\n";);
  195      SASSERT(_a - _b == _r);

  752  void mpbq_manager::select_small_core(unsynch_mpq_manager & qm, mpq const & lower, mpbq const & upper, mpbq & r) {
  753:     TRACE("select_small", tout << "lower (q): " << qm.to_string(lower) << ", upper (bq): " << to_string(upper) << "\n";);
  754      SASSERT(gt(upper, lower));

z3/src/util/mpf.cpp:
    70  
    71:     TRACE("mpf_dbg", tout << "set: value = " << value << std::endl;);
    72      if (value == 0) {

    99  
   100:     TRACE("mpf_dbg", tout << "set: res = " << to_string(o) << std::endl;);
   101  }

   118  
   119:     TRACE("mpf_dbg", tout << "set: " << value << " is: raw=" << raw << " (double)" <<
   120                            " sign=" << sign << " s=" << s << " e=" << e << std::endl;);

   141  
   142:     TRACE("mpf_dbg", tout << "set: res = " << to_string(o) << std::endl;);
   143  }

   154  
   155:     TRACE("mpf_dbg", tout << "set: " << value << " is: raw=" << raw << " (float)" <<
   156                               " sign=" << sign << " s=" << s << " e=" << e << std::endl;);

   177  
   178:     TRACE("mpf_dbg", tout << "set: res = " << to_string_raw(o) << std::endl;);
   179  }

   181  void mpf_manager::set(mpf & o, unsigned ebits, unsigned sbits, mpf_rounding_mode rm, mpq const & value) {
   182:     TRACE("mpf_dbg", tout << "set: " << m_mpq_manager.to_string(value) << " [" << ebits << "/" << sbits << "]"<< std::endl;);
   183      scoped_mpz exp(m_mpz_manager);

   185      set(o, ebits, sbits, rm, exp, value);
   186:     TRACE("mpf_dbg", tout << "set: res = " << to_string(o) << std::endl;);
   187  }

   189  void mpf_manager::set(mpf & o, unsigned ebits, unsigned sbits, mpf_rounding_mode rm, char const * value) {
   190:     TRACE("mpf_dbg", tout << "set: " << value << " [" << ebits << "/" << sbits << "]"<< std::endl;);
   191  

   211  
   212:     TRACE("mpf_dbg", tout << "sgn = " << sgn << " f = " << f << " e = " << e << std::endl;);
   213  

   222  
   223:     TRACE("mpf_dbg", tout << "set: res = " << to_string(o) << std::endl;);
   224  }

   227      // Assumption: this represents significand * 2^exponent.
   228:     TRACE("mpf_dbg", tout << "set: sig = " << m_mpq_manager.to_string(significand) << " exp = " << m_mpz_manager.to_string(exponent) << std::endl;);
   229  

   262  
   263:         TRACE("mpf_dbg", tout << "Normalized: sig = " << m_mpq_manager.to_string(sig) <<
   264                                   " exp = " << m_mpz_manager.to_string(exp) << std::endl;);

   281  
   282:         TRACE("mpf_dbg", tout << "sig = " << m_mpz_manager.to_string(o.significand) <<
   283                                   " exp = " << o.exponent << std::endl;);

   292  
   293:     TRACE("mpf_dbg", tout << "set: res = " << to_string(o) << std::endl;);
   294  }

   531  
   532:         TRACE("mpf_dbg", tout << "A  = " << to_string(a) << std::endl;);
   533:         TRACE("mpf_dbg", tout << "B  = " << to_string(b) << std::endl;);
   534:         TRACE("mpf_dbg", tout << "d  = " << exp_delta << std::endl;);
   535  

   544  
   545:         TRACE("mpf_dbg", tout << "A' = " << m_mpz_manager.to_string(a.significand()) << std::endl;);
   546:         TRACE("mpf_dbg", tout << "B' = " << m_mpz_manager.to_string(b.significand()) << std::endl;);
   547  

   549          if (sgn(a) != sgn(b)) {
   550:             TRACE("mpf_dbg", tout << "SUBTRACTING" << std::endl;);
   551              m_mpz_manager.sub(a.significand(), b.significand(), o.significand);

   555          else {
   556:             TRACE("mpf_dbg", tout << "ADDING" << std::endl;);
   557              m_mpz_manager.add(a.significand(), b.significand(), o.significand);

   561  
   562:         TRACE("mpf_dbg", tout << "sum[-2:sbits+2] = " << m_mpz_manager.to_string(o.significand) << std::endl;);
   563  

   567              bool neg = m_mpz_manager.is_neg(o.significand);
   568:             TRACE("mpf_dbg", tout << "NEG=" << neg << std::endl;);
   569              m_mpz_manager.abs(o.significand);
   570:             TRACE("mpf_dbg", tout << "fs[-1:sbits+2] = " << m_mpz_manager.to_string(o.significand) << std::endl;);
   571              o.sign = ((!a.sign() &&  b.sign() &&  neg) ||

   580  void mpf_manager::mul(mpf_rounding_mode rm, mpf const & x, mpf const & y, mpf & o) {
   581:     TRACE("mpf_mul_bug", tout << "rm: " << rm << "\n";
   582            tout << "X: " << to_string(x) << "\n";

   585  
   586:     TRACE("mpf_dbg", tout << "X = " << to_string(x) << std::endl;);
   587:     TRACE("mpf_dbg", tout << "Y = " << to_string(y) << std::endl;);
   588  

   630  
   631:         TRACE("mpf_dbg", tout << "A = " << to_string(a) << std::endl;);
   632:         TRACE("mpf_dbg", tout << "B = " << to_string(b) << std::endl;);
   633  

   635  
   636:         TRACE("mpf_dbg", tout << "A' = " << m_mpz_manager.to_string(a.significand()) << std::endl;);
   637:         TRACE("mpf_dbg", tout << "B' = " << m_mpz_manager.to_string(b.significand()) << std::endl;);
   638  

   640  
   641:         TRACE("mpf_dbg", tout << "PRODUCT = " << to_string(o) << std::endl;);
   642  

   654      }
   655:     TRACE("mpf_mul_bug", tout << "result: " << to_string(o) << "\n";);
   656  }

   660  
   661:     TRACE("mpf_dbg", tout << "X = " << to_string(x) << std::endl;);
   662:     TRACE("mpf_dbg", tout << "Y = " << to_string(y) << std::endl;);
   663  

   712  
   713:         TRACE("mpf_dbg", tout << "A = " << to_string(a) << std::endl;);
   714:         TRACE("mpf_dbg", tout << "B = " << to_string(b) << std::endl;);
   715  

   717  
   718:         TRACE("mpf_dbg", tout << "A' = " << m_mpz_manager.to_string(a.significand()) << std::endl;);
   719:         TRACE("mpf_dbg", tout << "B' = " << m_mpz_manager.to_string(b.significand()) << std::endl;);
   720  

   724  
   725:         TRACE("mpf_dbg", tout << "QUOTIENT = " << to_string(o) << std::endl;);
   726  

   732  
   733:         TRACE("mpf_dbg", tout << "QUOTIENT' = " << to_string(o) << std::endl;);
   734  

   742  
   743:     TRACE("mpf_dbg", tout << "X = " << to_string(x) << std::endl;);
   744:     TRACE("mpf_dbg", tout << "Y = " << to_string(y) << std::endl;);
   745:     TRACE("mpf_dbg", tout << "Z = " << to_string(z) << std::endl;);
   746  

   803  
   804:         TRACE("mpf_dbg", tout << "A = " << to_string(a) << std::endl;
   805                           tout << "B = " << to_string(b) << std::endl;

   820  
   821:         TRACE("mpf_dbg", tout << "M = " << to_string(mr) << std::endl;
   822                           tout << "M = " << to_string_binary(mr, 1, 0) << std::endl;);

   834  
   835:         TRACE("mpf_dbg", tout << "C_= " << to_string(c) << std::endl;
   836                           tout << "C_= " << to_string_binary(c, 1, 0) << std::endl;);

   842          if (exp(c) > exp(mr)) {
   843:             TRACE("mpf_dbg", tout << "Swap!" << std::endl;);
   844              mr.swap(c);

   857          m_mpz_manager.machine_div_rem(c.significand(), m_powers2(exp_delta), c.significand(), sticky_rem);
   858:         TRACE("mpf_dbg", tout << "alignment shift by delta=" << exp_delta << " -> sig = " << m_mpz_manager.to_string(c.significand()) <<
   859                           " sticky_rem = " << m_mpz_manager.to_string(sticky_rem) << std::endl;);

   861  
   862:         TRACE("mpf_dbg", tout << "M'= " << m_mpz_manager.to_string(mr.significand()) << std::endl;
   863                           tout << "M'= " << to_string_binary(mr, 1, 0) << std::endl; );
   864:         TRACE("mpf_dbg", tout << "C'= " << m_mpz_manager.to_string(c.significand()) << std::endl;
   865                           tout << "C'= " << to_string_binary(c, 1, 0) << std::endl; );

   870          if (sgn(mr) != sgn(c)) {
   871:             TRACE("mpf_dbg", tout << "SUBTRACTING" << std::endl;);
   872              m_mpz_manager.sub(mr.significand(), c.significand(), res.significand());

   882          else {
   883:             TRACE("mpf_dbg", tout << "ADDING" << std::endl;);
   884              m_mpz_manager.add(mr.significand(), c.significand(), res.significand());

   889  
   890:         TRACE("mpf_dbg", tout << "S'= " << m_mpz_manager.to_string(res.significand()) << std::endl;
   891                           tout << "S'= " << to_string_binary(res, 1, 0) << std::endl; );

   901              m_mpz_manager.machine_div2k(res.significand(), 1);
   902:             TRACE("mpf_dbg", tout << "Add/Sub overflew into 4.xxx!" << std::endl;
   903                               tout << "S*= " << to_string_binary(res, 2, 0) << std::endl;);

   913  
   914:         TRACE("mpf_dbg", tout << "R*= " << to_string_binary(res, 2, 0) << " (renormalized, delta=" << renorm_delta << ")" << std::endl;);
   915  

   930  
   931:             TRACE("mpf_dbg", tout << "sum[-1:sbits+2] = " << m_mpz_manager.to_string(o.significand) << std::endl;
   932                              tout << "R = " << to_string_binary(o, 1, 3) << std::endl;);

   963      while (m.neq(lower, upper)) {
   964:         STRACE("mpf_dbg", tout << "SIG = " << m.to_string(in) <<
   965                                      " LOWER = " << m.to_string(lower) <<

   970              if (m.eq(product, in)) {
   971:                 STRACE("mpf_dbg", tout << "choosing lower" << std::endl;);
   972                  m.set(o, lower);

   974              else {
   975:                 STRACE("mpf_dbg", tout << "choosing upper" << std::endl;);
   976                  m.set(o, upper); // choosing upper is like a sticky bit here.

   984  
   985:         STRACE("mpf_dbg", tout << "MID = " << m.to_string(mid) <<
   986                                    " PROD = " << m.to_string(product) << std::endl;);

  1002  
  1003:     TRACE("mpf_dbg", tout << "X = " << to_string(x) << std::endl;);
  1004  

  1021  
  1022:         TRACE("mpf_dbg", tout << "A = " << to_string(a) << std::endl;);
  1023  

  1030                  m_mpz_manager.dec(o.significand);
  1031:             TRACE("mpf_dbg", tout << "dec'ed " << m_mpz_manager.to_string(o.significand) << std::endl;);
  1032          }

  1038  
  1039:     TRACE("mpf_dbg", tout << "SQRT = " << to_string(o) << std::endl;);
  1040  }

  1044  
  1045:     TRACE("mpf_dbg", tout << "X = " << to_string(x) << std::endl;);
  1046  

  1070              bool tie = m_mpz_manager.is_zero(x.significand) && x.exponent == -1;
  1071:             TRACE("mpf_dbg", tout << "tie = " << tie << std::endl;);
  1072              if (tie && rm == MPF_ROUND_NEAREST_TEVEN)

  1094  
  1095:         TRACE("mpf_dbg", tout << "A = " << to_string_raw(a) << std::endl;);
  1096  

  1105          const mpz & shiftm1_p = m_powers2(shift-1);
  1106:         TRACE("mpf_dbg", tout << "shift=" << shift << std::endl;);
  1107:         TRACE("mpf_dbg", tout << "shiftm1_p=" << m_mpz_manager.to_string(shiftm1_p) << std::endl;);
  1108  

  1110          m_mpz_manager.machine_div_rem(o.significand, shift_p, div, rem);
  1111:         TRACE("mpf_dbg", tout << "div=" << m_mpz_manager.to_string(div) << " rem=" << m_mpz_manager.to_string(rem) << std::endl;);
  1112  

  1119              (void)less_than_tie;
  1120:             TRACE("mpf_dbg", tout << "tie= " << tie << "; <tie = " << less_than_tie << "; >tie = " << more_than_tie << std::endl;);
  1121              if (tie) {

  1123                      (rm == MPF_ROUND_NEAREST_TAWAY)) {
  1124:                     TRACE("mpf_dbg", tout << "div++ (1)" << std::endl;);
  1125                      m_mpz_manager.inc(div);

  1131                      m_mpz_manager.inc(div);
  1132:                     TRACE("mpf_dbg", tout << "div++ (2)" << std::endl;);
  1133                  }

  1161  
  1162:     TRACE("mpf_dbg", tout << "INTEGRAL = " << to_string(o) << std::endl;);
  1163  }

  1211          if (inc) m_mpz_manager.inc(z);
  1212:         TRACE("mpf_dbg_sbv",
  1213                tout << "SBV: (" << to_string(x) << ") == " << m_mpq_manager.to_string(z) << std::endl;

  1222  
  1223:     TRACE("mpf_dbg", tout << "SBV = " << m_mpq_manager.to_string(o) << std::endl;);
  1224  }

  1249  
  1250:     TRACE("mpf_dbg", tout << "IEEE_BV = " << m_mpz_manager.to_string(o) << std::endl;);
  1251  }

  1279  
  1280:     TRACE("mpf_dbg_rem", tout << "x=" << to_string(x) << std::endl;
  1281                           tout << "y=" << to_string(y) << std::endl;

  1298  
  1299:     TRACE("mpf_dbg_rem", tout << "X/Y_exp=" << x_div_y_exp << std::endl;
  1300                           tout << "X/Y_sig_lrg=" << m_mpz_manager.to_string(x_div_y_sig_lrg) << std::endl;

  1319          bool more_than_tie = m_mpz_manager.gt(Q_rem, shiftm1_p);
  1320:         TRACE("mpf_dbg_rem", tout << "tie= " << tie << "; >tie= " << more_than_tie << std::endl;);
  1321          if ((tie && m_mpz_manager.is_odd(Q_sig)) || more_than_tie)

  1328      (void)Q_sgn;
  1329:     TRACE("mpf_dbg_rem", tout << "Q_exp=" << Q_exp << std::endl;
  1330                           tout << "Q_sig=" << m_mpz_manager.to_string(Q_sig) << std::endl;

  1349      (void)YQ_sgn;
  1350:     TRACE("mpf_dbg_rem", tout << "YQ_sgn=" << YQ_sgn << std::endl;
  1351                           tout << "YQ_exp=" << YQ_exp << std::endl;

  1362      mpf_exp_t exp_delta = exp(x) - YQ_exp;
  1363:     TRACE("mpf_dbg_rem", tout << "exp_delta=" << exp_delta << std::endl;);
  1364      SASSERT(INT_MIN < exp_delta && exp_delta <= INT_MAX);

  1391              m_mpz_manager.inc(subtrahend);
  1392:         TRACE("mpf_dbg_rem", tout << "aligned subtrahend=" << m_mpz_manager.to_string(subtrahend) << std::endl;);
  1393      }

  1395      m_mpz_manager.sub(minuend, subtrahend, X_YQ_sig);
  1396:     TRACE("mpf_dbg_rem", tout << "X_YQ_sig'=" << m_mpz_manager.to_string(X_YQ_sig) << std::endl;);
  1397  

  1407  
  1408:         TRACE("mpf_dbg_rem", tout << "minuend=" << m_mpz_manager.to_string(minuend) << std::endl;
  1409                               tout << "subtrahend=" << m_mpz_manager.to_string(subtrahend) << std::endl;

  1418          m_mpz_manager.machine_div_rem(X_YQ_sig, m_powers2(sbits-1), X_YQ_sig, rnd_bits);
  1419:         TRACE("mpf_dbg_rem", tout << "final sticky=" << m_mpz_manager.to_string(rnd_bits) << std::endl; );
  1420  

  1432  
  1433:     TRACE("mpf_dbg_rem", tout << "partial remainder = " << to_string_hexfloat(x) << std::endl;);
  1434  }

  1438  
  1439:     TRACE("mpf_dbg_rem", tout << "X = " << to_string(x) << "=" << to_string_hexfloat(x) << std::endl;
  1440                           tout << "Y = " << to_string(y) << "=" << to_string_hexfloat(y) << std::endl;);

  1480  
  1481:     TRACE("mpf_dbg_rem", tout << "R = " << to_string(o) << "=" << to_string_hexfloat(o) << std::endl; );
  1482:     TRACE("mpf_dbg", tout << "REMAINDER = " << to_string(o) << std::endl;);
  1483  }

  1544  
  1545:             //TRACE("mpf_dbg", tout << "SIG=" << m_mpq_manager.to_string(sig(x)) << std::endl; );
  1546:             //TRACE("mpf_dbg", tout << "NUM=" << m_mpq_manager.to_string(num) << std::endl;);
  1547:             //TRACE("mpf_dbg", tout << "DEN=" << m_mpq_manager.to_string(denom) << std::endl;);
  1548:             //TRACE("mpf_dbg", tout << "EXP=" << exponent << std::endl;);
  1549  

  1916  void mpf_manager::unpack(mpf & o, bool normalize) {
  1917:     TRACE("mpf_dbg", tout << "unpack " << to_string(o) << ": ebits=" <<
  1918                               o.ebits << " sbits=" << o.sbits <<

  1960  
  1961:     TRACE("mpf_dbg", tout << "RND: " << to_string(o) << std::endl;
  1962                       tout << to_string_binary(o, 1, 3) << std::endl;);

  1993  
  1994:     TRACE("mpf_dbg", tout << "e_min_norm = " << e_min << std::endl;
  1995                       tout << "e_max_norm = " << e_max << std::endl;

  2002  
  2003:     TRACE("mpf_dbg", tout << "Shift distance: " << m_mpz_manager.to_string(sigma) << " " << ((m_mpz_manager.is_nonneg(sigma))?"(LEFT)":"(RIGHT)") << std::endl;);
  2004  

  2019  
  2020:     TRACE("mpf_dbg", tout << "Shifted: " << to_string(o) << std::endl;
  2021                       tout << to_string_binary(o, 1, 3) << std::endl;);

  2033  
  2034:     TRACE("mpf_dbg", tout << "sign=" << o.sign << " last=" << last << " round=" << round << " sticky=" << sticky << std::endl;);
  2035:     TRACE("mpf_dbg", tout << "before rounding decision: " << to_string(o) << std::endl;);
  2036  

  2048  
  2049:     TRACE("mpf_dbg", tout << "Rounding increment -> significand +" << (int)inc << std::endl;);
  2050      if (inc)

  2052  
  2053:     TRACE("mpf_dbg", tout << "Rounded significand: " << to_string(o) << std::endl;);
  2054  

  2063      bool SIGovf = o.exponent > e_max;
  2064:     TRACE("mpf_dbg", tout << "Post-normalized: " << to_string(o) << std::endl;);
  2065:     TRACE("mpf_dbg", tout << "SIGovf = " << SIGovf << std::endl;);
  2066  

  2071  
  2072:     TRACE("mpf_dbg", tout << "OVF2 = " << OVF2 << std::endl;);
  2073:     TRACE("mpf_dbg", tout << "o_has_max_exp = " << o_has_max_exp << std::endl;);
  2074  

  2080          if (m_mpz_manager.ge(o.significand, p)) {
  2081:             TRACE("mpf_dbg", tout << "NORMAL: " << m_mpz_manager.to_string(o.significand) << std::endl;);
  2082              m_mpz_manager.sub(o.significand, p, o.significand); // Strips the hidden bit.

  2084          else {
  2085:             TRACE("mpf_dbg", tout << "DENORMAL: " << m_mpz_manager.to_string(o.significand) << std::endl;);
  2086              o.exponent = mk_bot_exp(o.ebits);

  2089  
  2090:     TRACE("mpf_dbg", tout << "ROUNDED = " << to_string(o) << std::endl;
  2091                       tout << to_string_binary(o, -1, 0) << " (hidden bit, unbiased exp)." << std::endl;);

  2094  void mpf_manager::round_sqrt(mpf_rounding_mode rm, mpf & o) {
  2095:     TRACE("mpf_dbg", tout << "RND-SQRT: " << to_string(o) << std::endl;);
  2096  

  2116  
  2117:     TRACE("mpf_dbg", tout << "last=" << last << " round=" << round << " sticky=" << sticky << " --> inc=" << inc << std::endl;);
  2118  

  2123  
  2124:     TRACE("mpf_dbg", tout << "ROUNDED = " << to_string(o) << std::endl;);
  2125  }

z3/src/util/mpff.cpp:
   328  void mpff_manager::set_core(mpff & n, mpz_manager<SYNCH> & m, mpz const & v) {
   329:     TRACE("mpff", tout << "mpz->mpff\n"; m.display(tout, v); tout << "\n";);
   330      if (m.is_int64(v)) {
   331:         TRACE("mpff", tout << "is_int64 " << m.get_int64(v) << "\n";);
   332          set(n, m.get_int64(v));

   334      else if (m.is_uint64(v)) {
   335:         TRACE("mpff", tout << "is_uint64\n";);
   336          set(n, m.get_uint64(v));

   344          }
   345:         TRACE("mpff", tout << "w words: "; for (unsigned i = 0; i < w.size(); i++) tout << w[i] << " "; tout << "\n";);
   346          unsigned w_sz = w.size();

   370      }
   371:     TRACE("mpff", tout << "mpz->mpff result:\n"; display_raw(tout, n); tout << "\n";);
   372      SASSERT(check(n));

   424  bool mpff_manager::lt(mpff const & a, mpff const & b) const {
   425:     STRACE("mpff_trace", tout << "[mpff] ("; display(tout, a); tout << " < "; display(tout, b); tout << ") == ";);
   426      if (is_zero(a)) {
   427          if (is_zero(b) || is_neg(b)) {
   428:             STRACE("mpff_trace", tout << "(1 == 0)\n";);
   429              return false;

   431          else {
   432:             STRACE("mpff_trace", tout << "(1 == 1)\n";);
   433              SASSERT(is_pos(b));

   439          if (is_neg(a)) {
   440:             STRACE("mpff_trace", tout << "(1 == 1)\n";);
   441              return true;

   444              SASSERT(is_pos(a));
   445:             STRACE("mpff_trace", tout << "(1 == 0)\n";);
   446              return false;

   452          if (b.m_sign == 0) {
   453:             STRACE("mpff_trace", tout << "(1 == 1)\n";);
   454              return true; // neg < pos

   459              (a.m_exponent == b.m_exponent && ::lt(m_precision, sig(b), sig(a)));
   460:         STRACE("mpff_trace", tout << "(" << r << " == 1)\n";);
   461          return r;

   464          if (b.m_sign == 1) {
   465:             STRACE("mpff_trace", tout << "(1 == 0)\n";);
   466              return false; // pos < neg

   471              (a.m_exponent == b.m_exponent && ::lt(m_precision, sig(a), sig(b)));
   472:         STRACE("mpff_trace", tout << "(" << r << " == 1)\n";);
   473          return r;

   649  
   650:     TRACE("mpff", tout << (is_sub ? "sub" : "add") << "("; display(tout, a); tout << ", "; display(tout, b); tout << ")\n";);
   651      

   768      }
   769:     TRACE("mpff", tout << "result: "; display(tout, c); tout << "\n";);
   770      SASSERT(check(c));

   773  void mpff_manager::add(mpff const & a, mpff const & b, mpff & c) {
   774:     STRACE("mpff_trace", tout << "[mpff] "; display(tout, a); tout << " + "; display(tout, b); tout << " " << (m_to_plus_inf ? "<=" : ">=") << " ";);
   775      add_sub(false, a, b, c);
   776:     STRACE("mpff_trace", display(tout, c); tout << "\n";);  
   777  }

   779  void mpff_manager::sub(mpff const & a, mpff const & b, mpff & c) {
   780:     STRACE("mpff_trace", tout << "[mpff] "; display(tout, a); tout << " - "; display(tout, b); tout << " " << (m_to_plus_inf ? "<=" : ">=") << " ";);
   781      add_sub(true, a, b, c);
   782:     STRACE("mpff_trace", display(tout, c); tout << "\n";);  
   783  }

   785  void mpff_manager::mul(mpff const & a, mpff const & b, mpff & c) {
   786:     STRACE("mpff_trace", tout << "[mpff] ("; display(tout, a); tout << ") * ("; display(tout, b); tout << ") " << (m_to_plus_inf ? "<=" : ">=") << " ";);
   787      if (is_zero(a) || is_zero(b)) {

   791          allocate_if_needed(c);
   792:         TRACE("mpff", tout << "mul("; display(tout, a); tout << ", "; display(tout, b); tout << ")\n";);
   793          c.m_sign    = a.m_sign ^ b.m_sign;

   803          SASSERT(num_leading_zeros <= m_precision_bits);
   804:         TRACE("mpff", tout << "num_leading_zeros: " << num_leading_zeros << "\n";);
   805          // We must shift right (m_precision_bits - num_leading_zeros)

   814          bool _inc_significand = ((c.m_sign == 1) != m_to_plus_inf) && has_one_at_first_k_bits(m_precision*2, r, shift);
   815:         TRACE("mpff", 
   816                tout << "c.m_sign: " << c.m_sign << ", m_to_plus_inf: " << m_to_plus_inf 

   824          set_exponent(c, exp_c);
   825:         TRACE("mpff", tout << "result: "; display(tout, c); tout << "\n";);
   826          SASSERT(check(c));
   827      }
   828:     STRACE("mpff_trace", display(tout, c); tout << "\n";);  
   829  }

   833          throw div0_exception();
   834:     STRACE("mpff_trace", tout << "[mpff] ("; display(tout, a); tout << ") / ("; display(tout, b); tout << ") " << (m_to_plus_inf ? "<=" : ">=") << " ";);
   835      if (is_zero(a)) {

   874                            r);
   875:         TRACE("mpff_div", 
   876                unsigned j = q_sz; 

   917      }
   918:     STRACE("mpff_trace", display(tout, c); tout << "\n";);  
   919  }

   923          return; 
   924:     STRACE("mpff_trace", tout << "[mpff] Floor["; display(tout, n); tout << "] == ";);
   925      if (n.m_exponent <= -static_cast<int>(m_precision_bits)) {

   953      SASSERT(check(n));
   954:     STRACE("mpff_trace", display(tout, n); tout << "\n";);  
   955  }

   959          return; 
   960:     STRACE("mpff_trace", tout << "[mpff] Ceiling["; display(tout, n); tout << "] == ";);
   961      if (n.m_exponent <= -static_cast<int>(m_precision_bits)) {

   989      SASSERT(check(n));
   990:     STRACE("mpff_trace", display(tout, n); tout << "\n";);  
   991  }

  1055      }
  1056:     STRACE("mpff_trace", tout << "[mpff] ("; display(tout, _a); tout << ") ^ " << _p << (m_to_plus_inf ? "<=" : ">="); display(tout, b); tout << "\n";);
  1057:     TRACE("mpff_power", display_raw(tout, b); tout << "\n";);
  1058      SASSERT(check(b));

  1126      int exp = n.m_exponent;
  1127:     TRACE("mpff_to_mpq", tout << "to_mpq: "; display(tout, n); tout << "\nexp: " << exp << "\n";);
  1128      if (exp < 0 && exp > -static_cast<int>(m_precision_bits) && !has_one_at_first_k_bits(m_precision, sig(n), -n.m_exponent)) {

z3/src/util/mpfx.cpp:
  336  bool mpfx_manager::lt(mpfx const & a, mpfx const & b) const {
  337:     STRACE("mpfx_trace", tout << "[mpfx] ("; display(tout, a); tout << " < "; display(tout, b); tout << ") == ";);
  338      bool r;

  355      }
  356:     STRACE("mpfx_trace", tout << "(" << r << " == 1)\n";);
  357      return r;

  372  
  373:     TRACE("mpfx", tout << (is_sub ? "sub" : "add") << "("; display(tout, a); tout << ", "; display(tout, b); tout << ")\n";);
  374  

  407      }
  408:     TRACE("mpfx", tout << "result: "; display(tout, c); tout << "\n";);
  409      SASSERT(check(c));

  412  void mpfx_manager::add(mpfx const & a, mpfx const & b, mpfx & c) {
  413:     STRACE("mpfx_trace", tout << "[mpfx] "; display(tout, a); tout << " + "; display(tout, b); tout << " == ";);
  414      add_sub(false, a, b, c);
  415:     STRACE("mpfx_trace", display(tout, c); tout << "\n";);  
  416  }

  418  void mpfx_manager::sub(mpfx const & a, mpfx const & b, mpfx & c) {
  419:     STRACE("mpfx_trace", tout << "[mpfx] "; display(tout, a); tout << " - "; display(tout, b); tout << " == ";);
  420      add_sub(true, a, b, c);
  421:     STRACE("mpfx_trace", display(tout, c); tout << "\n";);  
  422  }

  424  void mpfx_manager::mul(mpfx const & a, mpfx const & b, mpfx & c) {
  425:     STRACE("mpfx_trace", tout << "[mpfx] ("; display(tout, a); tout << ") * ("; display(tout, b); tout << ") " << (m_to_plus_inf ? "<=" : ">=") << " ";);
  426      if (is_zero(a) || is_zero(b)) {

  447      }
  448:     STRACE("mpfx_trace", display(tout, c); tout << "\n";);  
  449      SASSERT(check(c));

  454          throw div0_exception();
  455:     STRACE("mpfx_trace", tout << "[mpfx] ("; display(tout, a); tout << ") / ("; display(tout, b); tout << ") " << (m_to_plus_inf ? "<=" : ">=") << " ";);
  456      if (is_zero(a)) {

  521      }
  522:     STRACE("mpfx_trace", display(tout, c); tout << "\n";);  
  523      SASSERT(check(c));

  526  void mpfx_manager::div2k(mpfx & a, unsigned k) {
  527:     STRACE("mpfx_trace", tout << "[mpfx] ("; display(tout, a); tout << ") / (2^" << k << ") " << (m_to_plus_inf ? "<=" : ">=") << " ";);
  528      if (!is_zero(a) && k > 0) {

  539      }
  540:     STRACE("mpfx_trace", display(tout, a); tout << "\n";);  
  541      SASSERT(check(a));

  563  void mpfx_manager::floor(mpfx & n) {
  564:     STRACE("mpfx_trace", tout << "[mpfx] Floor["; display(tout, n); tout << "] == ";);
  565      unsigned * w = words(n);

  583      SASSERT(check(n));
  584:     STRACE("mpfx_trace", display(tout, n); tout << "\n";);  
  585  }

  587  void mpfx_manager::ceil(mpfx & n) {
  588:     STRACE("mpfx_trace", tout << "[mpfx] Ceiling["; display(tout, n); tout << "] == ";);
  589      unsigned * w = words(n);

  607      SASSERT(check(n));
  608:     STRACE("mpfx_trace", display(tout, n); tout << "\n";);  
  609  }

  651      }
  652:     STRACE("mpfx_trace", tout << "[mpfx] ("; display(tout, _a); tout << ") ^ " << _p << (m_to_plus_inf ? "<=" : ">="); display(tout, b); tout << "\n";);
  653:     TRACE("mpfx_power", display_raw(tout, b); tout << "\n";);
  654      SASSERT(check(b));

z3/src/util/mpn.cpp:
   46  
   47:     TRACE("mpn", tout << ((res == 1) ? " > " : (res == -1) ? " < " : " == "); );
   48      

  188  
  189:     // TRACE("mpn_dbg", display_raw(tout, quot, lnum - lden + 1); tout << ", ";
  190      //                  display_raw(tout, rem, lden); tout << std::endl; );

  204      if (temp[lnum] != 0) ok = false;
  205:     CTRACE("mpn_dbg", !ok, tout << "DIV BUG: quot * denom + rem = "; display_raw(tout, temp.data(), lnum+1); tout << std::endl; );
  206      SASSERT(ok);

  245  
  246:     TRACE("mpn_norm", tout << "Normalized: n_numer="; display_raw(tout, n_numer.data(), n_numer.size()); 
  247                        tout << " n_denom="; display_raw(tout, n_denom.data(), n_denom.size()); tout << std::endl; );

  284          }
  285:         TRACE("mpn_div1", 
  286                mpn_double_digit r_hat = temp % (mpn_double_digit) denom;

  338          }
  339:         TRACE("mpn_div", tout << "q_hat=" << q_hat << " r_hat=" << r_hat;
  340                           tout << " ms="; display_raw(tout, ms.data(), n);

  350      SASSERT(buf && lbuf > 0);    
  351:     TRACE("mpn_to_string", tout << "[mpn] to_string "; display_raw(tout, a, lng); tout << " == "; );
  352  

  383  
  384:     TRACE("mpn_to_string", tout << buf << std::endl; );
  385  

  399      char char_buf[4096];
  400:     TRACE("mpn", tout << "[mpn] " << to_string(a, lnga, char_buf, sizeof(char_buf));
  401                   tout << " " << op << " " << to_string(b, lngb, char_buf, sizeof(char_buf));

  408      char char_buf[4096];
  409:     TRACE("mpn", tout << to_string(a, lnga, char_buf, sizeof(char_buf)); );
  410  #endif

  415      char char_buf[4096];
  416:     TRACE("mpn", tout << to_string(a, lnga, char_buf, sizeof(char_buf)) << std::endl; );
  417  #endif

z3/src/util/mpq.cpp:
  199      }
  200:     TRACE("mpq_set", tout << "[before] a: " << to_string(a) << "\n";);
  201      if (str[0] == '/' || str[0] == '.' || str[0] == 'e' || str[0] == 'E') {

  241                  }
  242:                 TRACE("mpq_set", tout << "[exp]: " << exp << ", str[0]: " << (str[0] - '0') << std::endl;);
  243                  ++str;

  260                  power(_qten, static_cast<unsigned>(exp), _exp);
  261:                 TRACE("mpq_set", tout << "a: " << to_string(a) << ", exp_sign:" << exp_sign << ", exp: " << exp << " " << to_string(_exp) << std::endl;);
  262                  if (exp_sign)

  367  void mpq_manager<SYNCH>::rat_mul(mpz const & a, mpq const & b, mpq & c) {
  368:     STRACE("rat_mpq", tout << "[mpq] " << to_string(a) << " * " << to_string(b) << " == ";); 
  369      mul(a, b.m_num, c.m_num);

  371      normalize(c);
  372:     STRACE("rat_mpq", tout << to_string(c) << "\n";);
  373  }

  377  void mpq_manager<SYNCH>::rat_mul(mpq const & a, mpq const & b, mpq & c) {
  378:     STRACE("rat_mpq", tout << "[mpq] " << to_string(a) << " * " << to_string(b) << " == ";); 
  379      if (SYNCH) {

  389      }
  390:     STRACE("rat_mpq", tout << to_string(c) << "\n";);
  391  }

  394  void mpq_manager<SYNCH>::rat_add(mpq const & a, mpq const & b, mpq & c) {
  395:     STRACE("rat_mpq", tout << "[mpq] " << to_string(a) << " + " << to_string(b) << " == ";); 
  396      if (SYNCH) {

  406      }
  407:     STRACE("rat_mpq", tout << to_string(c) << "\n";);
  408  }

  411  void mpq_manager<SYNCH>::rat_sub(mpq const & a, mpq const & b, mpq & c) {
  412:     STRACE("rat_mpq", tout << "[mpq] " << to_string(a) << " - " << to_string(b) << " == ";); 
  413      if (SYNCH) {

  423      }
  424:     STRACE("rat_mpq", tout << to_string(c) << "\n";);
  425  }

z3/src/util/mpq.h:
   76      void rat_add(mpq const & a, mpz const & b, mpq & c) {
   77:         STRACE("rat_mpq", tout << "[mpq] " << to_string(a) << " + " << to_string(b) << " == ";); 
   78          if (SYNCH) {

   91          }
   92:         STRACE("rat_mpq", tout << to_string(c) << "\n";);
   93      }

  230      void add(mpq const & a, mpq const & b, mpq & c) {
  231:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " + " << to_string(b) << " == ";); 
  232          if (is_zero(b)) {

  244          }
  245:         STRACE("mpq", tout << to_string(c) << "\n";);
  246      }

  248      void add(mpq const & a, mpz const & b, mpq & c) {
  249:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " + " << to_string(b) << " == ";); 
  250          if (is_zero(b)) {

  262          }
  263:         STRACE("mpq", tout << to_string(c) << "\n";);
  264      }

  268      void sub(mpq const & a, mpq const & b, mpq & c) {
  269:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " - " << to_string(b) << " == ";); 
  270          if (is_int(a) && is_int(b)) {

  275              rat_sub(a, b, c);
  276:         STRACE("mpq", tout << to_string(c) << "\n";);
  277      }

  294      void mul(mpq const & a, mpq const & b, mpq & c) {
  295:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " * " << to_string(b) << " == ";); 
  296          if (is_int(a) && is_int(b)) {

  301              rat_mul(a, b, c);
  302:         STRACE("mpq", tout << to_string(c) << "\n";);
  303      }

  305      void mul(mpz const & a, mpq const & b, mpq & c) {
  306:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " * " << to_string(b) << " == ";); 
  307          if (is_int(b)) {

  312              rat_mul(a, b, c);
  313:         STRACE("mpq", tout << to_string(c) << "\n";);
  314      }

  433      void div(mpq const & a, mpq const & b, mpq & c) {
  434:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " / " << to_string(b) << " == ";); 
  435          if (is_zero(a) || is_one(b)) {

  455          normalize(c);
  456:         STRACE("mpq", tout << to_string(c) << "\n";);
  457      }

  459      void div(mpq const & a, mpz const & b, mpq & c) {
  460:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " / " << to_string(b) << " == ";); 
  461          if (is_zero(a) || is_one(b)) {

  471          normalize(c);
  472:         STRACE("mpq", tout << to_string(c) << "\n";);
  473      }

  475      void acc_div(mpq & a, mpz const & b) {
  476:         STRACE("mpq", tout << "[mpq] " << to_string(a) << " / " << to_string(b) << " == ";); 
  477          mul(a.m_den, b, a.m_den);

  482          normalize(a);
  483:         STRACE("mpq", tout << to_string(a) << "\n";);
  484      }

z3/src/util/mpz.cpp:
   247  void mpz_manager<SYNCH>::add(mpz const & a, mpz const & b, mpz & c) {
   248:     STRACE("mpz", tout << "[mpz] " << to_string(a) << " + " << to_string(b) << " == ";); 
   249      if (is_small(a) && is_small(b)) {

   254      }
   255:     STRACE("mpz", tout << to_string(c) << "\n";);
   256  }

   259  void mpz_manager<SYNCH>::sub(mpz const & a, mpz const & b, mpz & c) {
   260:     STRACE("mpz", tout << "[mpz] " << to_string(a) << " - " << to_string(b) << " == ";); 
   261      if (is_small(a) && is_small(b)) {

   266      }
   267:     STRACE("mpz", tout << to_string(c) << "\n";);
   268  }

   503  void mpz_manager<SYNCH>::mul(mpz const & a, mpz const & b, mpz & c) {
   504:     STRACE("mpz", tout << "[mpz] " << to_string(a) << " * " << to_string(b) << " == ";); 
   505      if (is_small(a) && is_small(b)) {

   510      }
   511:     STRACE("mpz", tout << to_string(c) << "\n";);
   512  }

   551  void mpz_manager<SYNCH>::machine_div_rem(mpz const & a, mpz const & b, mpz & q, mpz & r) {
   552:     STRACE("mpz", tout << "[mpz-ext] divrem(" << to_string(a) << ",  " << to_string(b) << ") == ";); 
   553      if (is_small(a) && is_small(b)) {

   561      }
   562:     STRACE("mpz", tout << "(" << to_string(q) << ", " << to_string(r) << ")\n";);
   563  }

   566  void mpz_manager<SYNCH>::machine_div(mpz const & a, mpz const & b, mpz & c) {
   567:     STRACE("mpz", tout << "[mpz-ext] machine-div(" << to_string(a) << ",  " << to_string(b) << ") == ";); 
   568      if (is_small(b) && i64(b) == 0)

   574          big_div(a, b, c);
   575:     STRACE("mpz", tout << to_string(c) << "\n";);
   576  }

   585  void mpz_manager<SYNCH>::rem(mpz const & a, mpz const & b, mpz & c) {
   586:     STRACE("mpz", tout << "[mpz-ext] rem(" << to_string(a) << ",  " << to_string(b) << ") == ";); 
   587      if (is_small(a) && is_small(b)) {

   592      }
   593:     STRACE("mpz", tout << to_string(c) << "\n";);
   594  }

   598  void mpz_manager<SYNCH>::div_gcd(mpz const& a, mpz const& b, mpz & c) {
   599:     STRACE("mpz", tout << "[mpz-ext] div(" << to_string(a) << ",  " << to_string(b) << ") == ";); 
   600      if (is_one(b)) {

   605      }
   606:     STRACE("mpz", tout << to_string(c) << "\n";);    
   607  }

   610  void mpz_manager<SYNCH>::div(mpz const & a, mpz const & b, mpz & c) {
   611:     STRACE("mpz", tout << "[mpz-ext] div(" << to_string(a) << ",  " << to_string(b) << ") == ";); 
   612      if (is_one(b)) {

   628      }
   629:     STRACE("mpz", tout << to_string(c) << "\n";);
   630  }

   633  void mpz_manager<SYNCH>::mod(mpz const & a, mpz const & b, mpz & c) {
   634:     STRACE("mpz", tout << "[mpz-ext] mod(" << to_string(a) << ",  " << to_string(b) << ") == ";); 
   635      rem(a, b, c);

   641      }
   642:     STRACE("mpz", tout << to_string(c) << "\n";);
   643  }

   646  void mpz_manager<SYNCH>::neg(mpz & a) {
   647:     STRACE("mpz", tout << "[mpz] 0 - " << to_string(a) << " == ";); 
   648      if (is_small(a) && a.m_val == INT_MIN) {

   662  #endif
   663:     STRACE("mpz", tout << to_string(a) << "\n";); 
   664  }

  1193          std::sort(p.begin(), p.end(), lt);
  1194:         TRACE("mpz_gcd", for (unsigned i = 0; i < sz; i++) tout << p[i] << ":" << size_info(as[p[i]]) << " "; tout << "\n";);
  1195          gcd(as[p[0]], as[p[1]], g);

  1306          set(c, a);
  1307:         TRACE("lcm_bug", tout << "1. lcm(" << to_string(a) << ", " << to_string(b) << ") = " << to_string(c) << "\n";);
  1308      }

  1310          set(c, b);
  1311:         TRACE("lcm_bug", tout << "2. lcm(" << to_string(a) << ", " << to_string(b) << ") = " << to_string(c) << "\n";);
  1312      }

  1315          gcd(a, b, r);
  1316:         TRACE("lcm_bug", tout << "gcd(" << to_string(a) << ", " << to_string(b) << ") = " << to_string(r) << "\n";);
  1317          if (eq(r, a)) {
  1318              set(c, b);
  1319:             TRACE("lcm_bug", tout << "3. lcm(" << to_string(a) << ", " << to_string(b) << ") = " << to_string(c) << "\n";);
  1320          }

  1322              set(c, a);
  1323:             TRACE("lcm_bug", tout << "4. lcm(" << to_string(a) << ", " << to_string(b) << ") = " << to_string(c) << "\n";);
  1324          }

  1329              mul(r, b, c);
  1330:             TRACE("lcm_bug", tout << "5. lcm(" << to_string(a) << ", " << to_string(b) << ") = " << to_string(c) << "\n";);
  1331          }

  1339      SASSERT(is_nonneg(b));
  1340:     TRACE("mpz", tout << "is_small(a): " << is_small(a) << ", is_small(b): " << is_small(b) << "\n";);
  1341      if (is_small(a) && is_small(b)) {

  1352          while (!is_zero(a1) && !is_zero(b1)) {
  1353:             TRACE("mpz", tout << "a1: " << to_string(a1) << ", b1: " << to_string(b1) << "\n";);
  1354              mod(a1, m_two64, a2);
  1355              mod(b1, m_two64, b2);
  1356:             TRACE("mpz", tout << "a2: " << to_string(a2) << ", b2: " << to_string(b2) << "\n";);
  1357              uint64_t v = get_uint64(a2) | get_uint64(b2);
  1358:             TRACE("mpz", tout << "uint(a2): " << get_uint64(a2) << ", uint(b2): " << get_uint64(b2) << "\n";);
  1359              set(tmp, v);

  1480              }
  1481:             TRACE("bitwise_not", tout << "sz: " << sz << ", v: " << v << ", n: " << n << "\n";);
  1482              set(tmp, v);

  1490          del(a1); del(a2); del(m); del(tmp);
  1491:         TRACE("bitwise_not", tout << "sz: " << sz << " a: " << to_string(a) << " c: " << to_string(c) << "\n";);
  1492      }

  2065      digit_t * ds = c->m_digits;
  2066:     TRACE("mpz_2k", tout << "bit_shift: " << bit_shift << ", comp_shift: " << comp_shift << ", new_sz: " << new_sz << ", sz: " << sz << "\n";);
  2067      if (new_sz < sz) {

  2116  #ifndef _MP_GMP
  2117:     TRACE("mpz_mul2k", tout << "mul2k\na: " << to_string(a) << "\nk: " << k << "\n";);
  2118      unsigned word_shift  = k / (8 * sizeof(digit_t));

  2122      ensure_capacity(a, new_sz);
  2123:     TRACE("mpz_mul2k", tout << "word_shift: " << word_shift << "\nbit_shift: " << bit_shift << "\nold_sz: " << old_sz << "\nnew_sz: " << new_sz 
  2124            << "\na after ensure capacity:\n" << to_string(a) << "\n";

  2161      normalize(a);
  2162:     TRACE("mpz_mul2k", tout << "mul2k result:\n" << to_string(a) << "\n";);
  2163  #else

  2405              machine_div2k(mid, 1);
  2406:             TRACE("mpz", tout << "upper: "; display(tout, upper); tout << "\nlower: "; display(tout, lower); tout << "\nmid: "; display(tout, mid); tout << "\n";);
  2407              power(mid, n, mid_n);

  2514      }
  2515:     STRACE("divides", tout << "[mpz] Divisible["; display(tout, b); tout << ", "; display(tout, a); tout << "] == " << (r?"True":"False") << "\n";);
  2516:     TRACE("divides_bug", tout << "tmp: "; display(tout, tmp); tout << "\n";);
  2517      return r;

z3/src/util/mpzzp.h:
   53          }
   54:         TRACE("mpzzp", tout << "lower: " << m_manager.to_string(m_lower) << ", upper: " << m_manager.to_string(m_upper) << "\n";);
   55      }

  173              // a*t1 + p*t2 = 1 => a*t1 = 1 (mod p) => t1 is the inverse (t3 == 1)
  174:             TRACE("mpzp_inv_bug", tout << "a: " << m().to_string(a) << ", p: " << m().to_string(m_p) << "\n";);
  175              p_normalize(a);
  176:             TRACE("mpzp_inv_bug", tout << "after normalization a: " << m().to_string(a) << "\n";);
  177              m().gcd(a, m_p, m_inv_tmp1, m_inv_tmp2, m_inv_tmp3);
  178:             TRACE("mpzp_inv_bug", tout << "tmp1: " << m().to_string(m_inv_tmp1) << "\ntmp2: " << m().to_string(m_inv_tmp2) 
  179                    << "\ntmp3: " << m().to_string(m_inv_tmp3) << "\n";);

z3/src/util/parray.h:
   40          SASSERT(capacity(r) == c);
   41:         TRACE("parray_mem", tout << "allocated values[" << c << "]: " << r << "\n";);
   42          return r;

   48          size_t c     = capacity(vs);
   49:         TRACE("parray_mem", tout << "deallocated values[" << c << "]: " << vs << "\n";);
   50          size_t * mem = reinterpret_cast<size_t*>(vs);

  100          cell * r = new (m_allocator.allocate(sizeof(cell))) cell(k);
  101:         TRACE("parray_mem", tout << "allocated cell: " << r << "\n";);
  102          return r;

  121              }
  122:             TRACE("parray_mem", tout << "deallocated cell: " << c << "\n";);
  123              c->~cell();

  141          if (!c) return;
  142:         TRACE("parray_mem", tout << "dec_ref(" << c << "), ref_count: " << c->m_ref_count << "\n";);
  143          SASSERT(c->m_ref_count > 0);

z3/src/util/sorting_network.h:
   696          literal mk_exactly_1(bool full, unsigned n, literal const* xs) {
   697:             TRACE("pb", tout << "exactly 1 with " << n << " arguments " << (full?"full":"not full") << "\n";);
   698              literal_vector ors;

   726          literal mk_at_most_1(bool full, unsigned n, literal const* xs, literal_vector& ors, bool use_ors) {
   727:             TRACE("pb_verbose", tout << (full?"full":"partial") << " ";
   728                    for (unsigned i = 0; i < n; ++i) tout << xs[i] << " ";

   950              }
   951:             TRACE("pb_verbose", 
   952                    //pp(tout << N << ": ", in);                  

  1036          void card(unsigned k, unsigned n, literal const* xs, literal_vector& out) {
  1037:             TRACE("pb_verbose", tout << "card k: " << k << " n: " << n << "\n";);
  1038              if (n <= k) {

  1041              else if (use_dcard(k, n)) {
  1042:                 TRACE("pb_verbose", tout << "use dcard\n";);
  1043                  dsorting(k, n, xs, out);

  1045              else {
  1046:                 TRACE("pb_verbose", tout << "use merge\n";);
  1047                  literal_vector out1, out2;

  1052              }
  1053:             TRACE("pb_verbose", tout << "card k: " << k << " n: " << n << "\n";
  1054                    //pp(tout << "in:", n, xs) << "\n";

  1117              }
  1118:             TRACE("pb_verbose", tout << "merge a: " << a << " b: " << b << " ";
  1119                    tout << "num clauses " << m_stats.m_num_compiled_clauses - nc << "\n";

  1180              SASSERT(out.size() == as.size() + bs.size());
  1181:             TRACE("pb_verbose", tout << "interleave: " << as.size() << " " << bs.size() << " ";
  1182                    tout << "num clauses " << m_stats.m_num_compiled_clauses - nc << "\n";

  1194          void sorting(unsigned n, literal const* xs, literal_vector& out) {
  1195:             TRACE("pb_verbose", tout << "sorting: " << n << "\n";);
  1196              switch(n) {

  1206                  if (use_dsorting(n)) {
  1207:                     TRACE("pb_verbose", tout << "use dsorting: " << n << "\n";);
  1208                      dsorting(n, n, xs, out);

  1210                  else {
  1211:                     TRACE("pb_verbose", tout << "use merge: " << n << "\n";);
  1212                      literal_vector out1, out2;

  1221              }
  1222:             TRACE("pb_verbose", tout << "sorting: " << n << "\n";
  1223                    //pp(tout << "in:", n, xs) << "\n"; 

  1333              }
  1334:             TRACE("pb_verbose", tout << "smerge: c:" << c << " a:" << a << " b:" << b << " ";
  1335                    tout << "num clauses " << m_stats.m_num_compiled_clauses - nc << "\n";

  1423              }
  1424:             TRACE("pb_verbose", tout << "dsmerge: c:" << c << " a:" << a << " b:" << b << " ";
  1425                    tout << "num clauses: " << m_stats.m_num_compiled_clauses - nc << "\n";

  1465              }
  1466:             TRACE("pb_verbose", 
  1467                    tout << "dsorting m: " << m << " n: " << n << " ";

  1484                          unsigned n, literal const* xs) {
  1485:             TRACE("pb_verbose", tout << "k:" << k << " offset: " << offset << " n: " << n << " ";
  1486                    //pp(tout, lits) << "\n";

z3/src/util/state_graph.cpp:
   22  void state_graph::add_state_core(state s) {
   23:     STRACE("state_graph", tout << "add(" << s << ") ";);
   24      SASSERT(!m_seen.contains(s));

   40      // should already have been renamed.
   41:     STRACE("state_graph", tout << "del(" << s << ") ";);
   42      SASSERT(m_seen.contains(s));

   51  void state_graph::mark_unknown_core(state s) {
   52:     STRACE("state_graph", tout << "unk(" << s << ") ";);
   53      SASSERT(m_state_ufind.is_root(s));

   58  void state_graph::mark_live_core(state s) {
   59:     STRACE("state_graph", tout << "live(" << s << ") ";);
   60      SASSERT(m_state_ufind.is_root(s));

   65  void state_graph::mark_dead_core(state s) {
   66:     STRACE("state_graph", tout << "dead(" << s << ") ";);
   67      SASSERT(m_state_ufind.is_root(s));

   80  void state_graph::add_edge_core(state s1, state s2, bool maybecycle) {
   81:     STRACE("state_graph", tout << "add(" << s1 << "," << s2 << ","
   82                                 << (maybecycle ? "y" : "n") << ") ";);

   97  void state_graph::remove_edge_core(state s1, state s2) {
   98:     STRACE("state_graph", tout << "del(" << s1 << "," << s2 << ") ";);
   99      SASSERT(m_targets[s1].contains(s2));

  129      SASSERT(m_unknown.contains(s2));
  130:     STRACE("state_graph", tout << "merge(" << s1 << "," << s2 << ") ";);
  131      m_state_ufind.merge(s1, s2);

  264      if (m_seen.contains(s)) return;
  265:     STRACE("state_graph", tout << "[state_graph] adding state " << s << ": ";);
  266      add_state_core(s);

  269      CASSERT("state_graph", check_invariant());
  270:     STRACE("state_graph", tout << std::endl;);
  271  }
  272  void state_graph::mark_live(state s) {
  273:     STRACE("state_graph", tout << "[state_graph] marking live " << s << ": ";);
  274      SASSERT(m_unexplored.contains(s) || m_live.contains(s));

  280      CASSERT("state_graph", check_invariant());
  281:     STRACE("state_graph", tout << std::endl;);
  282  }
  283  void state_graph::add_edge(state s1, state s2, bool maybecycle) {
  284:     STRACE("state_graph", tout << "[state_graph] adding edge "
  285                                 << s1 << "->" << s2 << ": ";);

  294      CASSERT("state_graph", check_invariant());
  295:     STRACE("state_graph", tout << std::endl;);
  296  }

  300      if (m_live.contains(s)) return;
  301:     STRACE("state_graph", tout << "[state_graph] marking done " << s << ": ";);
  302      if (m_unexplored.contains(s)) mark_unknown_core(s);

  307      CASSERT("state_graph", check_invariant());
  308:     STRACE("state_graph", tout << std::endl;);
  309  }

  415  
  416:     STRACE("state_graph", tout << "(invariant passed) ";);
  417      return true;

z3/src/util/tbv.cpp:
   33          for (auto t : allocated_tbvs)
   34:             TRACE("doc", tout << "dangling: " << t << "\n";););
   35  }

   44          if (s_debug_alloc) {
   45:             TRACE("doc", tout << allocated_tbvs.size() << " " << r << "\n";);
   46          }

  180          if (s_debug_alloc) {
  181:             TRACE("doc", tout << "deallocate: " << bv << "\n";);
  182          }

z3/src/util/total_order.h:
   89          if (vbn_a < 2 || (vb_a > vbn_a - 2)) {
   90:             TRACE("total_order", tout << "relabeling...\n"; tout << "\n";);
   91              uint64_t  v0       = v(a);

  102              }
  103:             TRACE("total_order", tout << "j: " << j << " curr_gap: " << curr_gap << " sz: " << sz << "\n";);
  104              if (j == sz)

z3/src/util/union_find.h:
   74          unsigned r2 = m_find[r1];
   75:         TRACE("union_find", tout << "unmerging " << r1 << " " << r2 << "\n";);
   76          SASSERT(find(r2) == r2);

  122          unsigned r2 = find(v2);
  123:         TRACE("union_find", tout << "merging " << r1 << " " << r2 << "\n";);
  124          if (r1 == r2)

  139      void set_root(unsigned v, unsigned root) {
  140:         TRACE("union_find", tout << "merging " << v << " " << root << "\n";);
  141          SASSERT(v != root);
